GitDiffStart: d96936f1efc371d5c638a3ba6b0fc044f0c0eb6d | Tue Feb 21 07:24:56 2012 +0000
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/ParseUtils.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/ParseUtils.java
new file mode 100644
index 0000000..c6ab3bf
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/ParseUtils.java
@@ -0,0 +1,157 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.context;
+
+import org.apache.lucene.spatial.base.exception.InvalidShapeException;
+
+/**
+ * Utility methods related to parsing shapes.
+ * Methods here were formerly in DistanceUtils.
+ */
+public class ParseUtils {
+  private ParseUtils() {
+  }
+
+  /**
+   * Given a string containing <i>dimension</i> values encoded in it, separated by commas, return a String array of length <i>dimension</i>
+   * containing the values.
+   *
+   * @param out         A preallocated array.  Must be size dimension.  If it is not it will be resized.
+   * @param externalVal The value to parse
+   * @param dimension   The expected number of values for the point
+   * @return An array of the values that make up the point (aka vector)
+   * @throws org.apache.lucene.spatial.base.exception.InvalidShapeException if the dimension specified does not match the number of values in the externalValue.
+   */
+  public static String[] parsePoint(String[] out, String externalVal, int dimension) throws InvalidShapeException {
+    //TODO: Should we support sparse vectors?
+    if (out == null || out.length != dimension) out = new String[dimension];
+    int idx = externalVal.indexOf(',');
+    int end = idx;
+    int start = 0;
+    int i = 0;
+    if (idx == -1 && dimension == 1 && externalVal.length() > 0) {//we have a single point, dimension better be 1
+      out[0] = externalVal.trim();
+      i = 1;
+    } else if (idx > 0) {//if it is zero, that is an error
+      //Parse out a comma separated list of point values, as in: 73.5,89.2,7773.4
+      for (; i < dimension; i++) {
+        while (start < end && externalVal.charAt(start) == ' ') start++;
+        while (end > start && externalVal.charAt(end - 1) == ' ') end--;
+        if (start == end) {
+          break;
+        }
+        out[i] = externalVal.substring(start, end);
+        start = idx + 1;
+        end = externalVal.indexOf(',', start);
+        idx = end;
+        if (end == -1) {
+          end = externalVal.length();
+        }
+      }
+    }
+    if (i != dimension) {
+      throw new InvalidShapeException("incompatible dimension (" + dimension +
+              ") and values (" + externalVal + ").  Only " + i + " values specified");
+    }
+    return out;
+  }
+
+  /**
+   * Given a string containing <i>dimension</i> values encoded in it, separated by commas, return a double array of length <i>dimension</i>
+   * containing the values.
+   *
+   * @param out         A preallocated array.  Must be size dimension.  If it is not it will be resized.
+   * @param externalVal The value to parse
+   * @param dimension   The expected number of values for the point
+   * @return An array of the values that make up the point (aka vector)
+   * @throws org.apache.lucene.spatial.base.exception.InvalidShapeException if the dimension specified does not match the number of values in the externalValue.
+   */
+  public static double[] parsePointDouble(double[] out, String externalVal, int dimension) throws InvalidShapeException{
+    if (out == null || out.length != dimension) out = new double[dimension];
+    int idx = externalVal.indexOf(',');
+    int end = idx;
+    int start = 0;
+    int i = 0;
+    if (idx == -1 && dimension == 1 && externalVal.length() > 0) {//we have a single point, dimension better be 1
+      out[0] = Double.parseDouble(externalVal.trim());
+      i = 1;
+    } else if (idx > 0) {//if it is zero, that is an error
+      //Parse out a comma separated list of point values, as in: 73.5,89.2,7773.4
+      for (; i < dimension; i++) {
+        //TODO: abstract common code with other parsePoint
+        while (start < end && externalVal.charAt(start) == ' ') start++;
+        while (end > start && externalVal.charAt(end - 1) == ' ') end--;
+        if (start == end) {
+          break;
+        }
+        out[i] = Double.parseDouble(externalVal.substring(start, end));
+        start = idx + 1;
+        end = externalVal.indexOf(',', start);
+        idx = end;
+        if (end == -1) {
+          end = externalVal.length();
+        }
+      }
+    }
+    if (i != dimension) {
+      throw new InvalidShapeException("incompatible dimension (" + dimension +
+              ") and values (" + externalVal + ").  Only " + i + " values specified");
+    }
+    return out;
+  }
+
+  public static final double[] parseLatitudeLongitude(String latLonStr) throws InvalidShapeException {
+    return parseLatitudeLongitude(null, latLonStr);
+  }
+
+  /**
+   * extract (by calling {@link #parsePoint(String[], String, int)} and validate the latitude and longitude contained
+   * in the String by making sure the latitude is between 90 & -90 and longitude is between -180 and 180.
+   * <p/>
+   * The latitude is assumed to be the first part of the string and the longitude the second part.
+   *
+   * @param latLon    A preallocated array to hold the result
+   * @param latLonStr The string to parse.  Latitude is the first value, longitude is the second.
+   * @return The lat long
+   * @throws org.apache.lucene.spatial.base.exception.InvalidShapeException if there was an error parsing
+   */
+  public static final double[] parseLatitudeLongitude(double[] latLon, String latLonStr) throws InvalidShapeException {
+    if (latLon == null) {
+      latLon = new double[2];
+    }
+    double[] toks = parsePointDouble(null, latLonStr, 2);
+
+    if (toks[0] < -90.0 || toks[0] > 90.0) {
+      throw new InvalidShapeException(
+              "Invalid latitude: latitudes are range -90 to 90: provided lat: ["
+                      + toks[0] + "]");
+    }
+    latLon[0] = toks[0];
+
+
+    if (toks[1] < -180.0 || toks[1] > 180.0) {
+
+      throw new InvalidShapeException(
+              "Invalid longitude: longitudes are range -180 to 180: provided lon: ["
+                      + toks[1] + "]");
+    }
+    latLon[1] = toks[1];
+
+    return latLon;
+  }
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/SpatialContext.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/SpatialContext.java
new file mode 100644
index 0000000..1f4ea4a
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/SpatialContext.java
@@ -0,0 +1,249 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.context;
+
+import org.apache.lucene.spatial.base.distance.*;
+import org.apache.lucene.spatial.base.exception.InvalidShapeException;
+import org.apache.lucene.spatial.base.shape.Circle;
+import org.apache.lucene.spatial.base.shape.Point;
+import org.apache.lucene.spatial.base.shape.Rectangle;
+import org.apache.lucene.spatial.base.shape.Shape;
+import org.apache.lucene.spatial.base.shape.simple.RectangleImpl;
+
+import java.text.NumberFormat;
+import java.util.Locale;
+import java.util.StringTokenizer;
+
+/**
+ * This holds things like distance units, distance calculator, and world bounds.
+ * Threadsafe & immutable.
+ */
+public abstract class SpatialContext {
+
+  //These are non-null
+  private final DistanceUnits units;
+  private final DistanceCalculator calculator;
+  private final Rectangle worldBounds;
+
+  public static RectangleImpl GEO_WORLDBOUNDS = new RectangleImpl(-180,180,-90,90);
+  public static RectangleImpl MAX_WORLDBOUNDS;
+  static {
+    double v = Double.MAX_VALUE;
+    MAX_WORLDBOUNDS = new RectangleImpl(-v, v, -v, v);
+  }
+  
+  protected final Double maxCircleDistance;//only for geo
+  protected final boolean NUDGE = false;//TODO document
+
+  /**
+   *
+   * @param units Required; and establishes geo vs cartesian.
+   * @param calculator Optional; defaults to Haversine or cartesian depending on units.
+   * @param worldBounds Optional; defaults to GEO_WORLDBOUNDS or MAX_WORLDBOUNDS depending on units.
+   */
+  protected SpatialContext(DistanceUnits units, DistanceCalculator calculator, Rectangle worldBounds) {
+    if (units == null)
+      throw new IllegalArgumentException("units can't be null");
+    this.units = units;
+
+    if (calculator == null) {
+      calculator = isGeo()
+          ? new GeodesicSphereDistCalc.Haversine(units.earthRadius())
+          : new CartesianDistCalc();
+    }
+    this.calculator = calculator;
+
+    if (worldBounds == null) {
+      worldBounds = isGeo() ? GEO_WORLDBOUNDS : MAX_WORLDBOUNDS;
+    } else {
+      if (isGeo())
+        assert new RectangleImpl(worldBounds).equals(GEO_WORLDBOUNDS);
+      if (worldBounds.getCrossesDateLine())
+        throw new IllegalArgumentException("worldBounds shouldn't cross dateline: "+worldBounds);
+    }
+    //copy so we can ensure we have the right implementation
+    worldBounds = makeRect(worldBounds.getMinX(),worldBounds.getMaxX(),worldBounds.getMinY(),worldBounds.getMaxY());
+    this.worldBounds = worldBounds;
+    
+    this.maxCircleDistance = isGeo() ? calculator.degreesToDistance(180) : null;
+  }
+
+  public DistanceUnits getUnits() {
+    return units;
+  }
+
+  public DistanceCalculator getDistCalc() {
+    return calculator;
+  }
+
+  public Rectangle getWorldBounds() {
+    return worldBounds;
+  }
+
+  public double normX(double x) {
+    if (isGeo()) {
+      return DistanceUtils.normLonDEG(x);
+    } else {
+      return x;
+    }
+  }
+
+  public double normY(double y) {
+    if (isGeo()) {
+      y = DistanceUtils.normLatDEG(y);
+    }
+    return y;
+  }
+
+  /**
+   * Is this a geospatial context (true) or simply 2d spatial (false)
+   * @return
+   */
+  public boolean isGeo() {
+    return getUnits().isGeo();
+  }
+
+  /**
+   * Read a shape from a given string (ie, X Y, XMin XMax... WKT)
+   *
+   * (1) Point: X Y
+   *   1.23 4.56
+   *
+   * (2) BOX: XMin YMin XMax YMax
+   *   1.23 4.56 7.87 4.56
+   *
+   * (3) WKT
+   *   POLYGON( ... )
+   *   http://en.wikipedia.org/wiki/Well-known_text
+   *
+   */
+  public abstract Shape readShape(String value) throws InvalidShapeException;
+
+  public Point readLatCommaLonPoint(String value) throws InvalidShapeException {
+    double[] latLon = ParseUtils.parseLatitudeLongitude(value);
+    return makePoint(latLon[1],latLon[0]);
+  }
+
+  public abstract String toString(Shape shape);
+
+  /** Construct a point. The parameters will be normalized. */
+  public abstract Point makePoint( double x, double y );
+
+  /** Construct a rectangle. The parameters will be normalized. */
+  public abstract Rectangle makeRect(double minX, double maxX, double minY, double maxY);
+
+  /** Construct a circle. The parameters will be normalized. */
+  public Circle makeCircle(double x, double y, double distance) {
+    return makeCircle(makePoint(x,y),distance);
+  }
+
+  /**
+   *
+   * @param ctr
+   * @param distance The units of "distance" should be the same as {@link #getUnits()}.
+   * @return
+   */
+  public abstract Circle makeCircle(Point ctr, double distance);
+
+  protected Shape readStandardShape(String str) {
+    if (str.length() < 1) {
+      throw new InvalidShapeException(str);
+    }
+
+    if(Character.isLetter(str.charAt(0))) {
+      if( str.startsWith( "Circle(" ) ) {
+        int idx = str.lastIndexOf( ')' );
+        if( idx > 0 ) {
+          String body = str.substring( "Circle(".length(), idx );
+          StringTokenizer st = new StringTokenizer(body, " ");
+          String token = st.nextToken();
+          Point pt;
+          if (token.indexOf(',') != -1) {
+            pt = readLatCommaLonPoint(token);
+          } else {
+            double x = Double.parseDouble(token);
+            double y = Double.parseDouble(st.nextToken());
+            pt = makePoint(x,y);
+          }
+          Double d = null;
+
+          String arg = st.nextToken();
+          idx = arg.indexOf( '=' );
+          if( idx > 0 ) {
+            String k = arg.substring( 0,idx );
+            if( k.equals( "d" ) || k.equals( "distance" ) ) {
+              d = Double.parseDouble( arg.substring(idx+1));
+            }
+            else {
+              throw new InvalidShapeException( "unknown arg: "+k+" :: " +str );
+            }
+          }
+          else {
+            d = Double.parseDouble(arg);
+          }
+          if( st.hasMoreTokens() ) {
+            throw new InvalidShapeException( "Extra arguments: "+st.nextToken()+" :: " +str );
+          }
+          if( d == null ) {
+            throw new InvalidShapeException( "Missing Distance: "+str );
+          }
+          //NOTE: we are assuming the units of 'd' is the same as that of the spatial context.
+          return makeCircle(pt, d);
+        }
+      }
+      return null;
+    }
+
+    if (str.indexOf(',') != -1)
+      return readLatCommaLonPoint(str);
+    StringTokenizer st = new StringTokenizer(str, " ");
+    double p0 = Double.parseDouble(st.nextToken());
+    double p1 = Double.parseDouble(st.nextToken());
+    if (st.hasMoreTokens()) {
+      double p2 = Double.parseDouble(st.nextToken());
+      double p3 = Double.parseDouble(st.nextToken());
+      if (st.hasMoreTokens())
+        throw new InvalidShapeException("Only 4 numbers supported (rect) but found more: "+str);
+      return makeRect(p0, p2, p1, p3);
+    }
+    return makePoint(p0, p1);
+  }
+
+  public String writeRect(Rectangle rect) {
+    NumberFormat nf = NumberFormat.getInstance(Locale.US);
+    nf.setGroupingUsed(false);
+    nf.setMaximumFractionDigits(6);
+    nf.setMinimumFractionDigits(6);
+
+    return
+      nf.format(rect.getMinX()) + " " +
+      nf.format(rect.getMinY()) + " " +
+      nf.format(rect.getMaxX()) + " " +
+      nf.format(rect.getMaxY());
+  }
+
+  @Override
+  public String toString() {
+    return getClass().getSimpleName()+"{" +
+        "units=" + units +
+        ", calculator=" + calculator +
+        ", worldBounds=" + worldBounds +
+        '}';
+  }
+
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/SpatialContextFactory.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/SpatialContextFactory.java
new file mode 100644
index 0000000..8ebed98
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/SpatialContextFactory.java
@@ -0,0 +1,114 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.context;
+
+import org.apache.lucene.spatial.base.context.simple.SimpleSpatialContext;
+import org.apache.lucene.spatial.base.context.simple.SimpleSpatialContextFactory;
+import org.apache.lucene.spatial.base.distance.*;
+import org.apache.lucene.spatial.base.shape.Rectangle;
+
+import java.util.Map;
+
+/**
+ * Factory for a SpatialContext.
+ * is 
+ * @author dsmiley
+ */
+public abstract class SpatialContextFactory {
+  protected Map<String, String> args;
+  protected ClassLoader classLoader;
+  
+  protected DistanceUnits units;
+  protected DistanceCalculator calculator;
+  protected Rectangle worldBounds;
+
+  /**
+   * The factory class is lookuped up via "spatialContextFactory" in args
+   * then falling back to a Java system property (with initial caps). If neither are specified
+   * then {@link SimpleSpatialContextFactory} is chosen.
+   * @param args
+   * @param classLoader
+   * @return
+   */
+  public static SpatialContext makeSpatialContext(Map<String,String> args, ClassLoader classLoader) {
+    SpatialContextFactory instance;
+    String cname = args.get("spatialContextFactory");
+    if (cname == null)
+      cname = System.getProperty("SpatialContextFactory");
+    if (cname == null)
+      instance = new SimpleSpatialContextFactory();
+    else {
+      try {
+        Class c = classLoader.loadClass(cname);
+        instance = (SpatialContextFactory) c.newInstance();
+      } catch (Exception e) {
+        throw new RuntimeException(e);
+      }
+    }
+    instance.init(args,classLoader);
+    return instance.newSpatialContext();
+  }
+
+  protected void init(Map<String, String> args, ClassLoader classLoader) {
+    this.args = args;
+    this.classLoader = classLoader;
+    initUnits();
+    initCalculator();
+    initWorldBounds();
+  }
+
+  protected void initUnits() {
+    String unitsStr = args.get("units");
+    if (unitsStr != null)
+      units = DistanceUnits.findDistanceUnit(unitsStr);
+    if (units == null)
+      units = DistanceUnits.KILOMETERS;
+  }
+
+  protected void initCalculator() {
+    String calcStr = args.get("distCalculator");
+    if (calcStr == null)
+      return;
+    if (calcStr.equalsIgnoreCase("haversine")) {
+      calculator = new GeodesicSphereDistCalc.Haversine(units.earthRadius());
+    } else if (calcStr.equalsIgnoreCase("lawOfCosines")) {
+      calculator = new GeodesicSphereDistCalc.LawOfCosines(units.earthRadius());
+    } else if (calcStr.equalsIgnoreCase("vincentySphere")) {
+      calculator = new GeodesicSphereDistCalc.Vincenty(units.earthRadius());
+    } else if (calcStr.equalsIgnoreCase("cartesian")) {
+      calculator = new CartesianDistCalc();
+    } else if (calcStr.equalsIgnoreCase("cartesian^2")) {
+      calculator = new CartesianDistCalc(true);
+    } else {
+      throw new RuntimeException("Unknown calculator: "+calcStr);
+    }
+  }
+
+  protected void initWorldBounds() {
+    String worldBoundsStr = args.get("worldBounds");
+    if (worldBoundsStr == null)
+      return;
+    //kinda ugly we do this just to read a rectangle.  TODO refactor
+    SimpleSpatialContext simpleCtx = new SimpleSpatialContext(units, calculator, null);
+    worldBounds = (Rectangle) simpleCtx.readShape(worldBoundsStr);
+  }
+
+  /** Subclasses should simply construct the instance from the initialized configuration. */
+  protected abstract SpatialContext newSpatialContext();
+
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/simple/SimpleSpatialContext.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/simple/SimpleSpatialContext.java
new file mode 100644
index 0000000..413eae1
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/simple/SimpleSpatialContext.java
@@ -0,0 +1,139 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.context.simple;
+
+import org.apache.lucene.spatial.base.context.SpatialContext;
+import org.apache.lucene.spatial.base.distance.DistanceCalculator;
+import org.apache.lucene.spatial.base.distance.DistanceUnits;
+import org.apache.lucene.spatial.base.exception.InvalidShapeException;
+import org.apache.lucene.spatial.base.shape.Circle;
+import org.apache.lucene.spatial.base.shape.Point;
+import org.apache.lucene.spatial.base.shape.Rectangle;
+import org.apache.lucene.spatial.base.shape.Shape;
+import org.apache.lucene.spatial.base.shape.simple.CircleImpl;
+import org.apache.lucene.spatial.base.shape.simple.GeoCircleImpl;
+import org.apache.lucene.spatial.base.shape.simple.PointImpl;
+import org.apache.lucene.spatial.base.shape.simple.RectangleImpl;
+
+import java.text.NumberFormat;
+import java.util.Locale;
+
+public class SimpleSpatialContext extends SpatialContext {
+
+  public static SimpleSpatialContext GEO_KM = new SimpleSpatialContext(DistanceUnits.KILOMETERS);
+
+  public SimpleSpatialContext(DistanceUnits units) {
+    this(units, null, null);
+  }
+
+  public SimpleSpatialContext(DistanceUnits units, DistanceCalculator calculator, Rectangle worldBounds) {
+    super(units, calculator, worldBounds);
+  }
+
+  @Override
+  public Shape readShape(String value) throws InvalidShapeException {
+    Shape s = super.readStandardShape( value );
+    if( s == null ) {
+      throw new InvalidShapeException( "Unable to read: "+value );
+    }
+    return s;
+  }
+
+  @Override
+  public String toString(Shape shape) {
+    if (Point.class.isInstance(shape)) {
+      NumberFormat nf = NumberFormat.getInstance(Locale.US);
+      nf.setGroupingUsed(false);
+      nf.setMaximumFractionDigits(6);
+      nf.setMinimumFractionDigits(6);
+      Point point = (Point) shape;
+      return nf.format(point.getX()) + " " + nf.format(point.getY());
+    } else if (Rectangle.class.isInstance(shape)) {
+      return writeRect((Rectangle) shape);
+    }
+    return shape.toString();
+  }
+
+  @Override
+  public Circle makeCircle(Point point, double distance) {
+    if (distance < 0)
+      throw new InvalidShapeException("distance must be >= 0; got "+distance);
+    if (isGeo())
+      return new GeoCircleImpl( point, Math.min(distance,maxCircleDistance), this );
+    else
+      return new CircleImpl( point, distance, this );
+  }
+
+  @Override
+  public Rectangle makeRect(double minX, double maxX, double minY, double maxY) {
+    //--Normalize parameters
+    if (isGeo()) {
+      double delta = calcWidth(minX,maxX);
+      if (delta >= 360) {
+        //The only way to officially support complete longitude wrap-around is via western longitude = -180. We can't
+        // support any point because 0 is undifferentiated in sign.
+        minX = -180;
+        maxX = 180;
+      } else {
+        minX = normX(minX);
+        maxX = normX(maxX);
+        assert Math.abs(delta - calcWidth(minX,maxX)) < 0.0001;//recompute delta; should be the same
+      }
+      if (minY > maxY) {
+        throw new IllegalArgumentException("maxY must be >= minY");
+      }
+      if (minY < -90 || minY > 90 || maxY < -90 || maxY > 90)
+        throw new IllegalArgumentException("minY or maxY is outside of -90 to 90 bounds. What did you mean?");
+//      debatable what to do in this situation.
+//      if (minY < -90) {
+//        minX = -180;
+//        maxX = 180;
+//        maxY = Math.min(90,Math.max(maxY,-90 + (-90 - minY)));
+//        minY = -90;
+//      }
+//      if (maxY > 90) {
+//        minX = -180;
+//        maxX = 180;
+//        minY = Math.max(-90,Math.min(minY,90 - (maxY - 90)));
+//        maxY = 90;
+//      }
+
+    } else {
+      //these normalizations probably won't do anything since it's not geo but should probably call them any way.
+      minX = normX(minX);
+      maxX = normX(maxX);
+      minY = normY(minY);
+      maxY = normY(maxY);
+    }
+    return new RectangleImpl( minX, maxX, minY, maxY );
+  }
+
+  private double calcWidth(double minX,double maxX) {
+    double w = maxX - minX;
+    if (w < 0) {//only true when minX > maxX (WGS84 assumed)
+      w += 360;
+      assert w >= 0;
+    }
+    return w;
+  }
+
+  @Override
+  public Point makePoint(double x, double y) {
+    return new PointImpl(normX(x),normY(y));
+  }
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/simple/SimpleSpatialContextFactory.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/simple/SimpleSpatialContextFactory.java
new file mode 100644
index 0000000..2ace223
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/simple/SimpleSpatialContextFactory.java
@@ -0,0 +1,31 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.context.simple;
+
+import org.apache.lucene.spatial.base.context.SpatialContext;
+import org.apache.lucene.spatial.base.context.SpatialContextFactory;
+
+/**
+* @author dsmiley
+*/
+public class SimpleSpatialContextFactory extends SpatialContextFactory {
+  @Override
+  protected SpatialContext newSpatialContext() {
+    return new SimpleSpatialContext(units,calculator,worldBounds);
+  }
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/AbstractDistanceCalculator.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/AbstractDistanceCalculator.java
new file mode 100644
index 0000000..e07598e
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/AbstractDistanceCalculator.java
@@ -0,0 +1,36 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.distance;
+
+import org.apache.lucene.spatial.base.shape.Point;
+
+/**
+ * @author David Smiley - dsmiley@mitre.org
+ */
+public abstract class AbstractDistanceCalculator implements DistanceCalculator {
+
+  @Override
+  public double distance(Point from, Point to) {
+    return distance(from, to.getX(), to.getY());
+  }
+
+  @Override
+  public String toString() {
+    return getClass().getSimpleName();
+  }
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/CartesianDistCalc.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/CartesianDistCalc.java
new file mode 100644
index 0000000..853eba7
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/CartesianDistCalc.java
@@ -0,0 +1,98 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.distance;
+
+import org.apache.lucene.spatial.base.context.SpatialContext;
+import org.apache.lucene.spatial.base.shape.Point;
+import org.apache.lucene.spatial.base.shape.Rectangle;
+
+public class CartesianDistCalc extends AbstractDistanceCalculator {
+
+  private final boolean squared;
+
+  public CartesianDistCalc() {
+    this.squared = false;
+  }
+
+  public CartesianDistCalc(boolean squared) {
+    this.squared = squared;
+  }
+
+  @Override
+  public double distance(Point from, double toX, double toY) {
+    double result = 0;
+
+    double v = from.getX() - toX;
+    result += (v * v);
+
+    v = from.getY() - toY;
+    result += (v * v);
+
+    if( squared )
+      return result;
+
+    return Math.sqrt(result);
+  }
+
+  @Override
+  public Point pointOnBearing(Point from, double dist, double bearingDEG, SpatialContext ctx) {
+    if (dist == 0)
+      return from;
+    double bearingRAD = Math.toDegrees(bearingDEG);
+    double x = Math.sin(bearingRAD) * dist;
+    double y = Math.cos(bearingRAD) * dist;
+    return ctx.makePoint(from.getX()+x, from.getY()+y);
+  }
+
+  @Override
+  public double distanceToDegrees(double distance) {
+    throw new UnsupportedOperationException("no geo!");
+  }
+
+  @Override
+  public double degreesToDistance(double degrees) {
+    throw new UnsupportedOperationException("no geo!");
+  }
+
+  @Override
+  public Rectangle calcBoxByDistFromPt(Point from, double distance, SpatialContext ctx) {
+    return ctx.makeRect(from.getX()-distance,from.getX()+distance,from.getY()-distance,from.getY()+distance);
+  }
+
+  @Override
+  public double calcBoxByDistFromPtHorizAxis(Point from, double distance, SpatialContext ctx) {
+    return from.getY();
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (o == null || getClass() != o.getClass()) return false;
+
+    CartesianDistCalc that = (CartesianDistCalc) o;
+
+    if (squared != that.squared) return false;
+
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    return (squared ? 1 : 0);
+  }
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/DistanceCalculator.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/DistanceCalculator.java
new file mode 100644
index 0000000..d6cdb92
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/DistanceCalculator.java
@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.distance;
+
+import org.apache.lucene.spatial.base.context.SpatialContext;
+import org.apache.lucene.spatial.base.shape.Point;
+import org.apache.lucene.spatial.base.shape.Rectangle;
+
+public interface DistanceCalculator {
+
+  public double distance(Point from, Point to);
+  public double distance(Point from, double toX, double toY);
+
+  public Point pointOnBearing(Point from, double dist, double bearingDEG, SpatialContext ctx);
+  
+  /**
+   * Converts a distance to radians (multiples of the radius). A spherical
+   * earth model is assumed for geospatial, and non-geospatial is the identity function.
+   */
+  public double distanceToDegrees(double distance);
+
+  public double degreesToDistance(double degrees);
+
+  //public Point pointOnBearing(Point from, double angle);
+
+  public Rectangle calcBoxByDistFromPt(Point from, double distance, SpatialContext ctx);
+
+  public double calcBoxByDistFromPtHorizAxis(Point from, double distance, SpatialContext ctx);
+
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/DistanceUnits.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/DistanceUnits.java
new file mode 100644
index 0000000..8540b27
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/DistanceUnits.java
@@ -0,0 +1,120 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.distance;
+
+/**
+ * Enum representing difference distance units, currently only kilometers and
+ * miles
+ */
+public enum DistanceUnits {
+
+  //TODO do we need circumference?
+  KILOMETERS("km", DistanceUtils.EARTH_MEAN_RADIUS_KM, 40076),
+  MILES("miles", DistanceUtils.EARTH_MEAN_RADIUS_MI, 24902),
+  RADIANS("radians", 1, Math.PI * 2),//experimental
+  CARTESIAN("u", -1, -1);
+
+
+  private final String units;
+
+  private final double earthCircumference;
+
+  private final double earthRadius;
+
+  /**
+   * Creates a new DistanceUnit that represents the given unit
+   *
+   * @param units Distance unit in String form
+   * @param earthRadius Radius of the Earth in the specific distance unit
+   * @param earthCircumfence Circumference of the Earth in the specific distance unit
+   */
+  DistanceUnits(String units, double earthRadius, double earthCircumfence) {
+    this.units = units;
+    this.earthCircumference = earthCircumfence;
+    this.earthRadius = earthRadius;
+  }
+
+  /**
+   * Returns the DistanceUnit which represents the given unit
+   *
+   * @param unit Unit whose DistanceUnit should be found
+   * @return DistanceUnit representing the unit
+   * @throws IllegalArgumentException if no DistanceUnit which represents the given unit is found
+   */
+  public static DistanceUnits findDistanceUnit(String unit) {
+    if (MILES.getUnits().equalsIgnoreCase(unit) || unit.equalsIgnoreCase("mi")) {
+      return MILES;
+    }
+    if (KILOMETERS.getUnits().equalsIgnoreCase(unit)) {
+      return KILOMETERS;
+    }
+    if (CARTESIAN.getUnits().equalsIgnoreCase(unit) || unit.length()==0) {
+      return CARTESIAN;
+    }
+    throw new IllegalArgumentException("Unknown distance unit " + unit);
+  }
+
+  /**
+   * Converts the given distance in given DistanceUnit, to a distance in the unit represented by {@code this}
+   *
+   * @param distance Distance to convert
+   * @param from Unit to convert the distance from
+   * @return Given distance converted to the distance in the given unit
+   */
+  public double convert(double distance, DistanceUnits from) {
+    if (from == this) {
+      return distance;
+    }
+    if (this == CARTESIAN || from == CARTESIAN) {
+      throw new IllegalStateException("Can't convert cartesian distances: "+from+" -> "+this);
+    }
+    return (this == MILES) ? distance * DistanceUtils.KM_TO_MILES : distance * DistanceUtils.MILES_TO_KM;
+  }
+
+  /**
+   * Returns the string representation of the distance unit
+   *
+   * @return String representation of the distance unit
+   */
+  public String getUnits() {
+    return units;
+  }
+
+  /**
+   * Returns the <a href="http://en.wikipedia.org/wiki/Earth_radius">average earth radius</a>
+   *
+   * @return the average earth radius
+   */
+  public double earthRadius() {
+    return earthRadius;
+  }
+
+  /**
+   * Returns the <a href="http://www.lyberty.com/encyc/articles/earth.html">circumference of the Earth</a>
+   *
+   * @return  the circumference of the Earth
+   */
+  public double earthCircumference() {
+    return earthCircumference;
+  }
+  
+  public boolean isGeo() {
+    return earthRadius > 0;
+  }
+}
+
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/DistanceUtils.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/DistanceUtils.java
new file mode 100644
index 0000000..8b46f39
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/DistanceUtils.java
@@ -0,0 +1,427 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.distance;
+
+import org.apache.lucene.spatial.base.context.SpatialContext;
+import org.apache.lucene.spatial.base.shape.Rectangle;
+
+import static java.lang.Math.toRadians;
+
+/**
+ * Various distance calculations and constants.
+ * Originally from Lucene 3x's old spatial module. It has been modified here.
+ */
+public class DistanceUtils {
+
+  //pre-compute some angles that are commonly used
+  public static final double DEG_45_AS_RADS = Math.PI / 4.0;
+  public static final double SIN_45_AS_RADS = Math.sin(DEG_45_AS_RADS);
+  public static final double DEG_90_AS_RADS = Math.PI / 2;
+  public static final double DEG_180_AS_RADS = Math.PI;
+  public static final double DEG_225_AS_RADS = 5 * DEG_45_AS_RADS;
+  public static final double DEG_270_AS_RADS = 3 * DEG_90_AS_RADS;
+
+
+  public static final double KM_TO_MILES = 0.621371192;
+  public static final double MILES_TO_KM = 1 / KM_TO_MILES;//1.609
+
+  /**
+   * The International Union of Geodesy and Geophysics says the Earth's mean radius in KM is:
+   *
+   * [1] http://en.wikipedia.org/wiki/Earth_radius
+   */
+  public static final double EARTH_MEAN_RADIUS_KM = 6371.0087714;
+  public static final double EARTH_EQUATORIAL_RADIUS_KM = 6378.1370;
+
+  public static final double EARTH_MEAN_RADIUS_MI = EARTH_MEAN_RADIUS_KM * KM_TO_MILES;
+  public static final double EARTH_EQUATORIAL_RADIUS_MI = EARTH_EQUATORIAL_RADIUS_KM * KM_TO_MILES;
+
+  /**
+   * Calculate the p-norm (i.e. length) between two vectors
+   *
+   * @param vec1  The first vector
+   * @param vec2  The second vector
+   * @param power The power (2 for cartesian distance, 1 for manhattan, etc.)
+   * @return The length.
+   *         <p/>
+   *         See http://en.wikipedia.org/wiki/Lp_space
+   * @see #vectorDistance(double[], double[], double, double)
+   */
+  public static double vectorDistance(double[] vec1, double[] vec2, double power) {
+    return vectorDistance(vec1, vec2, power, 1.0 / power);
+  }
+
+  /**
+   * Calculate the p-norm (i.e. length) between two vectors
+   *
+   * @param vec1         The first vector
+   * @param vec2         The second vector
+   * @param power        The power (2 for cartesian distance, 1 for manhattan, etc.)
+   * @param oneOverPower If you've precalculated oneOverPower and cached it, use this method to save one division operation over {@link #vectorDistance(double[], double[], double)}.
+   * @return The length.
+   */
+  public static double vectorDistance(double[] vec1, double[] vec2, double power, double oneOverPower) {
+    double result = 0;
+
+    if (power == 0) {
+      for (int i = 0; i < vec1.length; i++) {
+        result += vec1[i] - vec2[i] == 0 ? 0 : 1;
+      }
+
+    } else if (power == 1.0) {
+      for (int i = 0; i < vec1.length; i++) {
+        result += vec1[i] - vec2[i];
+      }
+    } else if (power == 2.0) {
+      result = Math.sqrt(distSquaredCartesian(vec1, vec2));
+    } else if (power == Integer.MAX_VALUE || Double.isInfinite(power)) {//infinite norm?
+      for (int i = 0; i < vec1.length; i++) {
+        result = Math.max(result, Math.max(vec1[i], vec2[i]));
+      }
+    } else {
+      for (int i = 0; i < vec1.length; i++) {
+        result += Math.pow(vec1[i] - vec2[i], power);
+      }
+      result = Math.pow(result, oneOverPower);
+    }
+    return result;
+  }
+
+  /**
+   * Return the coordinates of a vector that is the corner of a box (upper right or lower left), assuming a Rectangular
+   * coordinate system.  Note, this does not apply for points on a sphere or ellipse (although it could be used as an approximation).
+   *
+   * @param center     The center point
+   * @param result Holds the result, potentially resizing if needed.
+   * @param distance   The d from the center to the corner
+   * @param upperRight If true, return the coords for the upper right corner, else return the lower left.
+   * @return The point, either the upperLeft or the lower right
+   */
+  public static double[] vectorBoxCorner(double[] center, double[] result, double distance, boolean upperRight) {
+    if (result == null || result.length != center.length) {
+      result = new double[center.length];
+    }
+    if (upperRight == false) {
+      distance = -distance;
+    }
+    //We don't care about the power here,
+    // b/c we are always in a rectangular coordinate system, so any norm can be used by
+    //using the definition of sine
+    distance = SIN_45_AS_RADS * distance; // sin(Pi/4) == (2^0.5)/2 == opp/hyp == opp/distance, solve for opp, similarly for cosine
+    for (int i = 0; i < center.length; i++) {
+      result[i] = center[i] + distance;
+    }
+    return result;
+  }
+
+  /**
+   * Given a start point (startLat, startLon) and a bearing on a sphere of radius <i>sphereRadius</i>, return the destination point.
+   *
+   *
+   * @param startLat The starting point latitude, in radians
+   * @param startLon The starting point longitude, in radians
+   * @param distanceRAD The distance to travel along the bearing in radians.
+   * @param bearingRAD The bearing, in radians.  North is a 0, moving clockwise till radians(360).
+   * @param result A preallocated array to hold the results.  If null, a new one is constructed.
+   * @return The destination point, in radians.  First entry is latitude, second is longitude
+   */
+  public static double[] pointOnBearingRAD(double startLat, double startLon, double distanceRAD, double bearingRAD, double[] result) {
+    /*
+ 	lat2 = asin(sin(lat1)*cos(d/R) + cos(lat1)*sin(d/R)*cos(θ))
+  	lon2 = lon1 + atan2(sin(θ)*sin(d/R)*cos(lat1), cos(d/R)??in(lat1)*sin(lat2))
+
+     */
+    double cosAngDist = Math.cos(distanceRAD);
+    double cosStartLat = Math.cos(startLat);
+    double sinAngDist = Math.sin(distanceRAD);
+    double sinStartLat = Math.sin(startLat);
+    double lat2 = Math.asin(sinStartLat * cosAngDist +
+            cosStartLat * sinAngDist * Math.cos(bearingRAD));
+
+    double lon2 = startLon + Math.atan2(Math.sin(bearingRAD) * sinAngDist * cosStartLat,
+            cosAngDist - sinStartLat * Math.sin(lat2));
+
+    /*lat2 = (lat2*180)/Math.PI;
+    lon2 = (lon2*180)/Math.PI;*/
+    //From Lucene.  Move back to Lucene when synced
+    // normalize lon first
+    if (result == null || result.length != 2){
+      result = new double[2];
+    }
+    result[0] = lat2;
+    result[1] = lon2;
+    normLngRAD(result);
+
+    // normalize lat - could flip poles
+    normLatRAD(result);
+    return result;
+  }
+
+  /**
+   * @param latLng The lat/lon, in radians. lat in position 0, lon in position 1
+   */
+  public static void normLatRAD(double[] latLng) {
+
+    if (latLng[0] > DEG_90_AS_RADS) {
+      latLng[0] = DEG_90_AS_RADS - (latLng[0] - DEG_90_AS_RADS);
+      if (latLng[1] < 0) {
+        latLng[1] = latLng[1] + DEG_180_AS_RADS;
+      } else {
+        latLng[1] = latLng[1] - DEG_180_AS_RADS;
+      }
+    } else if (latLng[0] < -DEG_90_AS_RADS) {
+      latLng[0] = -DEG_90_AS_RADS - (latLng[0] + DEG_90_AS_RADS);
+      if (latLng[1] < 0) {
+        latLng[1] = latLng[1] + DEG_180_AS_RADS;
+      } else {
+        latLng[1] = latLng[1] - DEG_180_AS_RADS;
+      }
+    }
+
+  }
+
+  /**
+   * Returns a normalized Lng rectangle shape for the bounding box
+   *
+   * @param latLng The lat/lon, in radians, lat in position 0, lon in position 1
+   */
+  @Deprecated
+  public static void normLngRAD(double[] latLng) {
+    if (latLng[1] > DEG_180_AS_RADS) {
+      latLng[1] = -1.0 * (DEG_180_AS_RADS - (latLng[1] - DEG_180_AS_RADS));
+    } else if (latLng[1] < -DEG_180_AS_RADS) {
+      latLng[1] = (latLng[1] + DEG_180_AS_RADS) + DEG_180_AS_RADS;
+    }
+  }
+
+  /**
+   * Puts in range -180 <= lon_deg < +180.
+   */
+  public static double normLonDEG(double lon_deg) {
+    if (lon_deg >= -180 && lon_deg < 180)
+      return lon_deg;//common case, and avoids slight double precision shifting
+    double off = (lon_deg + 180) % 360;
+    return off < 0 ? 180 + off : -180 + off;
+  }
+
+  /**
+   * Puts in range -90 <= lat_deg <= 90.
+   */
+  public static double normLatDEG(double lat_deg) {
+    if (lat_deg >= -90 && lat_deg <= 90)
+      return lat_deg;//common case, and avoids slight double precision shifting
+    double off = Math.abs((lat_deg + 90) % 360);
+    return (off <= 180 ? off : 360-off) - 90;
+  }
+
+  public static Rectangle calcBoxByDistFromPtDEG(double lat, double lon, double distance, SpatialContext ctx) {
+    //See http://janmatuschek.de/LatitudeLongitudeBoundingCoordinates Section 3.1, 3.2 and 3.3
+
+    double radius = ctx.getUnits().earthRadius();
+    double dist_rad = distance / radius;
+    double dist_deg = Math.toDegrees(dist_rad);
+
+    if (dist_deg == 0)
+      return ctx.makeRect(lon,lon,lat,lat);
+
+    if (dist_deg >= 180)//distance is >= opposite side of the globe
+      return ctx.getWorldBounds();
+
+    //--calc latitude bounds
+    double latN_deg = lat + dist_deg;
+    double latS_deg = lat - dist_deg;
+
+    if (latN_deg >= 90 || latS_deg <= -90) {//touches either pole
+      //we have special logic for longitude
+      double lonW_deg = -180, lonE_deg = 180;//world wrap: 360 deg
+      if (latN_deg <= 90 && latS_deg >= -90) {//doesn't pass either pole: 180 deg
+        lonW_deg = lon -90;
+        lonE_deg = lon +90;
+      }
+      if (latN_deg > 90)
+        latN_deg = 90;
+      if (latS_deg < -90)
+        latS_deg = -90;
+
+      return ctx.makeRect(lonW_deg, lonE_deg, latS_deg, latN_deg);
+    } else {
+      //--calc longitude bounds
+      double lon_delta_deg = calcBoxByDistFromPtVertAxisOffsetDEG(lat, lon, distance, radius);
+
+      double lonW_deg = lon -lon_delta_deg;
+      double lonE_deg = lon +lon_delta_deg;
+
+      return ctx.makeRect(lonW_deg, lonE_deg, latS_deg, latN_deg);//ctx will normalize longitude
+    }
+  }
+
+  public static double calcBoxByDistFromPtVertAxisOffsetDEG(double lat, double lon, double distance, double radius) {
+    //http://gis.stackexchange.com/questions/19221/find-tangent-point-on-circle-furthest-east-or-west
+    if (distance == 0)
+      return 0;
+    double lat_rad = toRadians(lat);
+    double dist_rad = distance / radius;
+    double result_rad = Math.asin(Math.sin(dist_rad) / Math.cos(lat_rad));
+
+    if (!Double.isNaN(result_rad))
+      return Math.toDegrees(result_rad);
+    return 90;
+  }
+
+  public static double calcBoxByDistFromPtHorizAxisDEG(double lat, double lon, double distance, double radius) {
+    //http://gis.stackexchange.com/questions/19221/find-tangent-point-on-circle-furthest-east-or-west
+    if (distance == 0)
+      return lat;
+    double lat_rad = toRadians(lat);
+    double dist_rad = distance / radius;
+    double result_rad = Math.asin( Math.sin(lat_rad) / Math.cos(dist_rad));
+    if (!Double.isNaN(result_rad))
+      return Math.toDegrees(result_rad);
+    //TODO should we use use ctx.getBoundaryNudgeDegrees() offsets here or let caller?
+    if (lat > 0)
+      return 90;
+    if (lat < 0)
+      return -90;
+    return lat;
+  }
+
+  /**
+   * The square of the cartesian Distance.  Not really a distance, but useful if all that matters is
+   * comparing the result to another one.
+   *
+   * @param vec1 The first point
+   * @param vec2 The second point
+   * @return The squared cartesian distance
+   */
+  public static double distSquaredCartesian(double[] vec1, double[] vec2) {
+    double result = 0;
+    for (int i = 0; i < vec1.length; i++) {
+      double v = vec1[i] - vec2[i];
+      result += v * v;
+    }
+    return result;
+  }
+
+  /**
+   *
+   * @param lat1     The y coordinate of the first point, in radians
+   * @param lon1     The x coordinate of the first point, in radians
+   * @param lat2     The y coordinate of the second point, in radians
+   * @param lon2     The x coordinate of the second point, in radians
+   * @return The distance between the two points, as determined by the Haversine formula, in radians.
+   */
+  public static double distHaversineRAD(double lat1, double lon1, double lat2, double lon2) {
+    //TODO investigate slightly different formula using asin() and min() http://www.movable-type.co.uk/scripts/gis-faq-5.1.html
+
+    // Check for same position
+    if (lat1 == lat2 && lon1 == lon2)
+      return 0.0;
+    double hsinX = Math.sin((lon1 - lon2) * 0.5);
+    double hsinY = Math.sin((lat1 - lat2) * 0.5);
+    double h = hsinY * hsinY +
+            (Math.cos(lat1) * Math.cos(lat2) * hsinX * hsinX);
+    return 2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h));
+  }
+
+  /**
+   * Calculates the distance between two lat/lng's using the Law of Cosines. Due to numeric conditioning
+   * errors, it is not as accurate as the Haversine formula for small distances.  But with
+   * double precision, it isn't that bad -- <a href="http://www.movable-type.co.uk/scripts/latlong.html">
+   *   allegedly 1 meter</a>.
+   * <p/>
+   * See <a href="http://gis.stackexchange.com/questions/4906/why-is-law-of-cosines-more-preferable-than-haversine-when-calculating-distance-b">
+   *  Why is law of cosines more preferable than haversine when calculating distance between two latitude-longitude points?</a>
+   * <p/>
+   * The arguments and return value are in radians.
+   */
+  public static double distLawOfCosinesRAD(double lat1, double lon1, double lat2, double lon2) {
+    //TODO validate formula
+
+    //(MIGRATED FROM org.apache.lucene.spatial.geometry.LatLng.arcDistance())
+    // Imported from mq java client.  Variable references changed to match.
+
+    // Check for same position
+    if (lat1 == lat2 && lon1 == lon2)
+      return 0.0;
+
+    // Get the m_dLongitude difference. Don't need to worry about
+    // crossing 180 since cos(x) = cos(-x)
+    double dLon = lon2 - lon1;
+
+    double a = DEG_90_AS_RADS - lat1;
+    double c = DEG_90_AS_RADS - lat2;
+    double cosB = (Math.cos(a) * Math.cos(c))
+        + (Math.sin(a) * Math.sin(c) * Math.cos(dLon));
+
+    // Find angle subtended (with some bounds checking) in radians
+    if (cosB < -1.0)
+      return Math.PI;
+    else if (cosB >= 1.0)
+      return 0;
+    else
+      return Math.acos(cosB);
+  }
+
+  /**
+   * Calculates the great circle distance using the Vincenty Formula, simplified for a spherical model. This formula
+   * is accurate for any pair of points. The equation
+   * was taken from <a href="http://en.wikipedia.org/wiki/Great-circle_distance">Wikipedia</a>.
+   * <p/>
+   * The arguments are in radians, and the result is in radians.
+   */
+  public static double distVincentyRAD(double lat1, double lon1, double lat2, double lon2) {
+    // Check for same position
+    if (lat1 == lat2 && lon1 == lon2)
+      return 0.0;
+
+    double cosLat1 = Math.cos(lat1);
+    double cosLat2 = Math.cos(lat2);
+    double sinLat1 = Math.sin(lat1);
+    double sinLat2 = Math.sin(lat2);
+    double dLon = lon2 - lon1;
+    double cosDLon = Math.cos(dLon);
+    double sinDLon = Math.sin(dLon);
+
+    double a = cosLat2 * sinDLon;
+    double b = cosLat1*sinLat2 - sinLat1*cosLat2*cosDLon;
+    double c = sinLat1*sinLat2 + cosLat1*cosLat2*cosDLon;
+    
+    return Math.atan2(Math.sqrt(a*a+b*b),c);
+  }
+
+  /**
+   * Converts a distance in the units of the radius to degrees (360 degrees are in a circle). A spherical
+   * earth model is assumed.
+   */
+  public static double dist2Degrees(double dist, double radius) {
+    return Math.toDegrees(dist2Radians(dist, radius));
+  }
+
+  /**
+   * Converts a distance in the units of the radius to radians (multiples of the radius). A spherical
+   * earth model is assumed.
+   */
+  public static double dist2Radians(double dist, double radius) {
+    return dist / radius;
+  }
+
+  public static double radians2Dist(double radians, double radius) {
+    return radians * radius;
+  }
+
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/GeodesicSphereDistCalc.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/GeodesicSphereDistCalc.java
new file mode 100644
index 0000000..304fcc9
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/GeodesicSphereDistCalc.java
@@ -0,0 +1,133 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.distance;
+
+import org.apache.lucene.spatial.base.context.SpatialContext;
+import org.apache.lucene.spatial.base.shape.Point;
+import org.apache.lucene.spatial.base.shape.Rectangle;
+
+import static java.lang.Math.toRadians;
+
+/**
+ * A base class for a Distance Calculator that assumes a spherical earth model.
+ * @author dsmiley
+ */
+public abstract class GeodesicSphereDistCalc extends AbstractDistanceCalculator {
+  protected final double radius;
+
+  public GeodesicSphereDistCalc(double radius) {
+    this.radius = radius;
+  }
+
+  @Override
+  public double distanceToDegrees(double distance) {
+    return DistanceUtils.dist2Degrees(distance, radius);
+  }
+
+  @Override
+  public double degreesToDistance(double degrees) {
+    return DistanceUtils.radians2Dist(toRadians(degrees), radius);
+  }
+
+  @Override
+  public Point pointOnBearing(Point from, double dist, double bearingDEG, SpatialContext ctx) {
+    //TODO avoid unnecessary double[] intermediate object
+    if (dist == 0)
+      return from;
+    double[] latLon = DistanceUtils.pointOnBearingRAD(
+        toRadians(from.getY()), toRadians(from.getX()),
+        DistanceUtils.dist2Radians(dist,ctx.getUnits().earthRadius()),
+        toRadians(bearingDEG), null);
+    return ctx.makePoint(Math.toDegrees(latLon[1]), Math.toDegrees(latLon[0]));
+  }
+
+  @Override
+  public Rectangle calcBoxByDistFromPt(Point from, double distance, SpatialContext ctx) {
+    assert radius == ctx.getUnits().earthRadius();
+    if (distance == 0)
+      return from.getBoundingBox();
+    return DistanceUtils.calcBoxByDistFromPtDEG(from.getY(), from.getX(), distance, ctx);
+  }
+
+  @Override
+  public double calcBoxByDistFromPtHorizAxis(Point from, double distance, SpatialContext ctx) {
+    return DistanceUtils.calcBoxByDistFromPtHorizAxisDEG(from.getY(), from.getX(), distance, radius);
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (o == null || getClass() != o.getClass()) return false;
+
+    GeodesicSphereDistCalc that = (GeodesicSphereDistCalc) o;
+
+    if (Double.compare(that.radius, radius) != 0) return false;
+
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    long temp = radius != +0.0d ? Double.doubleToLongBits(radius) : 0L;
+    return (int) (temp ^ (temp >>> 32));
+  }
+
+  @Override
+  public final double distance(Point from, double toX, double toY) {
+    return distanceLatLonRAD(toRadians(from.getY()), toRadians(from.getX()), toRadians(toY), toRadians(toX)) * radius;
+  }
+
+  protected abstract double distanceLatLonRAD(double lat1, double lon1, double lat2, double lon2);
+
+  public static class Haversine extends GeodesicSphereDistCalc {
+
+    public Haversine(double radius) {
+      super(radius);
+    }
+
+    @Override
+    protected double distanceLatLonRAD(double lat1, double lon1, double lat2, double lon2) {
+      return DistanceUtils.distHaversineRAD(lat1,lon1,lat2,lon2);
+    }
+
+  }
+
+  public static class LawOfCosines extends GeodesicSphereDistCalc {
+
+    public LawOfCosines(double radius) {
+      super(radius);
+    }
+
+    @Override
+    protected double distanceLatLonRAD(double lat1, double lon1, double lat2, double lon2) {
+      return DistanceUtils.distLawOfCosinesRAD(lat1, lon1, lat2, lon2);
+    }
+
+  }
+
+  public static class Vincenty extends GeodesicSphereDistCalc {
+    public Vincenty(double radius) {
+      super(radius);
+    }
+
+    @Override
+    protected double distanceLatLonRAD(double lat1, double lon1, double lat2, double lon2) {
+      return DistanceUtils.distVincentyRAD(lat1, lon1, lat2, lon2);
+    }
+  }
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/package-info.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/package-info.java
new file mode 100644
index 0000000..0a15a97
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/package-info.java
@@ -0,0 +1,22 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Ways to calculate distance
+ */
+package org.apache.lucene.spatial.base.distance;
+
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/exception/InvalidShapeException.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/exception/InvalidShapeException.java
new file mode 100644
index 0000000..a8c052d
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/exception/InvalidShapeException.java
@@ -0,0 +1,29 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.exception;
+
+public class InvalidShapeException extends RuntimeException {
+
+  public InvalidShapeException(String reason, Throwable cause) {
+    super(reason, cause);
+  }
+
+  public InvalidShapeException(String reason) {
+    super(reason);
+  }
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/exception/InvalidSpatialArgument.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/exception/InvalidSpatialArgument.java
new file mode 100644
index 0000000..29dc10e
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/exception/InvalidSpatialArgument.java
@@ -0,0 +1,29 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.exception;
+
+public class InvalidSpatialArgument extends RuntimeException {
+
+  public InvalidSpatialArgument(String reason, Throwable cause) {
+    super(reason, cause);
+  }
+
+  public InvalidSpatialArgument(String reason) {
+    super(reason);
+  }
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/exception/UnsupportedSpatialOperation.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/exception/UnsupportedSpatialOperation.java
new file mode 100644
index 0000000..74da848
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/exception/UnsupportedSpatialOperation.java
@@ -0,0 +1,27 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.exception;
+
+import org.apache.lucene.spatial.base.query.SpatialOperation;
+
+public class UnsupportedSpatialOperation extends UnsupportedOperationException {
+
+  public UnsupportedSpatialOperation(SpatialOperation op) {
+    super(op.getName());
+  }
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/LineReader.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/LineReader.java
new file mode 100644
index 0000000..0bad39a
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/LineReader.java
@@ -0,0 +1,113 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.io;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.util.Iterator;
+
+public abstract class LineReader<T> implements Iterator<T> {
+
+  private int count = 0;
+  private int lineNumber = 0;
+  private BufferedReader reader;
+  private String nextLine;
+
+  public abstract T parseLine( String line );
+
+  protected void readComment( String line ) {
+
+  }
+
+  public LineReader(InputStream in) throws IOException {
+    reader = new BufferedReader(
+        new InputStreamReader( in, "UTF-8" ) );
+    next();
+  }
+
+  public LineReader(Reader r) throws IOException {
+    if (r instanceof BufferedReader) {
+      reader = (BufferedReader) r;
+    } else {
+      reader = new BufferedReader(r);
+    }
+    next();
+  }
+
+  public LineReader(File f) throws IOException {
+    reader = new BufferedReader(new InputStreamReader(new FileInputStream(f), "UTF-8"));
+    next();
+  }
+
+  @Override
+  public boolean hasNext() {
+    return nextLine != null;
+  }
+
+  @Override
+  public T next() {
+    T val = null;
+    if (nextLine != null) {
+      val = parseLine(nextLine);
+      count++;
+    }
+
+    if (reader != null) {
+      try {
+        while( reader != null ) {
+          nextLine = reader.readLine();
+          lineNumber++;
+          if (nextLine == null ) {
+            reader.close();
+            reader = null;
+          }
+          else if( nextLine.startsWith( "#" ) ) {
+            readComment( nextLine );
+          }
+          else {
+            nextLine = nextLine.trim();
+            if( nextLine.length() > 0 ) {
+              break;
+            }
+          }
+        }
+      } catch (IOException ioe) {
+        throw new RuntimeException("IOException thrown while reading/closing reader", ioe);
+      }
+    }
+    return val;
+  }
+
+  @Override
+  public void remove() {
+    throw new UnsupportedOperationException();
+  }
+
+  public int getLineNumber() {
+    return lineNumber;
+  }
+
+  public int getCount() {
+    return count;
+  }
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/geonames/Geoname.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/geonames/Geoname.java
new file mode 100644
index 0000000..cc6d8d6
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/geonames/Geoname.java
@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.io.geonames;
+
+import java.sql.Date;
+
+public class Geoname {
+  public int id;
+  public String name; // name of geographical point (utf8) varchar(200)
+  public String nameASCII; // name of geographical point in plain ascii characters, varchar(200)
+  public String[] alternateNames; // alternatenames, comma separated varchar(5000)
+  public double latitude;
+  public double longitude;
+  public char featureClass;
+  public String featureCode; // 10
+  public String countryCode; // 2
+  public String[] countryCode2; // alternate country codes, comma separated, ISO-3166 2-letter country code, 60 characters
+  public String adminCode1; // fipscode (subject to change to iso code), see exceptions below, see file admin1Codes.txt for display names of this code; varchar(20)
+  public String adminCode2; // code for the second administrative division, a county in the US, see file admin2Codes.txt; varchar(80)
+  public String adminCode3; // code for third level administrative division, varchar(20)
+  public String adminCode4; // code for fourth level administrative division, varchar(20)
+  public Long population;
+  public Integer elevation; // in meters, integer
+  public Integer gtopo30;   // average elevation of 30'x30' (ca 900mx900m) area in meters, integer
+  public String timezone;
+  public Date modified;  // date of last modification in yyyy-MM-dd format
+
+  public Geoname(String line) {
+    String[] vals = line.split("\t");
+    id = Integer.parseInt(vals[0]);
+    name = vals[1];
+    nameASCII = vals[2];
+    alternateNames = vals[3].split(",");
+    latitude = Double.parseDouble(vals[4]);
+    longitude = Double.parseDouble(vals[5]);
+    featureClass = vals[6].length() > 0 ? vals[6].charAt(0) : 'S';
+    featureCode = vals[7];
+    countryCode = vals[8];
+    countryCode2 = vals[9].split(",");
+    adminCode1 = vals[10];
+    adminCode2 = vals[11];
+    adminCode3 = vals[12];
+    adminCode4 = vals[13];
+    if (vals[14].length() > 0) {
+      population = Long.decode(vals[14]);
+    }
+    if (vals[15].length() > 0) {
+      elevation = Integer.decode(vals[15]);
+    }
+    if (vals[16].length() > 0) {
+      gtopo30 = Integer.decode(vals[16]);
+    }
+    timezone = vals[17];
+    if (vals[18].length() > 0) {
+      modified = Date.valueOf(vals[18]);
+    }
+  }
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/geonames/GeonamesReader.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/geonames/GeonamesReader.java
new file mode 100644
index 0000000..9158d10
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/geonames/GeonamesReader.java
@@ -0,0 +1,40 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.io.geonames;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.Reader;
+
+import org.apache.lucene.spatial.base.io.LineReader;
+
+public class GeonamesReader extends LineReader<Geoname> {
+
+  public GeonamesReader(Reader r) throws IOException {
+    super( r );
+  }
+
+  public GeonamesReader(File f) throws IOException {
+    super( f );
+  }
+
+  @Override
+  public Geoname parseLine(String line) {
+    return new Geoname( line );
+  }
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/sample/SampleData.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/sample/SampleData.java
new file mode 100644
index 0000000..caefe07
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/sample/SampleData.java
@@ -0,0 +1,41 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.io.sample;
+
+import java.util.Comparator;
+
+
+public class SampleData {
+  public String id;
+  public String name;
+  public String shape;
+
+  public SampleData(String line) {
+    String[] vals = line.split("\t");
+    id = vals[0];
+    name = vals[1];
+    shape = vals[2];
+  }
+
+  public static Comparator<SampleData> NAME_ORDER = new Comparator<SampleData>() {
+    @Override
+    public int compare(SampleData o1, SampleData o2) {
+      return o1.name.compareTo( o2.name );
+    }
+  };
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/sample/SampleDataReader.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/sample/SampleDataReader.java
new file mode 100644
index 0000000..8d79cb7
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/sample/SampleDataReader.java
@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.io.sample;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+
+import org.apache.lucene.spatial.base.io.LineReader;
+
+public class SampleDataReader extends LineReader<SampleData> {
+
+  public SampleDataReader(InputStream r) throws IOException {
+    super( r );
+  }
+
+  public SampleDataReader(Reader r) throws IOException {
+    super( r );
+  }
+
+  public SampleDataReader(File f) throws IOException {
+    super( f );
+  }
+
+  @Override
+  public SampleData parseLine(String line) {
+    return new SampleData( line );
+  }
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/package-info.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/package-info.java
new file mode 100644
index 0000000..aa3585f
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/package-info.java
@@ -0,0 +1,23 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * This package is spatal stuff without any lucene dependencies
+ * Things implemented in this package could be calculated on the client side
+ */
+package org.apache.lucene.spatial.base;
+
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/Node.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/Node.java
new file mode 100644
index 0000000..03a3a9f
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/Node.java
@@ -0,0 +1,215 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.prefix;
+
+import org.apache.lucene.spatial.base.shape.SpatialRelation;
+import org.apache.lucene.spatial.base.shape.Point;
+import org.apache.lucene.spatial.base.shape.Shape;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Represents a grid cell. These are not necessarily threadsafe, although new Cell("") (world cell) must be.
+ */
+public abstract class Node implements Comparable<Node> {
+  public static final byte LEAF_BYTE = '+';//NOTE: must sort before letters & numbers
+
+  /*
+  Holds a byte[] and/or String representation of the cell. Both are lazy constructed from the other.
+  Neither contains the trailing leaf byte.
+   */
+  private byte[] bytes;
+  private int b_off;
+  private int b_len;
+
+  private String token;//this is the only part of equality
+
+  protected SpatialRelation shapeRel;//set in getSubCells(filter), and via setLeaf().
+  private SpatialPrefixTree spatialPrefixTree;
+
+  protected Node(SpatialPrefixTree spatialPrefixTree, String token) {
+    this.spatialPrefixTree = spatialPrefixTree;
+    this.token = token;
+    if (token.length() > 0 && token.charAt(token.length() - 1) == (char) LEAF_BYTE) {
+      this.token = token.substring(0, token.length() - 1);
+      setLeaf();
+    }
+
+    if (getLevel() == 0)
+      getShape();//ensure any lazy instantiation completes to make this threadsafe
+  }
+
+  protected Node(SpatialPrefixTree spatialPrefixTree, byte[] bytes, int off, int len) {
+    this.spatialPrefixTree = spatialPrefixTree;
+    this.bytes = bytes;
+    this.b_off = off;
+    this.b_len = len;
+    b_fixLeaf();
+  }
+
+  public void reset(byte[] bytes, int off, int len) {
+    assert getLevel() != 0;
+    token = null;
+    shapeRel = null;
+    this.bytes = bytes;
+    this.b_off = off;
+    this.b_len = len;
+    b_fixLeaf();
+  }
+
+  private void b_fixLeaf() {
+    if (bytes[b_off + b_len - 1] == LEAF_BYTE) {
+      b_len--;
+      setLeaf();
+    } else if (getLevel() == spatialPrefixTree.getMaxLevels()) {
+      setLeaf();
+    }
+  }
+
+  public SpatialRelation getShapeRel() {
+    return shapeRel;
+  }
+
+  public boolean isLeaf() {
+    return shapeRel == SpatialRelation.WITHIN;
+  }
+
+  public void setLeaf() {
+    assert getLevel() != 0;
+    shapeRel = SpatialRelation.WITHIN;
+  }
+
+  /**
+   * Note: doesn't contain a trailing leaf byte.
+   */
+  public String getTokenString() {
+    if (token == null) {
+      token = new String(bytes, b_off, b_len, SpatialPrefixTree.UTF8);
+    }
+    return token;
+  }
+
+  /**
+   * Note: doesn't contain a trailing leaf byte.
+   */
+  public byte[] getTokenBytes() {
+    if (bytes != null) {
+      if (b_off != 0 || b_len != bytes.length) {
+        throw new IllegalStateException("Not supported if byte[] needs to be recreated.");
+      }
+    } else {
+      bytes = token.getBytes(SpatialPrefixTree.UTF8);
+      b_off = 0;
+      b_len = bytes.length;
+    }
+    return bytes;
+  }
+
+  public int getLevel() {
+    return token != null ? token.length() : b_len;
+  }
+
+  //TODO add getParent() and update some algorithms to use this?
+  //public Cell getParent();
+
+  /**
+   * Like {@link #getSubCells()} but with the results filtered by a shape. If that shape is a {@link org.apache.lucene.spatial.base.shape.Point} then it
+   * must call {@link #getSubCell(org.apache.lucene.spatial.base.shape.Point)};
+   * Precondition: Never called when getLevel() == maxLevel.
+   *
+   * @param shapeFilter an optional filter for the returned cells.
+   * @return A set of cells (no dups), sorted. Not Modifiable.
+   */
+  public Collection<Node> getSubCells(Shape shapeFilter) {
+    //Note: Higher-performing subclasses might override to consider the shape filter to generate fewer cells.
+    if (shapeFilter instanceof Point) {
+      return Collections.singleton(getSubCell((Point) shapeFilter));
+    }
+    Collection<Node> cells = getSubCells();
+
+    if (shapeFilter == null) {
+      return cells;
+    }
+    List<Node> copy = new ArrayList<Node>(cells.size());//copy since cells contractually isn't modifiable
+    for (Node cell : cells) {
+      SpatialRelation rel = cell.getShape().relate(shapeFilter, spatialPrefixTree.ctx);
+      if (rel == SpatialRelation.DISJOINT)
+        continue;
+      cell.shapeRel = rel;
+      copy.add(cell);
+    }
+    cells = copy;
+    return cells;
+  }
+
+  /**
+   * Performant implementations are expected to implement this efficiently by considering the current
+   * cell's boundary.
+   * Precondition: Never called when getLevel() == maxLevel.
+   * Precondition: this.getShape().relate(p) != DISJOINT.
+   *
+   * @param p
+   * @return
+   */
+  public abstract Node getSubCell(Point p);
+
+  //TODO Cell getSubCell(byte b)
+
+  /**
+   * Gets the cells at the next grid cell level that cover this cell.
+   * Precondition: Never called when getLevel() == maxLevel.
+   *
+   * @return A set of cells (no dups), sorted. Not Modifiable.
+   */
+  protected abstract Collection<Node> getSubCells();
+
+  /**
+   * {@link #getSubCells()}.size() -- usually a constant. Should be >=2
+   */
+  public abstract int getSubCellsSize();
+
+  public abstract Shape getShape();
+
+  public Point getCenter() {
+    return getShape().getCenter();
+  }
+
+  @Override
+  public int compareTo(Node o) {
+    return getTokenString().compareTo(o.getTokenString());
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    return !(obj == null || !(obj instanceof Node)) && getTokenString().equals(((Node) obj).getTokenString());
+  }
+
+  @Override
+  public int hashCode() {
+    return getTokenString().hashCode();
+  }
+
+  @Override
+  public String toString() {
+    return getTokenString() + (isLeaf() ? (char) LEAF_BYTE : "");
+  }
+
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/SpatialPrefixTree.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/SpatialPrefixTree.java
new file mode 100644
index 0000000..58dbe1c
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/SpatialPrefixTree.java
@@ -0,0 +1,246 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.prefix;
+
+import org.apache.lucene.spatial.base.context.SpatialContext;
+import org.apache.lucene.spatial.base.shape.Point;
+import org.apache.lucene.spatial.base.shape.Shape;
+
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * A Spatial Prefix Tree, or Trie, which decomposes shapes into prefixed strings at variable lengths corresponding to
+ * variable precision.  Each string corresponds to a spatial region.
+ *
+ * Implementations of this class should be thread-safe and immutable once initialized.
+ */
+public abstract class SpatialPrefixTree {
+
+  protected static final Charset UTF8 = Charset.forName("UTF-8");
+
+  protected final int maxLevels;
+
+  protected final SpatialContext ctx;
+
+  public SpatialPrefixTree(SpatialContext ctx, int maxLevels) {
+    assert maxLevels > 0;
+    this.ctx = ctx;
+    this.maxLevels = maxLevels;
+  }
+
+  public SpatialContext getSpatialContext() {
+    return ctx;
+  }
+
+  public int getMaxLevels() {
+    return maxLevels;
+  }
+
+  @Override
+  public String toString() {
+    return getClass().getSimpleName() + "(maxLevels:" + maxLevels + ",ctx:" + ctx + ")";
+  }
+
+  /**
+   * See {@link org.apache.lucene.spatial.base.query.SpatialArgs#getDistPrecision()}.
+   * A grid level looked up via {@link #getLevelForDistance(double)} is returned.
+   *
+   * @param shape
+   * @param precision 0-0.5
+   * @return 1-maxLevels
+   */
+  public int getMaxLevelForPrecision(Shape shape, double precision) {
+    if (precision < 0 || precision > 0.5) {
+      throw new IllegalArgumentException("Precision " + precision + " must be between [0-0.5]");
+    }
+    if (precision == 0 || shape instanceof Point) {
+      return maxLevels;
+    }
+    double bboxArea = shape.getBoundingBox().getArea();
+    if (bboxArea == 0) {
+      return maxLevels;
+    }
+    double avgSideLenFromCenter = Math.sqrt(bboxArea) / 2;
+    return getLevelForDistance(avgSideLenFromCenter * precision);
+  }
+
+  /**
+   * Returns the level of the smallest grid size with a side length that is greater or equal to the provided
+   * distance.
+   *
+   * @param dist >= 0
+   * @return level [1-maxLevels]
+   */
+  public abstract int getLevelForDistance(double dist);
+
+  //TODO double getDistanceForLevel(int level)
+
+  private transient Node worldNode;//cached
+
+  /**
+   * Returns the level 0 cell which encompasses all spatial data. Equivalent to {@link #getNode(String)} with "".
+   * This cell is threadsafe, just like a spatial prefix grid is, although cells aren't
+   * generally threadsafe.
+   * TODO rename to getTopCell or is this fine?
+   */
+  public Node getWorldNode() {
+    if (worldNode == null) {
+      worldNode = getNode("");
+    }
+    return worldNode;
+  }
+
+  /**
+   * The cell for the specified token. The empty string should be equal to {@link #getWorldNode()}.
+   * Precondition: Never called when token length > maxLevel.
+   */
+  public abstract Node getNode(String token);
+
+  public abstract Node getNode(byte[] bytes, int offset, int len);
+
+  public final Node getNode(byte[] bytes, int offset, int len, Node target) {
+    if (target == null) {
+      return getNode(bytes, offset, len);
+    }
+
+    target.reset(bytes, offset, len);
+    return target;
+  }
+
+  protected Node getNode(Point p, int level) {
+    return getNodes(p, level, false).get(0);
+  }
+
+  /**
+   * Gets the intersecting & including cells for the specified shape, without exceeding detail level.
+   * The result is a set of cells (no dups), sorted. Unmodifiable.
+   * <p/>
+   * This implementation checks if shape is a Point and if so uses an implementation that
+   * recursively calls {@link Node#getSubCell(org.apache.lucene.spatial.base.shape.Point)}. Cell subclasses
+   * ideally implement that method with a quick implementation, otherwise, subclasses should
+   * override this method to invoke {@link #getNodesAltPoint(org.apache.lucene.spatial.base.shape.Point, int, boolean)}.
+   * TODO consider another approach returning an iterator -- won't build up all cells in memory.
+   */
+  public List<Node> getNodes(Shape shape, int detailLevel, boolean inclParents) {
+    if (detailLevel > maxLevels) {
+      throw new IllegalArgumentException("detailLevel > maxLevels");
+    }
+
+    List<Node> cells;
+    if (shape instanceof Point) {
+      //optimized point algorithm
+      final int initialCapacity = inclParents ? 1 + detailLevel : 1;
+      cells = new ArrayList<Node>(initialCapacity);
+      recursiveGetNodes(getWorldNode(), (Point) shape, detailLevel, true, cells);
+      assert cells.size() == initialCapacity;
+    } else {
+      cells = new ArrayList<Node>(inclParents ? 1024 : 512);
+      recursiveGetNodes(getWorldNode(), shape, detailLevel, inclParents, cells);
+    }
+    if (inclParents) {
+      Node c = cells.remove(0);//remove getWorldNode()
+      assert c.getLevel() == 0;
+    }
+    return cells;
+  }
+
+  private void recursiveGetNodes(Node node, Shape shape, int detailLevel, boolean inclParents,
+                                 Collection<Node> result) {
+    if (node.isLeaf()) {//cell is within shape
+      result.add(node);
+      return;
+    }
+    final Collection<Node> subCells = node.getSubCells(shape);
+    if (node.getLevel() == detailLevel - 1) {
+      if (subCells.size() < node.getSubCellsSize()) {
+        if (inclParents)
+          result.add(node);
+        for (Node subCell : subCells) {
+          subCell.setLeaf();
+        }
+        result.addAll(subCells);
+      } else {//a bottom level (i.e. detail level) optimization where all boxes intersect, so use parent cell.
+        node.setLeaf();
+        result.add(node);
+      }
+    } else {
+      if (inclParents) {
+        result.add(node);
+      }
+      for (Node subCell : subCells) {
+        recursiveGetNodes(subCell, shape, detailLevel, inclParents, result);//tail call
+      }
+    }
+  }
+
+  private void recursiveGetNodes(Node node, Point point, int detailLevel, boolean inclParents,
+                                 Collection<Node> result) {
+    if (inclParents) {
+      result.add(node);
+    }
+    final Node pCell = node.getSubCell(point);
+    if (node.getLevel() == detailLevel - 1) {
+      pCell.setLeaf();
+      result.add(pCell);
+    } else {
+      recursiveGetNodes(pCell, point, detailLevel, inclParents, result);//tail call
+    }
+  }
+
+  /**
+   * Subclasses might override {@link #getNodes(org.apache.lucene.spatial.base.shape.Shape, int, boolean)}
+   * and check if the argument is a shape and if so, delegate
+   * to this implementation, which calls {@link #getNode(org.apache.lucene.spatial.base.shape.Point, int)} and
+   * then calls {@link #getNode(String)} repeatedly if inclParents is true.
+   */
+  protected final List<Node> getNodesAltPoint(Point p, int detailLevel, boolean inclParents) {
+    Node cell = getNode(p, detailLevel);
+    if (!inclParents) {
+      return Collections.singletonList(cell);
+    }
+
+    String endToken = cell.getTokenString();
+    assert endToken.length() == detailLevel;
+    List<Node> cells = new ArrayList<Node>(detailLevel);
+    for (int i = 1; i < detailLevel; i++) {
+      cells.add(getNode(endToken.substring(0, i)));
+    }
+    cells.add(cell);
+    return cells;
+  }
+
+  /**
+   * Will add the trailing leaf byte for leaves. This isn't particularly efficient.
+   */
+  public static List<String> nodesToTokenStrings(Collection<Node> nodes) {
+    List<String> tokens = new ArrayList<String>((nodes.size()));
+    for (Node node : nodes) {
+      final String token = node.getTokenString();
+      if (node.isLeaf()) {
+        tokens.add(token + (char) Node.LEAF_BYTE);
+      } else {
+        tokens.add(token);
+      }
+    }
+    return tokens;
+  }
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/SpatialPrefixTreeFactory.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/SpatialPrefixTreeFactory.java
new file mode 100644
index 0000000..56c6b42
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/SpatialPrefixTreeFactory.java
@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.prefix;
+
+import org.apache.lucene.spatial.base.context.SpatialContext;
+import org.apache.lucene.spatial.base.distance.DistanceUnits;
+import org.apache.lucene.spatial.base.distance.DistanceUtils;
+import org.apache.lucene.spatial.base.prefix.geohash.GeohashPrefixTree;
+import org.apache.lucene.spatial.base.prefix.quad.QuadPrefixTree;
+
+import java.util.Map;
+
+/**
+ * @author dsmiley
+ */
+public abstract class SpatialPrefixTreeFactory {
+
+  private static final double DEFAULT_GEO_MAX_DETAIL_KM = 0.001;//1m
+
+  protected Map<String, String> args;
+  protected SpatialContext ctx;
+  protected Integer maxLevels;
+
+  /**
+   * The factory  is looked up via "prefixTree" in args, expecting "geohash" or "quad".
+   * If its neither of these, then "geohash" is chosen for a geo context, otherwise "quad" is chosen.
+   */
+  public static SpatialPrefixTree makeSPT(Map<String,String> args, ClassLoader classLoader, SpatialContext ctx) {
+    SpatialPrefixTreeFactory instance;
+    String cname = args.get("prefixTree");
+    if (cname == null)
+      cname = ctx.isGeo() ? "geohash" : "quad";
+    if ("geohash".equalsIgnoreCase(cname))
+      instance = new GeohashPrefixTree.Factory();
+    else if ("quad".equalsIgnoreCase(cname))
+      instance = new QuadPrefixTree.Factory();
+    else {
+      try {
+        Class c = classLoader.loadClass(cname);
+        instance = (SpatialPrefixTreeFactory) c.newInstance();
+      } catch (Exception e) {
+        throw new RuntimeException(e);
+      }
+    }
+    instance.init(args,ctx);
+    return instance.newSPT();
+  }
+
+  protected void init(Map<String, String> args, SpatialContext ctx) {
+    this.args = args;
+    this.ctx = ctx;
+    initMaxLevels();
+  }
+
+  protected void initMaxLevels() {
+    String mlStr = args.get("maxLevels");
+    if (mlStr != null) {
+      maxLevels = Integer.valueOf(mlStr);
+      return;
+    }
+
+    double degrees;
+    String maxDetailDistStr = args.get("maxDetailDist");
+    if (maxDetailDistStr == null) {
+      if (!ctx.isGeo()) {
+        return;//let default to max
+      }
+      degrees = DistanceUtils.dist2Degrees(DEFAULT_GEO_MAX_DETAIL_KM, DistanceUnits.KILOMETERS.earthRadius());
+    } else {
+      degrees = DistanceUtils.dist2Degrees(Double.parseDouble(maxDetailDistStr), ctx.getUnits().earthRadius());
+    }
+    maxLevels = getLevelForDistance(degrees) + 1;//returns 1 greater
+  }
+
+  /** Calls {@link SpatialPrefixTree#getLevelForDistance(double)}. */
+  protected abstract int getLevelForDistance(double degrees);
+
+  protected abstract SpatialPrefixTree newSPT();
+
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/geohash/GeohashPrefixTree.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/geohash/GeohashPrefixTree.java
new file mode 100644
index 0000000..1f96c2c
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/geohash/GeohashPrefixTree.java
@@ -0,0 +1,150 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.prefix.geohash;
+
+import org.apache.lucene.spatial.base.context.SpatialContext;
+import org.apache.lucene.spatial.base.prefix.Node;
+import org.apache.lucene.spatial.base.prefix.SpatialPrefixTree;
+import org.apache.lucene.spatial.base.prefix.SpatialPrefixTreeFactory;
+import org.apache.lucene.spatial.base.shape.Point;
+import org.apache.lucene.spatial.base.shape.Rectangle;
+import org.apache.lucene.spatial.base.shape.Shape;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+/**
+ * A SpatialPrefixGrid based on Geohashes.  Uses {@link GeohashUtils} to do all the geohash work.
+ */
+public class GeohashPrefixTree extends SpatialPrefixTree {
+
+  public static class Factory extends SpatialPrefixTreeFactory {
+
+    @Override
+    protected int getLevelForDistance(double degrees) {
+      GeohashPrefixTree grid = new GeohashPrefixTree(ctx, GeohashPrefixTree.getMaxLevelsPossible());
+      return grid.getLevelForDistance(degrees) + 1;//returns 1 greater
+    }
+
+    @Override
+    protected SpatialPrefixTree newSPT() {
+      return new GeohashPrefixTree(ctx,
+          maxLevels != null ? maxLevels : GeohashPrefixTree.getMaxLevelsPossible());
+    }
+  }
+
+  public GeohashPrefixTree(SpatialContext ctx, int maxLevels) {
+    super(ctx, maxLevels);
+    Rectangle bounds = ctx.getWorldBounds();
+    if (bounds.getMinX() != -180)
+      throw new IllegalArgumentException("Geohash only supports lat-lon world bounds. Got "+bounds);
+    int MAXP = getMaxLevelsPossible();
+    if (maxLevels <= 0 || maxLevels > MAXP)
+      throw new IllegalArgumentException("maxLen must be [1-"+MAXP+"] but got "+ maxLevels);
+  }
+
+  /** Any more than this and there's no point (double lat & lon are the same). */
+  public static int getMaxLevelsPossible() {
+    return GeohashUtils.MAX_PRECISION;
+  }
+
+  @Override
+  public int getLevelForDistance(double dist) {
+    final int level = GeohashUtils.lookupHashLenForWidthHeight(dist, dist);
+    return Math.max(Math.min(level, maxLevels), 1);
+  }
+
+  @Override
+  public Node getNode(Point p, int level) {
+    return new GhCell(GeohashUtils.encodeLatLon(p.getY(), p.getX(), level));//args are lat,lon (y,x)
+  }
+
+  @Override
+  public Node getNode(String token) {
+    return new GhCell(token);
+  }
+
+  @Override
+  public Node getNode(byte[] bytes, int offset, int len) {
+    return new GhCell(bytes, offset, len);
+  }
+
+  @Override
+  public List<Node> getNodes(Shape shape, int detailLevel, boolean inclParents) {
+    return shape instanceof Point ? super.getNodesAltPoint((Point) shape, detailLevel, inclParents) :
+        super.getNodes(shape, detailLevel, inclParents);
+  }
+
+  class GhCell extends Node {
+    GhCell(String token) {
+      super(GeohashPrefixTree.this, token);
+    }
+
+    GhCell(byte[] bytes, int off, int len) {
+      super(GeohashPrefixTree.this, bytes, off, len);
+    }
+
+    @Override
+    public void reset(byte[] bytes, int off, int len) {
+      super.reset(bytes, off, len);
+      shape = null;
+    }
+
+    @Override
+    public Collection<Node> getSubCells() {
+      String[] hashes = GeohashUtils.getSubGeohashes(getGeohash());//sorted
+      List<Node> cells = new ArrayList<Node>(hashes.length);
+      for (String hash : hashes) {
+        cells.add(new GhCell(hash));
+      }
+      return cells;
+    }
+
+    @Override
+    public int getSubCellsSize() {
+      return 32;//8x4
+    }
+
+    @Override
+    public Node getSubCell(Point p) {
+      return GeohashPrefixTree.this.getNode(p,getLevel()+1);//not performant!
+    }
+
+    private Shape shape;//cache
+
+    @Override
+    public Shape getShape() {
+      if (shape == null) {
+        shape = GeohashUtils.decodeBoundary(getGeohash(), ctx);
+      }
+      return shape;
+    }
+
+    @Override
+    public Point getCenter() {
+      return GeohashUtils.decode(getGeohash(), ctx);
+    }
+
+    private String getGeohash() {
+      return getTokenString();
+    }
+
+  }//class GhCell
+
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/geohash/GeohashUtils.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/geohash/GeohashUtils.java
new file mode 100644
index 0000000..15fed96
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/geohash/GeohashUtils.java
@@ -0,0 +1,196 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.prefix.geohash;
+
+import org.apache.lucene.spatial.base.context.SpatialContext;
+import org.apache.lucene.spatial.base.shape.Rectangle;
+import org.apache.lucene.spatial.base.shape.Point;
+
+import java.util.Arrays;
+
+/**
+ * Utilities for encoding and decoding geohashes. Based on
+ * <a href="http://en.wikipedia.org/wiki/Geohash">http://en.wikipedia.org/wiki/Geohash</a>.
+ */
+public class GeohashUtils {
+
+  private static final char[] BASE_32 = {'0', '1', '2', '3', '4', '5', '6',
+      '7', '8', '9', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'j', 'k', 'm', 'n',
+      'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};//note: this is sorted
+
+  private static final int[] BASE_32_IDX;//sparse array of indexes from '0' to 'z'
+
+  public static final int MAX_PRECISION = 24;//DWS: I forget what level results in needless more precision but it's about this
+  private static final int[] BITS = {16, 8, 4, 2, 1};
+
+  static {
+    BASE_32_IDX = new int[BASE_32[BASE_32.length-1] - BASE_32[0] + 1];
+    assert BASE_32_IDX.length < 100;//reasonable length
+    Arrays.fill(BASE_32_IDX,-500);
+    for (int i = 0; i < BASE_32.length; i++) {
+      BASE_32_IDX[BASE_32[i] - BASE_32[0]] = i;
+    }
+  }
+
+  private GeohashUtils() {
+  }
+
+  /**
+   * Encodes the given latitude and longitude into a geohash
+   *
+   * @param latitude Latitude to encode
+   * @param longitude Longitude to encode
+   * @return Geohash encoding of the longitude and latitude
+   */
+  public static String encodeLatLon(double latitude, double longitude) {
+    return encodeLatLon(latitude, longitude, 12);
+  }
+
+  public static String encodeLatLon(double latitude, double longitude, int precision) {
+    double[] latInterval = {-90.0, 90.0};
+    double[] lngInterval = {-180.0, 180.0};
+
+    final StringBuilder geohash = new StringBuilder(precision);
+    boolean isEven = true;
+
+    int bit = 0;
+    int ch = 0;
+
+    while (geohash.length() < precision) {
+      double mid = 0.0;
+      if (isEven) {
+        mid = (lngInterval[0] + lngInterval[1]) / 2D;
+        if (longitude > mid) {
+          ch |= BITS[bit];
+          lngInterval[0] = mid;
+        } else {
+          lngInterval[1] = mid;
+        }
+      } else {
+        mid = (latInterval[0] + latInterval[1]) / 2D;
+        if (latitude > mid) {
+          ch |= BITS[bit];
+          latInterval[0] = mid;
+        } else {
+          latInterval[1] = mid;
+        }
+      }
+
+      isEven = !isEven;
+
+      if (bit < 4) {
+        bit++;
+      } else {
+        geohash.append(BASE_32[ch]);
+        bit = 0;
+        ch = 0;
+      }
+    }
+
+    return geohash.toString();
+  }
+
+  /**
+   * Decodes the given geohash into a latitude and longitude
+   *
+   * @param geohash Geohash to deocde
+   * @return Array with the latitude at index 0, and longitude at index 1
+   */
+  public static Point decode(String geohash, SpatialContext ctx) {
+    Rectangle rect = decodeBoundary(geohash,ctx);
+    double latitude = (rect.getMinY() + rect.getMaxY()) / 2D;
+    double longitude = (rect.getMinX() + rect.getMaxX()) / 2D;
+    return ctx.makePoint(longitude,latitude);
+	}
+
+  /** Returns min-max lat, min-max lon. */
+  public static Rectangle decodeBoundary(String geohash, SpatialContext ctx) {
+    double minY = -90, maxY = 90, minX = -180, maxX = 180;
+    boolean isEven = true;
+
+    for (int i = 0; i < geohash.length(); i++) {
+      char c = geohash.charAt(i);
+      if (c >= 'A' && c <= 'Z')
+        c -= ('A' - 'a');
+      final int cd = BASE_32_IDX[c - BASE_32[0]];//TODO check successful?
+
+      for (int mask : BITS) {
+        if (isEven) {
+          if ((cd & mask) != 0) {
+            minX = (minX + maxX) / 2D;
+          } else {
+            maxX = (minX + maxX) / 2D;
+          }
+        } else {
+          if ((cd & mask) != 0) {
+            minY = (minY + maxY) / 2D;
+          } else {
+            maxY = (minY + maxY) / 2D;
+          }
+        }
+        isEven = !isEven;
+      }
+
+    }
+    return ctx.makeRect(minX, maxX, minY, maxY);
+  }
+
+  /** Array of geohashes 1 level below the baseGeohash. Sorted. */
+  public static String[] getSubGeohashes(String baseGeohash) {
+    String[] hashes = new String[BASE_32.length];
+    for (int i = 0; i < BASE_32.length; i++) {//note: already sorted
+      char c = BASE_32[i];
+      hashes[i] = baseGeohash+c;
+    }
+    return hashes;
+  }
+
+  public static double[] lookupDegreesSizeForHashLen(int hashLen) {
+    return new double[]{hashLenToLatHeight[hashLen], hashLenToLonWidth[hashLen]};
+  }
+
+  /**
+   * Return the longest geohash length that will have a width & height >= specified arguments.
+   */
+  public static int lookupHashLenForWidthHeight(double width, double height) {
+    //loop through hash length arrays from beginning till we find one.
+    for(int len = 1; len <= MAX_PRECISION; len++) {
+      double latHeight = hashLenToLatHeight[len];
+      double lonWidth = hashLenToLonWidth[len];
+      if (latHeight < height || lonWidth < width)
+        return len-1;//previous length is big enough to encompass specified width & height
+    }
+    return MAX_PRECISION;
+  }
+
+  /** See the table at http://en.wikipedia.org/wiki/Geohash */
+  private static final double[] hashLenToLatHeight, hashLenToLonWidth;
+  static {
+    hashLenToLatHeight = new double[MAX_PRECISION +1];
+    hashLenToLonWidth = new double[MAX_PRECISION +1];
+    hashLenToLatHeight[0] = 90*2;
+    hashLenToLonWidth[0] = 180*2;
+    boolean even = false;
+    for(int i = 1; i <= MAX_PRECISION; i++) {
+      hashLenToLatHeight[i] = hashLenToLatHeight[i-1]/(even?8:4);
+      hashLenToLonWidth[i] = hashLenToLonWidth[i-1]/(even?4:8);
+      even = ! even;
+    }
+  }
+
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/package-info.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/package-info.java
new file mode 100644
index 0000000..6b156d3
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/package-info.java
@@ -0,0 +1,28 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * The Spatial Prefix package supports spatial indexing by index-time tokens
+ * where adding characters to a string gives greater resolution.
+ *
+ * Potential Implementations include:
+ *  * http://en.wikipedia.org/wiki/Quadtree
+ *  * http://en.wikipedia.org/wiki/Geohash
+ *  * http://healpix.jpl.nasa.gov/
+ */
+package org.apache.lucene.spatial.base.prefix;
+
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/quad/QuadPrefixTree.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/quad/QuadPrefixTree.java
new file mode 100644
index 0000000..a1ea653
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/quad/QuadPrefixTree.java
@@ -0,0 +1,301 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.prefix.quad;
+
+import org.apache.lucene.spatial.base.prefix.SpatialPrefixTreeFactory;
+import org.apache.lucene.spatial.base.shape.SpatialRelation;
+import org.apache.lucene.spatial.base.context.SpatialContext;
+import org.apache.lucene.spatial.base.prefix.Node;
+import org.apache.lucene.spatial.base.prefix.SpatialPrefixTree;
+import org.apache.lucene.spatial.base.shape.Point;
+import org.apache.lucene.spatial.base.shape.Rectangle;
+import org.apache.lucene.spatial.base.shape.Shape;
+import org.apache.lucene.spatial.base.shape.simple.PointImpl;
+
+import java.text.NumberFormat;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+public class QuadPrefixTree extends SpatialPrefixTree {
+
+  public static class Factory extends SpatialPrefixTreeFactory {
+
+    @Override
+    protected int getLevelForDistance(double degrees) {
+      QuadPrefixTree grid = new QuadPrefixTree(ctx, MAX_LEVELS_POSSIBLE);
+      return grid.getLevelForDistance(degrees) + 1;//returns 1 greater
+    }
+
+    @Override
+    protected SpatialPrefixTree newSPT() {
+      return new QuadPrefixTree(ctx,
+          maxLevels != null ? maxLevels : MAX_LEVELS_POSSIBLE);
+    }
+  }
+
+  public static final int MAX_LEVELS_POSSIBLE = 50;//not really sure how big this should be
+
+  public static final int DEFAULT_MAX_LEVELS = 12;
+  private final double xmin;
+  private final double xmax;
+  private final double ymin;
+  private final double ymax;
+  private final double xmid;
+  private final double ymid;
+
+  private final double gridW;
+  public final double gridH;
+
+  final double[] levelW;
+  final double[] levelH;
+  final int[]    levelS; // side
+  final int[]    levelN; // number
+
+  public QuadPrefixTree(
+      SpatialContext ctx, Rectangle bounds, int maxLevels) {
+    super(ctx, maxLevels);
+    this.xmin = bounds.getMinX();
+    this.xmax = bounds.getMaxX();
+    this.ymin = bounds.getMinY();
+    this.ymax = bounds.getMaxY();
+
+    levelW = new double[maxLevels];
+    levelH = new double[maxLevels];
+    levelS = new int[maxLevels];
+    levelN = new int[maxLevels];
+
+    gridW = xmax - xmin;
+    gridH = ymax - ymin;
+    this.xmid = xmin + gridW/2.0;
+    this.ymid = ymin + gridH/2.0;
+    levelW[0] = gridW/2.0;
+    levelH[0] = gridH/2.0;
+    levelS[0] = 2;
+    levelN[0] = 4;
+
+    for (int i = 1; i < levelW.length; i++) {
+      levelW[i] = levelW[i - 1] / 2.0;
+      levelH[i] = levelH[i - 1] / 2.0;
+      levelS[i] = levelS[i - 1] * 2;
+      levelN[i] = levelN[i - 1] * 4;
+    }
+  }
+
+  public QuadPrefixTree(SpatialContext ctx) {
+    this(ctx, DEFAULT_MAX_LEVELS);
+  }
+
+  public QuadPrefixTree(
+      SpatialContext ctx, int maxLevels) {
+    this(ctx, ctx.getWorldBounds(), maxLevels);
+  }
+
+  public void printInfo() {
+    NumberFormat nf = NumberFormat.getNumberInstance();
+    nf.setMaximumFractionDigits(5);
+    nf.setMinimumFractionDigits(5);
+    nf.setMinimumIntegerDigits(3);
+
+    for (int i = 0; i < maxLevels; i++) {
+      System.out.println(i + "]\t" + nf.format(levelW[i]) + "\t" + nf.format(levelH[i]) + "\t" +
+          levelS[i] + "\t" + (levelS[i] * levelS[i]));
+    }
+  }
+
+  @Override
+  public int getLevelForDistance(double dist) {
+    for (int i = 1; i < maxLevels; i++) {
+      //note: level[i] is actually a lookup for level i+1
+      if(dist > levelW[i] || dist > levelH[i]) {
+        return i;
+      }
+    }
+    return maxLevels;
+  }
+
+  @Override
+  public Node getNode(Point p, int level) {
+    List<Node> cells = new ArrayList<Node>(1);
+    build(xmid, ymid, 0, cells, new StringBuilder(), new PointImpl(p.getX(),p.getY()), level);
+    return cells.get(0);//note cells could be longer if p on edge
+  }
+
+  @Override
+  public Node getNode(String token) {
+    return new QuadCell(token);
+  }
+
+  @Override
+  public Node getNode(byte[] bytes, int offset, int len) {
+    return new QuadCell(bytes, offset, len);
+  }
+
+  @Override //for performance
+  public List<Node> getNodes(Shape shape, int detailLevel, boolean inclParents) {
+    if (shape instanceof Point)
+      return super.getNodesAltPoint((Point) shape, detailLevel, inclParents);
+    else
+      return super.getNodes(shape, detailLevel, inclParents);
+  }
+
+  private void build(
+      double x,
+      double y,
+      int level,
+      List<Node> matches,
+      StringBuilder str,
+      Shape shape,
+      int maxLevel) {
+    assert str.length() == level;
+    double w = levelW[level] / 2;
+    double h = levelH[level] / 2;
+
+    // Z-Order
+    // http://en.wikipedia.org/wiki/Z-order_%28curve%29
+    checkBattenberg('A', x - w, y + h, level, matches, str, shape, maxLevel);
+    checkBattenberg('B', x + w, y + h, level, matches, str, shape, maxLevel);
+    checkBattenberg('C', x - w, y - h, level, matches, str, shape, maxLevel);
+    checkBattenberg('D', x + w, y - h, level, matches, str, shape, maxLevel);
+
+    // possibly consider hilbert curve
+    // http://en.wikipedia.org/wiki/Hilbert_curve
+    // http://blog.notdot.net/2009/11/Damn-Cool-Algorithms-Spatial-indexing-with-Quadtrees-and-Hilbert-Curves
+    // if we actually use the range property in the query, this could be useful
+  }
+
+  private void checkBattenberg(
+      char c,
+      double cx,
+      double cy,
+      int level,
+      List<Node> matches,
+      StringBuilder str,
+      Shape shape,
+      int maxLevel) {
+    assert str.length() == level;
+    double w = levelW[level] / 2;
+    double h = levelH[level] / 2;
+
+    int strlen = str.length();
+    Rectangle rectangle = ctx.makeRect(cx - w, cx + w, cy - h, cy + h);
+    SpatialRelation v = shape.relate(rectangle, ctx);
+    if (SpatialRelation.CONTAINS == v) {
+      str.append(c);
+      //str.append(SpatialPrefixGrid.COVER);
+      matches.add(new QuadCell(str.toString(),v.transpose()));
+    } else if (SpatialRelation.DISJOINT == v) {
+      // nothing
+    } else { // SpatialRelation.WITHIN, SpatialRelation.INTERSECTS
+      str.append(c);
+
+      int nextLevel = level+1;
+      if (nextLevel >= maxLevel) {
+        //str.append(SpatialPrefixGrid.INTERSECTS);
+        matches.add(new QuadCell(str.toString(),v.transpose()));
+      } else {
+        build(cx, cy, nextLevel, matches, str, shape, maxLevel);
+      }
+    }
+    str.setLength(strlen);
+  }
+
+  class QuadCell extends Node {
+
+    public QuadCell(String token) {
+      super(QuadPrefixTree.this, token);
+    }
+
+    public QuadCell(String token, SpatialRelation shapeRel) {
+      super(QuadPrefixTree.this, token);
+      this.shapeRel = shapeRel;
+    }
+
+    QuadCell(byte[] bytes, int off, int len) {
+      super(QuadPrefixTree.this, bytes, off, len);
+    }
+
+    @Override
+    public void reset(byte[] bytes, int off, int len) {
+      super.reset(bytes, off, len);
+      shape = null;
+    }
+
+    @Override
+    public Collection<Node> getSubCells() {
+      List<Node> cells = new ArrayList<Node>(4);
+      cells.add(new QuadCell(getTokenString()+"A"));
+      cells.add(new QuadCell(getTokenString()+"B"));
+      cells.add(new QuadCell(getTokenString()+"C"));
+      cells.add(new QuadCell(getTokenString()+"D"));
+      return cells;
+    }
+
+    @Override
+    public int getSubCellsSize() {
+      return 4;
+    }
+
+    @Override
+    public Node getSubCell(Point p) {
+      return QuadPrefixTree.this.getNode(p,getLevel()+1);//not performant!
+    }
+
+    private Shape shape;//cache
+
+    @Override
+    public Shape getShape() {
+      if (shape == null)
+        shape = makeShape();
+      return shape;
+    }
+
+    private Rectangle makeShape() {
+      String token = getTokenString();
+      double xmin = QuadPrefixTree.this.xmin;
+      double ymin = QuadPrefixTree.this.ymin;
+
+      for (int i = 0; i < token.length(); i++) {
+        char c = token.charAt(i);
+        if ('A' == c || 'a' == c) {
+          ymin += levelH[i];
+        } else if ('B' == c || 'b' == c) {
+          xmin += levelW[i];
+          ymin += levelH[i];
+        } else if ('C' == c || 'c' == c) {
+          // nothing really
+        }
+        else if('D' == c || 'd' == c) {
+          xmin += levelW[i];
+        } else {
+          throw new RuntimeException("unexpected char: " + c);
+        }
+      }
+      int len = token.length();
+      double width, height;
+      if (len > 0) {
+        width = levelW[len-1];
+        height = levelH[len-1];
+      } else {
+        width = gridW;
+        height = gridH;
+      }
+      return ctx.makeRect(xmin, xmin + width, ymin, ymin + height);
+    }
+  }//QuadCell
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/query/SpatialArgs.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/query/SpatialArgs.java
new file mode 100644
index 0000000..c559358
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/query/SpatialArgs.java
@@ -0,0 +1,134 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.query;
+
+import org.apache.lucene.spatial.base.context.SpatialContext;
+import org.apache.lucene.spatial.base.context.simple.SimpleSpatialContext;
+import org.apache.lucene.spatial.base.distance.DistanceUnits;
+import org.apache.lucene.spatial.base.exception.InvalidSpatialArgument;
+import org.apache.lucene.spatial.base.shape.Shape;
+
+public class SpatialArgs {
+
+  public static final double DEFAULT_DIST_PRECISION = 0.025d;
+
+  private SpatialOperation operation;
+  private Shape shape;
+  private double distPrecision = DEFAULT_DIST_PRECISION;
+
+  // Useful for 'distance' calculations
+  private Double min;
+  private Double max;
+
+  public SpatialArgs(SpatialOperation operation) {
+    this.operation = operation;
+  }
+
+  public SpatialArgs(SpatialOperation operation, Shape shape) {
+    this.operation = operation;
+    this.shape = shape;
+  }
+
+  /**
+   * Check if the arguments make sense -- throw an exception if not
+   */
+  public void validate() throws InvalidSpatialArgument {
+    if (operation.isTargetNeedsArea() && !shape.hasArea()) {
+      throw new InvalidSpatialArgument(operation + " only supports geometry with area");
+    }
+  }
+
+  public String toString( SpatialContext context ) {
+    StringBuilder str = new StringBuilder();
+    str.append( operation.getName() ).append( '(' );
+    str.append( context.toString( shape ) );
+    if( min != null ) {
+      str.append(" min=").append(min);
+    }
+    if( max != null ) {
+      str.append(" max=").append(max);
+    }
+    str.append(" distPrec=").append(String.format("%.2f%%", distPrecision/100d));
+    str.append( ')' );
+    return str.toString();
+  }
+
+  @Override
+  public String toString()
+  {
+    return toString( new SimpleSpatialContext(DistanceUnits.KILOMETERS) );
+  }
+
+  //------------------------------------------------
+  // Getters & Setters
+  //------------------------------------------------
+
+  public SpatialOperation getOperation() {
+    return operation;
+  }
+
+  public void setOperation(SpatialOperation operation) {
+    this.operation = operation;
+  }
+
+  /**
+   * Considers {@link SpatialOperation#BBoxWithin} in returning the shape.
+   * @return
+   */
+  public Shape getShape() {
+    if (shape != null && (operation == SpatialOperation.BBoxWithin || operation == SpatialOperation.BBoxIntersects))
+      return shape.getBoundingBox();
+    return shape;
+  }
+
+  public void setShape(Shape shape) {
+    this.shape = shape;
+  }
+
+  /**
+   * The fraction of the distance from the center of the query shape to its nearest edge that is considered acceptable
+   * error. The algorithm for computing the distance to the nearest edge is actually a little different. It normalizes
+   * the shape to a square given it's bounding box area:
+   * <pre>sqrt(shape.bbox.area)/2</pre>
+   * And the error distance is beyond the shape such that the shape is a minimum shape.
+   */
+  public Double getDistPrecision() {
+    return distPrecision;
+  }
+
+  public void setDistPrecision(Double distPrecision) {
+    if (distPrecision != null)
+      this.distPrecision = distPrecision;
+  }
+
+  public Double getMin() {
+    return min;
+  }
+
+  public void setMin(Double min) {
+    this.min = min;
+  }
+
+  public Double getMax() {
+    return max;
+  }
+
+  public void setMax(Double max) {
+    this.max = max;
+  }
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/query/SpatialArgsParser.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/query/SpatialArgsParser.java
new file mode 100644
index 0000000..961dd25
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/query/SpatialArgsParser.java
@@ -0,0 +1,88 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.query;
+
+import org.apache.lucene.spatial.base.context.SpatialContext;
+import org.apache.lucene.spatial.base.exception.InvalidShapeException;
+import org.apache.lucene.spatial.base.exception.InvalidSpatialArgument;
+import org.apache.lucene.spatial.base.shape.Shape;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.StringTokenizer;
+
+public class SpatialArgsParser
+{
+  public SpatialArgs parse(String v, SpatialContext ctx) throws InvalidSpatialArgument, InvalidShapeException {
+    int idx = v.indexOf('(');
+    int edx = v.lastIndexOf(')');
+
+    if (idx < 0 || idx > edx) {
+      throw new InvalidSpatialArgument("missing parens: " + v, null);
+    }
+
+    SpatialOperation op = SpatialOperation.get(v.substring(0, idx).trim());
+
+    String body = v.substring(idx + 1, edx).trim();
+    if (body.length() < 1) {
+      throw new InvalidSpatialArgument("missing body : " + v, null);
+    }
+
+    Shape shape = ctx.readShape(body);
+    SpatialArgs args = new SpatialArgs(op,shape);
+
+    if (v.length() > (edx + 1)) {
+      body = v.substring( edx+1 ).trim();
+      if (body.length() > 0) {
+        Map<String,String> aa = parseMap(body);
+        args.setMin(readDouble(aa.remove("min")) );
+        args.setMax(readDouble(aa.remove("max")));
+        args.setDistPrecision(readDouble(aa.remove("distPrec")));
+        if (!aa.isEmpty()) {
+          throw new InvalidSpatialArgument("unused parameters: " + aa, null);
+        }
+      }
+    }
+    return args;
+  }
+
+  protected static Double readDouble(String v) {
+      return v == null ? null : Double.valueOf(v);
+  }
+
+  protected static boolean readBool(String v, boolean defaultValue) {
+      return v == null ? defaultValue : Boolean.parseBoolean(v);
+  }
+
+  protected static Map<String,String> parseMap(String body) {
+    Map<String,String> map = new HashMap<String,String>();
+    StringTokenizer st = new StringTokenizer(body, " \n\t");
+    while (st.hasMoreTokens()) {
+      String a = st.nextToken();
+      int idx = a.indexOf('=');
+      if (idx > 0) {
+        String k = a.substring(0, idx);
+        String v = a.substring(idx + 1);
+        map.put(k, v);
+      } else {
+        map.put(a, a);
+      }
+    }
+    return map;
+  }
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/query/SpatialOperation.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/query/SpatialOperation.java
new file mode 100644
index 0000000..b4be743
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/query/SpatialOperation.java
@@ -0,0 +1,107 @@
+/* See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * Esri Inc. licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.spatial.base.query;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+
+import org.apache.lucene.spatial.base.exception.InvalidSpatialArgument;
+
+/**
+ * A clause that compares a stored geometry to a supplied geometry.
+ */
+public class SpatialOperation implements Serializable {
+  // Private registry
+  private static final Map<String, SpatialOperation> registry = new HashMap<String, SpatialOperation>();
+  private static final List<SpatialOperation> list = new ArrayList<SpatialOperation>();
+
+  // Geometry Operations
+  public static final SpatialOperation BBoxIntersects = new SpatialOperation("BBoxIntersects", true, false, false);
+  public static final SpatialOperation BBoxWithin     = new SpatialOperation("BBoxWithin", true, false, false);
+  public static final SpatialOperation Contains       = new SpatialOperation("Contains", true, true, false);
+  public static final SpatialOperation Intersects     = new SpatialOperation("Intersects", true, false, false);
+  public static final SpatialOperation IsEqualTo      = new SpatialOperation("IsEqualTo", false, false, false);
+  public static final SpatialOperation IsDisjointTo   = new SpatialOperation("IsDisjointTo", false, false, false);
+  public static final SpatialOperation IsWithin       = new SpatialOperation("IsWithin", true, false, true);
+  public static final SpatialOperation Overlaps       = new SpatialOperation("Overlaps", true, false, true);
+
+  // Member variables
+  private final boolean scoreIsMeaningful;
+  private final boolean sourceNeedsArea;
+  private final boolean targetNeedsArea;
+  private final String name;
+
+  protected SpatialOperation(String name, boolean scoreIsMeaningful, boolean sourceNeedsArea, boolean targetNeedsArea) {
+    this.name = name;
+    this.scoreIsMeaningful = scoreIsMeaningful;
+    this.sourceNeedsArea = sourceNeedsArea;
+    this.targetNeedsArea = targetNeedsArea;
+    registry.put(name, this);
+    registry.put(name.toUpperCase(Locale.US), this);
+    list.add( this );
+  }
+
+  public static SpatialOperation get( String v ) {
+    SpatialOperation op = registry.get( v );
+    if( op == null ) {
+      op = registry.get(v.toUpperCase(Locale.US));
+    }
+    if( op == null ) {
+      throw new InvalidSpatialArgument("Unknown Operation: " + v );
+    }
+    return op;
+  }
+
+  public static List<SpatialOperation> values() {
+    return list;
+  }
+
+  public static boolean is( SpatialOperation op, SpatialOperation ... tst ) {
+    for( SpatialOperation t : tst ) {
+      if( op == t ) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+
+  // ================================================= Getters / Setters =============================================
+
+  public boolean isScoreIsMeaningful() {
+    return scoreIsMeaningful;
+  }
+
+  public boolean isSourceNeedsArea() {
+    return sourceNeedsArea;
+  }
+
+  public boolean isTargetNeedsArea() {
+    return targetNeedsArea;
+  }
+
+  public String getName() {
+    return name;
+  }
+
+  @Override
+  public String toString() {
+    return name;
+  }
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/query/package-info.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/query/package-info.java
new file mode 100644
index 0000000..ded6980
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/query/package-info.java
@@ -0,0 +1,26 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+/**
+ * Lucene spatial Query options
+ * <ul>
+ *  <li>useful for client side requets</li>
+ * </ul>
+ */
+package org.apache.lucene.spatial.base.query;
+
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/Circle.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/Circle.java
new file mode 100644
index 0000000..ad718f3
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/Circle.java
@@ -0,0 +1,25 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.shape;
+
+/**
+ * This is basically a circle.
+ */
+public interface Circle extends Shape {
+  double getDistance();
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/MultiShape.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/MultiShape.java
new file mode 100644
index 0000000..d2e6873
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/MultiShape.java
@@ -0,0 +1,108 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.shape;
+
+import org.apache.commons.lang.builder.EqualsBuilder;
+import org.apache.commons.lang.builder.HashCodeBuilder;
+import org.apache.lucene.spatial.base.context.SpatialContext;
+
+import java.util.Collection;
+
+/**
+ * A collection of Shape objects.
+ */
+public class MultiShape implements Shape {
+  private final Collection<Shape> geoms;
+  private final Rectangle bbox;
+
+  public MultiShape(Collection<Shape> geoms, SpatialContext ctx) {
+    this.geoms = geoms;
+    double minX = Double.MAX_VALUE;
+    double minY = Double.MAX_VALUE;
+    double maxX = Double.MIN_VALUE;
+    double maxY = Double.MIN_VALUE;
+    for (Shape geom : geoms) {
+      Rectangle r = geom.getBoundingBox();
+      minX = Math.min(minX,r.getMinX());
+      minY = Math.min(minY,r.getMinY());
+      maxX = Math.max(maxX,r.getMaxX());
+      maxY = Math.max(maxY,r.getMaxY());
+    }
+    this.bbox = ctx.makeRect(minX, maxX, minY, maxY);
+  }
+
+  @Override
+  public Rectangle getBoundingBox() {
+    return bbox;
+  }
+
+  @Override
+  public Point getCenter() {
+    return bbox.getCenter();
+  }
+
+  @Override
+  public boolean hasArea() {
+    for (Shape geom : geoms) {
+      if( geom.hasArea() ) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  @Override
+  public SpatialRelation relate(Shape other, SpatialContext ctx) {
+    boolean allOutside = true;
+    boolean allContains = true;
+    for (Shape geom : geoms) {
+      SpatialRelation sect = geom.relate(other, ctx);
+      if (sect != SpatialRelation.DISJOINT)
+        allOutside = false;
+      if (sect != SpatialRelation.CONTAINS)
+        allContains = false;
+      if (!allContains && !allOutside)
+        return SpatialRelation.INTERSECTS;//short circuit
+    }
+    if (allOutside)
+      return SpatialRelation.DISJOINT;
+    if (allContains)
+      return SpatialRelation.CONTAINS;
+    return SpatialRelation.INTERSECTS;
+  }
+
+
+  @Override
+  public boolean equals(Object obj) {
+    if (obj == null) { return false; }
+    if (obj == this) { return true; }
+    if (obj.getClass() != getClass()) {
+      return false;
+    }
+    MultiShape rhs = (MultiShape) obj;
+    return new EqualsBuilder()
+                  .append(geoms, rhs.geoms)
+                  .isEquals();
+  }
+
+  @Override
+  public int hashCode() {
+    return new HashCodeBuilder(83, 29).append(geoms.hashCode()).
+      toHashCode();
+  }
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/Point.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/Point.java
new file mode 100644
index 0000000..fd66020
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/Point.java
@@ -0,0 +1,24 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.shape;
+
+public interface Point extends Shape {
+
+  public double getX();
+  public double getY();
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/Rectangle.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/Rectangle.java
new file mode 100644
index 0000000..f0935ff
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/Rectangle.java
@@ -0,0 +1,40 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.shape;
+
+import org.apache.lucene.spatial.base.context.SpatialContext;
+
+public interface Rectangle extends Shape {
+
+  public double getWidth();
+  public double getHeight();
+
+  public double getMinX();
+  public double getMinY();
+  public double getMaxX();
+  public double getMaxY();
+
+  /** If {@link #hasArea()} then this returns the area, otherwise it returns 0. */
+  public double getArea();
+  /** Only meaningful for geospatial contexts. */
+  public boolean getCrossesDateLine();
+
+  /* There is no axis line shape, and this is more efficient then creating a flat Rectangle for intersect(). */
+  public SpatialRelation relate_yRange(double minY, double maxY, SpatialContext ctx);
+  public SpatialRelation relate_xRange(double minX, double maxX, SpatialContext ctx);
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/Shape.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/Shape.java
new file mode 100644
index 0000000..3292c11
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/Shape.java
@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.shape;
+
+import org.apache.lucene.spatial.base.context.SpatialContext;
+
+public interface Shape {
+
+  /**
+   * Describe the relationship between the two objects.  For example
+   *
+   *   this is WITHIN other
+   *   this CONTAINS other
+   *   this is DISJOINT other
+   *   this INTERSECTS other
+   *
+   * The context object is optional -- it may include spatial reference.
+   */
+  SpatialRelation relate(Shape other, SpatialContext ctx);
+
+  /**
+   * Get the bounding box for this Shape
+   */
+  Rectangle getBoundingBox();
+
+  /**
+   * @return true if the shape has area.  This will be false for points and lines
+   */
+  boolean hasArea();
+
+  Point getCenter();
+}
+
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/SpatialRelation.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/SpatialRelation.java
new file mode 100644
index 0000000..1a6181c
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/SpatialRelation.java
@@ -0,0 +1,69 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.shape;
+
+/**
+ * The set of spatial relationships.  Naming is consistent with OGC spec conventions as seen in SQL/MM and others.
+ * No equality case.  If two Shape instances are equal then the result might be CONTAINS or WITHIN, and
+ * some logic might fail under this edge condition when it's not careful to check.
+ * Client code must be written to detect this and act accordingly.  In RectangleImpl.relate(), it checks
+ * for this explicitly, for example.  TestShapes2D.assertRelation() checks too.
+ */
+public enum SpatialRelation {
+  WITHIN,
+  CONTAINS,
+  DISJOINT,
+  INTERSECTS;
+  //Don't have these: TOUCHES, CROSSES, OVERLAPS
+
+  public SpatialRelation transpose() {
+    switch(this) {
+      case CONTAINS: return SpatialRelation.WITHIN;
+      case WITHIN: return SpatialRelation.CONTAINS;
+      default: return this;
+    }
+  }
+
+  /**
+   * If you were to call aShape.relate(bShape) and aShape.relate(cShape), you could call
+   * this to merge the intersect results as if bShape & cShape were combined into {@link MultiShape}.
+   * @param other
+   * @return
+   */
+  public SpatialRelation combine(SpatialRelation other) {
+    if (this == other)
+      return this;
+    if (this == WITHIN || other == WITHIN)
+      return WITHIN;
+    return INTERSECTS;
+  }
+
+  public boolean intersects() {
+    return this != DISJOINT;
+  }
+
+  /** Not commutative!  WITHIN.inverse().inverse() != WITHIN. */
+  public SpatialRelation inverse() {
+    switch(this) {
+      case DISJOINT: return CONTAINS;
+      case CONTAINS: return DISJOINT;
+      case WITHIN: return INTERSECTS;//not commutative!
+    }
+    return INTERSECTS;
+  }
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/simple/CircleImpl.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/simple/CircleImpl.java
new file mode 100644
index 0000000..144f053
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/simple/CircleImpl.java
@@ -0,0 +1,234 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.shape.simple;
+
+import org.apache.commons.lang.builder.EqualsBuilder;
+import org.apache.commons.lang.builder.HashCodeBuilder;
+import org.apache.lucene.spatial.base.context.SpatialContext;
+import org.apache.lucene.spatial.base.shape.*;
+
+/**
+ * A circle, also known as a point-radius, based on a
+ * {@link org.apache.lucene.spatial.base.distance.DistanceCalculator} which does all the work. This implementation
+ * should work for both cartesian 2D and geodetic sphere surfaces.
+ * Threadsafe & immutable.
+ */
+public class CircleImpl implements Circle {
+
+  protected final Point point;
+  protected final double distance;
+
+  protected final SpatialContext ctx;
+
+  /* below is calculated & cached: */
+  
+  protected final Rectangle enclosingBox;
+
+  //we don't have a line shape so we use a rectangle for these axis
+
+  public CircleImpl(Point p, double dist, SpatialContext ctx) {
+    //We assume any normalization / validation of params already occurred (including bounding dist)
+    this.point = p;
+    this.distance = dist;
+    this.ctx = ctx;
+    this.enclosingBox = ctx.getDistCalc().calcBoxByDistFromPt(point, distance, ctx);
+  }
+
+  public Point getCenter() {
+    return point;
+  }
+
+  @Override
+  public double getDistance() {
+    return distance;
+  }
+
+  public boolean contains(double x, double y) {
+    return ctx.getDistCalc().distance(point, x, y) <= distance;
+  }
+
+  @Override
+  public boolean hasArea() {
+    return distance > 0;
+  }
+
+  /**
+   * Note that the bounding box might contain a minX that is > maxX, due to WGS84 dateline.
+   * @return
+   */
+  @Override
+  public Rectangle getBoundingBox() {
+    return enclosingBox;
+  }
+
+  @Override
+  public SpatialRelation relate(Shape other, SpatialContext ctx) {
+    assert this.ctx == ctx;
+//This shortcut was problematic in testing due to distinctions of CONTAINS/WITHIN for no-area shapes (lines, points).
+//    if (distance == 0) {
+//      return point.relate(other,ctx).intersects() ? SpatialRelation.WITHIN : SpatialRelation.DISJOINT;
+//    }
+
+    if (other instanceof Point) {
+      return relate((Point) other, ctx);
+    }
+    if (other instanceof Rectangle) {
+      return relate((Rectangle) other, ctx);
+    }
+    if (other instanceof Circle) {
+      return relate((Circle) other, ctx);
+    }
+    return other.relate(this, ctx).transpose();
+  }
+
+  public SpatialRelation relate(Point point, SpatialContext ctx) {
+    return contains(point.getX(),point.getY()) ? SpatialRelation.CONTAINS : SpatialRelation.DISJOINT;
+  }
+
+  public SpatialRelation relate(Rectangle r, SpatialContext ctx) {
+    //Note: Surprisingly complicated!
+
+    //--We start by leveraging the fact we have a calculated bbox that is "cheaper" than use of DistanceCalculator.
+    final SpatialRelation bboxSect = enclosingBox.relate(r, ctx);
+    if (bboxSect == SpatialRelation.DISJOINT || bboxSect == SpatialRelation.WITHIN)
+      return bboxSect;
+    else if (bboxSect == SpatialRelation.CONTAINS && enclosingBox.equals(r))//nasty identity edge-case
+      return SpatialRelation.WITHIN;
+    //bboxSect is INTERSECTS or CONTAINS
+    //The result can be DISJOINT, CONTAINS, or INTERSECTS (not WITHIN)
+
+    return relateRectanglePhase2(r, bboxSect, ctx);
+  }
+
+  protected SpatialRelation relateRectanglePhase2(final Rectangle r, SpatialRelation bboxSect, SpatialContext ctx) {
+    /*
+     !! DOES NOT WORK WITH GEO CROSSING DATELINE OR WORLD-WRAP.
+     TODO upgrade to handle crossing dateline, but not world-wrap; use some x-shifting code from RectangleImpl.
+     */
+
+    //At this point, the only thing we are certain of is that circle is *NOT* WITHIN r, since the bounding box of a
+    // circle MUST be within r for the circle to be within r.
+
+    //--Quickly determine if they are DISJOINT or not.
+    //see http://stackoverflow.com/questions/401847/circle-rectangle-collision-detection-intersection/1879223#1879223
+    final double closestX;
+    double ctr_x = getXAxis();
+    if ( ctr_x < r.getMinX() )
+      closestX = r.getMinX();
+    else if (ctr_x > r.getMaxX())
+      closestX = r.getMaxX();
+    else
+      closestX = ctr_x;
+
+    final double closestY;
+    double ctr_y = getYAxis();
+    if ( ctr_y < r.getMinY() )
+      closestY = r.getMinY();
+    else if (ctr_y > r.getMaxY())
+      closestY = r.getMaxY();
+    else
+      closestY = ctr_y;
+
+    //Check if there is an intersection from this circle to closestXY
+    boolean didContainOnClosestXY = false;
+    if (ctr_x == closestX) {
+      double deltaY = Math.abs(ctr_y - closestY);
+      double distYCirc = (ctr_y < closestY ? enclosingBox.getMaxY() - ctr_y : ctr_y - enclosingBox.getMinY());
+      if (deltaY > distYCirc)
+        return SpatialRelation.DISJOINT;
+    } else if (ctr_y == closestY) {
+      double deltaX = Math.abs(ctr_x - closestX);
+      double distXCirc = (ctr_x < closestX ? enclosingBox.getMaxX() - ctr_x : ctr_x - enclosingBox.getMinX());
+      if (deltaX > distXCirc)
+        return SpatialRelation.DISJOINT;
+    } else {
+      //fallback on more expensive calculation
+      didContainOnClosestXY = true;
+      if(! contains(closestX,closestY) )
+        return SpatialRelation.DISJOINT;
+    }
+
+    //At this point we know that it's *NOT* DISJOINT, so there is some level of intersection. It's *NOT* WITHIN either.
+    // The only question left is whether circle CONTAINS r or simply intersects it.
+
+    //If circle contains r, then its bbox MUST also CONTAIN r.
+    if (bboxSect != SpatialRelation.CONTAINS)
+      return SpatialRelation.INTERSECTS;
+
+    //Find the farthest point of r away from the center of the circle. If that point is contained, then all of r is
+    // contained.
+    double farthestX = r.getMaxX() - ctr_x > ctr_x - r.getMinX() ? r.getMaxX() : r.getMinX();
+    double farthestY = r.getMaxY() - ctr_y > ctr_y - r.getMinY() ? r.getMaxY() : r.getMinY();
+    if (contains(farthestX,farthestY))
+      return SpatialRelation.CONTAINS;
+    return SpatialRelation.INTERSECTS;
+  }
+
+  /**
+   * The y axis horizontal of maximal left-right extent of the circle.
+   */
+  protected double getYAxis() {
+    return point.getY();
+  }
+
+  protected double getXAxis() {
+    return point.getX();
+  }
+
+  public SpatialRelation relate(Circle circle, SpatialContext ctx) {
+    double crossDist = ctx.getDistCalc().distance(point, circle.getCenter());
+    double aDist = distance, bDist = circle.getDistance();
+    if (crossDist > aDist + bDist)
+      return SpatialRelation.DISJOINT;
+    if (crossDist < aDist && crossDist + bDist <= aDist)
+      return SpatialRelation.CONTAINS;
+    if (crossDist < bDist && crossDist + aDist <= bDist)
+      return SpatialRelation.WITHIN;
+
+    return SpatialRelation.INTERSECTS;
+  }
+
+  @Override
+  public String toString() {
+    return "Circle(" + point + ",d=" + distance + ')';
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (obj == null) { return false; }
+    if (obj == this) { return true; }
+    if (obj.getClass() != getClass()) {
+      return false;
+    }
+    CircleImpl rhs = (CircleImpl) obj;
+    return new EqualsBuilder()
+                  .append(point, rhs.point)
+                  .append(distance, rhs.distance)
+                  .append(ctx, rhs.ctx)
+                  .isEquals();
+  }
+
+  @Override
+  public int hashCode() {
+    return new HashCodeBuilder(11, 97).
+      append(point).
+      append(distance).
+      append(ctx).
+      toHashCode();
+  }
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/simple/GeoCircleImpl.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/simple/GeoCircleImpl.java
new file mode 100644
index 0000000..8ac353d
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/simple/GeoCircleImpl.java
@@ -0,0 +1,226 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.shape.simple;
+
+import org.apache.lucene.spatial.base.context.SpatialContext;
+import org.apache.lucene.spatial.base.shape.SpatialRelation;
+import org.apache.lucene.spatial.base.shape.Point;
+import org.apache.lucene.spatial.base.shape.Rectangle;
+
+/**
+ * @author David Smiley - dsmiley@mitre.org
+ */
+public class GeoCircleImpl extends CircleImpl {
+  private final double distDEG;// [0 TO 180]
+  private final GeoCircleImpl inverseCircle;//when distance reaches > 1/2 way around the world, cache the inverse.
+  private final double horizAxisY;//see getYAxis
+
+  public GeoCircleImpl(Point p, double dist, SpatialContext ctx) {
+    super(p, dist, ctx);
+    assert ctx.isGeo();
+
+    //In the direction of latitude (N,S), distance is the same number of degrees.
+    distDEG = ctx.getDistCalc().distanceToDegrees(distance);
+
+    if (distDEG > 90) {
+      assert enclosingBox.getWidth() == 360;
+      double backDistDEG = 180 - distDEG;
+      if (backDistDEG >= 0) {
+        double backDistance = ctx.getDistCalc().degreesToDistance(backDistDEG);
+        Point backPoint = ctx.makePoint(getCenter().getX() + 180, getCenter().getY() + 180);
+        inverseCircle = new GeoCircleImpl(backPoint,backDistance,ctx);
+      } else
+        inverseCircle = null;//whole globe
+      horizAxisY = getCenter().getY();//although probably not used
+    } else {
+      inverseCircle = null;
+      double _horizAxisY = ctx.getDistCalc().calcBoxByDistFromPtHorizAxis(getCenter(), distance, ctx);
+      //some rare numeric conditioning cases can cause this to be barely beyond the box
+      if (_horizAxisY > enclosingBox.getMaxY()) {
+        horizAxisY = enclosingBox.getMaxY();
+      } else if (_horizAxisY < enclosingBox.getMinY()) {
+        horizAxisY = enclosingBox.getMinY();
+      } else {
+        horizAxisY = _horizAxisY;
+      }
+      //assert enclosingBox.relate_yRange(horizAxis,horizAxis,ctx).intersects();
+    }
+
+  }
+
+  @Override
+  protected double getYAxis() {
+    return horizAxisY;
+  }
+
+  /**
+   * Called after bounding box is intersected.
+   * @bboxSect INTERSECTS or CONTAINS from enclosingBox's intersection
+   * @result DISJOINT, CONTAINS, or INTERSECTS (not WITHIN)
+   */
+  @Override
+  protected SpatialRelation relateRectanglePhase2(Rectangle r, SpatialRelation bboxSect, SpatialContext ctx) {
+
+    //Rectangle wraps around the world longitudinally creating a solid band; there are no corners to test intersection
+    if (r.getWidth() == 360) {
+      return SpatialRelation.INTERSECTS;
+    }
+
+    if (inverseCircle != null) {
+      return inverseCircle.relate(r, ctx).inverse();
+    }
+
+    //if a pole is wrapped, we have a separate algorithm
+    if (enclosingBox.getWidth() == 360) {
+      return relateRectangleCircleWrapsPole(r, ctx);
+    }
+
+    //This is an optimization path for when there are no dateline or pole issues.
+    if (!enclosingBox.getCrossesDateLine() && !r.getCrossesDateLine()) {
+      return super.relateRectanglePhase2(r, bboxSect, ctx);
+    }
+
+    //do quick check to see if all corners are within this circle for CONTAINS
+    int cornersIntersect = numCornersIntersect(r);
+    if (cornersIntersect == 4) {
+      //ensure r's x axis is within c's.  If it doesn't, r sneaks around the globe to touch the other side (intersect).
+      SpatialRelation xIntersect = r.relate_xRange(enclosingBox.getMinX(), enclosingBox.getMaxX(), ctx);
+      if (xIntersect == SpatialRelation.WITHIN)
+        return SpatialRelation.CONTAINS;
+      return SpatialRelation.INTERSECTS;
+    }
+
+    //INTERSECT or DISJOINT ?
+    if (cornersIntersect > 0)
+      return SpatialRelation.INTERSECTS;
+
+    //Now we check if one of the axis of the circle intersect with r.  If so we have
+    // intersection.
+
+    /* x axis intersects  */
+    if ( r.relate_yRange(getYAxis(), getYAxis(), ctx).intersects() // at y vertical
+          && r.relate_xRange(enclosingBox.getMinX(), enclosingBox.getMaxX(), ctx).intersects() )
+      return SpatialRelation.INTERSECTS;
+
+    /* y axis intersects */
+    if (r.relate_xRange(getXAxis(), getXAxis(), ctx).intersects()) { // at x horizontal
+      double yTop = getCenter().getY()+ distDEG;
+      assert yTop <= 90;
+      double yBot = getCenter().getY()- distDEG;
+      assert yBot >= -90;
+      if (r.relate_yRange(yBot, yTop, ctx).intersects())//back bottom
+        return SpatialRelation.INTERSECTS;
+    }
+
+    return SpatialRelation.DISJOINT;
+  }
+
+  private SpatialRelation relateRectangleCircleWrapsPole(Rectangle r, SpatialContext ctx) {
+    //This method handles the case where the circle wraps ONE pole, but not both.  For both,
+    // there is the inverseCircle case handled before now.  The only exception is for the case where
+    // the circle covers the entire globe, and we'll check that first.
+    if (distDEG == 180)//whole globe
+      return SpatialRelation.CONTAINS;
+
+    //Check if r is within the pole wrap region:
+    double yTop = getCenter().getY()+ distDEG;
+    if (yTop > 90) {
+      double yTopOverlap = yTop - 90;
+      assert yTopOverlap <= 90;
+      if (r.getMinY() >= 90 - yTopOverlap)
+        return SpatialRelation.CONTAINS;
+    } else {
+      double yBot = point.getY() - distDEG;
+      if (yBot < -90) {
+        double yBotOverlap = -90 - yBot;
+        assert yBotOverlap <= 90;
+        if (r.getMaxY() <= -90 + yBotOverlap)
+          return SpatialRelation.CONTAINS;
+      } else {
+        //This point is probably not reachable ??
+        assert yTop == 90 || yBot == -90;//we simply touch a pole
+        //continue
+      }
+    }
+
+    //If there are no corners to check intersection because r wraps completely...
+    if (r.getWidth() == 360)
+      return SpatialRelation.INTERSECTS;
+
+    //Check corners:
+    int cornersIntersect = numCornersIntersect(r);
+    // (It might be possible to reduce contains() calls within nCI() to exactly two, but this intersection
+    //  code is complicated enough as it is.)
+    if (cornersIntersect == 4) {//all
+      double backX = ctx.normX(getCenter().getX()+180);
+      if (r.relate_xRange(backX, backX, ctx).intersects())
+        return SpatialRelation.INTERSECTS;
+      else
+        return SpatialRelation.CONTAINS;
+    } else if (cornersIntersect == 0) {//none
+      double frontX = getCenter().getX();
+      if (r.relate_xRange(frontX, frontX, ctx).intersects())
+        return SpatialRelation.INTERSECTS;
+      else
+        return SpatialRelation.DISJOINT;
+    } else//partial
+      return SpatialRelation.INTERSECTS;
+  }
+
+  /** Returns either 0 for none, 1 for some, or 4 for all. */
+  private int numCornersIntersect(Rectangle r) {
+    //We play some logic games to avoid calling contains() which can be expensive.
+    boolean bool;//if true then all corners intersect, if false then no corners intersect
+    // for partial, we exit early with 1 and ignore bool.
+    bool = (contains(r.getMinX(),r.getMinY()));
+    if (contains(r.getMinX(),r.getMaxY())) {
+      if (!bool)
+        return 1;//partial
+    } else {
+      if (bool)
+        return 1;//partial
+    }
+    if (contains(r.getMaxX(),r.getMinY())) {
+      if (!bool)
+        return 1;//partial
+    } else {
+      if (bool)
+        return 1;//partial
+    }
+    if (contains(r.getMaxX(),r.getMaxY())) {
+      if (!bool)
+        return 1;//partial
+    } else {
+      if (bool)
+        return 1;//partial
+    }
+    return bool?4:0;
+  }
+
+  @Override
+  public String toString() {
+    //I'm deliberately making this look basic and not fully detailed with class name & misc fields.
+    //Add distance in degrees, which is easier to recognize, and earth radius agnostic.
+    String dStr = String.format("%.1f",distance);
+    if (ctx.isGeo()) {
+      double distDEG = ctx.getDistCalc().distanceToDegrees(distance);
+      dStr += String.format("=%.1f\u00B0",distDEG);
+    }
+    return "Circle(" + point + ",d=" + dStr + ')';
+  }
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/simple/PointImpl.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/simple/PointImpl.java
new file mode 100644
index 0000000..054e901
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/simple/PointImpl.java
@@ -0,0 +1,96 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.shape.simple;
+
+import org.apache.commons.lang.builder.EqualsBuilder;
+import org.apache.commons.lang.builder.HashCodeBuilder;
+import org.apache.lucene.spatial.base.shape.SpatialRelation;
+import org.apache.lucene.spatial.base.context.SpatialContext;
+import org.apache.lucene.spatial.base.shape.Rectangle;
+import org.apache.lucene.spatial.base.shape.Point;
+import org.apache.lucene.spatial.base.shape.Shape;
+
+
+public class PointImpl implements Point {
+
+  private final double x;
+  private final double y;
+
+  public PointImpl(double x, double y) {
+    this.x = x;
+    this.y = y;
+  }
+
+  @Override
+  public double getX() {
+    return x;
+  }
+
+  @Override
+  public double getY() {
+    return y;
+  }
+  @Override
+  public Rectangle getBoundingBox() {
+    return new RectangleImpl(x, x, y, y);
+  }
+
+  @Override
+  public PointImpl getCenter() {
+    return this;
+  }
+
+  @Override
+  public SpatialRelation relate(Shape other, SpatialContext ctx) {
+    if (other instanceof Point)
+      return this.equals(other) ? SpatialRelation.INTERSECTS : SpatialRelation.DISJOINT;
+    return other.relate(this, ctx).transpose();
+  }
+
+  @Override
+  public boolean hasArea() {
+    return false;
+  }
+
+  @Override
+  public String toString() {
+    return "Pt(x="+x+",y="+y+")";
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (obj == null) { return false; }
+    if (obj == this) { return true; }
+    if (obj.getClass() != getClass()) {
+      return false;
+    }
+    PointImpl rhs = (PointImpl) obj;
+    return new EqualsBuilder()
+                  .append(x, rhs.x)
+                  .append(y, rhs.y)
+                  .isEquals();
+  }
+
+  @Override
+  public int hashCode() {
+    return new HashCodeBuilder(5, 89).
+      append(x).
+      append(y).
+      toHashCode();
+  }
+}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/simple/RectangleImpl.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/simple/RectangleImpl.java
new file mode 100644
index 0000000..fb8e3c8
--- /dev/null
+++ b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/simple/RectangleImpl.java
@@ -0,0 +1,248 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.base.shape.simple;
+
+import org.apache.commons.lang.builder.EqualsBuilder;
+import org.apache.commons.lang.builder.HashCodeBuilder;
+import org.apache.lucene.spatial.base.shape.SpatialRelation;
+import org.apache.lucene.spatial.base.context.SpatialContext;
+import org.apache.lucene.spatial.base.distance.DistanceUtils;
+import org.apache.lucene.spatial.base.shape.*;
+
+/**
+ * A simple Rectangle implementation that also supports a longitudinal wrap-around. When minX > maxX, this will assume
+ * it is world coordinates that cross the date line using degrees.
+ * Immutable & threadsafe.
+ */
+public class RectangleImpl implements Rectangle {
+
+  private final double minX;
+  private final double maxX;
+  private final double minY;
+  private final double maxY;
+
+  //TODO change to West South East North to be more consistent with OGC?
+  public RectangleImpl(double minX, double maxX, double minY, double maxY) {
+    //We assume any normalization / validation of params already occurred.
+    this.minX = minX;
+    this.maxX = maxX;
+    this.minY = minY;
+    this.maxY = maxY;
+    assert minY <= maxY;
+  }
+
+  /** Copy constructor. */
+  public RectangleImpl(Rectangle r) {
+    this(r.getMinX(),r.getMaxX(),r.getMinY(),r.getMaxY());
+  }
+
+  @Override
+  public boolean hasArea() {
+    return maxX != minX && maxY != minY;
+  }
+
+  @Override
+  public double getArea() {
+    return getWidth() * getHeight();
+  }
+
+  @Override
+  public boolean getCrossesDateLine() {
+    return (minX > maxX);
+  }
+
+  @Override
+  public double getHeight() {
+    return maxY - minY;
+  }
+
+  @Override
+  public double getWidth() {
+    double w = maxX - minX;
+    if (w < 0) {//only true when minX > maxX (WGS84 assumed)
+      w += 360;
+      assert w >= 0;
+    }
+    return w;
+  }
+
+  @Override
+  public double getMaxX() {
+    return maxX;
+  }
+
+  @Override
+  public double getMaxY() {
+    return maxY;
+  }
+
+  @Override
+  public double getMinX() {
+    return minX;
+  }
+
+  @Override
+  public double getMinY() {
+    return minY;
+  }
+
+  @Override
+  public Rectangle getBoundingBox() {
+    return this;
+  }
+
+  @Override
+  public SpatialRelation relate(Shape other, SpatialContext ctx) {
+    if (other instanceof Point) {
+      return relate((Point) other, ctx);
+    }
+    if (other instanceof Rectangle) {
+      return relate((Rectangle) other, ctx);
+    }
+    return other.relate(this, ctx).transpose();
+  }
+
+  public SpatialRelation relate(Point point, SpatialContext ctx) {
+    if (point.getY() > getMaxY() || point.getY() < getMinY() ||
+        (getCrossesDateLine() ?
+            (point.getX() < minX && point.getX() > maxX)
+            : (point.getX() < minX || point.getX() > maxX) ))
+      return SpatialRelation.DISJOINT;
+    return SpatialRelation.CONTAINS;
+  }
+
+  public SpatialRelation relate(Rectangle rect, SpatialContext ctx) {
+    SpatialRelation yIntersect = relate_yRange(rect.getMinY(), rect.getMaxY(), ctx);
+    if (yIntersect == SpatialRelation.DISJOINT)
+      return SpatialRelation.DISJOINT;
+
+    SpatialRelation xIntersect = relate_xRange(rect.getMinX(), rect.getMaxX(), ctx);
+    if (xIntersect == SpatialRelation.DISJOINT)
+      return SpatialRelation.DISJOINT;
+
+    if (xIntersect == yIntersect)//in agreement
+      return xIntersect;
+
+    //if one side is equal, return the other
+    if (getMinX() == rect.getMinX() && getMaxX() == rect.getMaxX())
+      return yIntersect;
+    if (getMinY() == rect.getMinY() && getMaxY() == rect.getMaxY())
+      return xIntersect;
+
+    return SpatialRelation.INTERSECTS;
+  }
+
+  public SpatialRelation relate_yRange(double ext_minY, double ext_maxY, SpatialContext ctx) {
+    if (ext_minY > maxY || ext_maxY < minY) {
+      return SpatialRelation.DISJOINT;
+    }
+
+    if (ext_minY >= minY && ext_maxY <= maxY) {
+      return SpatialRelation.CONTAINS;
+    }
+
+    if (ext_minY <= minY && ext_maxY >= maxY) {
+      return SpatialRelation.WITHIN;
+    }
+    return SpatialRelation.INTERSECTS;
+  }
+
+  @Override
+  public SpatialRelation relate_xRange(double ext_minX, double ext_maxX, SpatialContext ctx) {
+    //For ext & this we have local minX and maxX variable pairs. We rotate them so that minX <= maxX
+    double minX = this.minX;
+    double maxX = this.maxX;
+    if (ctx.isGeo()) {
+      //the 360 check is an edge-case for complete world-wrap
+      double ext_width = ext_maxX - ext_minX;
+      if (ext_width < 0)//this logic unfortunately duplicates getWidth()
+        ext_width += 360;
+
+      if (ext_width < 360) {
+        ext_maxX = ext_minX + ext_width;
+      } else {
+        ext_maxX = 180+360;
+      }
+
+      if (getWidth() < 360) {
+        maxX = minX + getWidth();
+      } else {
+        maxX = 180+360;
+      }
+
+      if (maxX < ext_minX) {
+        minX += 360;
+        maxX += 360;
+      } else if (ext_maxX < minX) {
+        ext_minX += 360;
+        ext_maxX += 360;
+      }
+    }
+
+    if (ext_minX > maxX || ext_maxX < minX ) {
+      return SpatialRelation.DISJOINT;
+    }
+
+    if (ext_minX >= minX && ext_maxX <= maxX ) {
+      return SpatialRelation.CONTAINS;
+    }
+
+    if (ext_minX <= minX && ext_maxX >= maxX ) {
+      return SpatialRelation.WITHIN;
+    }
+    return SpatialRelation.INTERSECTS;
+  }
+
+  @Override
+  public String toString() {
+    return "Rect(minX=" + minX + ",maxX=" + maxX + ",minY=" + minY + ",maxY=" + maxY + ")";
+  }
+
+  @Override
+  public Point getCenter() {
+    final double y = getHeight() / 2 + minY;
+    double x = getWidth() / 2 + minX;
+    if (minX > maxX)//WGS84
+      x = DistanceUtils.normLonDEG(x);
+    return new PointImpl(x, y);
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (obj == null) { return false; }
+    if (obj == this) { return true; }
+    if (obj.getClass() != getClass()) {
+      return false;
+    }
+    RectangleImpl rhs = (RectangleImpl) obj;
+    return new EqualsBuilder()
+                  .append(minX, rhs.minX)
+                  .append(minY, rhs.minY)
+                  .append(maxX, rhs.maxX)
+                  .append(maxY, rhs.maxY)
+                  .isEquals();
+  }
+
+  @Override
+  public int hashCode() {
+    return new HashCodeBuilder(41, 37).
+    append(minX).append(minY).
+    append(maxX).append(maxY).
+      toHashCode();
+  }
+}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/context/ParseUtils.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/context/ParseUtils.java
deleted file mode 100644
index c6ab3bf..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/context/ParseUtils.java
+++ /dev/null
@@ -1,157 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.context;
-
-import org.apache.lucene.spatial.base.exception.InvalidShapeException;
-
-/**
- * Utility methods related to parsing shapes.
- * Methods here were formerly in DistanceUtils.
- */
-public class ParseUtils {
-  private ParseUtils() {
-  }
-
-  /**
-   * Given a string containing <i>dimension</i> values encoded in it, separated by commas, return a String array of length <i>dimension</i>
-   * containing the values.
-   *
-   * @param out         A preallocated array.  Must be size dimension.  If it is not it will be resized.
-   * @param externalVal The value to parse
-   * @param dimension   The expected number of values for the point
-   * @return An array of the values that make up the point (aka vector)
-   * @throws org.apache.lucene.spatial.base.exception.InvalidShapeException if the dimension specified does not match the number of values in the externalValue.
-   */
-  public static String[] parsePoint(String[] out, String externalVal, int dimension) throws InvalidShapeException {
-    //TODO: Should we support sparse vectors?
-    if (out == null || out.length != dimension) out = new String[dimension];
-    int idx = externalVal.indexOf(',');
-    int end = idx;
-    int start = 0;
-    int i = 0;
-    if (idx == -1 && dimension == 1 && externalVal.length() > 0) {//we have a single point, dimension better be 1
-      out[0] = externalVal.trim();
-      i = 1;
-    } else if (idx > 0) {//if it is zero, that is an error
-      //Parse out a comma separated list of point values, as in: 73.5,89.2,7773.4
-      for (; i < dimension; i++) {
-        while (start < end && externalVal.charAt(start) == ' ') start++;
-        while (end > start && externalVal.charAt(end - 1) == ' ') end--;
-        if (start == end) {
-          break;
-        }
-        out[i] = externalVal.substring(start, end);
-        start = idx + 1;
-        end = externalVal.indexOf(',', start);
-        idx = end;
-        if (end == -1) {
-          end = externalVal.length();
-        }
-      }
-    }
-    if (i != dimension) {
-      throw new InvalidShapeException("incompatible dimension (" + dimension +
-              ") and values (" + externalVal + ").  Only " + i + " values specified");
-    }
-    return out;
-  }
-
-  /**
-   * Given a string containing <i>dimension</i> values encoded in it, separated by commas, return a double array of length <i>dimension</i>
-   * containing the values.
-   *
-   * @param out         A preallocated array.  Must be size dimension.  If it is not it will be resized.
-   * @param externalVal The value to parse
-   * @param dimension   The expected number of values for the point
-   * @return An array of the values that make up the point (aka vector)
-   * @throws org.apache.lucene.spatial.base.exception.InvalidShapeException if the dimension specified does not match the number of values in the externalValue.
-   */
-  public static double[] parsePointDouble(double[] out, String externalVal, int dimension) throws InvalidShapeException{
-    if (out == null || out.length != dimension) out = new double[dimension];
-    int idx = externalVal.indexOf(',');
-    int end = idx;
-    int start = 0;
-    int i = 0;
-    if (idx == -1 && dimension == 1 && externalVal.length() > 0) {//we have a single point, dimension better be 1
-      out[0] = Double.parseDouble(externalVal.trim());
-      i = 1;
-    } else if (idx > 0) {//if it is zero, that is an error
-      //Parse out a comma separated list of point values, as in: 73.5,89.2,7773.4
-      for (; i < dimension; i++) {
-        //TODO: abstract common code with other parsePoint
-        while (start < end && externalVal.charAt(start) == ' ') start++;
-        while (end > start && externalVal.charAt(end - 1) == ' ') end--;
-        if (start == end) {
-          break;
-        }
-        out[i] = Double.parseDouble(externalVal.substring(start, end));
-        start = idx + 1;
-        end = externalVal.indexOf(',', start);
-        idx = end;
-        if (end == -1) {
-          end = externalVal.length();
-        }
-      }
-    }
-    if (i != dimension) {
-      throw new InvalidShapeException("incompatible dimension (" + dimension +
-              ") and values (" + externalVal + ").  Only " + i + " values specified");
-    }
-    return out;
-  }
-
-  public static final double[] parseLatitudeLongitude(String latLonStr) throws InvalidShapeException {
-    return parseLatitudeLongitude(null, latLonStr);
-  }
-
-  /**
-   * extract (by calling {@link #parsePoint(String[], String, int)} and validate the latitude and longitude contained
-   * in the String by making sure the latitude is between 90 & -90 and longitude is between -180 and 180.
-   * <p/>
-   * The latitude is assumed to be the first part of the string and the longitude the second part.
-   *
-   * @param latLon    A preallocated array to hold the result
-   * @param latLonStr The string to parse.  Latitude is the first value, longitude is the second.
-   * @return The lat long
-   * @throws org.apache.lucene.spatial.base.exception.InvalidShapeException if there was an error parsing
-   */
-  public static final double[] parseLatitudeLongitude(double[] latLon, String latLonStr) throws InvalidShapeException {
-    if (latLon == null) {
-      latLon = new double[2];
-    }
-    double[] toks = parsePointDouble(null, latLonStr, 2);
-
-    if (toks[0] < -90.0 || toks[0] > 90.0) {
-      throw new InvalidShapeException(
-              "Invalid latitude: latitudes are range -90 to 90: provided lat: ["
-                      + toks[0] + "]");
-    }
-    latLon[0] = toks[0];
-
-
-    if (toks[1] < -180.0 || toks[1] > 180.0) {
-
-      throw new InvalidShapeException(
-              "Invalid longitude: longitudes are range -180 to 180: provided lon: ["
-                      + toks[1] + "]");
-    }
-    latLon[1] = toks[1];
-
-    return latLon;
-  }
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/context/SpatialContext.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/context/SpatialContext.java
deleted file mode 100644
index 1f4ea4a..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/context/SpatialContext.java
+++ /dev/null
@@ -1,249 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.context;
-
-import org.apache.lucene.spatial.base.distance.*;
-import org.apache.lucene.spatial.base.exception.InvalidShapeException;
-import org.apache.lucene.spatial.base.shape.Circle;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-import org.apache.lucene.spatial.base.shape.Shape;
-import org.apache.lucene.spatial.base.shape.simple.RectangleImpl;
-
-import java.text.NumberFormat;
-import java.util.Locale;
-import java.util.StringTokenizer;
-
-/**
- * This holds things like distance units, distance calculator, and world bounds.
- * Threadsafe & immutable.
- */
-public abstract class SpatialContext {
-
-  //These are non-null
-  private final DistanceUnits units;
-  private final DistanceCalculator calculator;
-  private final Rectangle worldBounds;
-
-  public static RectangleImpl GEO_WORLDBOUNDS = new RectangleImpl(-180,180,-90,90);
-  public static RectangleImpl MAX_WORLDBOUNDS;
-  static {
-    double v = Double.MAX_VALUE;
-    MAX_WORLDBOUNDS = new RectangleImpl(-v, v, -v, v);
-  }
-  
-  protected final Double maxCircleDistance;//only for geo
-  protected final boolean NUDGE = false;//TODO document
-
-  /**
-   *
-   * @param units Required; and establishes geo vs cartesian.
-   * @param calculator Optional; defaults to Haversine or cartesian depending on units.
-   * @param worldBounds Optional; defaults to GEO_WORLDBOUNDS or MAX_WORLDBOUNDS depending on units.
-   */
-  protected SpatialContext(DistanceUnits units, DistanceCalculator calculator, Rectangle worldBounds) {
-    if (units == null)
-      throw new IllegalArgumentException("units can't be null");
-    this.units = units;
-
-    if (calculator == null) {
-      calculator = isGeo()
-          ? new GeodesicSphereDistCalc.Haversine(units.earthRadius())
-          : new CartesianDistCalc();
-    }
-    this.calculator = calculator;
-
-    if (worldBounds == null) {
-      worldBounds = isGeo() ? GEO_WORLDBOUNDS : MAX_WORLDBOUNDS;
-    } else {
-      if (isGeo())
-        assert new RectangleImpl(worldBounds).equals(GEO_WORLDBOUNDS);
-      if (worldBounds.getCrossesDateLine())
-        throw new IllegalArgumentException("worldBounds shouldn't cross dateline: "+worldBounds);
-    }
-    //copy so we can ensure we have the right implementation
-    worldBounds = makeRect(worldBounds.getMinX(),worldBounds.getMaxX(),worldBounds.getMinY(),worldBounds.getMaxY());
-    this.worldBounds = worldBounds;
-    
-    this.maxCircleDistance = isGeo() ? calculator.degreesToDistance(180) : null;
-  }
-
-  public DistanceUnits getUnits() {
-    return units;
-  }
-
-  public DistanceCalculator getDistCalc() {
-    return calculator;
-  }
-
-  public Rectangle getWorldBounds() {
-    return worldBounds;
-  }
-
-  public double normX(double x) {
-    if (isGeo()) {
-      return DistanceUtils.normLonDEG(x);
-    } else {
-      return x;
-    }
-  }
-
-  public double normY(double y) {
-    if (isGeo()) {
-      y = DistanceUtils.normLatDEG(y);
-    }
-    return y;
-  }
-
-  /**
-   * Is this a geospatial context (true) or simply 2d spatial (false)
-   * @return
-   */
-  public boolean isGeo() {
-    return getUnits().isGeo();
-  }
-
-  /**
-   * Read a shape from a given string (ie, X Y, XMin XMax... WKT)
-   *
-   * (1) Point: X Y
-   *   1.23 4.56
-   *
-   * (2) BOX: XMin YMin XMax YMax
-   *   1.23 4.56 7.87 4.56
-   *
-   * (3) WKT
-   *   POLYGON( ... )
-   *   http://en.wikipedia.org/wiki/Well-known_text
-   *
-   */
-  public abstract Shape readShape(String value) throws InvalidShapeException;
-
-  public Point readLatCommaLonPoint(String value) throws InvalidShapeException {
-    double[] latLon = ParseUtils.parseLatitudeLongitude(value);
-    return makePoint(latLon[1],latLon[0]);
-  }
-
-  public abstract String toString(Shape shape);
-
-  /** Construct a point. The parameters will be normalized. */
-  public abstract Point makePoint( double x, double y );
-
-  /** Construct a rectangle. The parameters will be normalized. */
-  public abstract Rectangle makeRect(double minX, double maxX, double minY, double maxY);
-
-  /** Construct a circle. The parameters will be normalized. */
-  public Circle makeCircle(double x, double y, double distance) {
-    return makeCircle(makePoint(x,y),distance);
-  }
-
-  /**
-   *
-   * @param ctr
-   * @param distance The units of "distance" should be the same as {@link #getUnits()}.
-   * @return
-   */
-  public abstract Circle makeCircle(Point ctr, double distance);
-
-  protected Shape readStandardShape(String str) {
-    if (str.length() < 1) {
-      throw new InvalidShapeException(str);
-    }
-
-    if(Character.isLetter(str.charAt(0))) {
-      if( str.startsWith( "Circle(" ) ) {
-        int idx = str.lastIndexOf( ')' );
-        if( idx > 0 ) {
-          String body = str.substring( "Circle(".length(), idx );
-          StringTokenizer st = new StringTokenizer(body, " ");
-          String token = st.nextToken();
-          Point pt;
-          if (token.indexOf(',') != -1) {
-            pt = readLatCommaLonPoint(token);
-          } else {
-            double x = Double.parseDouble(token);
-            double y = Double.parseDouble(st.nextToken());
-            pt = makePoint(x,y);
-          }
-          Double d = null;
-
-          String arg = st.nextToken();
-          idx = arg.indexOf( '=' );
-          if( idx > 0 ) {
-            String k = arg.substring( 0,idx );
-            if( k.equals( "d" ) || k.equals( "distance" ) ) {
-              d = Double.parseDouble( arg.substring(idx+1));
-            }
-            else {
-              throw new InvalidShapeException( "unknown arg: "+k+" :: " +str );
-            }
-          }
-          else {
-            d = Double.parseDouble(arg);
-          }
-          if( st.hasMoreTokens() ) {
-            throw new InvalidShapeException( "Extra arguments: "+st.nextToken()+" :: " +str );
-          }
-          if( d == null ) {
-            throw new InvalidShapeException( "Missing Distance: "+str );
-          }
-          //NOTE: we are assuming the units of 'd' is the same as that of the spatial context.
-          return makeCircle(pt, d);
-        }
-      }
-      return null;
-    }
-
-    if (str.indexOf(',') != -1)
-      return readLatCommaLonPoint(str);
-    StringTokenizer st = new StringTokenizer(str, " ");
-    double p0 = Double.parseDouble(st.nextToken());
-    double p1 = Double.parseDouble(st.nextToken());
-    if (st.hasMoreTokens()) {
-      double p2 = Double.parseDouble(st.nextToken());
-      double p3 = Double.parseDouble(st.nextToken());
-      if (st.hasMoreTokens())
-        throw new InvalidShapeException("Only 4 numbers supported (rect) but found more: "+str);
-      return makeRect(p0, p2, p1, p3);
-    }
-    return makePoint(p0, p1);
-  }
-
-  public String writeRect(Rectangle rect) {
-    NumberFormat nf = NumberFormat.getInstance(Locale.US);
-    nf.setGroupingUsed(false);
-    nf.setMaximumFractionDigits(6);
-    nf.setMinimumFractionDigits(6);
-
-    return
-      nf.format(rect.getMinX()) + " " +
-      nf.format(rect.getMinY()) + " " +
-      nf.format(rect.getMaxX()) + " " +
-      nf.format(rect.getMaxY());
-  }
-
-  @Override
-  public String toString() {
-    return getClass().getSimpleName()+"{" +
-        "units=" + units +
-        ", calculator=" + calculator +
-        ", worldBounds=" + worldBounds +
-        '}';
-  }
-
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/context/SpatialContextFactory.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/context/SpatialContextFactory.java
deleted file mode 100644
index 8ebed98..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/context/SpatialContextFactory.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.context;
-
-import org.apache.lucene.spatial.base.context.simple.SimpleSpatialContext;
-import org.apache.lucene.spatial.base.context.simple.SimpleSpatialContextFactory;
-import org.apache.lucene.spatial.base.distance.*;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-
-import java.util.Map;
-
-/**
- * Factory for a SpatialContext.
- * is 
- * @author dsmiley
- */
-public abstract class SpatialContextFactory {
-  protected Map<String, String> args;
-  protected ClassLoader classLoader;
-  
-  protected DistanceUnits units;
-  protected DistanceCalculator calculator;
-  protected Rectangle worldBounds;
-
-  /**
-   * The factory class is lookuped up via "spatialContextFactory" in args
-   * then falling back to a Java system property (with initial caps). If neither are specified
-   * then {@link SimpleSpatialContextFactory} is chosen.
-   * @param args
-   * @param classLoader
-   * @return
-   */
-  public static SpatialContext makeSpatialContext(Map<String,String> args, ClassLoader classLoader) {
-    SpatialContextFactory instance;
-    String cname = args.get("spatialContextFactory");
-    if (cname == null)
-      cname = System.getProperty("SpatialContextFactory");
-    if (cname == null)
-      instance = new SimpleSpatialContextFactory();
-    else {
-      try {
-        Class c = classLoader.loadClass(cname);
-        instance = (SpatialContextFactory) c.newInstance();
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
-    }
-    instance.init(args,classLoader);
-    return instance.newSpatialContext();
-  }
-
-  protected void init(Map<String, String> args, ClassLoader classLoader) {
-    this.args = args;
-    this.classLoader = classLoader;
-    initUnits();
-    initCalculator();
-    initWorldBounds();
-  }
-
-  protected void initUnits() {
-    String unitsStr = args.get("units");
-    if (unitsStr != null)
-      units = DistanceUnits.findDistanceUnit(unitsStr);
-    if (units == null)
-      units = DistanceUnits.KILOMETERS;
-  }
-
-  protected void initCalculator() {
-    String calcStr = args.get("distCalculator");
-    if (calcStr == null)
-      return;
-    if (calcStr.equalsIgnoreCase("haversine")) {
-      calculator = new GeodesicSphereDistCalc.Haversine(units.earthRadius());
-    } else if (calcStr.equalsIgnoreCase("lawOfCosines")) {
-      calculator = new GeodesicSphereDistCalc.LawOfCosines(units.earthRadius());
-    } else if (calcStr.equalsIgnoreCase("vincentySphere")) {
-      calculator = new GeodesicSphereDistCalc.Vincenty(units.earthRadius());
-    } else if (calcStr.equalsIgnoreCase("cartesian")) {
-      calculator = new CartesianDistCalc();
-    } else if (calcStr.equalsIgnoreCase("cartesian^2")) {
-      calculator = new CartesianDistCalc(true);
-    } else {
-      throw new RuntimeException("Unknown calculator: "+calcStr);
-    }
-  }
-
-  protected void initWorldBounds() {
-    String worldBoundsStr = args.get("worldBounds");
-    if (worldBoundsStr == null)
-      return;
-    //kinda ugly we do this just to read a rectangle.  TODO refactor
-    SimpleSpatialContext simpleCtx = new SimpleSpatialContext(units, calculator, null);
-    worldBounds = (Rectangle) simpleCtx.readShape(worldBoundsStr);
-  }
-
-  /** Subclasses should simply construct the instance from the initialized configuration. */
-  protected abstract SpatialContext newSpatialContext();
-
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/context/simple/SimpleSpatialContext.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/context/simple/SimpleSpatialContext.java
deleted file mode 100644
index 413eae1..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/context/simple/SimpleSpatialContext.java
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.context.simple;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.distance.DistanceCalculator;
-import org.apache.lucene.spatial.base.distance.DistanceUnits;
-import org.apache.lucene.spatial.base.exception.InvalidShapeException;
-import org.apache.lucene.spatial.base.shape.Circle;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-import org.apache.lucene.spatial.base.shape.Shape;
-import org.apache.lucene.spatial.base.shape.simple.CircleImpl;
-import org.apache.lucene.spatial.base.shape.simple.GeoCircleImpl;
-import org.apache.lucene.spatial.base.shape.simple.PointImpl;
-import org.apache.lucene.spatial.base.shape.simple.RectangleImpl;
-
-import java.text.NumberFormat;
-import java.util.Locale;
-
-public class SimpleSpatialContext extends SpatialContext {
-
-  public static SimpleSpatialContext GEO_KM = new SimpleSpatialContext(DistanceUnits.KILOMETERS);
-
-  public SimpleSpatialContext(DistanceUnits units) {
-    this(units, null, null);
-  }
-
-  public SimpleSpatialContext(DistanceUnits units, DistanceCalculator calculator, Rectangle worldBounds) {
-    super(units, calculator, worldBounds);
-  }
-
-  @Override
-  public Shape readShape(String value) throws InvalidShapeException {
-    Shape s = super.readStandardShape( value );
-    if( s == null ) {
-      throw new InvalidShapeException( "Unable to read: "+value );
-    }
-    return s;
-  }
-
-  @Override
-  public String toString(Shape shape) {
-    if (Point.class.isInstance(shape)) {
-      NumberFormat nf = NumberFormat.getInstance(Locale.US);
-      nf.setGroupingUsed(false);
-      nf.setMaximumFractionDigits(6);
-      nf.setMinimumFractionDigits(6);
-      Point point = (Point) shape;
-      return nf.format(point.getX()) + " " + nf.format(point.getY());
-    } else if (Rectangle.class.isInstance(shape)) {
-      return writeRect((Rectangle) shape);
-    }
-    return shape.toString();
-  }
-
-  @Override
-  public Circle makeCircle(Point point, double distance) {
-    if (distance < 0)
-      throw new InvalidShapeException("distance must be >= 0; got "+distance);
-    if (isGeo())
-      return new GeoCircleImpl( point, Math.min(distance,maxCircleDistance), this );
-    else
-      return new CircleImpl( point, distance, this );
-  }
-
-  @Override
-  public Rectangle makeRect(double minX, double maxX, double minY, double maxY) {
-    //--Normalize parameters
-    if (isGeo()) {
-      double delta = calcWidth(minX,maxX);
-      if (delta >= 360) {
-        //The only way to officially support complete longitude wrap-around is via western longitude = -180. We can't
-        // support any point because 0 is undifferentiated in sign.
-        minX = -180;
-        maxX = 180;
-      } else {
-        minX = normX(minX);
-        maxX = normX(maxX);
-        assert Math.abs(delta - calcWidth(minX,maxX)) < 0.0001;//recompute delta; should be the same
-      }
-      if (minY > maxY) {
-        throw new IllegalArgumentException("maxY must be >= minY");
-      }
-      if (minY < -90 || minY > 90 || maxY < -90 || maxY > 90)
-        throw new IllegalArgumentException("minY or maxY is outside of -90 to 90 bounds. What did you mean?");
-//      debatable what to do in this situation.
-//      if (minY < -90) {
-//        minX = -180;
-//        maxX = 180;
-//        maxY = Math.min(90,Math.max(maxY,-90 + (-90 - minY)));
-//        minY = -90;
-//      }
-//      if (maxY > 90) {
-//        minX = -180;
-//        maxX = 180;
-//        minY = Math.max(-90,Math.min(minY,90 - (maxY - 90)));
-//        maxY = 90;
-//      }
-
-    } else {
-      //these normalizations probably won't do anything since it's not geo but should probably call them any way.
-      minX = normX(minX);
-      maxX = normX(maxX);
-      minY = normY(minY);
-      maxY = normY(maxY);
-    }
-    return new RectangleImpl( minX, maxX, minY, maxY );
-  }
-
-  private double calcWidth(double minX,double maxX) {
-    double w = maxX - minX;
-    if (w < 0) {//only true when minX > maxX (WGS84 assumed)
-      w += 360;
-      assert w >= 0;
-    }
-    return w;
-  }
-
-  @Override
-  public Point makePoint(double x, double y) {
-    return new PointImpl(normX(x),normY(y));
-  }
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/context/simple/SimpleSpatialContextFactory.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/context/simple/SimpleSpatialContextFactory.java
deleted file mode 100644
index 2ace223..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/context/simple/SimpleSpatialContextFactory.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.context.simple;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.context.SpatialContextFactory;
-
-/**
-* @author dsmiley
-*/
-public class SimpleSpatialContextFactory extends SpatialContextFactory {
-  @Override
-  protected SpatialContext newSpatialContext() {
-    return new SimpleSpatialContext(units,calculator,worldBounds);
-  }
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/distance/AbstractDistanceCalculator.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/distance/AbstractDistanceCalculator.java
deleted file mode 100644
index e07598e..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/distance/AbstractDistanceCalculator.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.distance;
-
-import org.apache.lucene.spatial.base.shape.Point;
-
-/**
- * @author David Smiley - dsmiley@mitre.org
- */
-public abstract class AbstractDistanceCalculator implements DistanceCalculator {
-
-  @Override
-  public double distance(Point from, Point to) {
-    return distance(from, to.getX(), to.getY());
-  }
-
-  @Override
-  public String toString() {
-    return getClass().getSimpleName();
-  }
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/distance/CartesianDistCalc.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/distance/CartesianDistCalc.java
deleted file mode 100644
index 853eba7..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/distance/CartesianDistCalc.java
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.distance;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-
-public class CartesianDistCalc extends AbstractDistanceCalculator {
-
-  private final boolean squared;
-
-  public CartesianDistCalc() {
-    this.squared = false;
-  }
-
-  public CartesianDistCalc(boolean squared) {
-    this.squared = squared;
-  }
-
-  @Override
-  public double distance(Point from, double toX, double toY) {
-    double result = 0;
-
-    double v = from.getX() - toX;
-    result += (v * v);
-
-    v = from.getY() - toY;
-    result += (v * v);
-
-    if( squared )
-      return result;
-
-    return Math.sqrt(result);
-  }
-
-  @Override
-  public Point pointOnBearing(Point from, double dist, double bearingDEG, SpatialContext ctx) {
-    if (dist == 0)
-      return from;
-    double bearingRAD = Math.toDegrees(bearingDEG);
-    double x = Math.sin(bearingRAD) * dist;
-    double y = Math.cos(bearingRAD) * dist;
-    return ctx.makePoint(from.getX()+x, from.getY()+y);
-  }
-
-  @Override
-  public double distanceToDegrees(double distance) {
-    throw new UnsupportedOperationException("no geo!");
-  }
-
-  @Override
-  public double degreesToDistance(double degrees) {
-    throw new UnsupportedOperationException("no geo!");
-  }
-
-  @Override
-  public Rectangle calcBoxByDistFromPt(Point from, double distance, SpatialContext ctx) {
-    return ctx.makeRect(from.getX()-distance,from.getX()+distance,from.getY()-distance,from.getY()+distance);
-  }
-
-  @Override
-  public double calcBoxByDistFromPtHorizAxis(Point from, double distance, SpatialContext ctx) {
-    return from.getY();
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (this == o) return true;
-    if (o == null || getClass() != o.getClass()) return false;
-
-    CartesianDistCalc that = (CartesianDistCalc) o;
-
-    if (squared != that.squared) return false;
-
-    return true;
-  }
-
-  @Override
-  public int hashCode() {
-    return (squared ? 1 : 0);
-  }
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/distance/DistanceCalculator.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/distance/DistanceCalculator.java
deleted file mode 100644
index d6cdb92..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/distance/DistanceCalculator.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.distance;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-
-public interface DistanceCalculator {
-
-  public double distance(Point from, Point to);
-  public double distance(Point from, double toX, double toY);
-
-  public Point pointOnBearing(Point from, double dist, double bearingDEG, SpatialContext ctx);
-  
-  /**
-   * Converts a distance to radians (multiples of the radius). A spherical
-   * earth model is assumed for geospatial, and non-geospatial is the identity function.
-   */
-  public double distanceToDegrees(double distance);
-
-  public double degreesToDistance(double degrees);
-
-  //public Point pointOnBearing(Point from, double angle);
-
-  public Rectangle calcBoxByDistFromPt(Point from, double distance, SpatialContext ctx);
-
-  public double calcBoxByDistFromPtHorizAxis(Point from, double distance, SpatialContext ctx);
-
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/distance/DistanceUnits.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/distance/DistanceUnits.java
deleted file mode 100644
index 8540b27..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/distance/DistanceUnits.java
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.distance;
-
-/**
- * Enum representing difference distance units, currently only kilometers and
- * miles
- */
-public enum DistanceUnits {
-
-  //TODO do we need circumference?
-  KILOMETERS("km", DistanceUtils.EARTH_MEAN_RADIUS_KM, 40076),
-  MILES("miles", DistanceUtils.EARTH_MEAN_RADIUS_MI, 24902),
-  RADIANS("radians", 1, Math.PI * 2),//experimental
-  CARTESIAN("u", -1, -1);
-
-
-  private final String units;
-
-  private final double earthCircumference;
-
-  private final double earthRadius;
-
-  /**
-   * Creates a new DistanceUnit that represents the given unit
-   *
-   * @param units Distance unit in String form
-   * @param earthRadius Radius of the Earth in the specific distance unit
-   * @param earthCircumfence Circumference of the Earth in the specific distance unit
-   */
-  DistanceUnits(String units, double earthRadius, double earthCircumfence) {
-    this.units = units;
-    this.earthCircumference = earthCircumfence;
-    this.earthRadius = earthRadius;
-  }
-
-  /**
-   * Returns the DistanceUnit which represents the given unit
-   *
-   * @param unit Unit whose DistanceUnit should be found
-   * @return DistanceUnit representing the unit
-   * @throws IllegalArgumentException if no DistanceUnit which represents the given unit is found
-   */
-  public static DistanceUnits findDistanceUnit(String unit) {
-    if (MILES.getUnits().equalsIgnoreCase(unit) || unit.equalsIgnoreCase("mi")) {
-      return MILES;
-    }
-    if (KILOMETERS.getUnits().equalsIgnoreCase(unit)) {
-      return KILOMETERS;
-    }
-    if (CARTESIAN.getUnits().equalsIgnoreCase(unit) || unit.length()==0) {
-      return CARTESIAN;
-    }
-    throw new IllegalArgumentException("Unknown distance unit " + unit);
-  }
-
-  /**
-   * Converts the given distance in given DistanceUnit, to a distance in the unit represented by {@code this}
-   *
-   * @param distance Distance to convert
-   * @param from Unit to convert the distance from
-   * @return Given distance converted to the distance in the given unit
-   */
-  public double convert(double distance, DistanceUnits from) {
-    if (from == this) {
-      return distance;
-    }
-    if (this == CARTESIAN || from == CARTESIAN) {
-      throw new IllegalStateException("Can't convert cartesian distances: "+from+" -> "+this);
-    }
-    return (this == MILES) ? distance * DistanceUtils.KM_TO_MILES : distance * DistanceUtils.MILES_TO_KM;
-  }
-
-  /**
-   * Returns the string representation of the distance unit
-   *
-   * @return String representation of the distance unit
-   */
-  public String getUnits() {
-    return units;
-  }
-
-  /**
-   * Returns the <a href="http://en.wikipedia.org/wiki/Earth_radius">average earth radius</a>
-   *
-   * @return the average earth radius
-   */
-  public double earthRadius() {
-    return earthRadius;
-  }
-
-  /**
-   * Returns the <a href="http://www.lyberty.com/encyc/articles/earth.html">circumference of the Earth</a>
-   *
-   * @return  the circumference of the Earth
-   */
-  public double earthCircumference() {
-    return earthCircumference;
-  }
-  
-  public boolean isGeo() {
-    return earthRadius > 0;
-  }
-}
-
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/distance/DistanceUtils.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/distance/DistanceUtils.java
deleted file mode 100644
index 8b46f39..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/distance/DistanceUtils.java
+++ /dev/null
@@ -1,427 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.distance;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-
-import static java.lang.Math.toRadians;
-
-/**
- * Various distance calculations and constants.
- * Originally from Lucene 3x's old spatial module. It has been modified here.
- */
-public class DistanceUtils {
-
-  //pre-compute some angles that are commonly used
-  public static final double DEG_45_AS_RADS = Math.PI / 4.0;
-  public static final double SIN_45_AS_RADS = Math.sin(DEG_45_AS_RADS);
-  public static final double DEG_90_AS_RADS = Math.PI / 2;
-  public static final double DEG_180_AS_RADS = Math.PI;
-  public static final double DEG_225_AS_RADS = 5 * DEG_45_AS_RADS;
-  public static final double DEG_270_AS_RADS = 3 * DEG_90_AS_RADS;
-
-
-  public static final double KM_TO_MILES = 0.621371192;
-  public static final double MILES_TO_KM = 1 / KM_TO_MILES;//1.609
-
-  /**
-   * The International Union of Geodesy and Geophysics says the Earth's mean radius in KM is:
-   *
-   * [1] http://en.wikipedia.org/wiki/Earth_radius
-   */
-  public static final double EARTH_MEAN_RADIUS_KM = 6371.0087714;
-  public static final double EARTH_EQUATORIAL_RADIUS_KM = 6378.1370;
-
-  public static final double EARTH_MEAN_RADIUS_MI = EARTH_MEAN_RADIUS_KM * KM_TO_MILES;
-  public static final double EARTH_EQUATORIAL_RADIUS_MI = EARTH_EQUATORIAL_RADIUS_KM * KM_TO_MILES;
-
-  /**
-   * Calculate the p-norm (i.e. length) between two vectors
-   *
-   * @param vec1  The first vector
-   * @param vec2  The second vector
-   * @param power The power (2 for cartesian distance, 1 for manhattan, etc.)
-   * @return The length.
-   *         <p/>
-   *         See http://en.wikipedia.org/wiki/Lp_space
-   * @see #vectorDistance(double[], double[], double, double)
-   */
-  public static double vectorDistance(double[] vec1, double[] vec2, double power) {
-    return vectorDistance(vec1, vec2, power, 1.0 / power);
-  }
-
-  /**
-   * Calculate the p-norm (i.e. length) between two vectors
-   *
-   * @param vec1         The first vector
-   * @param vec2         The second vector
-   * @param power        The power (2 for cartesian distance, 1 for manhattan, etc.)
-   * @param oneOverPower If you've precalculated oneOverPower and cached it, use this method to save one division operation over {@link #vectorDistance(double[], double[], double)}.
-   * @return The length.
-   */
-  public static double vectorDistance(double[] vec1, double[] vec2, double power, double oneOverPower) {
-    double result = 0;
-
-    if (power == 0) {
-      for (int i = 0; i < vec1.length; i++) {
-        result += vec1[i] - vec2[i] == 0 ? 0 : 1;
-      }
-
-    } else if (power == 1.0) {
-      for (int i = 0; i < vec1.length; i++) {
-        result += vec1[i] - vec2[i];
-      }
-    } else if (power == 2.0) {
-      result = Math.sqrt(distSquaredCartesian(vec1, vec2));
-    } else if (power == Integer.MAX_VALUE || Double.isInfinite(power)) {//infinite norm?
-      for (int i = 0; i < vec1.length; i++) {
-        result = Math.max(result, Math.max(vec1[i], vec2[i]));
-      }
-    } else {
-      for (int i = 0; i < vec1.length; i++) {
-        result += Math.pow(vec1[i] - vec2[i], power);
-      }
-      result = Math.pow(result, oneOverPower);
-    }
-    return result;
-  }
-
-  /**
-   * Return the coordinates of a vector that is the corner of a box (upper right or lower left), assuming a Rectangular
-   * coordinate system.  Note, this does not apply for points on a sphere or ellipse (although it could be used as an approximation).
-   *
-   * @param center     The center point
-   * @param result Holds the result, potentially resizing if needed.
-   * @param distance   The d from the center to the corner
-   * @param upperRight If true, return the coords for the upper right corner, else return the lower left.
-   * @return The point, either the upperLeft or the lower right
-   */
-  public static double[] vectorBoxCorner(double[] center, double[] result, double distance, boolean upperRight) {
-    if (result == null || result.length != center.length) {
-      result = new double[center.length];
-    }
-    if (upperRight == false) {
-      distance = -distance;
-    }
-    //We don't care about the power here,
-    // b/c we are always in a rectangular coordinate system, so any norm can be used by
-    //using the definition of sine
-    distance = SIN_45_AS_RADS * distance; // sin(Pi/4) == (2^0.5)/2 == opp/hyp == opp/distance, solve for opp, similarly for cosine
-    for (int i = 0; i < center.length; i++) {
-      result[i] = center[i] + distance;
-    }
-    return result;
-  }
-
-  /**
-   * Given a start point (startLat, startLon) and a bearing on a sphere of radius <i>sphereRadius</i>, return the destination point.
-   *
-   *
-   * @param startLat The starting point latitude, in radians
-   * @param startLon The starting point longitude, in radians
-   * @param distanceRAD The distance to travel along the bearing in radians.
-   * @param bearingRAD The bearing, in radians.  North is a 0, moving clockwise till radians(360).
-   * @param result A preallocated array to hold the results.  If null, a new one is constructed.
-   * @return The destination point, in radians.  First entry is latitude, second is longitude
-   */
-  public static double[] pointOnBearingRAD(double startLat, double startLon, double distanceRAD, double bearingRAD, double[] result) {
-    /*
- 	lat2 = asin(sin(lat1)*cos(d/R) + cos(lat1)*sin(d/R)*cos(θ))
-  	lon2 = lon1 + atan2(sin(θ)*sin(d/R)*cos(lat1), cos(d/R)??in(lat1)*sin(lat2))
-
-     */
-    double cosAngDist = Math.cos(distanceRAD);
-    double cosStartLat = Math.cos(startLat);
-    double sinAngDist = Math.sin(distanceRAD);
-    double sinStartLat = Math.sin(startLat);
-    double lat2 = Math.asin(sinStartLat * cosAngDist +
-            cosStartLat * sinAngDist * Math.cos(bearingRAD));
-
-    double lon2 = startLon + Math.atan2(Math.sin(bearingRAD) * sinAngDist * cosStartLat,
-            cosAngDist - sinStartLat * Math.sin(lat2));
-
-    /*lat2 = (lat2*180)/Math.PI;
-    lon2 = (lon2*180)/Math.PI;*/
-    //From Lucene.  Move back to Lucene when synced
-    // normalize lon first
-    if (result == null || result.length != 2){
-      result = new double[2];
-    }
-    result[0] = lat2;
-    result[1] = lon2;
-    normLngRAD(result);
-
-    // normalize lat - could flip poles
-    normLatRAD(result);
-    return result;
-  }
-
-  /**
-   * @param latLng The lat/lon, in radians. lat in position 0, lon in position 1
-   */
-  public static void normLatRAD(double[] latLng) {
-
-    if (latLng[0] > DEG_90_AS_RADS) {
-      latLng[0] = DEG_90_AS_RADS - (latLng[0] - DEG_90_AS_RADS);
-      if (latLng[1] < 0) {
-        latLng[1] = latLng[1] + DEG_180_AS_RADS;
-      } else {
-        latLng[1] = latLng[1] - DEG_180_AS_RADS;
-      }
-    } else if (latLng[0] < -DEG_90_AS_RADS) {
-      latLng[0] = -DEG_90_AS_RADS - (latLng[0] + DEG_90_AS_RADS);
-      if (latLng[1] < 0) {
-        latLng[1] = latLng[1] + DEG_180_AS_RADS;
-      } else {
-        latLng[1] = latLng[1] - DEG_180_AS_RADS;
-      }
-    }
-
-  }
-
-  /**
-   * Returns a normalized Lng rectangle shape for the bounding box
-   *
-   * @param latLng The lat/lon, in radians, lat in position 0, lon in position 1
-   */
-  @Deprecated
-  public static void normLngRAD(double[] latLng) {
-    if (latLng[1] > DEG_180_AS_RADS) {
-      latLng[1] = -1.0 * (DEG_180_AS_RADS - (latLng[1] - DEG_180_AS_RADS));
-    } else if (latLng[1] < -DEG_180_AS_RADS) {
-      latLng[1] = (latLng[1] + DEG_180_AS_RADS) + DEG_180_AS_RADS;
-    }
-  }
-
-  /**
-   * Puts in range -180 <= lon_deg < +180.
-   */
-  public static double normLonDEG(double lon_deg) {
-    if (lon_deg >= -180 && lon_deg < 180)
-      return lon_deg;//common case, and avoids slight double precision shifting
-    double off = (lon_deg + 180) % 360;
-    return off < 0 ? 180 + off : -180 + off;
-  }
-
-  /**
-   * Puts in range -90 <= lat_deg <= 90.
-   */
-  public static double normLatDEG(double lat_deg) {
-    if (lat_deg >= -90 && lat_deg <= 90)
-      return lat_deg;//common case, and avoids slight double precision shifting
-    double off = Math.abs((lat_deg + 90) % 360);
-    return (off <= 180 ? off : 360-off) - 90;
-  }
-
-  public static Rectangle calcBoxByDistFromPtDEG(double lat, double lon, double distance, SpatialContext ctx) {
-    //See http://janmatuschek.de/LatitudeLongitudeBoundingCoordinates Section 3.1, 3.2 and 3.3
-
-    double radius = ctx.getUnits().earthRadius();
-    double dist_rad = distance / radius;
-    double dist_deg = Math.toDegrees(dist_rad);
-
-    if (dist_deg == 0)
-      return ctx.makeRect(lon,lon,lat,lat);
-
-    if (dist_deg >= 180)//distance is >= opposite side of the globe
-      return ctx.getWorldBounds();
-
-    //--calc latitude bounds
-    double latN_deg = lat + dist_deg;
-    double latS_deg = lat - dist_deg;
-
-    if (latN_deg >= 90 || latS_deg <= -90) {//touches either pole
-      //we have special logic for longitude
-      double lonW_deg = -180, lonE_deg = 180;//world wrap: 360 deg
-      if (latN_deg <= 90 && latS_deg >= -90) {//doesn't pass either pole: 180 deg
-        lonW_deg = lon -90;
-        lonE_deg = lon +90;
-      }
-      if (latN_deg > 90)
-        latN_deg = 90;
-      if (latS_deg < -90)
-        latS_deg = -90;
-
-      return ctx.makeRect(lonW_deg, lonE_deg, latS_deg, latN_deg);
-    } else {
-      //--calc longitude bounds
-      double lon_delta_deg = calcBoxByDistFromPtVertAxisOffsetDEG(lat, lon, distance, radius);
-
-      double lonW_deg = lon -lon_delta_deg;
-      double lonE_deg = lon +lon_delta_deg;
-
-      return ctx.makeRect(lonW_deg, lonE_deg, latS_deg, latN_deg);//ctx will normalize longitude
-    }
-  }
-
-  public static double calcBoxByDistFromPtVertAxisOffsetDEG(double lat, double lon, double distance, double radius) {
-    //http://gis.stackexchange.com/questions/19221/find-tangent-point-on-circle-furthest-east-or-west
-    if (distance == 0)
-      return 0;
-    double lat_rad = toRadians(lat);
-    double dist_rad = distance / radius;
-    double result_rad = Math.asin(Math.sin(dist_rad) / Math.cos(lat_rad));
-
-    if (!Double.isNaN(result_rad))
-      return Math.toDegrees(result_rad);
-    return 90;
-  }
-
-  public static double calcBoxByDistFromPtHorizAxisDEG(double lat, double lon, double distance, double radius) {
-    //http://gis.stackexchange.com/questions/19221/find-tangent-point-on-circle-furthest-east-or-west
-    if (distance == 0)
-      return lat;
-    double lat_rad = toRadians(lat);
-    double dist_rad = distance / radius;
-    double result_rad = Math.asin( Math.sin(lat_rad) / Math.cos(dist_rad));
-    if (!Double.isNaN(result_rad))
-      return Math.toDegrees(result_rad);
-    //TODO should we use use ctx.getBoundaryNudgeDegrees() offsets here or let caller?
-    if (lat > 0)
-      return 90;
-    if (lat < 0)
-      return -90;
-    return lat;
-  }
-
-  /**
-   * The square of the cartesian Distance.  Not really a distance, but useful if all that matters is
-   * comparing the result to another one.
-   *
-   * @param vec1 The first point
-   * @param vec2 The second point
-   * @return The squared cartesian distance
-   */
-  public static double distSquaredCartesian(double[] vec1, double[] vec2) {
-    double result = 0;
-    for (int i = 0; i < vec1.length; i++) {
-      double v = vec1[i] - vec2[i];
-      result += v * v;
-    }
-    return result;
-  }
-
-  /**
-   *
-   * @param lat1     The y coordinate of the first point, in radians
-   * @param lon1     The x coordinate of the first point, in radians
-   * @param lat2     The y coordinate of the second point, in radians
-   * @param lon2     The x coordinate of the second point, in radians
-   * @return The distance between the two points, as determined by the Haversine formula, in radians.
-   */
-  public static double distHaversineRAD(double lat1, double lon1, double lat2, double lon2) {
-    //TODO investigate slightly different formula using asin() and min() http://www.movable-type.co.uk/scripts/gis-faq-5.1.html
-
-    // Check for same position
-    if (lat1 == lat2 && lon1 == lon2)
-      return 0.0;
-    double hsinX = Math.sin((lon1 - lon2) * 0.5);
-    double hsinY = Math.sin((lat1 - lat2) * 0.5);
-    double h = hsinY * hsinY +
-            (Math.cos(lat1) * Math.cos(lat2) * hsinX * hsinX);
-    return 2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h));
-  }
-
-  /**
-   * Calculates the distance between two lat/lng's using the Law of Cosines. Due to numeric conditioning
-   * errors, it is not as accurate as the Haversine formula for small distances.  But with
-   * double precision, it isn't that bad -- <a href="http://www.movable-type.co.uk/scripts/latlong.html">
-   *   allegedly 1 meter</a>.
-   * <p/>
-   * See <a href="http://gis.stackexchange.com/questions/4906/why-is-law-of-cosines-more-preferable-than-haversine-when-calculating-distance-b">
-   *  Why is law of cosines more preferable than haversine when calculating distance between two latitude-longitude points?</a>
-   * <p/>
-   * The arguments and return value are in radians.
-   */
-  public static double distLawOfCosinesRAD(double lat1, double lon1, double lat2, double lon2) {
-    //TODO validate formula
-
-    //(MIGRATED FROM org.apache.lucene.spatial.geometry.LatLng.arcDistance())
-    // Imported from mq java client.  Variable references changed to match.
-
-    // Check for same position
-    if (lat1 == lat2 && lon1 == lon2)
-      return 0.0;
-
-    // Get the m_dLongitude difference. Don't need to worry about
-    // crossing 180 since cos(x) = cos(-x)
-    double dLon = lon2 - lon1;
-
-    double a = DEG_90_AS_RADS - lat1;
-    double c = DEG_90_AS_RADS - lat2;
-    double cosB = (Math.cos(a) * Math.cos(c))
-        + (Math.sin(a) * Math.sin(c) * Math.cos(dLon));
-
-    // Find angle subtended (with some bounds checking) in radians
-    if (cosB < -1.0)
-      return Math.PI;
-    else if (cosB >= 1.0)
-      return 0;
-    else
-      return Math.acos(cosB);
-  }
-
-  /**
-   * Calculates the great circle distance using the Vincenty Formula, simplified for a spherical model. This formula
-   * is accurate for any pair of points. The equation
-   * was taken from <a href="http://en.wikipedia.org/wiki/Great-circle_distance">Wikipedia</a>.
-   * <p/>
-   * The arguments are in radians, and the result is in radians.
-   */
-  public static double distVincentyRAD(double lat1, double lon1, double lat2, double lon2) {
-    // Check for same position
-    if (lat1 == lat2 && lon1 == lon2)
-      return 0.0;
-
-    double cosLat1 = Math.cos(lat1);
-    double cosLat2 = Math.cos(lat2);
-    double sinLat1 = Math.sin(lat1);
-    double sinLat2 = Math.sin(lat2);
-    double dLon = lon2 - lon1;
-    double cosDLon = Math.cos(dLon);
-    double sinDLon = Math.sin(dLon);
-
-    double a = cosLat2 * sinDLon;
-    double b = cosLat1*sinLat2 - sinLat1*cosLat2*cosDLon;
-    double c = sinLat1*sinLat2 + cosLat1*cosLat2*cosDLon;
-    
-    return Math.atan2(Math.sqrt(a*a+b*b),c);
-  }
-
-  /**
-   * Converts a distance in the units of the radius to degrees (360 degrees are in a circle). A spherical
-   * earth model is assumed.
-   */
-  public static double dist2Degrees(double dist, double radius) {
-    return Math.toDegrees(dist2Radians(dist, radius));
-  }
-
-  /**
-   * Converts a distance in the units of the radius to radians (multiples of the radius). A spherical
-   * earth model is assumed.
-   */
-  public static double dist2Radians(double dist, double radius) {
-    return dist / radius;
-  }
-
-  public static double radians2Dist(double radians, double radius) {
-    return radians * radius;
-  }
-
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/distance/GeodesicSphereDistCalc.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/distance/GeodesicSphereDistCalc.java
deleted file mode 100644
index 304fcc9..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/distance/GeodesicSphereDistCalc.java
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.distance;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-
-import static java.lang.Math.toRadians;
-
-/**
- * A base class for a Distance Calculator that assumes a spherical earth model.
- * @author dsmiley
- */
-public abstract class GeodesicSphereDistCalc extends AbstractDistanceCalculator {
-  protected final double radius;
-
-  public GeodesicSphereDistCalc(double radius) {
-    this.radius = radius;
-  }
-
-  @Override
-  public double distanceToDegrees(double distance) {
-    return DistanceUtils.dist2Degrees(distance, radius);
-  }
-
-  @Override
-  public double degreesToDistance(double degrees) {
-    return DistanceUtils.radians2Dist(toRadians(degrees), radius);
-  }
-
-  @Override
-  public Point pointOnBearing(Point from, double dist, double bearingDEG, SpatialContext ctx) {
-    //TODO avoid unnecessary double[] intermediate object
-    if (dist == 0)
-      return from;
-    double[] latLon = DistanceUtils.pointOnBearingRAD(
-        toRadians(from.getY()), toRadians(from.getX()),
-        DistanceUtils.dist2Radians(dist,ctx.getUnits().earthRadius()),
-        toRadians(bearingDEG), null);
-    return ctx.makePoint(Math.toDegrees(latLon[1]), Math.toDegrees(latLon[0]));
-  }
-
-  @Override
-  public Rectangle calcBoxByDistFromPt(Point from, double distance, SpatialContext ctx) {
-    assert radius == ctx.getUnits().earthRadius();
-    if (distance == 0)
-      return from.getBoundingBox();
-    return DistanceUtils.calcBoxByDistFromPtDEG(from.getY(), from.getX(), distance, ctx);
-  }
-
-  @Override
-  public double calcBoxByDistFromPtHorizAxis(Point from, double distance, SpatialContext ctx) {
-    return DistanceUtils.calcBoxByDistFromPtHorizAxisDEG(from.getY(), from.getX(), distance, radius);
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (this == o) return true;
-    if (o == null || getClass() != o.getClass()) return false;
-
-    GeodesicSphereDistCalc that = (GeodesicSphereDistCalc) o;
-
-    if (Double.compare(that.radius, radius) != 0) return false;
-
-    return true;
-  }
-
-  @Override
-  public int hashCode() {
-    long temp = radius != +0.0d ? Double.doubleToLongBits(radius) : 0L;
-    return (int) (temp ^ (temp >>> 32));
-  }
-
-  @Override
-  public final double distance(Point from, double toX, double toY) {
-    return distanceLatLonRAD(toRadians(from.getY()), toRadians(from.getX()), toRadians(toY), toRadians(toX)) * radius;
-  }
-
-  protected abstract double distanceLatLonRAD(double lat1, double lon1, double lat2, double lon2);
-
-  public static class Haversine extends GeodesicSphereDistCalc {
-
-    public Haversine(double radius) {
-      super(radius);
-    }
-
-    @Override
-    protected double distanceLatLonRAD(double lat1, double lon1, double lat2, double lon2) {
-      return DistanceUtils.distHaversineRAD(lat1,lon1,lat2,lon2);
-    }
-
-  }
-
-  public static class LawOfCosines extends GeodesicSphereDistCalc {
-
-    public LawOfCosines(double radius) {
-      super(radius);
-    }
-
-    @Override
-    protected double distanceLatLonRAD(double lat1, double lon1, double lat2, double lon2) {
-      return DistanceUtils.distLawOfCosinesRAD(lat1, lon1, lat2, lon2);
-    }
-
-  }
-
-  public static class Vincenty extends GeodesicSphereDistCalc {
-    public Vincenty(double radius) {
-      super(radius);
-    }
-
-    @Override
-    protected double distanceLatLonRAD(double lat1, double lon1, double lat2, double lon2) {
-      return DistanceUtils.distVincentyRAD(lat1, lon1, lat2, lon2);
-    }
-  }
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/distance/package-info.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/distance/package-info.java
deleted file mode 100644
index 0a15a97..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/distance/package-info.java
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * Ways to calculate distance
- */
-package org.apache.lucene.spatial.base.distance;
-
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/exception/InvalidShapeException.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/exception/InvalidShapeException.java
deleted file mode 100644
index a8c052d..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/exception/InvalidShapeException.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.exception;
-
-public class InvalidShapeException extends RuntimeException {
-
-  public InvalidShapeException(String reason, Throwable cause) {
-    super(reason, cause);
-  }
-
-  public InvalidShapeException(String reason) {
-    super(reason);
-  }
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/exception/InvalidSpatialArgument.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/exception/InvalidSpatialArgument.java
deleted file mode 100644
index 29dc10e..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/exception/InvalidSpatialArgument.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.exception;
-
-public class InvalidSpatialArgument extends RuntimeException {
-
-  public InvalidSpatialArgument(String reason, Throwable cause) {
-    super(reason, cause);
-  }
-
-  public InvalidSpatialArgument(String reason) {
-    super(reason);
-  }
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/exception/UnsupportedSpatialOperation.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/exception/UnsupportedSpatialOperation.java
deleted file mode 100644
index 74da848..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/exception/UnsupportedSpatialOperation.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.exception;
-
-import org.apache.lucene.spatial.base.query.SpatialOperation;
-
-public class UnsupportedSpatialOperation extends UnsupportedOperationException {
-
-  public UnsupportedSpatialOperation(SpatialOperation op) {
-    super(op.getName());
-  }
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/io/LineReader.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/io/LineReader.java
deleted file mode 100644
index 0bad39a..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/io/LineReader.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.io;
-
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.util.Iterator;
-
-public abstract class LineReader<T> implements Iterator<T> {
-
-  private int count = 0;
-  private int lineNumber = 0;
-  private BufferedReader reader;
-  private String nextLine;
-
-  public abstract T parseLine( String line );
-
-  protected void readComment( String line ) {
-
-  }
-
-  public LineReader(InputStream in) throws IOException {
-    reader = new BufferedReader(
-        new InputStreamReader( in, "UTF-8" ) );
-    next();
-  }
-
-  public LineReader(Reader r) throws IOException {
-    if (r instanceof BufferedReader) {
-      reader = (BufferedReader) r;
-    } else {
-      reader = new BufferedReader(r);
-    }
-    next();
-  }
-
-  public LineReader(File f) throws IOException {
-    reader = new BufferedReader(new InputStreamReader(new FileInputStream(f), "UTF-8"));
-    next();
-  }
-
-  @Override
-  public boolean hasNext() {
-    return nextLine != null;
-  }
-
-  @Override
-  public T next() {
-    T val = null;
-    if (nextLine != null) {
-      val = parseLine(nextLine);
-      count++;
-    }
-
-    if (reader != null) {
-      try {
-        while( reader != null ) {
-          nextLine = reader.readLine();
-          lineNumber++;
-          if (nextLine == null ) {
-            reader.close();
-            reader = null;
-          }
-          else if( nextLine.startsWith( "#" ) ) {
-            readComment( nextLine );
-          }
-          else {
-            nextLine = nextLine.trim();
-            if( nextLine.length() > 0 ) {
-              break;
-            }
-          }
-        }
-      } catch (IOException ioe) {
-        throw new RuntimeException("IOException thrown while reading/closing reader", ioe);
-      }
-    }
-    return val;
-  }
-
-  @Override
-  public void remove() {
-    throw new UnsupportedOperationException();
-  }
-
-  public int getLineNumber() {
-    return lineNumber;
-  }
-
-  public int getCount() {
-    return count;
-  }
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/io/geonames/Geoname.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/io/geonames/Geoname.java
deleted file mode 100644
index cc6d8d6..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/io/geonames/Geoname.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.io.geonames;
-
-import java.sql.Date;
-
-public class Geoname {
-  public int id;
-  public String name; // name of geographical point (utf8) varchar(200)
-  public String nameASCII; // name of geographical point in plain ascii characters, varchar(200)
-  public String[] alternateNames; // alternatenames, comma separated varchar(5000)
-  public double latitude;
-  public double longitude;
-  public char featureClass;
-  public String featureCode; // 10
-  public String countryCode; // 2
-  public String[] countryCode2; // alternate country codes, comma separated, ISO-3166 2-letter country code, 60 characters
-  public String adminCode1; // fipscode (subject to change to iso code), see exceptions below, see file admin1Codes.txt for display names of this code; varchar(20)
-  public String adminCode2; // code for the second administrative division, a county in the US, see file admin2Codes.txt; varchar(80)
-  public String adminCode3; // code for third level administrative division, varchar(20)
-  public String adminCode4; // code for fourth level administrative division, varchar(20)
-  public Long population;
-  public Integer elevation; // in meters, integer
-  public Integer gtopo30;   // average elevation of 30'x30' (ca 900mx900m) area in meters, integer
-  public String timezone;
-  public Date modified;  // date of last modification in yyyy-MM-dd format
-
-  public Geoname(String line) {
-    String[] vals = line.split("\t");
-    id = Integer.parseInt(vals[0]);
-    name = vals[1];
-    nameASCII = vals[2];
-    alternateNames = vals[3].split(",");
-    latitude = Double.parseDouble(vals[4]);
-    longitude = Double.parseDouble(vals[5]);
-    featureClass = vals[6].length() > 0 ? vals[6].charAt(0) : 'S';
-    featureCode = vals[7];
-    countryCode = vals[8];
-    countryCode2 = vals[9].split(",");
-    adminCode1 = vals[10];
-    adminCode2 = vals[11];
-    adminCode3 = vals[12];
-    adminCode4 = vals[13];
-    if (vals[14].length() > 0) {
-      population = Long.decode(vals[14]);
-    }
-    if (vals[15].length() > 0) {
-      elevation = Integer.decode(vals[15]);
-    }
-    if (vals[16].length() > 0) {
-      gtopo30 = Integer.decode(vals[16]);
-    }
-    timezone = vals[17];
-    if (vals[18].length() > 0) {
-      modified = Date.valueOf(vals[18]);
-    }
-  }
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/io/geonames/GeonamesReader.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/io/geonames/GeonamesReader.java
deleted file mode 100644
index 9158d10..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/io/geonames/GeonamesReader.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.io.geonames;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.Reader;
-
-import org.apache.lucene.spatial.base.io.LineReader;
-
-public class GeonamesReader extends LineReader<Geoname> {
-
-  public GeonamesReader(Reader r) throws IOException {
-    super( r );
-  }
-
-  public GeonamesReader(File f) throws IOException {
-    super( f );
-  }
-
-  @Override
-  public Geoname parseLine(String line) {
-    return new Geoname( line );
-  }
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/io/sample/SampleData.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/io/sample/SampleData.java
deleted file mode 100644
index caefe07..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/io/sample/SampleData.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.io.sample;
-
-import java.util.Comparator;
-
-
-public class SampleData {
-  public String id;
-  public String name;
-  public String shape;
-
-  public SampleData(String line) {
-    String[] vals = line.split("\t");
-    id = vals[0];
-    name = vals[1];
-    shape = vals[2];
-  }
-
-  public static Comparator<SampleData> NAME_ORDER = new Comparator<SampleData>() {
-    @Override
-    public int compare(SampleData o1, SampleData o2) {
-      return o1.name.compareTo( o2.name );
-    }
-  };
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/io/sample/SampleDataReader.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/io/sample/SampleDataReader.java
deleted file mode 100644
index 8d79cb7..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/io/sample/SampleDataReader.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.io.sample;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.Reader;
-
-import org.apache.lucene.spatial.base.io.LineReader;
-
-public class SampleDataReader extends LineReader<SampleData> {
-
-  public SampleDataReader(InputStream r) throws IOException {
-    super( r );
-  }
-
-  public SampleDataReader(Reader r) throws IOException {
-    super( r );
-  }
-
-  public SampleDataReader(File f) throws IOException {
-    super( f );
-  }
-
-  @Override
-  public SampleData parseLine(String line) {
-    return new SampleData( line );
-  }
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/package-info.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/package-info.java
deleted file mode 100644
index aa3585f..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/package-info.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * This package is spatal stuff without any lucene dependencies
- * Things implemented in this package could be calculated on the client side
- */
-package org.apache.lucene.spatial.base;
-
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/prefix/Node.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/prefix/Node.java
deleted file mode 100644
index 03a3a9f..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/prefix/Node.java
+++ /dev/null
@@ -1,215 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.prefix;
-
-import org.apache.lucene.spatial.base.shape.SpatialRelation;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.apache.lucene.spatial.base.shape.Shape;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * Represents a grid cell. These are not necessarily threadsafe, although new Cell("") (world cell) must be.
- */
-public abstract class Node implements Comparable<Node> {
-  public static final byte LEAF_BYTE = '+';//NOTE: must sort before letters & numbers
-
-  /*
-  Holds a byte[] and/or String representation of the cell. Both are lazy constructed from the other.
-  Neither contains the trailing leaf byte.
-   */
-  private byte[] bytes;
-  private int b_off;
-  private int b_len;
-
-  private String token;//this is the only part of equality
-
-  protected SpatialRelation shapeRel;//set in getSubCells(filter), and via setLeaf().
-  private SpatialPrefixTree spatialPrefixTree;
-
-  protected Node(SpatialPrefixTree spatialPrefixTree, String token) {
-    this.spatialPrefixTree = spatialPrefixTree;
-    this.token = token;
-    if (token.length() > 0 && token.charAt(token.length() - 1) == (char) LEAF_BYTE) {
-      this.token = token.substring(0, token.length() - 1);
-      setLeaf();
-    }
-
-    if (getLevel() == 0)
-      getShape();//ensure any lazy instantiation completes to make this threadsafe
-  }
-
-  protected Node(SpatialPrefixTree spatialPrefixTree, byte[] bytes, int off, int len) {
-    this.spatialPrefixTree = spatialPrefixTree;
-    this.bytes = bytes;
-    this.b_off = off;
-    this.b_len = len;
-    b_fixLeaf();
-  }
-
-  public void reset(byte[] bytes, int off, int len) {
-    assert getLevel() != 0;
-    token = null;
-    shapeRel = null;
-    this.bytes = bytes;
-    this.b_off = off;
-    this.b_len = len;
-    b_fixLeaf();
-  }
-
-  private void b_fixLeaf() {
-    if (bytes[b_off + b_len - 1] == LEAF_BYTE) {
-      b_len--;
-      setLeaf();
-    } else if (getLevel() == spatialPrefixTree.getMaxLevels()) {
-      setLeaf();
-    }
-  }
-
-  public SpatialRelation getShapeRel() {
-    return shapeRel;
-  }
-
-  public boolean isLeaf() {
-    return shapeRel == SpatialRelation.WITHIN;
-  }
-
-  public void setLeaf() {
-    assert getLevel() != 0;
-    shapeRel = SpatialRelation.WITHIN;
-  }
-
-  /**
-   * Note: doesn't contain a trailing leaf byte.
-   */
-  public String getTokenString() {
-    if (token == null) {
-      token = new String(bytes, b_off, b_len, SpatialPrefixTree.UTF8);
-    }
-    return token;
-  }
-
-  /**
-   * Note: doesn't contain a trailing leaf byte.
-   */
-  public byte[] getTokenBytes() {
-    if (bytes != null) {
-      if (b_off != 0 || b_len != bytes.length) {
-        throw new IllegalStateException("Not supported if byte[] needs to be recreated.");
-      }
-    } else {
-      bytes = token.getBytes(SpatialPrefixTree.UTF8);
-      b_off = 0;
-      b_len = bytes.length;
-    }
-    return bytes;
-  }
-
-  public int getLevel() {
-    return token != null ? token.length() : b_len;
-  }
-
-  //TODO add getParent() and update some algorithms to use this?
-  //public Cell getParent();
-
-  /**
-   * Like {@link #getSubCells()} but with the results filtered by a shape. If that shape is a {@link org.apache.lucene.spatial.base.shape.Point} then it
-   * must call {@link #getSubCell(org.apache.lucene.spatial.base.shape.Point)};
-   * Precondition: Never called when getLevel() == maxLevel.
-   *
-   * @param shapeFilter an optional filter for the returned cells.
-   * @return A set of cells (no dups), sorted. Not Modifiable.
-   */
-  public Collection<Node> getSubCells(Shape shapeFilter) {
-    //Note: Higher-performing subclasses might override to consider the shape filter to generate fewer cells.
-    if (shapeFilter instanceof Point) {
-      return Collections.singleton(getSubCell((Point) shapeFilter));
-    }
-    Collection<Node> cells = getSubCells();
-
-    if (shapeFilter == null) {
-      return cells;
-    }
-    List<Node> copy = new ArrayList<Node>(cells.size());//copy since cells contractually isn't modifiable
-    for (Node cell : cells) {
-      SpatialRelation rel = cell.getShape().relate(shapeFilter, spatialPrefixTree.ctx);
-      if (rel == SpatialRelation.DISJOINT)
-        continue;
-      cell.shapeRel = rel;
-      copy.add(cell);
-    }
-    cells = copy;
-    return cells;
-  }
-
-  /**
-   * Performant implementations are expected to implement this efficiently by considering the current
-   * cell's boundary.
-   * Precondition: Never called when getLevel() == maxLevel.
-   * Precondition: this.getShape().relate(p) != DISJOINT.
-   *
-   * @param p
-   * @return
-   */
-  public abstract Node getSubCell(Point p);
-
-  //TODO Cell getSubCell(byte b)
-
-  /**
-   * Gets the cells at the next grid cell level that cover this cell.
-   * Precondition: Never called when getLevel() == maxLevel.
-   *
-   * @return A set of cells (no dups), sorted. Not Modifiable.
-   */
-  protected abstract Collection<Node> getSubCells();
-
-  /**
-   * {@link #getSubCells()}.size() -- usually a constant. Should be >=2
-   */
-  public abstract int getSubCellsSize();
-
-  public abstract Shape getShape();
-
-  public Point getCenter() {
-    return getShape().getCenter();
-  }
-
-  @Override
-  public int compareTo(Node o) {
-    return getTokenString().compareTo(o.getTokenString());
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    return !(obj == null || !(obj instanceof Node)) && getTokenString().equals(((Node) obj).getTokenString());
-  }
-
-  @Override
-  public int hashCode() {
-    return getTokenString().hashCode();
-  }
-
-  @Override
-  public String toString() {
-    return getTokenString() + (isLeaf() ? (char) LEAF_BYTE : "");
-  }
-
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/prefix/SpatialPrefixTree.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/prefix/SpatialPrefixTree.java
deleted file mode 100644
index 58dbe1c..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/prefix/SpatialPrefixTree.java
+++ /dev/null
@@ -1,246 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.prefix;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.apache.lucene.spatial.base.shape.Shape;
-
-import java.nio.charset.Charset;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * A Spatial Prefix Tree, or Trie, which decomposes shapes into prefixed strings at variable lengths corresponding to
- * variable precision.  Each string corresponds to a spatial region.
- *
- * Implementations of this class should be thread-safe and immutable once initialized.
- */
-public abstract class SpatialPrefixTree {
-
-  protected static final Charset UTF8 = Charset.forName("UTF-8");
-
-  protected final int maxLevels;
-
-  protected final SpatialContext ctx;
-
-  public SpatialPrefixTree(SpatialContext ctx, int maxLevels) {
-    assert maxLevels > 0;
-    this.ctx = ctx;
-    this.maxLevels = maxLevels;
-  }
-
-  public SpatialContext getSpatialContext() {
-    return ctx;
-  }
-
-  public int getMaxLevels() {
-    return maxLevels;
-  }
-
-  @Override
-  public String toString() {
-    return getClass().getSimpleName() + "(maxLevels:" + maxLevels + ",ctx:" + ctx + ")";
-  }
-
-  /**
-   * See {@link org.apache.lucene.spatial.base.query.SpatialArgs#getDistPrecision()}.
-   * A grid level looked up via {@link #getLevelForDistance(double)} is returned.
-   *
-   * @param shape
-   * @param precision 0-0.5
-   * @return 1-maxLevels
-   */
-  public int getMaxLevelForPrecision(Shape shape, double precision) {
-    if (precision < 0 || precision > 0.5) {
-      throw new IllegalArgumentException("Precision " + precision + " must be between [0-0.5]");
-    }
-    if (precision == 0 || shape instanceof Point) {
-      return maxLevels;
-    }
-    double bboxArea = shape.getBoundingBox().getArea();
-    if (bboxArea == 0) {
-      return maxLevels;
-    }
-    double avgSideLenFromCenter = Math.sqrt(bboxArea) / 2;
-    return getLevelForDistance(avgSideLenFromCenter * precision);
-  }
-
-  /**
-   * Returns the level of the smallest grid size with a side length that is greater or equal to the provided
-   * distance.
-   *
-   * @param dist >= 0
-   * @return level [1-maxLevels]
-   */
-  public abstract int getLevelForDistance(double dist);
-
-  //TODO double getDistanceForLevel(int level)
-
-  private transient Node worldNode;//cached
-
-  /**
-   * Returns the level 0 cell which encompasses all spatial data. Equivalent to {@link #getNode(String)} with "".
-   * This cell is threadsafe, just like a spatial prefix grid is, although cells aren't
-   * generally threadsafe.
-   * TODO rename to getTopCell or is this fine?
-   */
-  public Node getWorldNode() {
-    if (worldNode == null) {
-      worldNode = getNode("");
-    }
-    return worldNode;
-  }
-
-  /**
-   * The cell for the specified token. The empty string should be equal to {@link #getWorldNode()}.
-   * Precondition: Never called when token length > maxLevel.
-   */
-  public abstract Node getNode(String token);
-
-  public abstract Node getNode(byte[] bytes, int offset, int len);
-
-  public final Node getNode(byte[] bytes, int offset, int len, Node target) {
-    if (target == null) {
-      return getNode(bytes, offset, len);
-    }
-
-    target.reset(bytes, offset, len);
-    return target;
-  }
-
-  protected Node getNode(Point p, int level) {
-    return getNodes(p, level, false).get(0);
-  }
-
-  /**
-   * Gets the intersecting & including cells for the specified shape, without exceeding detail level.
-   * The result is a set of cells (no dups), sorted. Unmodifiable.
-   * <p/>
-   * This implementation checks if shape is a Point and if so uses an implementation that
-   * recursively calls {@link Node#getSubCell(org.apache.lucene.spatial.base.shape.Point)}. Cell subclasses
-   * ideally implement that method with a quick implementation, otherwise, subclasses should
-   * override this method to invoke {@link #getNodesAltPoint(org.apache.lucene.spatial.base.shape.Point, int, boolean)}.
-   * TODO consider another approach returning an iterator -- won't build up all cells in memory.
-   */
-  public List<Node> getNodes(Shape shape, int detailLevel, boolean inclParents) {
-    if (detailLevel > maxLevels) {
-      throw new IllegalArgumentException("detailLevel > maxLevels");
-    }
-
-    List<Node> cells;
-    if (shape instanceof Point) {
-      //optimized point algorithm
-      final int initialCapacity = inclParents ? 1 + detailLevel : 1;
-      cells = new ArrayList<Node>(initialCapacity);
-      recursiveGetNodes(getWorldNode(), (Point) shape, detailLevel, true, cells);
-      assert cells.size() == initialCapacity;
-    } else {
-      cells = new ArrayList<Node>(inclParents ? 1024 : 512);
-      recursiveGetNodes(getWorldNode(), shape, detailLevel, inclParents, cells);
-    }
-    if (inclParents) {
-      Node c = cells.remove(0);//remove getWorldNode()
-      assert c.getLevel() == 0;
-    }
-    return cells;
-  }
-
-  private void recursiveGetNodes(Node node, Shape shape, int detailLevel, boolean inclParents,
-                                 Collection<Node> result) {
-    if (node.isLeaf()) {//cell is within shape
-      result.add(node);
-      return;
-    }
-    final Collection<Node> subCells = node.getSubCells(shape);
-    if (node.getLevel() == detailLevel - 1) {
-      if (subCells.size() < node.getSubCellsSize()) {
-        if (inclParents)
-          result.add(node);
-        for (Node subCell : subCells) {
-          subCell.setLeaf();
-        }
-        result.addAll(subCells);
-      } else {//a bottom level (i.e. detail level) optimization where all boxes intersect, so use parent cell.
-        node.setLeaf();
-        result.add(node);
-      }
-    } else {
-      if (inclParents) {
-        result.add(node);
-      }
-      for (Node subCell : subCells) {
-        recursiveGetNodes(subCell, shape, detailLevel, inclParents, result);//tail call
-      }
-    }
-  }
-
-  private void recursiveGetNodes(Node node, Point point, int detailLevel, boolean inclParents,
-                                 Collection<Node> result) {
-    if (inclParents) {
-      result.add(node);
-    }
-    final Node pCell = node.getSubCell(point);
-    if (node.getLevel() == detailLevel - 1) {
-      pCell.setLeaf();
-      result.add(pCell);
-    } else {
-      recursiveGetNodes(pCell, point, detailLevel, inclParents, result);//tail call
-    }
-  }
-
-  /**
-   * Subclasses might override {@link #getNodes(org.apache.lucene.spatial.base.shape.Shape, int, boolean)}
-   * and check if the argument is a shape and if so, delegate
-   * to this implementation, which calls {@link #getNode(org.apache.lucene.spatial.base.shape.Point, int)} and
-   * then calls {@link #getNode(String)} repeatedly if inclParents is true.
-   */
-  protected final List<Node> getNodesAltPoint(Point p, int detailLevel, boolean inclParents) {
-    Node cell = getNode(p, detailLevel);
-    if (!inclParents) {
-      return Collections.singletonList(cell);
-    }
-
-    String endToken = cell.getTokenString();
-    assert endToken.length() == detailLevel;
-    List<Node> cells = new ArrayList<Node>(detailLevel);
-    for (int i = 1; i < detailLevel; i++) {
-      cells.add(getNode(endToken.substring(0, i)));
-    }
-    cells.add(cell);
-    return cells;
-  }
-
-  /**
-   * Will add the trailing leaf byte for leaves. This isn't particularly efficient.
-   */
-  public static List<String> nodesToTokenStrings(Collection<Node> nodes) {
-    List<String> tokens = new ArrayList<String>((nodes.size()));
-    for (Node node : nodes) {
-      final String token = node.getTokenString();
-      if (node.isLeaf()) {
-        tokens.add(token + (char) Node.LEAF_BYTE);
-      } else {
-        tokens.add(token);
-      }
-    }
-    return tokens;
-  }
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/prefix/SpatialPrefixTreeFactory.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/prefix/SpatialPrefixTreeFactory.java
deleted file mode 100644
index 56c6b42..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/prefix/SpatialPrefixTreeFactory.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.prefix;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.distance.DistanceUnits;
-import org.apache.lucene.spatial.base.distance.DistanceUtils;
-import org.apache.lucene.spatial.base.prefix.geohash.GeohashPrefixTree;
-import org.apache.lucene.spatial.base.prefix.quad.QuadPrefixTree;
-
-import java.util.Map;
-
-/**
- * @author dsmiley
- */
-public abstract class SpatialPrefixTreeFactory {
-
-  private static final double DEFAULT_GEO_MAX_DETAIL_KM = 0.001;//1m
-
-  protected Map<String, String> args;
-  protected SpatialContext ctx;
-  protected Integer maxLevels;
-
-  /**
-   * The factory  is looked up via "prefixTree" in args, expecting "geohash" or "quad".
-   * If its neither of these, then "geohash" is chosen for a geo context, otherwise "quad" is chosen.
-   */
-  public static SpatialPrefixTree makeSPT(Map<String,String> args, ClassLoader classLoader, SpatialContext ctx) {
-    SpatialPrefixTreeFactory instance;
-    String cname = args.get("prefixTree");
-    if (cname == null)
-      cname = ctx.isGeo() ? "geohash" : "quad";
-    if ("geohash".equalsIgnoreCase(cname))
-      instance = new GeohashPrefixTree.Factory();
-    else if ("quad".equalsIgnoreCase(cname))
-      instance = new QuadPrefixTree.Factory();
-    else {
-      try {
-        Class c = classLoader.loadClass(cname);
-        instance = (SpatialPrefixTreeFactory) c.newInstance();
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
-    }
-    instance.init(args,ctx);
-    return instance.newSPT();
-  }
-
-  protected void init(Map<String, String> args, SpatialContext ctx) {
-    this.args = args;
-    this.ctx = ctx;
-    initMaxLevels();
-  }
-
-  protected void initMaxLevels() {
-    String mlStr = args.get("maxLevels");
-    if (mlStr != null) {
-      maxLevels = Integer.valueOf(mlStr);
-      return;
-    }
-
-    double degrees;
-    String maxDetailDistStr = args.get("maxDetailDist");
-    if (maxDetailDistStr == null) {
-      if (!ctx.isGeo()) {
-        return;//let default to max
-      }
-      degrees = DistanceUtils.dist2Degrees(DEFAULT_GEO_MAX_DETAIL_KM, DistanceUnits.KILOMETERS.earthRadius());
-    } else {
-      degrees = DistanceUtils.dist2Degrees(Double.parseDouble(maxDetailDistStr), ctx.getUnits().earthRadius());
-    }
-    maxLevels = getLevelForDistance(degrees) + 1;//returns 1 greater
-  }
-
-  /** Calls {@link SpatialPrefixTree#getLevelForDistance(double)}. */
-  protected abstract int getLevelForDistance(double degrees);
-
-  protected abstract SpatialPrefixTree newSPT();
-
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/prefix/geohash/GeohashPrefixTree.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/prefix/geohash/GeohashPrefixTree.java
deleted file mode 100644
index 1f96c2c..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/prefix/geohash/GeohashPrefixTree.java
+++ /dev/null
@@ -1,150 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.prefix.geohash;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.prefix.Node;
-import org.apache.lucene.spatial.base.prefix.SpatialPrefixTree;
-import org.apache.lucene.spatial.base.prefix.SpatialPrefixTreeFactory;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-import org.apache.lucene.spatial.base.shape.Shape;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-/**
- * A SpatialPrefixGrid based on Geohashes.  Uses {@link GeohashUtils} to do all the geohash work.
- */
-public class GeohashPrefixTree extends SpatialPrefixTree {
-
-  public static class Factory extends SpatialPrefixTreeFactory {
-
-    @Override
-    protected int getLevelForDistance(double degrees) {
-      GeohashPrefixTree grid = new GeohashPrefixTree(ctx, GeohashPrefixTree.getMaxLevelsPossible());
-      return grid.getLevelForDistance(degrees) + 1;//returns 1 greater
-    }
-
-    @Override
-    protected SpatialPrefixTree newSPT() {
-      return new GeohashPrefixTree(ctx,
-          maxLevels != null ? maxLevels : GeohashPrefixTree.getMaxLevelsPossible());
-    }
-  }
-
-  public GeohashPrefixTree(SpatialContext ctx, int maxLevels) {
-    super(ctx, maxLevels);
-    Rectangle bounds = ctx.getWorldBounds();
-    if (bounds.getMinX() != -180)
-      throw new IllegalArgumentException("Geohash only supports lat-lon world bounds. Got "+bounds);
-    int MAXP = getMaxLevelsPossible();
-    if (maxLevels <= 0 || maxLevels > MAXP)
-      throw new IllegalArgumentException("maxLen must be [1-"+MAXP+"] but got "+ maxLevels);
-  }
-
-  /** Any more than this and there's no point (double lat & lon are the same). */
-  public static int getMaxLevelsPossible() {
-    return GeohashUtils.MAX_PRECISION;
-  }
-
-  @Override
-  public int getLevelForDistance(double dist) {
-    final int level = GeohashUtils.lookupHashLenForWidthHeight(dist, dist);
-    return Math.max(Math.min(level, maxLevels), 1);
-  }
-
-  @Override
-  public Node getNode(Point p, int level) {
-    return new GhCell(GeohashUtils.encodeLatLon(p.getY(), p.getX(), level));//args are lat,lon (y,x)
-  }
-
-  @Override
-  public Node getNode(String token) {
-    return new GhCell(token);
-  }
-
-  @Override
-  public Node getNode(byte[] bytes, int offset, int len) {
-    return new GhCell(bytes, offset, len);
-  }
-
-  @Override
-  public List<Node> getNodes(Shape shape, int detailLevel, boolean inclParents) {
-    return shape instanceof Point ? super.getNodesAltPoint((Point) shape, detailLevel, inclParents) :
-        super.getNodes(shape, detailLevel, inclParents);
-  }
-
-  class GhCell extends Node {
-    GhCell(String token) {
-      super(GeohashPrefixTree.this, token);
-    }
-
-    GhCell(byte[] bytes, int off, int len) {
-      super(GeohashPrefixTree.this, bytes, off, len);
-    }
-
-    @Override
-    public void reset(byte[] bytes, int off, int len) {
-      super.reset(bytes, off, len);
-      shape = null;
-    }
-
-    @Override
-    public Collection<Node> getSubCells() {
-      String[] hashes = GeohashUtils.getSubGeohashes(getGeohash());//sorted
-      List<Node> cells = new ArrayList<Node>(hashes.length);
-      for (String hash : hashes) {
-        cells.add(new GhCell(hash));
-      }
-      return cells;
-    }
-
-    @Override
-    public int getSubCellsSize() {
-      return 32;//8x4
-    }
-
-    @Override
-    public Node getSubCell(Point p) {
-      return GeohashPrefixTree.this.getNode(p,getLevel()+1);//not performant!
-    }
-
-    private Shape shape;//cache
-
-    @Override
-    public Shape getShape() {
-      if (shape == null) {
-        shape = GeohashUtils.decodeBoundary(getGeohash(), ctx);
-      }
-      return shape;
-    }
-
-    @Override
-    public Point getCenter() {
-      return GeohashUtils.decode(getGeohash(), ctx);
-    }
-
-    private String getGeohash() {
-      return getTokenString();
-    }
-
-  }//class GhCell
-
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/prefix/geohash/GeohashUtils.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/prefix/geohash/GeohashUtils.java
deleted file mode 100644
index 15fed96..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/prefix/geohash/GeohashUtils.java
+++ /dev/null
@@ -1,196 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.prefix.geohash;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-import org.apache.lucene.spatial.base.shape.Point;
-
-import java.util.Arrays;
-
-/**
- * Utilities for encoding and decoding geohashes. Based on
- * <a href="http://en.wikipedia.org/wiki/Geohash">http://en.wikipedia.org/wiki/Geohash</a>.
- */
-public class GeohashUtils {
-
-  private static final char[] BASE_32 = {'0', '1', '2', '3', '4', '5', '6',
-      '7', '8', '9', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'j', 'k', 'm', 'n',
-      'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};//note: this is sorted
-
-  private static final int[] BASE_32_IDX;//sparse array of indexes from '0' to 'z'
-
-  public static final int MAX_PRECISION = 24;//DWS: I forget what level results in needless more precision but it's about this
-  private static final int[] BITS = {16, 8, 4, 2, 1};
-
-  static {
-    BASE_32_IDX = new int[BASE_32[BASE_32.length-1] - BASE_32[0] + 1];
-    assert BASE_32_IDX.length < 100;//reasonable length
-    Arrays.fill(BASE_32_IDX,-500);
-    for (int i = 0; i < BASE_32.length; i++) {
-      BASE_32_IDX[BASE_32[i] - BASE_32[0]] = i;
-    }
-  }
-
-  private GeohashUtils() {
-  }
-
-  /**
-   * Encodes the given latitude and longitude into a geohash
-   *
-   * @param latitude Latitude to encode
-   * @param longitude Longitude to encode
-   * @return Geohash encoding of the longitude and latitude
-   */
-  public static String encodeLatLon(double latitude, double longitude) {
-    return encodeLatLon(latitude, longitude, 12);
-  }
-
-  public static String encodeLatLon(double latitude, double longitude, int precision) {
-    double[] latInterval = {-90.0, 90.0};
-    double[] lngInterval = {-180.0, 180.0};
-
-    final StringBuilder geohash = new StringBuilder(precision);
-    boolean isEven = true;
-
-    int bit = 0;
-    int ch = 0;
-
-    while (geohash.length() < precision) {
-      double mid = 0.0;
-      if (isEven) {
-        mid = (lngInterval[0] + lngInterval[1]) / 2D;
-        if (longitude > mid) {
-          ch |= BITS[bit];
-          lngInterval[0] = mid;
-        } else {
-          lngInterval[1] = mid;
-        }
-      } else {
-        mid = (latInterval[0] + latInterval[1]) / 2D;
-        if (latitude > mid) {
-          ch |= BITS[bit];
-          latInterval[0] = mid;
-        } else {
-          latInterval[1] = mid;
-        }
-      }
-
-      isEven = !isEven;
-
-      if (bit < 4) {
-        bit++;
-      } else {
-        geohash.append(BASE_32[ch]);
-        bit = 0;
-        ch = 0;
-      }
-    }
-
-    return geohash.toString();
-  }
-
-  /**
-   * Decodes the given geohash into a latitude and longitude
-   *
-   * @param geohash Geohash to deocde
-   * @return Array with the latitude at index 0, and longitude at index 1
-   */
-  public static Point decode(String geohash, SpatialContext ctx) {
-    Rectangle rect = decodeBoundary(geohash,ctx);
-    double latitude = (rect.getMinY() + rect.getMaxY()) / 2D;
-    double longitude = (rect.getMinX() + rect.getMaxX()) / 2D;
-    return ctx.makePoint(longitude,latitude);
-	}
-
-  /** Returns min-max lat, min-max lon. */
-  public static Rectangle decodeBoundary(String geohash, SpatialContext ctx) {
-    double minY = -90, maxY = 90, minX = -180, maxX = 180;
-    boolean isEven = true;
-
-    for (int i = 0; i < geohash.length(); i++) {
-      char c = geohash.charAt(i);
-      if (c >= 'A' && c <= 'Z')
-        c -= ('A' - 'a');
-      final int cd = BASE_32_IDX[c - BASE_32[0]];//TODO check successful?
-
-      for (int mask : BITS) {
-        if (isEven) {
-          if ((cd & mask) != 0) {
-            minX = (minX + maxX) / 2D;
-          } else {
-            maxX = (minX + maxX) / 2D;
-          }
-        } else {
-          if ((cd & mask) != 0) {
-            minY = (minY + maxY) / 2D;
-          } else {
-            maxY = (minY + maxY) / 2D;
-          }
-        }
-        isEven = !isEven;
-      }
-
-    }
-    return ctx.makeRect(minX, maxX, minY, maxY);
-  }
-
-  /** Array of geohashes 1 level below the baseGeohash. Sorted. */
-  public static String[] getSubGeohashes(String baseGeohash) {
-    String[] hashes = new String[BASE_32.length];
-    for (int i = 0; i < BASE_32.length; i++) {//note: already sorted
-      char c = BASE_32[i];
-      hashes[i] = baseGeohash+c;
-    }
-    return hashes;
-  }
-
-  public static double[] lookupDegreesSizeForHashLen(int hashLen) {
-    return new double[]{hashLenToLatHeight[hashLen], hashLenToLonWidth[hashLen]};
-  }
-
-  /**
-   * Return the longest geohash length that will have a width & height >= specified arguments.
-   */
-  public static int lookupHashLenForWidthHeight(double width, double height) {
-    //loop through hash length arrays from beginning till we find one.
-    for(int len = 1; len <= MAX_PRECISION; len++) {
-      double latHeight = hashLenToLatHeight[len];
-      double lonWidth = hashLenToLonWidth[len];
-      if (latHeight < height || lonWidth < width)
-        return len-1;//previous length is big enough to encompass specified width & height
-    }
-    return MAX_PRECISION;
-  }
-
-  /** See the table at http://en.wikipedia.org/wiki/Geohash */
-  private static final double[] hashLenToLatHeight, hashLenToLonWidth;
-  static {
-    hashLenToLatHeight = new double[MAX_PRECISION +1];
-    hashLenToLonWidth = new double[MAX_PRECISION +1];
-    hashLenToLatHeight[0] = 90*2;
-    hashLenToLonWidth[0] = 180*2;
-    boolean even = false;
-    for(int i = 1; i <= MAX_PRECISION; i++) {
-      hashLenToLatHeight[i] = hashLenToLatHeight[i-1]/(even?8:4);
-      hashLenToLonWidth[i] = hashLenToLonWidth[i-1]/(even?4:8);
-      even = ! even;
-    }
-  }
-
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/prefix/package-info.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/prefix/package-info.java
deleted file mode 100644
index 6b156d3..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/prefix/package-info.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * The Spatial Prefix package supports spatial indexing by index-time tokens
- * where adding characters to a string gives greater resolution.
- *
- * Potential Implementations include:
- *  * http://en.wikipedia.org/wiki/Quadtree
- *  * http://en.wikipedia.org/wiki/Geohash
- *  * http://healpix.jpl.nasa.gov/
- */
-package org.apache.lucene.spatial.base.prefix;
-
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/prefix/quad/QuadPrefixTree.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/prefix/quad/QuadPrefixTree.java
deleted file mode 100644
index a1ea653..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/prefix/quad/QuadPrefixTree.java
+++ /dev/null
@@ -1,301 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.prefix.quad;
-
-import org.apache.lucene.spatial.base.prefix.SpatialPrefixTreeFactory;
-import org.apache.lucene.spatial.base.shape.SpatialRelation;
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.prefix.Node;
-import org.apache.lucene.spatial.base.prefix.SpatialPrefixTree;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-import org.apache.lucene.spatial.base.shape.Shape;
-import org.apache.lucene.spatial.base.shape.simple.PointImpl;
-
-import java.text.NumberFormat;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-public class QuadPrefixTree extends SpatialPrefixTree {
-
-  public static class Factory extends SpatialPrefixTreeFactory {
-
-    @Override
-    protected int getLevelForDistance(double degrees) {
-      QuadPrefixTree grid = new QuadPrefixTree(ctx, MAX_LEVELS_POSSIBLE);
-      return grid.getLevelForDistance(degrees) + 1;//returns 1 greater
-    }
-
-    @Override
-    protected SpatialPrefixTree newSPT() {
-      return new QuadPrefixTree(ctx,
-          maxLevels != null ? maxLevels : MAX_LEVELS_POSSIBLE);
-    }
-  }
-
-  public static final int MAX_LEVELS_POSSIBLE = 50;//not really sure how big this should be
-
-  public static final int DEFAULT_MAX_LEVELS = 12;
-  private final double xmin;
-  private final double xmax;
-  private final double ymin;
-  private final double ymax;
-  private final double xmid;
-  private final double ymid;
-
-  private final double gridW;
-  public final double gridH;
-
-  final double[] levelW;
-  final double[] levelH;
-  final int[]    levelS; // side
-  final int[]    levelN; // number
-
-  public QuadPrefixTree(
-      SpatialContext ctx, Rectangle bounds, int maxLevels) {
-    super(ctx, maxLevels);
-    this.xmin = bounds.getMinX();
-    this.xmax = bounds.getMaxX();
-    this.ymin = bounds.getMinY();
-    this.ymax = bounds.getMaxY();
-
-    levelW = new double[maxLevels];
-    levelH = new double[maxLevels];
-    levelS = new int[maxLevels];
-    levelN = new int[maxLevels];
-
-    gridW = xmax - xmin;
-    gridH = ymax - ymin;
-    this.xmid = xmin + gridW/2.0;
-    this.ymid = ymin + gridH/2.0;
-    levelW[0] = gridW/2.0;
-    levelH[0] = gridH/2.0;
-    levelS[0] = 2;
-    levelN[0] = 4;
-
-    for (int i = 1; i < levelW.length; i++) {
-      levelW[i] = levelW[i - 1] / 2.0;
-      levelH[i] = levelH[i - 1] / 2.0;
-      levelS[i] = levelS[i - 1] * 2;
-      levelN[i] = levelN[i - 1] * 4;
-    }
-  }
-
-  public QuadPrefixTree(SpatialContext ctx) {
-    this(ctx, DEFAULT_MAX_LEVELS);
-  }
-
-  public QuadPrefixTree(
-      SpatialContext ctx, int maxLevels) {
-    this(ctx, ctx.getWorldBounds(), maxLevels);
-  }
-
-  public void printInfo() {
-    NumberFormat nf = NumberFormat.getNumberInstance();
-    nf.setMaximumFractionDigits(5);
-    nf.setMinimumFractionDigits(5);
-    nf.setMinimumIntegerDigits(3);
-
-    for (int i = 0; i < maxLevels; i++) {
-      System.out.println(i + "]\t" + nf.format(levelW[i]) + "\t" + nf.format(levelH[i]) + "\t" +
-          levelS[i] + "\t" + (levelS[i] * levelS[i]));
-    }
-  }
-
-  @Override
-  public int getLevelForDistance(double dist) {
-    for (int i = 1; i < maxLevels; i++) {
-      //note: level[i] is actually a lookup for level i+1
-      if(dist > levelW[i] || dist > levelH[i]) {
-        return i;
-      }
-    }
-    return maxLevels;
-  }
-
-  @Override
-  public Node getNode(Point p, int level) {
-    List<Node> cells = new ArrayList<Node>(1);
-    build(xmid, ymid, 0, cells, new StringBuilder(), new PointImpl(p.getX(),p.getY()), level);
-    return cells.get(0);//note cells could be longer if p on edge
-  }
-
-  @Override
-  public Node getNode(String token) {
-    return new QuadCell(token);
-  }
-
-  @Override
-  public Node getNode(byte[] bytes, int offset, int len) {
-    return new QuadCell(bytes, offset, len);
-  }
-
-  @Override //for performance
-  public List<Node> getNodes(Shape shape, int detailLevel, boolean inclParents) {
-    if (shape instanceof Point)
-      return super.getNodesAltPoint((Point) shape, detailLevel, inclParents);
-    else
-      return super.getNodes(shape, detailLevel, inclParents);
-  }
-
-  private void build(
-      double x,
-      double y,
-      int level,
-      List<Node> matches,
-      StringBuilder str,
-      Shape shape,
-      int maxLevel) {
-    assert str.length() == level;
-    double w = levelW[level] / 2;
-    double h = levelH[level] / 2;
-
-    // Z-Order
-    // http://en.wikipedia.org/wiki/Z-order_%28curve%29
-    checkBattenberg('A', x - w, y + h, level, matches, str, shape, maxLevel);
-    checkBattenberg('B', x + w, y + h, level, matches, str, shape, maxLevel);
-    checkBattenberg('C', x - w, y - h, level, matches, str, shape, maxLevel);
-    checkBattenberg('D', x + w, y - h, level, matches, str, shape, maxLevel);
-
-    // possibly consider hilbert curve
-    // http://en.wikipedia.org/wiki/Hilbert_curve
-    // http://blog.notdot.net/2009/11/Damn-Cool-Algorithms-Spatial-indexing-with-Quadtrees-and-Hilbert-Curves
-    // if we actually use the range property in the query, this could be useful
-  }
-
-  private void checkBattenberg(
-      char c,
-      double cx,
-      double cy,
-      int level,
-      List<Node> matches,
-      StringBuilder str,
-      Shape shape,
-      int maxLevel) {
-    assert str.length() == level;
-    double w = levelW[level] / 2;
-    double h = levelH[level] / 2;
-
-    int strlen = str.length();
-    Rectangle rectangle = ctx.makeRect(cx - w, cx + w, cy - h, cy + h);
-    SpatialRelation v = shape.relate(rectangle, ctx);
-    if (SpatialRelation.CONTAINS == v) {
-      str.append(c);
-      //str.append(SpatialPrefixGrid.COVER);
-      matches.add(new QuadCell(str.toString(),v.transpose()));
-    } else if (SpatialRelation.DISJOINT == v) {
-      // nothing
-    } else { // SpatialRelation.WITHIN, SpatialRelation.INTERSECTS
-      str.append(c);
-
-      int nextLevel = level+1;
-      if (nextLevel >= maxLevel) {
-        //str.append(SpatialPrefixGrid.INTERSECTS);
-        matches.add(new QuadCell(str.toString(),v.transpose()));
-      } else {
-        build(cx, cy, nextLevel, matches, str, shape, maxLevel);
-      }
-    }
-    str.setLength(strlen);
-  }
-
-  class QuadCell extends Node {
-
-    public QuadCell(String token) {
-      super(QuadPrefixTree.this, token);
-    }
-
-    public QuadCell(String token, SpatialRelation shapeRel) {
-      super(QuadPrefixTree.this, token);
-      this.shapeRel = shapeRel;
-    }
-
-    QuadCell(byte[] bytes, int off, int len) {
-      super(QuadPrefixTree.this, bytes, off, len);
-    }
-
-    @Override
-    public void reset(byte[] bytes, int off, int len) {
-      super.reset(bytes, off, len);
-      shape = null;
-    }
-
-    @Override
-    public Collection<Node> getSubCells() {
-      List<Node> cells = new ArrayList<Node>(4);
-      cells.add(new QuadCell(getTokenString()+"A"));
-      cells.add(new QuadCell(getTokenString()+"B"));
-      cells.add(new QuadCell(getTokenString()+"C"));
-      cells.add(new QuadCell(getTokenString()+"D"));
-      return cells;
-    }
-
-    @Override
-    public int getSubCellsSize() {
-      return 4;
-    }
-
-    @Override
-    public Node getSubCell(Point p) {
-      return QuadPrefixTree.this.getNode(p,getLevel()+1);//not performant!
-    }
-
-    private Shape shape;//cache
-
-    @Override
-    public Shape getShape() {
-      if (shape == null)
-        shape = makeShape();
-      return shape;
-    }
-
-    private Rectangle makeShape() {
-      String token = getTokenString();
-      double xmin = QuadPrefixTree.this.xmin;
-      double ymin = QuadPrefixTree.this.ymin;
-
-      for (int i = 0; i < token.length(); i++) {
-        char c = token.charAt(i);
-        if ('A' == c || 'a' == c) {
-          ymin += levelH[i];
-        } else if ('B' == c || 'b' == c) {
-          xmin += levelW[i];
-          ymin += levelH[i];
-        } else if ('C' == c || 'c' == c) {
-          // nothing really
-        }
-        else if('D' == c || 'd' == c) {
-          xmin += levelW[i];
-        } else {
-          throw new RuntimeException("unexpected char: " + c);
-        }
-      }
-      int len = token.length();
-      double width, height;
-      if (len > 0) {
-        width = levelW[len-1];
-        height = levelH[len-1];
-      } else {
-        width = gridW;
-        height = gridH;
-      }
-      return ctx.makeRect(xmin, xmin + width, ymin, ymin + height);
-    }
-  }//QuadCell
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/query/SpatialArgs.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/query/SpatialArgs.java
deleted file mode 100644
index c559358..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/query/SpatialArgs.java
+++ /dev/null
@@ -1,134 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.query;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.context.simple.SimpleSpatialContext;
-import org.apache.lucene.spatial.base.distance.DistanceUnits;
-import org.apache.lucene.spatial.base.exception.InvalidSpatialArgument;
-import org.apache.lucene.spatial.base.shape.Shape;
-
-public class SpatialArgs {
-
-  public static final double DEFAULT_DIST_PRECISION = 0.025d;
-
-  private SpatialOperation operation;
-  private Shape shape;
-  private double distPrecision = DEFAULT_DIST_PRECISION;
-
-  // Useful for 'distance' calculations
-  private Double min;
-  private Double max;
-
-  public SpatialArgs(SpatialOperation operation) {
-    this.operation = operation;
-  }
-
-  public SpatialArgs(SpatialOperation operation, Shape shape) {
-    this.operation = operation;
-    this.shape = shape;
-  }
-
-  /**
-   * Check if the arguments make sense -- throw an exception if not
-   */
-  public void validate() throws InvalidSpatialArgument {
-    if (operation.isTargetNeedsArea() && !shape.hasArea()) {
-      throw new InvalidSpatialArgument(operation + " only supports geometry with area");
-    }
-  }
-
-  public String toString( SpatialContext context ) {
-    StringBuilder str = new StringBuilder();
-    str.append( operation.getName() ).append( '(' );
-    str.append( context.toString( shape ) );
-    if( min != null ) {
-      str.append(" min=").append(min);
-    }
-    if( max != null ) {
-      str.append(" max=").append(max);
-    }
-    str.append(" distPrec=").append(String.format("%.2f%%", distPrecision/100d));
-    str.append( ')' );
-    return str.toString();
-  }
-
-  @Override
-  public String toString()
-  {
-    return toString( new SimpleSpatialContext(DistanceUnits.KILOMETERS) );
-  }
-
-  //------------------------------------------------
-  // Getters & Setters
-  //------------------------------------------------
-
-  public SpatialOperation getOperation() {
-    return operation;
-  }
-
-  public void setOperation(SpatialOperation operation) {
-    this.operation = operation;
-  }
-
-  /**
-   * Considers {@link SpatialOperation#BBoxWithin} in returning the shape.
-   * @return
-   */
-  public Shape getShape() {
-    if (shape != null && (operation == SpatialOperation.BBoxWithin || operation == SpatialOperation.BBoxIntersects))
-      return shape.getBoundingBox();
-    return shape;
-  }
-
-  public void setShape(Shape shape) {
-    this.shape = shape;
-  }
-
-  /**
-   * The fraction of the distance from the center of the query shape to its nearest edge that is considered acceptable
-   * error. The algorithm for computing the distance to the nearest edge is actually a little different. It normalizes
-   * the shape to a square given it's bounding box area:
-   * <pre>sqrt(shape.bbox.area)/2</pre>
-   * And the error distance is beyond the shape such that the shape is a minimum shape.
-   */
-  public Double getDistPrecision() {
-    return distPrecision;
-  }
-
-  public void setDistPrecision(Double distPrecision) {
-    if (distPrecision != null)
-      this.distPrecision = distPrecision;
-  }
-
-  public Double getMin() {
-    return min;
-  }
-
-  public void setMin(Double min) {
-    this.min = min;
-  }
-
-  public Double getMax() {
-    return max;
-  }
-
-  public void setMax(Double max) {
-    this.max = max;
-  }
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/query/SpatialArgsParser.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/query/SpatialArgsParser.java
deleted file mode 100644
index 961dd25..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/query/SpatialArgsParser.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.query;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.exception.InvalidShapeException;
-import org.apache.lucene.spatial.base.exception.InvalidSpatialArgument;
-import org.apache.lucene.spatial.base.shape.Shape;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.StringTokenizer;
-
-public class SpatialArgsParser
-{
-  public SpatialArgs parse(String v, SpatialContext ctx) throws InvalidSpatialArgument, InvalidShapeException {
-    int idx = v.indexOf('(');
-    int edx = v.lastIndexOf(')');
-
-    if (idx < 0 || idx > edx) {
-      throw new InvalidSpatialArgument("missing parens: " + v, null);
-    }
-
-    SpatialOperation op = SpatialOperation.get(v.substring(0, idx).trim());
-
-    String body = v.substring(idx + 1, edx).trim();
-    if (body.length() < 1) {
-      throw new InvalidSpatialArgument("missing body : " + v, null);
-    }
-
-    Shape shape = ctx.readShape(body);
-    SpatialArgs args = new SpatialArgs(op,shape);
-
-    if (v.length() > (edx + 1)) {
-      body = v.substring( edx+1 ).trim();
-      if (body.length() > 0) {
-        Map<String,String> aa = parseMap(body);
-        args.setMin(readDouble(aa.remove("min")) );
-        args.setMax(readDouble(aa.remove("max")));
-        args.setDistPrecision(readDouble(aa.remove("distPrec")));
-        if (!aa.isEmpty()) {
-          throw new InvalidSpatialArgument("unused parameters: " + aa, null);
-        }
-      }
-    }
-    return args;
-  }
-
-  protected static Double readDouble(String v) {
-      return v == null ? null : Double.valueOf(v);
-  }
-
-  protected static boolean readBool(String v, boolean defaultValue) {
-      return v == null ? defaultValue : Boolean.parseBoolean(v);
-  }
-
-  protected static Map<String,String> parseMap(String body) {
-    Map<String,String> map = new HashMap<String,String>();
-    StringTokenizer st = new StringTokenizer(body, " \n\t");
-    while (st.hasMoreTokens()) {
-      String a = st.nextToken();
-      int idx = a.indexOf('=');
-      if (idx > 0) {
-        String k = a.substring(0, idx);
-        String v = a.substring(idx + 1);
-        map.put(k, v);
-      } else {
-        map.put(a, a);
-      }
-    }
-    return map;
-  }
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/query/SpatialOperation.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/query/SpatialOperation.java
deleted file mode 100644
index b4be743..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/query/SpatialOperation.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/* See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * Esri Inc. licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.spatial.base.query;
-
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-
-import org.apache.lucene.spatial.base.exception.InvalidSpatialArgument;
-
-/**
- * A clause that compares a stored geometry to a supplied geometry.
- */
-public class SpatialOperation implements Serializable {
-  // Private registry
-  private static final Map<String, SpatialOperation> registry = new HashMap<String, SpatialOperation>();
-  private static final List<SpatialOperation> list = new ArrayList<SpatialOperation>();
-
-  // Geometry Operations
-  public static final SpatialOperation BBoxIntersects = new SpatialOperation("BBoxIntersects", true, false, false);
-  public static final SpatialOperation BBoxWithin     = new SpatialOperation("BBoxWithin", true, false, false);
-  public static final SpatialOperation Contains       = new SpatialOperation("Contains", true, true, false);
-  public static final SpatialOperation Intersects     = new SpatialOperation("Intersects", true, false, false);
-  public static final SpatialOperation IsEqualTo      = new SpatialOperation("IsEqualTo", false, false, false);
-  public static final SpatialOperation IsDisjointTo   = new SpatialOperation("IsDisjointTo", false, false, false);
-  public static final SpatialOperation IsWithin       = new SpatialOperation("IsWithin", true, false, true);
-  public static final SpatialOperation Overlaps       = new SpatialOperation("Overlaps", true, false, true);
-
-  // Member variables
-  private final boolean scoreIsMeaningful;
-  private final boolean sourceNeedsArea;
-  private final boolean targetNeedsArea;
-  private final String name;
-
-  protected SpatialOperation(String name, boolean scoreIsMeaningful, boolean sourceNeedsArea, boolean targetNeedsArea) {
-    this.name = name;
-    this.scoreIsMeaningful = scoreIsMeaningful;
-    this.sourceNeedsArea = sourceNeedsArea;
-    this.targetNeedsArea = targetNeedsArea;
-    registry.put(name, this);
-    registry.put(name.toUpperCase(Locale.US), this);
-    list.add( this );
-  }
-
-  public static SpatialOperation get( String v ) {
-    SpatialOperation op = registry.get( v );
-    if( op == null ) {
-      op = registry.get(v.toUpperCase(Locale.US));
-    }
-    if( op == null ) {
-      throw new InvalidSpatialArgument("Unknown Operation: " + v );
-    }
-    return op;
-  }
-
-  public static List<SpatialOperation> values() {
-    return list;
-  }
-
-  public static boolean is( SpatialOperation op, SpatialOperation ... tst ) {
-    for( SpatialOperation t : tst ) {
-      if( op == t ) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-
-  // ================================================= Getters / Setters =============================================
-
-  public boolean isScoreIsMeaningful() {
-    return scoreIsMeaningful;
-  }
-
-  public boolean isSourceNeedsArea() {
-    return sourceNeedsArea;
-  }
-
-  public boolean isTargetNeedsArea() {
-    return targetNeedsArea;
-  }
-
-  public String getName() {
-    return name;
-  }
-
-  @Override
-  public String toString() {
-    return name;
-  }
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/query/package-info.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/query/package-info.java
deleted file mode 100644
index ded6980..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/query/package-info.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-/**
- * Lucene spatial Query options
- * <ul>
- *  <li>useful for client side requets</li>
- * </ul>
- */
-package org.apache.lucene.spatial.base.query;
-
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/Circle.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/Circle.java
deleted file mode 100644
index ad718f3..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/Circle.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.shape;
-
-/**
- * This is basically a circle.
- */
-public interface Circle extends Shape {
-  double getDistance();
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/MultiShape.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/MultiShape.java
deleted file mode 100644
index d2e6873..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/MultiShape.java
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.shape;
-
-import org.apache.commons.lang.builder.EqualsBuilder;
-import org.apache.commons.lang.builder.HashCodeBuilder;
-import org.apache.lucene.spatial.base.context.SpatialContext;
-
-import java.util.Collection;
-
-/**
- * A collection of Shape objects.
- */
-public class MultiShape implements Shape {
-  private final Collection<Shape> geoms;
-  private final Rectangle bbox;
-
-  public MultiShape(Collection<Shape> geoms, SpatialContext ctx) {
-    this.geoms = geoms;
-    double minX = Double.MAX_VALUE;
-    double minY = Double.MAX_VALUE;
-    double maxX = Double.MIN_VALUE;
-    double maxY = Double.MIN_VALUE;
-    for (Shape geom : geoms) {
-      Rectangle r = geom.getBoundingBox();
-      minX = Math.min(minX,r.getMinX());
-      minY = Math.min(minY,r.getMinY());
-      maxX = Math.max(maxX,r.getMaxX());
-      maxY = Math.max(maxY,r.getMaxY());
-    }
-    this.bbox = ctx.makeRect(minX, maxX, minY, maxY);
-  }
-
-  @Override
-  public Rectangle getBoundingBox() {
-    return bbox;
-  }
-
-  @Override
-  public Point getCenter() {
-    return bbox.getCenter();
-  }
-
-  @Override
-  public boolean hasArea() {
-    for (Shape geom : geoms) {
-      if( geom.hasArea() ) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  @Override
-  public SpatialRelation relate(Shape other, SpatialContext ctx) {
-    boolean allOutside = true;
-    boolean allContains = true;
-    for (Shape geom : geoms) {
-      SpatialRelation sect = geom.relate(other, ctx);
-      if (sect != SpatialRelation.DISJOINT)
-        allOutside = false;
-      if (sect != SpatialRelation.CONTAINS)
-        allContains = false;
-      if (!allContains && !allOutside)
-        return SpatialRelation.INTERSECTS;//short circuit
-    }
-    if (allOutside)
-      return SpatialRelation.DISJOINT;
-    if (allContains)
-      return SpatialRelation.CONTAINS;
-    return SpatialRelation.INTERSECTS;
-  }
-
-
-  @Override
-  public boolean equals(Object obj) {
-    if (obj == null) { return false; }
-    if (obj == this) { return true; }
-    if (obj.getClass() != getClass()) {
-      return false;
-    }
-    MultiShape rhs = (MultiShape) obj;
-    return new EqualsBuilder()
-                  .append(geoms, rhs.geoms)
-                  .isEquals();
-  }
-
-  @Override
-  public int hashCode() {
-    return new HashCodeBuilder(83, 29).append(geoms.hashCode()).
-      toHashCode();
-  }
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/Point.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/Point.java
deleted file mode 100644
index fd66020..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/Point.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.shape;
-
-public interface Point extends Shape {
-
-  public double getX();
-  public double getY();
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/Rectangle.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/Rectangle.java
deleted file mode 100644
index f0935ff..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/Rectangle.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.shape;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-
-public interface Rectangle extends Shape {
-
-  public double getWidth();
-  public double getHeight();
-
-  public double getMinX();
-  public double getMinY();
-  public double getMaxX();
-  public double getMaxY();
-
-  /** If {@link #hasArea()} then this returns the area, otherwise it returns 0. */
-  public double getArea();
-  /** Only meaningful for geospatial contexts. */
-  public boolean getCrossesDateLine();
-
-  /* There is no axis line shape, and this is more efficient then creating a flat Rectangle for intersect(). */
-  public SpatialRelation relate_yRange(double minY, double maxY, SpatialContext ctx);
-  public SpatialRelation relate_xRange(double minX, double maxX, SpatialContext ctx);
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/Shape.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/Shape.java
deleted file mode 100644
index 3292c11..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/Shape.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.shape;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-
-public interface Shape {
-
-  /**
-   * Describe the relationship between the two objects.  For example
-   *
-   *   this is WITHIN other
-   *   this CONTAINS other
-   *   this is DISJOINT other
-   *   this INTERSECTS other
-   *
-   * The context object is optional -- it may include spatial reference.
-   */
-  SpatialRelation relate(Shape other, SpatialContext ctx);
-
-  /**
-   * Get the bounding box for this Shape
-   */
-  Rectangle getBoundingBox();
-
-  /**
-   * @return true if the shape has area.  This will be false for points and lines
-   */
-  boolean hasArea();
-
-  Point getCenter();
-}
-
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/SpatialRelation.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/SpatialRelation.java
deleted file mode 100644
index 1a6181c..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/SpatialRelation.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.shape;
-
-/**
- * The set of spatial relationships.  Naming is consistent with OGC spec conventions as seen in SQL/MM and others.
- * No equality case.  If two Shape instances are equal then the result might be CONTAINS or WITHIN, and
- * some logic might fail under this edge condition when it's not careful to check.
- * Client code must be written to detect this and act accordingly.  In RectangleImpl.relate(), it checks
- * for this explicitly, for example.  TestShapes2D.assertRelation() checks too.
- */
-public enum SpatialRelation {
-  WITHIN,
-  CONTAINS,
-  DISJOINT,
-  INTERSECTS;
-  //Don't have these: TOUCHES, CROSSES, OVERLAPS
-
-  public SpatialRelation transpose() {
-    switch(this) {
-      case CONTAINS: return SpatialRelation.WITHIN;
-      case WITHIN: return SpatialRelation.CONTAINS;
-      default: return this;
-    }
-  }
-
-  /**
-   * If you were to call aShape.relate(bShape) and aShape.relate(cShape), you could call
-   * this to merge the intersect results as if bShape & cShape were combined into {@link MultiShape}.
-   * @param other
-   * @return
-   */
-  public SpatialRelation combine(SpatialRelation other) {
-    if (this == other)
-      return this;
-    if (this == WITHIN || other == WITHIN)
-      return WITHIN;
-    return INTERSECTS;
-  }
-
-  public boolean intersects() {
-    return this != DISJOINT;
-  }
-
-  /** Not commutative!  WITHIN.inverse().inverse() != WITHIN. */
-  public SpatialRelation inverse() {
-    switch(this) {
-      case DISJOINT: return CONTAINS;
-      case CONTAINS: return DISJOINT;
-      case WITHIN: return INTERSECTS;//not commutative!
-    }
-    return INTERSECTS;
-  }
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/simple/CircleImpl.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/simple/CircleImpl.java
deleted file mode 100644
index 144f053..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/simple/CircleImpl.java
+++ /dev/null
@@ -1,234 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.shape.simple;
-
-import org.apache.commons.lang.builder.EqualsBuilder;
-import org.apache.commons.lang.builder.HashCodeBuilder;
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.shape.*;
-
-/**
- * A circle, also known as a point-radius, based on a
- * {@link org.apache.lucene.spatial.base.distance.DistanceCalculator} which does all the work. This implementation
- * should work for both cartesian 2D and geodetic sphere surfaces.
- * Threadsafe & immutable.
- */
-public class CircleImpl implements Circle {
-
-  protected final Point point;
-  protected final double distance;
-
-  protected final SpatialContext ctx;
-
-  /* below is calculated & cached: */
-  
-  protected final Rectangle enclosingBox;
-
-  //we don't have a line shape so we use a rectangle for these axis
-
-  public CircleImpl(Point p, double dist, SpatialContext ctx) {
-    //We assume any normalization / validation of params already occurred (including bounding dist)
-    this.point = p;
-    this.distance = dist;
-    this.ctx = ctx;
-    this.enclosingBox = ctx.getDistCalc().calcBoxByDistFromPt(point, distance, ctx);
-  }
-
-  public Point getCenter() {
-    return point;
-  }
-
-  @Override
-  public double getDistance() {
-    return distance;
-  }
-
-  public boolean contains(double x, double y) {
-    return ctx.getDistCalc().distance(point, x, y) <= distance;
-  }
-
-  @Override
-  public boolean hasArea() {
-    return distance > 0;
-  }
-
-  /**
-   * Note that the bounding box might contain a minX that is > maxX, due to WGS84 dateline.
-   * @return
-   */
-  @Override
-  public Rectangle getBoundingBox() {
-    return enclosingBox;
-  }
-
-  @Override
-  public SpatialRelation relate(Shape other, SpatialContext ctx) {
-    assert this.ctx == ctx;
-//This shortcut was problematic in testing due to distinctions of CONTAINS/WITHIN for no-area shapes (lines, points).
-//    if (distance == 0) {
-//      return point.relate(other,ctx).intersects() ? SpatialRelation.WITHIN : SpatialRelation.DISJOINT;
-//    }
-
-    if (other instanceof Point) {
-      return relate((Point) other, ctx);
-    }
-    if (other instanceof Rectangle) {
-      return relate((Rectangle) other, ctx);
-    }
-    if (other instanceof Circle) {
-      return relate((Circle) other, ctx);
-    }
-    return other.relate(this, ctx).transpose();
-  }
-
-  public SpatialRelation relate(Point point, SpatialContext ctx) {
-    return contains(point.getX(),point.getY()) ? SpatialRelation.CONTAINS : SpatialRelation.DISJOINT;
-  }
-
-  public SpatialRelation relate(Rectangle r, SpatialContext ctx) {
-    //Note: Surprisingly complicated!
-
-    //--We start by leveraging the fact we have a calculated bbox that is "cheaper" than use of DistanceCalculator.
-    final SpatialRelation bboxSect = enclosingBox.relate(r, ctx);
-    if (bboxSect == SpatialRelation.DISJOINT || bboxSect == SpatialRelation.WITHIN)
-      return bboxSect;
-    else if (bboxSect == SpatialRelation.CONTAINS && enclosingBox.equals(r))//nasty identity edge-case
-      return SpatialRelation.WITHIN;
-    //bboxSect is INTERSECTS or CONTAINS
-    //The result can be DISJOINT, CONTAINS, or INTERSECTS (not WITHIN)
-
-    return relateRectanglePhase2(r, bboxSect, ctx);
-  }
-
-  protected SpatialRelation relateRectanglePhase2(final Rectangle r, SpatialRelation bboxSect, SpatialContext ctx) {
-    /*
-     !! DOES NOT WORK WITH GEO CROSSING DATELINE OR WORLD-WRAP.
-     TODO upgrade to handle crossing dateline, but not world-wrap; use some x-shifting code from RectangleImpl.
-     */
-
-    //At this point, the only thing we are certain of is that circle is *NOT* WITHIN r, since the bounding box of a
-    // circle MUST be within r for the circle to be within r.
-
-    //--Quickly determine if they are DISJOINT or not.
-    //see http://stackoverflow.com/questions/401847/circle-rectangle-collision-detection-intersection/1879223#1879223
-    final double closestX;
-    double ctr_x = getXAxis();
-    if ( ctr_x < r.getMinX() )
-      closestX = r.getMinX();
-    else if (ctr_x > r.getMaxX())
-      closestX = r.getMaxX();
-    else
-      closestX = ctr_x;
-
-    final double closestY;
-    double ctr_y = getYAxis();
-    if ( ctr_y < r.getMinY() )
-      closestY = r.getMinY();
-    else if (ctr_y > r.getMaxY())
-      closestY = r.getMaxY();
-    else
-      closestY = ctr_y;
-
-    //Check if there is an intersection from this circle to closestXY
-    boolean didContainOnClosestXY = false;
-    if (ctr_x == closestX) {
-      double deltaY = Math.abs(ctr_y - closestY);
-      double distYCirc = (ctr_y < closestY ? enclosingBox.getMaxY() - ctr_y : ctr_y - enclosingBox.getMinY());
-      if (deltaY > distYCirc)
-        return SpatialRelation.DISJOINT;
-    } else if (ctr_y == closestY) {
-      double deltaX = Math.abs(ctr_x - closestX);
-      double distXCirc = (ctr_x < closestX ? enclosingBox.getMaxX() - ctr_x : ctr_x - enclosingBox.getMinX());
-      if (deltaX > distXCirc)
-        return SpatialRelation.DISJOINT;
-    } else {
-      //fallback on more expensive calculation
-      didContainOnClosestXY = true;
-      if(! contains(closestX,closestY) )
-        return SpatialRelation.DISJOINT;
-    }
-
-    //At this point we know that it's *NOT* DISJOINT, so there is some level of intersection. It's *NOT* WITHIN either.
-    // The only question left is whether circle CONTAINS r or simply intersects it.
-
-    //If circle contains r, then its bbox MUST also CONTAIN r.
-    if (bboxSect != SpatialRelation.CONTAINS)
-      return SpatialRelation.INTERSECTS;
-
-    //Find the farthest point of r away from the center of the circle. If that point is contained, then all of r is
-    // contained.
-    double farthestX = r.getMaxX() - ctr_x > ctr_x - r.getMinX() ? r.getMaxX() : r.getMinX();
-    double farthestY = r.getMaxY() - ctr_y > ctr_y - r.getMinY() ? r.getMaxY() : r.getMinY();
-    if (contains(farthestX,farthestY))
-      return SpatialRelation.CONTAINS;
-    return SpatialRelation.INTERSECTS;
-  }
-
-  /**
-   * The y axis horizontal of maximal left-right extent of the circle.
-   */
-  protected double getYAxis() {
-    return point.getY();
-  }
-
-  protected double getXAxis() {
-    return point.getX();
-  }
-
-  public SpatialRelation relate(Circle circle, SpatialContext ctx) {
-    double crossDist = ctx.getDistCalc().distance(point, circle.getCenter());
-    double aDist = distance, bDist = circle.getDistance();
-    if (crossDist > aDist + bDist)
-      return SpatialRelation.DISJOINT;
-    if (crossDist < aDist && crossDist + bDist <= aDist)
-      return SpatialRelation.CONTAINS;
-    if (crossDist < bDist && crossDist + aDist <= bDist)
-      return SpatialRelation.WITHIN;
-
-    return SpatialRelation.INTERSECTS;
-  }
-
-  @Override
-  public String toString() {
-    return "Circle(" + point + ",d=" + distance + ')';
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (obj == null) { return false; }
-    if (obj == this) { return true; }
-    if (obj.getClass() != getClass()) {
-      return false;
-    }
-    CircleImpl rhs = (CircleImpl) obj;
-    return new EqualsBuilder()
-                  .append(point, rhs.point)
-                  .append(distance, rhs.distance)
-                  .append(ctx, rhs.ctx)
-                  .isEquals();
-  }
-
-  @Override
-  public int hashCode() {
-    return new HashCodeBuilder(11, 97).
-      append(point).
-      append(distance).
-      append(ctx).
-      toHashCode();
-  }
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/simple/GeoCircleImpl.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/simple/GeoCircleImpl.java
deleted file mode 100644
index 8ac353d..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/simple/GeoCircleImpl.java
+++ /dev/null
@@ -1,226 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.shape.simple;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.shape.SpatialRelation;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-
-/**
- * @author David Smiley - dsmiley@mitre.org
- */
-public class GeoCircleImpl extends CircleImpl {
-  private final double distDEG;// [0 TO 180]
-  private final GeoCircleImpl inverseCircle;//when distance reaches > 1/2 way around the world, cache the inverse.
-  private final double horizAxisY;//see getYAxis
-
-  public GeoCircleImpl(Point p, double dist, SpatialContext ctx) {
-    super(p, dist, ctx);
-    assert ctx.isGeo();
-
-    //In the direction of latitude (N,S), distance is the same number of degrees.
-    distDEG = ctx.getDistCalc().distanceToDegrees(distance);
-
-    if (distDEG > 90) {
-      assert enclosingBox.getWidth() == 360;
-      double backDistDEG = 180 - distDEG;
-      if (backDistDEG >= 0) {
-        double backDistance = ctx.getDistCalc().degreesToDistance(backDistDEG);
-        Point backPoint = ctx.makePoint(getCenter().getX() + 180, getCenter().getY() + 180);
-        inverseCircle = new GeoCircleImpl(backPoint,backDistance,ctx);
-      } else
-        inverseCircle = null;//whole globe
-      horizAxisY = getCenter().getY();//although probably not used
-    } else {
-      inverseCircle = null;
-      double _horizAxisY = ctx.getDistCalc().calcBoxByDistFromPtHorizAxis(getCenter(), distance, ctx);
-      //some rare numeric conditioning cases can cause this to be barely beyond the box
-      if (_horizAxisY > enclosingBox.getMaxY()) {
-        horizAxisY = enclosingBox.getMaxY();
-      } else if (_horizAxisY < enclosingBox.getMinY()) {
-        horizAxisY = enclosingBox.getMinY();
-      } else {
-        horizAxisY = _horizAxisY;
-      }
-      //assert enclosingBox.relate_yRange(horizAxis,horizAxis,ctx).intersects();
-    }
-
-  }
-
-  @Override
-  protected double getYAxis() {
-    return horizAxisY;
-  }
-
-  /**
-   * Called after bounding box is intersected.
-   * @bboxSect INTERSECTS or CONTAINS from enclosingBox's intersection
-   * @result DISJOINT, CONTAINS, or INTERSECTS (not WITHIN)
-   */
-  @Override
-  protected SpatialRelation relateRectanglePhase2(Rectangle r, SpatialRelation bboxSect, SpatialContext ctx) {
-
-    //Rectangle wraps around the world longitudinally creating a solid band; there are no corners to test intersection
-    if (r.getWidth() == 360) {
-      return SpatialRelation.INTERSECTS;
-    }
-
-    if (inverseCircle != null) {
-      return inverseCircle.relate(r, ctx).inverse();
-    }
-
-    //if a pole is wrapped, we have a separate algorithm
-    if (enclosingBox.getWidth() == 360) {
-      return relateRectangleCircleWrapsPole(r, ctx);
-    }
-
-    //This is an optimization path for when there are no dateline or pole issues.
-    if (!enclosingBox.getCrossesDateLine() && !r.getCrossesDateLine()) {
-      return super.relateRectanglePhase2(r, bboxSect, ctx);
-    }
-
-    //do quick check to see if all corners are within this circle for CONTAINS
-    int cornersIntersect = numCornersIntersect(r);
-    if (cornersIntersect == 4) {
-      //ensure r's x axis is within c's.  If it doesn't, r sneaks around the globe to touch the other side (intersect).
-      SpatialRelation xIntersect = r.relate_xRange(enclosingBox.getMinX(), enclosingBox.getMaxX(), ctx);
-      if (xIntersect == SpatialRelation.WITHIN)
-        return SpatialRelation.CONTAINS;
-      return SpatialRelation.INTERSECTS;
-    }
-
-    //INTERSECT or DISJOINT ?
-    if (cornersIntersect > 0)
-      return SpatialRelation.INTERSECTS;
-
-    //Now we check if one of the axis of the circle intersect with r.  If so we have
-    // intersection.
-
-    /* x axis intersects  */
-    if ( r.relate_yRange(getYAxis(), getYAxis(), ctx).intersects() // at y vertical
-          && r.relate_xRange(enclosingBox.getMinX(), enclosingBox.getMaxX(), ctx).intersects() )
-      return SpatialRelation.INTERSECTS;
-
-    /* y axis intersects */
-    if (r.relate_xRange(getXAxis(), getXAxis(), ctx).intersects()) { // at x horizontal
-      double yTop = getCenter().getY()+ distDEG;
-      assert yTop <= 90;
-      double yBot = getCenter().getY()- distDEG;
-      assert yBot >= -90;
-      if (r.relate_yRange(yBot, yTop, ctx).intersects())//back bottom
-        return SpatialRelation.INTERSECTS;
-    }
-
-    return SpatialRelation.DISJOINT;
-  }
-
-  private SpatialRelation relateRectangleCircleWrapsPole(Rectangle r, SpatialContext ctx) {
-    //This method handles the case where the circle wraps ONE pole, but not both.  For both,
-    // there is the inverseCircle case handled before now.  The only exception is for the case where
-    // the circle covers the entire globe, and we'll check that first.
-    if (distDEG == 180)//whole globe
-      return SpatialRelation.CONTAINS;
-
-    //Check if r is within the pole wrap region:
-    double yTop = getCenter().getY()+ distDEG;
-    if (yTop > 90) {
-      double yTopOverlap = yTop - 90;
-      assert yTopOverlap <= 90;
-      if (r.getMinY() >= 90 - yTopOverlap)
-        return SpatialRelation.CONTAINS;
-    } else {
-      double yBot = point.getY() - distDEG;
-      if (yBot < -90) {
-        double yBotOverlap = -90 - yBot;
-        assert yBotOverlap <= 90;
-        if (r.getMaxY() <= -90 + yBotOverlap)
-          return SpatialRelation.CONTAINS;
-      } else {
-        //This point is probably not reachable ??
-        assert yTop == 90 || yBot == -90;//we simply touch a pole
-        //continue
-      }
-    }
-
-    //If there are no corners to check intersection because r wraps completely...
-    if (r.getWidth() == 360)
-      return SpatialRelation.INTERSECTS;
-
-    //Check corners:
-    int cornersIntersect = numCornersIntersect(r);
-    // (It might be possible to reduce contains() calls within nCI() to exactly two, but this intersection
-    //  code is complicated enough as it is.)
-    if (cornersIntersect == 4) {//all
-      double backX = ctx.normX(getCenter().getX()+180);
-      if (r.relate_xRange(backX, backX, ctx).intersects())
-        return SpatialRelation.INTERSECTS;
-      else
-        return SpatialRelation.CONTAINS;
-    } else if (cornersIntersect == 0) {//none
-      double frontX = getCenter().getX();
-      if (r.relate_xRange(frontX, frontX, ctx).intersects())
-        return SpatialRelation.INTERSECTS;
-      else
-        return SpatialRelation.DISJOINT;
-    } else//partial
-      return SpatialRelation.INTERSECTS;
-  }
-
-  /** Returns either 0 for none, 1 for some, or 4 for all. */
-  private int numCornersIntersect(Rectangle r) {
-    //We play some logic games to avoid calling contains() which can be expensive.
-    boolean bool;//if true then all corners intersect, if false then no corners intersect
-    // for partial, we exit early with 1 and ignore bool.
-    bool = (contains(r.getMinX(),r.getMinY()));
-    if (contains(r.getMinX(),r.getMaxY())) {
-      if (!bool)
-        return 1;//partial
-    } else {
-      if (bool)
-        return 1;//partial
-    }
-    if (contains(r.getMaxX(),r.getMinY())) {
-      if (!bool)
-        return 1;//partial
-    } else {
-      if (bool)
-        return 1;//partial
-    }
-    if (contains(r.getMaxX(),r.getMaxY())) {
-      if (!bool)
-        return 1;//partial
-    } else {
-      if (bool)
-        return 1;//partial
-    }
-    return bool?4:0;
-  }
-
-  @Override
-  public String toString() {
-    //I'm deliberately making this look basic and not fully detailed with class name & misc fields.
-    //Add distance in degrees, which is easier to recognize, and earth radius agnostic.
-    String dStr = String.format("%.1f",distance);
-    if (ctx.isGeo()) {
-      double distDEG = ctx.getDistCalc().distanceToDegrees(distance);
-      dStr += String.format("=%.1f\u00B0",distDEG);
-    }
-    return "Circle(" + point + ",d=" + dStr + ')';
-  }
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/simple/PointImpl.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/simple/PointImpl.java
deleted file mode 100644
index 054e901..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/simple/PointImpl.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.shape.simple;
-
-import org.apache.commons.lang.builder.EqualsBuilder;
-import org.apache.commons.lang.builder.HashCodeBuilder;
-import org.apache.lucene.spatial.base.shape.SpatialRelation;
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.apache.lucene.spatial.base.shape.Shape;
-
-
-public class PointImpl implements Point {
-
-  private final double x;
-  private final double y;
-
-  public PointImpl(double x, double y) {
-    this.x = x;
-    this.y = y;
-  }
-
-  @Override
-  public double getX() {
-    return x;
-  }
-
-  @Override
-  public double getY() {
-    return y;
-  }
-  @Override
-  public Rectangle getBoundingBox() {
-    return new RectangleImpl(x, x, y, y);
-  }
-
-  @Override
-  public PointImpl getCenter() {
-    return this;
-  }
-
-  @Override
-  public SpatialRelation relate(Shape other, SpatialContext ctx) {
-    if (other instanceof Point)
-      return this.equals(other) ? SpatialRelation.INTERSECTS : SpatialRelation.DISJOINT;
-    return other.relate(this, ctx).transpose();
-  }
-
-  @Override
-  public boolean hasArea() {
-    return false;
-  }
-
-  @Override
-  public String toString() {
-    return "Pt(x="+x+",y="+y+")";
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (obj == null) { return false; }
-    if (obj == this) { return true; }
-    if (obj.getClass() != getClass()) {
-      return false;
-    }
-    PointImpl rhs = (PointImpl) obj;
-    return new EqualsBuilder()
-                  .append(x, rhs.x)
-                  .append(y, rhs.y)
-                  .isEquals();
-  }
-
-  @Override
-  public int hashCode() {
-    return new HashCodeBuilder(5, 89).
-      append(x).
-      append(y).
-      toHashCode();
-  }
-}
diff --git a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/simple/RectangleImpl.java b/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/simple/RectangleImpl.java
deleted file mode 100644
index fb8e3c8..0000000
--- a/modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/simple/RectangleImpl.java
+++ /dev/null
@@ -1,248 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.shape.simple;
-
-import org.apache.commons.lang.builder.EqualsBuilder;
-import org.apache.commons.lang.builder.HashCodeBuilder;
-import org.apache.lucene.spatial.base.shape.SpatialRelation;
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.distance.DistanceUtils;
-import org.apache.lucene.spatial.base.shape.*;
-
-/**
- * A simple Rectangle implementation that also supports a longitudinal wrap-around. When minX > maxX, this will assume
- * it is world coordinates that cross the date line using degrees.
- * Immutable & threadsafe.
- */
-public class RectangleImpl implements Rectangle {
-
-  private final double minX;
-  private final double maxX;
-  private final double minY;
-  private final double maxY;
-
-  //TODO change to West South East North to be more consistent with OGC?
-  public RectangleImpl(double minX, double maxX, double minY, double maxY) {
-    //We assume any normalization / validation of params already occurred.
-    this.minX = minX;
-    this.maxX = maxX;
-    this.minY = minY;
-    this.maxY = maxY;
-    assert minY <= maxY;
-  }
-
-  /** Copy constructor. */
-  public RectangleImpl(Rectangle r) {
-    this(r.getMinX(),r.getMaxX(),r.getMinY(),r.getMaxY());
-  }
-
-  @Override
-  public boolean hasArea() {
-    return maxX != minX && maxY != minY;
-  }
-
-  @Override
-  public double getArea() {
-    return getWidth() * getHeight();
-  }
-
-  @Override
-  public boolean getCrossesDateLine() {
-    return (minX > maxX);
-  }
-
-  @Override
-  public double getHeight() {
-    return maxY - minY;
-  }
-
-  @Override
-  public double getWidth() {
-    double w = maxX - minX;
-    if (w < 0) {//only true when minX > maxX (WGS84 assumed)
-      w += 360;
-      assert w >= 0;
-    }
-    return w;
-  }
-
-  @Override
-  public double getMaxX() {
-    return maxX;
-  }
-
-  @Override
-  public double getMaxY() {
-    return maxY;
-  }
-
-  @Override
-  public double getMinX() {
-    return minX;
-  }
-
-  @Override
-  public double getMinY() {
-    return minY;
-  }
-
-  @Override
-  public Rectangle getBoundingBox() {
-    return this;
-  }
-
-  @Override
-  public SpatialRelation relate(Shape other, SpatialContext ctx) {
-    if (other instanceof Point) {
-      return relate((Point) other, ctx);
-    }
-    if (other instanceof Rectangle) {
-      return relate((Rectangle) other, ctx);
-    }
-    return other.relate(this, ctx).transpose();
-  }
-
-  public SpatialRelation relate(Point point, SpatialContext ctx) {
-    if (point.getY() > getMaxY() || point.getY() < getMinY() ||
-        (getCrossesDateLine() ?
-            (point.getX() < minX && point.getX() > maxX)
-            : (point.getX() < minX || point.getX() > maxX) ))
-      return SpatialRelation.DISJOINT;
-    return SpatialRelation.CONTAINS;
-  }
-
-  public SpatialRelation relate(Rectangle rect, SpatialContext ctx) {
-    SpatialRelation yIntersect = relate_yRange(rect.getMinY(), rect.getMaxY(), ctx);
-    if (yIntersect == SpatialRelation.DISJOINT)
-      return SpatialRelation.DISJOINT;
-
-    SpatialRelation xIntersect = relate_xRange(rect.getMinX(), rect.getMaxX(), ctx);
-    if (xIntersect == SpatialRelation.DISJOINT)
-      return SpatialRelation.DISJOINT;
-
-    if (xIntersect == yIntersect)//in agreement
-      return xIntersect;
-
-    //if one side is equal, return the other
-    if (getMinX() == rect.getMinX() && getMaxX() == rect.getMaxX())
-      return yIntersect;
-    if (getMinY() == rect.getMinY() && getMaxY() == rect.getMaxY())
-      return xIntersect;
-
-    return SpatialRelation.INTERSECTS;
-  }
-
-  public SpatialRelation relate_yRange(double ext_minY, double ext_maxY, SpatialContext ctx) {
-    if (ext_minY > maxY || ext_maxY < minY) {
-      return SpatialRelation.DISJOINT;
-    }
-
-    if (ext_minY >= minY && ext_maxY <= maxY) {
-      return SpatialRelation.CONTAINS;
-    }
-
-    if (ext_minY <= minY && ext_maxY >= maxY) {
-      return SpatialRelation.WITHIN;
-    }
-    return SpatialRelation.INTERSECTS;
-  }
-
-  @Override
-  public SpatialRelation relate_xRange(double ext_minX, double ext_maxX, SpatialContext ctx) {
-    //For ext & this we have local minX and maxX variable pairs. We rotate them so that minX <= maxX
-    double minX = this.minX;
-    double maxX = this.maxX;
-    if (ctx.isGeo()) {
-      //the 360 check is an edge-case for complete world-wrap
-      double ext_width = ext_maxX - ext_minX;
-      if (ext_width < 0)//this logic unfortunately duplicates getWidth()
-        ext_width += 360;
-
-      if (ext_width < 360) {
-        ext_maxX = ext_minX + ext_width;
-      } else {
-        ext_maxX = 180+360;
-      }
-
-      if (getWidth() < 360) {
-        maxX = minX + getWidth();
-      } else {
-        maxX = 180+360;
-      }
-
-      if (maxX < ext_minX) {
-        minX += 360;
-        maxX += 360;
-      } else if (ext_maxX < minX) {
-        ext_minX += 360;
-        ext_maxX += 360;
-      }
-    }
-
-    if (ext_minX > maxX || ext_maxX < minX ) {
-      return SpatialRelation.DISJOINT;
-    }
-
-    if (ext_minX >= minX && ext_maxX <= maxX ) {
-      return SpatialRelation.CONTAINS;
-    }
-
-    if (ext_minX <= minX && ext_maxX >= maxX ) {
-      return SpatialRelation.WITHIN;
-    }
-    return SpatialRelation.INTERSECTS;
-  }
-
-  @Override
-  public String toString() {
-    return "Rect(minX=" + minX + ",maxX=" + maxX + ",minY=" + minY + ",maxY=" + maxY + ")";
-  }
-
-  @Override
-  public Point getCenter() {
-    final double y = getHeight() / 2 + minY;
-    double x = getWidth() / 2 + minX;
-    if (minX > maxX)//WGS84
-      x = DistanceUtils.normLonDEG(x);
-    return new PointImpl(x, y);
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (obj == null) { return false; }
-    if (obj == this) { return true; }
-    if (obj.getClass() != getClass()) {
-      return false;
-    }
-    RectangleImpl rhs = (RectangleImpl) obj;
-    return new EqualsBuilder()
-                  .append(minX, rhs.minX)
-                  .append(minY, rhs.minY)
-                  .append(maxX, rhs.maxX)
-                  .append(maxY, rhs.maxY)
-                  .isEquals();
-  }
-
-  @Override
-  public int hashCode() {
-    return new HashCodeBuilder(41, 37).
-    append(minX).append(minY).
-    append(maxX).append(maxY).
-      toHashCode();
-  }
-}

