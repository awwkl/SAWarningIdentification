GitDiffStart: 8c5115ea9a6a158578959860b4163e94c9e2ed62 | Mon Mar 28 14:12:49 2016 -0400
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/compound/DictionaryCompoundWordTokenFilter.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/compound/DictionaryCompoundWordTokenFilter.java
index 3dfe3ab..b81a96c 100644
--- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/compound/DictionaryCompoundWordTokenFilter.java
+++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/compound/DictionaryCompoundWordTokenFilter.java
@@ -41,7 +41,7 @@ public class DictionaryCompoundWordTokenFilter extends CompoundWordTokenFilterBa
   public DictionaryCompoundWordTokenFilter(TokenStream input, CharArraySet dictionary) {
     super(input, dictionary);
     if (dictionary == null) {
-      throw new IllegalArgumentException("dictionary cannot be null");
+      throw new IllegalArgumentException("dictionary must not be null");
     }
   }
 
@@ -65,7 +65,7 @@ public class DictionaryCompoundWordTokenFilter extends CompoundWordTokenFilterBa
                                            int minWordSize, int minSubwordSize, int maxSubwordSize, boolean onlyLongestMatch) {
     super(input, dictionary, minWordSize, minSubwordSize, maxSubwordSize, onlyLongestMatch);
     if (dictionary == null) {
-      throw new IllegalArgumentException("dictionary cannot be null");
+      throw new IllegalArgumentException("dictionary must not be null");
     }
   }
 
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/payloads/NumericPayloadTokenFilter.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/payloads/NumericPayloadTokenFilter.java
index 9f9eec6..e5a4a45 100644
--- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/payloads/NumericPayloadTokenFilter.java
+++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/payloads/NumericPayloadTokenFilter.java
@@ -41,7 +41,7 @@ public class NumericPayloadTokenFilter extends TokenFilter {
   public NumericPayloadTokenFilter(TokenStream input, float payload, String typeMatch) {
     super(input);
     if (typeMatch == null) {
-      throw new IllegalArgumentException("typeMatch cannot be null");
+      throw new IllegalArgumentException("typeMatch must not be null");
     }
     //Need to encode the payload
     thePayload = new BytesRef(PayloadHelper.encodeFloat(payload));
diff --git a/lucene/core/src/java/org/apache/lucene/document/BinaryPoint.java b/lucene/core/src/java/org/apache/lucene/document/BinaryPoint.java
index 60fd9d63..7132a5d 100644
--- a/lucene/core/src/java/org/apache/lucene/document/BinaryPoint.java
+++ b/lucene/core/src/java/org/apache/lucene/document/BinaryPoint.java
@@ -47,19 +47,19 @@ public final class BinaryPoint extends Field {
 
   private static FieldType getType(byte[][] point) {
     if (point == null) {
-      throw new IllegalArgumentException("point cannot be null");
+      throw new IllegalArgumentException("point must not be null");
     }
     if (point.length == 0) {
-      throw new IllegalArgumentException("point cannot be 0 dimensions");
+      throw new IllegalArgumentException("point must not be 0 dimensions");
     }
     int bytesPerDim = -1;
     for(int i=0;i<point.length;i++) {
       byte[] oneDim = point[i];
       if (oneDim == null) {
-        throw new IllegalArgumentException("point cannot have null values");
+        throw new IllegalArgumentException("point must not have null values");
       }
       if (oneDim.length == 0) {
-        throw new IllegalArgumentException("point cannot have 0-length values");
+        throw new IllegalArgumentException("point must not have 0-length values");
       }
       if (bytesPerDim == -1) {
         bytesPerDim = oneDim.length;
@@ -79,10 +79,10 @@ public final class BinaryPoint extends Field {
 
   private static BytesRef pack(byte[]... point) {
     if (point == null) {
-      throw new IllegalArgumentException("point cannot be null");
+      throw new IllegalArgumentException("point must not be null");
     }
     if (point.length == 0) {
-      throw new IllegalArgumentException("point cannot be 0 dimensions");
+      throw new IllegalArgumentException("point must not be 0 dimensions");
     }
     if (point.length == 1) {
       return new BytesRef(point[0]);
@@ -90,11 +90,11 @@ public final class BinaryPoint extends Field {
     int bytesPerDim = -1;
     for(byte[] dim : point) {
       if (dim == null) {
-        throw new IllegalArgumentException("point cannot have null values");
+        throw new IllegalArgumentException("point must not have null values");
       }
       if (bytesPerDim == -1) {
         if (dim.length == 0) {
-          throw new IllegalArgumentException("point cannot have 0-length values");
+          throw new IllegalArgumentException("point must not have 0-length values");
         }
         bytesPerDim = dim.length;
       } else if (dim.length != bytesPerDim) {
diff --git a/lucene/core/src/java/org/apache/lucene/document/DoublePoint.java b/lucene/core/src/java/org/apache/lucene/document/DoublePoint.java
index 53de127..102e94f 100644
--- a/lucene/core/src/java/org/apache/lucene/document/DoublePoint.java
+++ b/lucene/core/src/java/org/apache/lucene/document/DoublePoint.java
@@ -81,10 +81,10 @@ public final class DoublePoint extends Field {
 
   private static BytesRef pack(double... point) {
     if (point == null) {
-      throw new IllegalArgumentException("point cannot be null");
+      throw new IllegalArgumentException("point must not be null");
     }
     if (point.length == 0) {
-      throw new IllegalArgumentException("point cannot be 0 dimensions");
+      throw new IllegalArgumentException("point must not be 0 dimensions");
     }
     byte[] packed = new byte[point.length * Double.BYTES];
     
diff --git a/lucene/core/src/java/org/apache/lucene/document/Field.java b/lucene/core/src/java/org/apache/lucene/document/Field.java
index 550d1fd..37fa255 100644
--- a/lucene/core/src/java/org/apache/lucene/document/Field.java
+++ b/lucene/core/src/java/org/apache/lucene/document/Field.java
@@ -97,11 +97,11 @@ public class Field implements IndexableField {
    */
   protected Field(String name, FieldType type) {
     if (name == null) {
-      throw new IllegalArgumentException("name cannot be null");
+      throw new IllegalArgumentException("name must not be null");
     }
     this.name = name;
     if (type == null) {
-      throw new IllegalArgumentException("type cannot be null");
+      throw new IllegalArgumentException("type must not be null");
     }
     this.type = type;
   }
@@ -118,13 +118,13 @@ public class Field implements IndexableField {
    */
   public Field(String name, Reader reader, FieldType type) {
     if (name == null) {
-      throw new IllegalArgumentException("name cannot be null");
+      throw new IllegalArgumentException("name must not be null");
     }
     if (type == null) {
-      throw new IllegalArgumentException("type cannot be null");
+      throw new IllegalArgumentException("type must not be null");
     }
     if (reader == null) {
-      throw new NullPointerException("reader cannot be null");
+      throw new NullPointerException("reader must not be null");
     }
     if (type.stored()) {
       throw new IllegalArgumentException("fields with a Reader value cannot be stored");
@@ -150,10 +150,10 @@ public class Field implements IndexableField {
    */
   public Field(String name, TokenStream tokenStream, FieldType type) {
     if (name == null) {
-      throw new IllegalArgumentException("name cannot be null");
+      throw new IllegalArgumentException("name must not be null");
     }
     if (tokenStream == null) {
-      throw new NullPointerException("tokenStream cannot be null");
+      throw new NullPointerException("tokenStream must not be null");
     }
     if (type.indexOptions() == IndexOptions.NONE || !type.tokenized()) {
       throw new IllegalArgumentException("TokenStream fields must be indexed and tokenized");
@@ -216,10 +216,10 @@ public class Field implements IndexableField {
    */
   public Field(String name, BytesRef bytes, FieldType type) {
     if (name == null) {
-      throw new IllegalArgumentException("name cannot be null");
+      throw new IllegalArgumentException("name must not be null");
     }
     if (bytes == null) {
-      throw new IllegalArgumentException("bytes cannot be null");
+      throw new IllegalArgumentException("bytes must not be null");
     }
     this.fieldsData = bytes;
     this.type = type;
@@ -240,10 +240,10 @@ public class Field implements IndexableField {
    */
   public Field(String name, String value, FieldType type) {
     if (name == null) {
-      throw new IllegalArgumentException("name cannot be null");
+      throw new IllegalArgumentException("name must not be null");
     }
     if (value == null) {
-      throw new IllegalArgumentException("value cannot be null");
+      throw new IllegalArgumentException("value must not be null");
     }
     if (!type.stored() && type.indexOptions() == IndexOptions.NONE) {
       throw new IllegalArgumentException("it doesn't make sense to have a field that "
@@ -307,7 +307,7 @@ public class Field implements IndexableField {
       throw new IllegalArgumentException("cannot change value type from " + fieldsData.getClass().getSimpleName() + " to String");
     }
     if (value == null) {
-      throw new IllegalArgumentException("value cannot be null");
+      throw new IllegalArgumentException("value must not be null");
     }
     fieldsData = value;
   }
@@ -346,7 +346,7 @@ public class Field implements IndexableField {
       throw new IllegalArgumentException("cannot set a BytesRef value on an indexed field");
     }
     if (value == null) {
-      throw new IllegalArgumentException("value cannot be null");
+      throw new IllegalArgumentException("value must not be null");
     }
     fieldsData = value;
   }
diff --git a/lucene/core/src/java/org/apache/lucene/document/FieldType.java b/lucene/core/src/java/org/apache/lucene/document/FieldType.java
index ae84016..2c0a62c 100644
--- a/lucene/core/src/java/org/apache/lucene/document/FieldType.java
+++ b/lucene/core/src/java/org/apache/lucene/document/FieldType.java
@@ -292,7 +292,7 @@ public class FieldType implements IndexableFieldType  {
   public void setIndexOptions(IndexOptions value) {
     checkIfFrozen();
     if (value == null) {
-      throw new NullPointerException("IndexOptions cannot be null");
+      throw new NullPointerException("IndexOptions must not be null");
     }
     this.indexOptions = value;
   }
@@ -482,7 +482,7 @@ public class FieldType implements IndexableFieldType  {
   public void setDocValuesType(DocValuesType type) {
     checkIfFrozen();
     if (type == null) {
-      throw new NullPointerException("DocValuesType cannot be null");
+      throw new NullPointerException("DocValuesType must not be null");
     }
     docValuesType = type;
   }
diff --git a/lucene/core/src/java/org/apache/lucene/document/FloatPoint.java b/lucene/core/src/java/org/apache/lucene/document/FloatPoint.java
index ab20928..f3626cf 100644
--- a/lucene/core/src/java/org/apache/lucene/document/FloatPoint.java
+++ b/lucene/core/src/java/org/apache/lucene/document/FloatPoint.java
@@ -81,10 +81,10 @@ public final class FloatPoint extends Field {
 
   private static BytesRef pack(float... point) {
     if (point == null) {
-      throw new IllegalArgumentException("point cannot be null");
+      throw new IllegalArgumentException("point must not be null");
     }
     if (point.length == 0) {
-      throw new IllegalArgumentException("point cannot be 0 dimensions");
+      throw new IllegalArgumentException("point must not be 0 dimensions");
     }
     byte[] packed = new byte[point.length * Float.BYTES];
     
diff --git a/lucene/core/src/java/org/apache/lucene/document/IntPoint.java b/lucene/core/src/java/org/apache/lucene/document/IntPoint.java
index db24fc9..41be876 100644
--- a/lucene/core/src/java/org/apache/lucene/document/IntPoint.java
+++ b/lucene/core/src/java/org/apache/lucene/document/IntPoint.java
@@ -81,10 +81,10 @@ public final class IntPoint extends Field {
 
   private static BytesRef pack(int... point) {
     if (point == null) {
-      throw new IllegalArgumentException("point cannot be null");
+      throw new IllegalArgumentException("point must not be null");
     }
     if (point.length == 0) {
-      throw new IllegalArgumentException("point cannot be 0 dimensions");
+      throw new IllegalArgumentException("point must not be 0 dimensions");
     }
     byte[] packed = new byte[point.length * Integer.BYTES];
     
diff --git a/lucene/core/src/java/org/apache/lucene/document/LongPoint.java b/lucene/core/src/java/org/apache/lucene/document/LongPoint.java
index ab2cb6f..6f45962 100644
--- a/lucene/core/src/java/org/apache/lucene/document/LongPoint.java
+++ b/lucene/core/src/java/org/apache/lucene/document/LongPoint.java
@@ -81,10 +81,10 @@ public final class LongPoint extends Field {
 
   private static BytesRef pack(long... point) {
     if (point == null) {
-      throw new IllegalArgumentException("point cannot be null");
+      throw new IllegalArgumentException("point must not be null");
     }
     if (point.length == 0) {
-      throw new IllegalArgumentException("point cannot be 0 dimensions");
+      throw new IllegalArgumentException("point must not be 0 dimensions");
     }
     byte[] packed = new byte[point.length * Long.BYTES];
     
diff --git a/lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain.java b/lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain.java
index 408f0bb..58ad981 100644
--- a/lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain.java
+++ b/lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain.java
@@ -440,7 +440,7 @@ final class DefaultIndexingChain extends DocConsumer {
 
     DocValuesType dvType = fieldType.docValuesType();
     if (dvType == null) {
-      throw new NullPointerException("docValuesType cannot be null (field: \"" + fieldName + "\")");
+      throw new NullPointerException("docValuesType must not be null (field: \"" + fieldName + "\")");
     }
     if (dvType != DocValuesType.NONE) {
       if (fp == null) {
diff --git a/lucene/core/src/java/org/apache/lucene/index/DocValuesFieldUpdates.java b/lucene/core/src/java/org/apache/lucene/index/DocValuesFieldUpdates.java
index 6c8eaf0..528d4bf 100644
--- a/lucene/core/src/java/org/apache/lucene/index/DocValuesFieldUpdates.java
+++ b/lucene/core/src/java/org/apache/lucene/index/DocValuesFieldUpdates.java
@@ -137,7 +137,7 @@ abstract class DocValuesFieldUpdates {
   protected DocValuesFieldUpdates(String field, DocValuesType type) {
     this.field = field;
     if (type == null) {
-      throw new NullPointerException("DocValuesType cannot be null");
+      throw new NullPointerException("DocValuesType must not be null");
     }
     this.type = type;
   }
diff --git a/lucene/core/src/java/org/apache/lucene/index/FieldInfo.java b/lucene/core/src/java/org/apache/lucene/index/FieldInfo.java
index 0dccf31..57cab47 100644
--- a/lucene/core/src/java/org/apache/lucene/index/FieldInfo.java
+++ b/lucene/core/src/java/org/apache/lucene/index/FieldInfo.java
@@ -63,8 +63,8 @@ public final class FieldInfo {
                    long dvGen, Map<String,String> attributes, int pointDimensionCount, int pointNumBytes) {
     this.name = Objects.requireNonNull(name);
     this.number = number;
-    this.docValuesType = Objects.requireNonNull(docValues, "DocValuesType cannot be null (field: \"" + name + "\")");
-    this.indexOptions = Objects.requireNonNull(indexOptions, "IndexOptions cannot be null (field: \"" + name + "\")");
+    this.docValuesType = Objects.requireNonNull(docValues, "DocValuesType must not be null (field: \"" + name + "\")");
+    this.indexOptions = Objects.requireNonNull(indexOptions, "IndexOptions must not be null (field: \"" + name + "\")");
     if (indexOptions != IndexOptions.NONE) {
       this.storeTermVector = storeTermVector;
       this.storePayloads = storePayloads;
@@ -130,7 +130,7 @@ public final class FieldInfo {
   void update(boolean storeTermVector, boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,
               int dimensionCount, int dimensionNumBytes) {
     if (indexOptions == null) {
-      throw new NullPointerException("IndexOptions cannot be null (field: \"" + name + "\")");
+      throw new NullPointerException("IndexOptions must not be null (field: \"" + name + "\")");
     }
     //System.out.println("FI.update field=" + name + " indexed=" + indexed + " omitNorms=" + omitNorms + " this.omitNorms=" + this.omitNorms);
     if (this.indexOptions != indexOptions) {
@@ -201,7 +201,7 @@ public final class FieldInfo {
 
   void setDocValuesType(DocValuesType type) {
     if (type == null) {
-      throw new NullPointerException("DocValuesType cannot be null (field: \"" + name + "\")");
+      throw new NullPointerException("DocValuesType must not be null (field: \"" + name + "\")");
     }
     if (docValuesType != DocValuesType.NONE && type != DocValuesType.NONE && docValuesType != type) {
       throw new IllegalArgumentException("cannot change DocValues type from " + docValuesType + " to " + type + " for field \"" + name + "\"");
diff --git a/lucene/core/src/java/org/apache/lucene/index/FieldInfos.java b/lucene/core/src/java/org/apache/lucene/index/FieldInfos.java
index a49a993..c80fb85 100644
--- a/lucene/core/src/java/org/apache/lucene/index/FieldInfos.java
+++ b/lucene/core/src/java/org/apache/lucene/index/FieldInfos.java
@@ -394,7 +394,7 @@ public class FieldInfos implements Iterable<FieldInfo> {
                                           boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues,
                                           int dimensionCount, int dimensionNumBytes) {
       if (docValues == null) {
-        throw new NullPointerException("DocValuesType cannot be null");
+        throw new NullPointerException("DocValuesType must not be null");
       }
       FieldInfo fi = fieldInfo(name);
       if (fi == null) {
diff --git a/lucene/core/src/java/org/apache/lucene/index/FilterLeafReader.java b/lucene/core/src/java/org/apache/lucene/index/FilterLeafReader.java
index 1d593c3..f273dba 100644
--- a/lucene/core/src/java/org/apache/lucene/index/FilterLeafReader.java
+++ b/lucene/core/src/java/org/apache/lucene/index/FilterLeafReader.java
@@ -67,7 +67,7 @@ public abstract class FilterLeafReader extends LeafReader {
      */
     public FilterFields(Fields in) {
       if (in == null) {
-        throw new NullPointerException("incoming Fields cannot be null");
+        throw new NullPointerException("incoming Fields must not be null");
       }
       this.in = in;
     }
@@ -103,7 +103,7 @@ public abstract class FilterLeafReader extends LeafReader {
      */
     public FilterTerms(Terms in) {
       if (in == null) {
-        throw new NullPointerException("incoming Terms cannot be null");
+        throw new NullPointerException("incoming Terms must not be null");
       }
       this.in = in;
     }
@@ -170,7 +170,7 @@ public abstract class FilterLeafReader extends LeafReader {
      */
     public FilterTermsEnum(TermsEnum in) {
       if (in == null) {
-        throw new NullPointerException("incoming TermsEnum cannot be null");
+        throw new NullPointerException("incoming TermsEnum must not be null");
       }
       this.in = in;
     }
@@ -233,7 +233,7 @@ public abstract class FilterLeafReader extends LeafReader {
      */
     public FilterPostingsEnum(PostingsEnum in) {
       if (in == null) {
-        throw new NullPointerException("incoming PostingsEnum cannot be null");
+        throw new NullPointerException("incoming PostingsEnum must not be null");
       }
       this.in = in;
     }
@@ -300,7 +300,7 @@ public abstract class FilterLeafReader extends LeafReader {
   public FilterLeafReader(LeafReader in) {
     super();
     if (in == null) {
-      throw new NullPointerException("incoming LeafReader cannot be null");
+      throw new NullPointerException("incoming LeafReader must not be null");
     }
     this.in = in;
     in.registerParentReader(this);
diff --git a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
index 66a0e73..2b45b6b 100644
--- a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
@@ -1592,7 +1592,7 @@ public class IndexWriter implements Closeable, TwoPhaseCommit, Accountable {
       final Field f = updates[i];
       final DocValuesType dvType = f.fieldType().docValuesType();
       if (dvType == null) {
-        throw new NullPointerException("DocValuesType cannot be null (field: \"" + f.name() + "\")");
+        throw new NullPointerException("DocValuesType must not be null (field: \"" + f.name() + "\")");
       }
       if (dvType == DocValuesType.NONE) {
         throw new IllegalArgumentException("can only update NUMERIC or BINARY fields! field=" + f.name());
diff --git a/lucene/core/src/java/org/apache/lucene/index/IndexWriterConfig.java b/lucene/core/src/java/org/apache/lucene/index/IndexWriterConfig.java
index 4a7cf71..a90d625 100644
--- a/lucene/core/src/java/org/apache/lucene/index/IndexWriterConfig.java
+++ b/lucene/core/src/java/org/apache/lucene/index/IndexWriterConfig.java
@@ -160,7 +160,7 @@ public final class IndexWriterConfig extends LiveIndexWriterConfig {
    * like NFS that do not support "delete on last close" semantics, which
    * Lucene's "point in time" search normally relies on.
    * <p>
-   * <b>NOTE:</b> the deletion policy cannot be null.
+   * <b>NOTE:</b> the deletion policy must not be null.
    *
    * <p>Only takes effect when IndexWriter is first created. 
    */
@@ -197,7 +197,7 @@ public final class IndexWriterConfig extends LiveIndexWriterConfig {
   /**
    * Expert: set the {@link Similarity} implementation used by this IndexWriter.
    * <p>
-   * <b>NOTE:</b> the similarity cannot be null.
+   * <b>NOTE:</b> the similarity must not be null.
    *
    * <p>Only takes effect when IndexWriter is first created. */
   public IndexWriterConfig setSimilarity(Similarity similarity) {
@@ -217,7 +217,7 @@ public final class IndexWriterConfig extends LiveIndexWriterConfig {
    * Expert: sets the merge scheduler used by this writer. The default is
    * {@link ConcurrentMergeScheduler}.
    * <p>
-   * <b>NOTE:</b> the merge scheduler cannot be null.
+   * <b>NOTE:</b> the merge scheduler must not be null.
    *
    * <p>Only takes effect when IndexWriter is first created. */
   public IndexWriterConfig setMergeScheduler(MergeScheduler mergeScheduler) {
diff --git a/lucene/core/src/java/org/apache/lucene/index/PointValuesWriter.java b/lucene/core/src/java/org/apache/lucene/index/PointValuesWriter.java
index f259c5b..e3d1c1d 100644
--- a/lucene/core/src/java/org/apache/lucene/index/PointValuesWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/index/PointValuesWriter.java
@@ -48,7 +48,7 @@ class PointValuesWriter {
   // TODO: if exactly the same value is added to exactly the same doc, should we dedup?
   public void addPackedValue(int docID, BytesRef value) {
     if (value == null) {
-      throw new IllegalArgumentException("field=" + fieldInfo.name + ": point value cannot be null");
+      throw new IllegalArgumentException("field=" + fieldInfo.name + ": point value must not be null");
     }
     if (value.length != fieldInfo.getPointDimensionCount() * fieldInfo.getPointNumBytes()) {
       throw new IllegalArgumentException("field=" + fieldInfo.name + ": this field's value has length=" + value.length + " but should be " + (fieldInfo.getPointDimensionCount() * fieldInfo.getPointNumBytes()));
diff --git a/lucene/core/src/java/org/apache/lucene/search/PrefixQuery.java b/lucene/core/src/java/org/apache/lucene/search/PrefixQuery.java
index 207a143..f4b5e50 100644
--- a/lucene/core/src/java/org/apache/lucene/search/PrefixQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/PrefixQuery.java
@@ -35,7 +35,7 @@ public class PrefixQuery extends AutomatonQuery {
     // It's OK to pass unlimited maxDeterminizedStates: the automaton is born small and determinized:
     super(prefix, toAutomaton(prefix.bytes()), Integer.MAX_VALUE, true);
     if (prefix == null) {
-      throw new NullPointerException("prefix cannot be null");
+      throw new NullPointerException("prefix must not be null");
     }
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/ReferenceManager.java b/lucene/core/src/java/org/apache/lucene/search/ReferenceManager.java
index 6ecf81b..c3487ad 100644
--- a/lucene/core/src/java/org/apache/lucene/search/ReferenceManager.java
+++ b/lucene/core/src/java/org/apache/lucene/search/ReferenceManager.java
@@ -291,7 +291,7 @@ public abstract class ReferenceManager<G> implements Closeable {
    */
   public void addListener(RefreshListener listener) {
     if (listener == null) {
-      throw new NullPointerException("Listener cannot be null");
+      throw new NullPointerException("Listener must not be null");
     }
     refreshListeners.add(listener);
   }
@@ -301,7 +301,7 @@ public abstract class ReferenceManager<G> implements Closeable {
    */
   public void removeListener(RefreshListener listener) {
     if (listener == null) {
-      throw new NullPointerException("Listener cannot be null");
+      throw new NullPointerException("Listener must not be null");
     }
     refreshListeners.remove(listener);
   }
diff --git a/lucene/core/src/java/org/apache/lucene/store/BaseDirectory.java b/lucene/core/src/java/org/apache/lucene/store/BaseDirectory.java
index a5fff24..709eb2c 100644
--- a/lucene/core/src/java/org/apache/lucene/store/BaseDirectory.java
+++ b/lucene/core/src/java/org/apache/lucene/store/BaseDirectory.java
@@ -35,7 +35,7 @@ public abstract class BaseDirectory extends Directory {
   protected BaseDirectory(LockFactory lockFactory) {
     super();
     if (lockFactory == null) {
-      throw new NullPointerException("LockFactory cannot be null, use an explicit instance!");
+      throw new NullPointerException("LockFactory must not be null, use an explicit instance!");
     }
     this.lockFactory = lockFactory;
   }
diff --git a/lucene/core/src/java/org/apache/lucene/util/CommandLineUtil.java b/lucene/core/src/java/org/apache/lucene/util/CommandLineUtil.java
index c4b2277..952e2c7 100644
--- a/lucene/core/src/java/org/apache/lucene/util/CommandLineUtil.java
+++ b/lucene/core/src/java/org/apache/lucene/util/CommandLineUtil.java
@@ -96,7 +96,7 @@ public final class CommandLineUtil {
   private static String adjustDirectoryClassName(String clazzName) {
     if (clazzName == null || clazzName.trim().length() == 0) {
       throw new IllegalArgumentException("The " + FSDirectory.class.getSimpleName()
-          + " implementation cannot be null or empty");
+          + " implementation must not be null or empty");
     }
     
     if (clazzName.indexOf(".") == -1) {// if not fully qualified, assume .store
diff --git a/lucene/core/src/java/org/apache/lucene/util/UnicodeUtil.java b/lucene/core/src/java/org/apache/lucene/util/UnicodeUtil.java
index 1a8022d..a21281f 100644
--- a/lucene/core/src/java/org/apache/lucene/util/UnicodeUtil.java
+++ b/lucene/core/src/java/org/apache/lucene/util/UnicodeUtil.java
@@ -449,7 +449,7 @@ public final class UnicodeUtil {
    *    content is prematurely truncated.
    */
   public static int UTF8toUTF32(final BytesRef utf8, final int[] ints) {
-    // TODO: ints cannot be null, should be an assert
+    // TODO: ints must not be null, should be an assert
     int utf32Count = 0;
     int utf8Upto = utf8.offset;
     final byte[] bytes = utf8.bytes;
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/range/Range.java b/lucene/facet/src/java/org/apache/lucene/facet/range/Range.java
index 2273831..5f6de98 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/range/Range.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/range/Range.java
@@ -31,7 +31,7 @@ public abstract class Range {
   /** Sole constructor. */
   protected Range(String label) {
     if (label == null) {
-      throw new NullPointerException("label cannot be null");
+      throw new NullPointerException("label must not be null");
     }
     this.label = label;
   }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader.java
index dee967e..c72e60b 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader.java
@@ -178,7 +178,7 @@ public class DirectoryTaxonomyReader extends TaxonomyReader {
             recreated = true;
           }
         } else if (!t1.equals(t2)) {
-          // t1 != null and t2 cannot be null b/c DirTaxoWriter always puts the commit data.
+          // t1 != null and t2 must not be null b/c DirTaxoWriter always puts the commit data.
           // it's ok to use String.equals because we require the two epoch values to be the same.
           recreated = true;
         }
diff --git a/lucene/highlighter/src/java/org/apache/lucene/search/postingshighlight/PostingsHighlighter.java b/lucene/highlighter/src/java/org/apache/lucene/search/postingshighlight/PostingsHighlighter.java
index 3c0a428..e4d3667 100644
--- a/lucene/highlighter/src/java/org/apache/lucene/search/postingshighlight/PostingsHighlighter.java
+++ b/lucene/highlighter/src/java/org/apache/lucene/search/postingshighlight/PostingsHighlighter.java
@@ -465,7 +465,7 @@ public class PostingsHighlighter {
 
     PassageFormatter fieldFormatter = getFormatter(field);
     if (fieldFormatter == null) {
-      throw new NullPointerException("PassageFormatter cannot be null");
+      throw new NullPointerException("PassageFormatter must not be null");
     }
     
     // check if we should do any multiterm processing
@@ -550,7 +550,7 @@ public class PostingsHighlighter {
       TermsEnum termsEnum, PostingsEnum[] postings, int n) throws IOException {
     PassageScorer scorer = getScorer(field);
     if (scorer == null) {
-      throw new NullPointerException("PassageScorer cannot be null");
+      throw new NullPointerException("PassageScorer must not be null");
     }
     PriorityQueue<OffsetsEnum> pq = new PriorityQueue<>();
     float weights[] = new float[terms.length];
diff --git a/lucene/misc/src/java/org/apache/lucene/store/WindowsDirectory.cpp b/lucene/misc/src/java/org/apache/lucene/store/WindowsDirectory.cpp
index e6063b9..416aed9 100644
--- a/lucene/misc/src/java/org/apache/lucene/store/WindowsDirectory.cpp
+++ b/lucene/misc/src/java/org/apache/lucene/store/WindowsDirectory.cpp
@@ -67,7 +67,7 @@ JNIEXPORT jlong JNICALL Java_org_apache_lucene_store_WindowsDirectory_open
   HANDLE handle;
   
   if (filename == NULL) {
-    throwException(env, "java/lang/NullPointerException", "filename cannot be null");
+    throwException(env, "java/lang/NullPointerException", "filename must not be null");
     return -1;
   }
   
@@ -109,7 +109,7 @@ JNIEXPORT jint JNICALL Java_org_apache_lucene_store_WindowsDirectory_read
   io.OffsetHigh = (DWORD) ((pos >> 0x20) & 0x7FFFFFFF);
   
   if (bytes == NULL) {
-    throwException(env, "java/lang/NullPointerException", "bytes cannot be null");
+    throwException(env, "java/lang/NullPointerException", "bytes must not be null");
     return -1;
   }
   
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java
index d0a371c..c00d88e 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java
@@ -342,7 +342,7 @@ public abstract class QueryParserBase extends QueryBuilder implements CommonQuer
    */
   public void setDateResolution(String fieldName, DateTools.Resolution dateResolution) {
     if (fieldName == null) {
-      throw new IllegalArgumentException("Field cannot be null.");
+      throw new IllegalArgumentException("Field must not be null.");
     }
 
     if (fieldToDateResolution == null) {
@@ -361,7 +361,7 @@ public abstract class QueryParserBase extends QueryBuilder implements CommonQuer
    */
   public DateTools.Resolution getDateResolution(String fieldName) {
     if (fieldName == null) {
-      throw new IllegalArgumentException("Field cannot be null.");
+      throw new IllegalArgumentException("Field must not be null.");
     }
 
     if (fieldToDateResolution == null) {
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/config/AbstractQueryConfig.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/config/AbstractQueryConfig.java
index e60f931..bfbde4d 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/config/AbstractQueryConfig.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/config/AbstractQueryConfig.java
@@ -51,7 +51,7 @@ public abstract class AbstractQueryConfig {
   public <T> T get(ConfigurationKey<T> key) {
     
     if (key == null) {
-      throw new IllegalArgumentException("key cannot be null!");
+      throw new IllegalArgumentException("key must not be null!");
     }
     
     return (T) this.configMap.get(key);
@@ -68,7 +68,7 @@ public abstract class AbstractQueryConfig {
   public <T> boolean has(ConfigurationKey<T> key) {
     
     if (key == null) {
-      throw new IllegalArgumentException("key cannot be null!");
+      throw new IllegalArgumentException("key must not be null!");
     }
     
     return this.configMap.containsKey(key);
@@ -85,7 +85,7 @@ public abstract class AbstractQueryConfig {
   public <T> void set(ConfigurationKey<T> key, T value) {
     
     if (key == null) {
-      throw new IllegalArgumentException("key cannot be null!");
+      throw new IllegalArgumentException("key must not be null!");
     }
     
     if (value == null) {
@@ -107,7 +107,7 @@ public abstract class AbstractQueryConfig {
   public <T> boolean unset(ConfigurationKey<T> key) {
     
     if (key == null) {
-      throw new IllegalArgumentException("key cannot be null!");
+      throw new IllegalArgumentException("key must not be null!");
     }
     
     return this.configMap.remove(key) != null;
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/config/FieldConfig.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/config/FieldConfig.java
index c8604d1..fae6f9f 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/config/FieldConfig.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/config/FieldConfig.java
@@ -26,13 +26,13 @@ public class FieldConfig extends AbstractQueryConfig {
   /**
    * Constructs a {@link FieldConfig}
    * 
-   * @param fieldName the field name, it cannot be null
+   * @param fieldName the field name, it must not be null
    * @throws IllegalArgumentException if the field name is null
    */
   public FieldConfig(String fieldName) {
 
     if (fieldName == null) {
-      throw new IllegalArgumentException("field name should not be null!");
+      throw new IllegalArgumentException("field name must not be null!");
     }
 
     this.fieldName = fieldName;
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/LegacyNumericConfig.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/LegacyNumericConfig.java
index 985f55a..6cd3c49 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/LegacyNumericConfig.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/LegacyNumericConfig.java
@@ -113,7 +113,7 @@ public class LegacyNumericConfig {
   public void setType(LegacyNumericType type) {
     
     if (type == null) {
-      throw new IllegalArgumentException("type cannot be null!");
+      throw new IllegalArgumentException("type must not be null!");
     }
     
     this.type = type;
@@ -126,12 +126,12 @@ public class LegacyNumericConfig {
    * 
    * @param format
    *          the {@link NumberFormat} used to parse a {@link String} to
-   *          {@link Number}, cannot be <code>null</code>
+   *          {@link Number}, must not be <code>null</code>
    */
   public void setNumberFormat(NumberFormat format) {
     
     if (format == null) {
-      throw new IllegalArgumentException("format cannot be null!");
+      throw new IllegalArgumentException("format must not be null!");
     }
     
     this.format = format;
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/LegacyNumericFieldConfigListener.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/LegacyNumericFieldConfigListener.java
index f2d3124..e5ba9da 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/LegacyNumericFieldConfigListener.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/LegacyNumericFieldConfigListener.java
@@ -48,7 +48,7 @@ public class LegacyNumericFieldConfigListener implements FieldConfigListener {
   public LegacyNumericFieldConfigListener(QueryConfigHandler config) {
     
     if (config == null) {
-      throw new IllegalArgumentException("config cannot be null!");
+      throw new IllegalArgumentException("config must not be null!");
     }
     
     this.config = config;
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/PointsConfig.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/PointsConfig.java
index db59b48..4123982 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/PointsConfig.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/PointsConfig.java
@@ -76,7 +76,7 @@ public class PointsConfig {
    */
   public void setType(Class<? extends Number> type) {
     if (type == null) {
-      throw new IllegalArgumentException("type cannot be null!");
+      throw new IllegalArgumentException("type must not be null!");
     }
     if (Integer.class.equals(type) == false &&
         Long.class.equals(type) == false &&
@@ -93,11 +93,11 @@ public class PointsConfig {
    * 
    * @param format
    *          the {@link NumberFormat} used to parse a {@link String} to
-   *          {@link Number}, cannot be <code>null</code>
+   *          {@link Number}, must not be <code>null</code>
    */
   public void setNumberFormat(NumberFormat format) {    
     if (format == null) {
-      throw new IllegalArgumentException("format cannot be null!");
+      throw new IllegalArgumentException("format must not be null!");
     } 
     this.format = format;
   }
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/PointsConfigListener.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/PointsConfigListener.java
index 9efbbb7..e7b5185 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/PointsConfigListener.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/PointsConfigListener.java
@@ -45,7 +45,7 @@ public class PointsConfigListener implements FieldConfigListener {
    */
   public PointsConfigListener(QueryConfigHandler config) { 
     if (config == null) {
-      throw new IllegalArgumentException("config cannot be null!");
+      throw new IllegalArgumentException("config must not be null!");
     }
     this.config = config;
   }
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/LegacyNumericRangeQueryNode.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/LegacyNumericRangeQueryNode.java
index 088ab98..27c285e 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/LegacyNumericRangeQueryNode.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/LegacyNumericRangeQueryNode.java
@@ -88,7 +88,7 @@ public class LegacyNumericRangeQueryNode extends
       boolean lowerInclusive, boolean upperInclusive, LegacyNumericConfig numericConfig) throws QueryNodeException {
     
     if (numericConfig == null) {
-      throw new IllegalArgumentException("numericConfig cannot be null!");
+      throw new IllegalArgumentException("numericConfig must not be null!");
     }
     
     LegacyNumericType lowerNumberType, upperNumberType;
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/PointRangeQueryNode.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/PointRangeQueryNode.java
index cb838fc..3611ebf 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/PointRangeQueryNode.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/PointRangeQueryNode.java
@@ -62,7 +62,7 @@ public class PointRangeQueryNode extends AbstractRangeQueryNode<PointQueryNode>
       boolean lowerInclusive, boolean upperInclusive, PointsConfig pointsConfig) throws QueryNodeException {
     
     if (pointsConfig == null) {
-      throw new IllegalArgumentException("pointsConfig cannot be null!");
+      throw new IllegalArgumentException("pointsConfig must not be null!");
     }
     
     Class<? extends Number> lowerNumberType, upperNumberType;
diff --git a/lucene/replicator/src/java/org/apache/lucene/replicator/RevisionFile.java b/lucene/replicator/src/java/org/apache/lucene/replicator/RevisionFile.java
index 7d3d4b7..2ca5205 100644
--- a/lucene/replicator/src/java/org/apache/lucene/replicator/RevisionFile.java
+++ b/lucene/replicator/src/java/org/apache/lucene/replicator/RevisionFile.java
@@ -34,7 +34,7 @@ public class RevisionFile {
   /** Constructor with the given file name. */
   public RevisionFile(String fileName) {
     if (fileName == null || fileName.isEmpty()) {
-      throw new IllegalArgumentException("fileName cannot be null or empty");
+      throw new IllegalArgumentException("fileName must not be null or empty");
     }
     this.fileName = fileName;
   }
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/BigIntegerPoint.java b/lucene/sandbox/src/java/org/apache/lucene/document/BigIntegerPoint.java
index efbb37c..4dc50d1 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/BigIntegerPoint.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/document/BigIntegerPoint.java
@@ -85,10 +85,10 @@ public class BigIntegerPoint extends Field {
 
   private static BytesRef pack(BigInteger... point) {
     if (point == null) {
-      throw new IllegalArgumentException("point cannot be null");
+      throw new IllegalArgumentException("point must not be null");
     }
     if (point.length == 0) {
-      throw new IllegalArgumentException("point cannot be 0 dimensions");
+      throw new IllegalArgumentException("point must not be 0 dimensions");
     }
     byte[] packed = new byte[point.length * BYTES];
     
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/InetAddressPoint.java b/lucene/sandbox/src/java/org/apache/lucene/document/InetAddressPoint.java
index c0739a4..7ebabab 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/InetAddressPoint.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/document/InetAddressPoint.java
@@ -68,7 +68,7 @@ public class InetAddressPoint extends Field {
   /** Change the values of this field */
   public void setInetAddressValue(InetAddress value) {
     if (value == null) {
-      throw new IllegalArgumentException("point cannot be null");
+      throw new IllegalArgumentException("point must not be null");
     }
     fieldsData = new BytesRef(encode(value));
   }
@@ -165,7 +165,7 @@ public class InetAddressPoint extends Field {
    */
   public static Query newPrefixQuery(String field, InetAddress value, int prefixLength) {
     if (value == null) {
-      throw new IllegalArgumentException("InetAddress cannot be null");
+      throw new IllegalArgumentException("InetAddress must not be null");
     }
     if (prefixLength < 0 || prefixLength > 8 * value.getAddress().length) {
       throw new IllegalArgumentException("illegal prefixLength '" + prefixLength + "'. Must be 0-32 for IPv4 ranges, 0-128 for IPv6 ranges");
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint.java b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint.java
index 1278ea5..60e8300 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint.java
@@ -236,7 +236,7 @@ public class LatLonPoint extends Field {
    * Create a query for matching a bounding box.
    * <p>
    * The box may cross over the dateline.
-   * @param field field name. cannot be null.
+   * @param field field name. must not be null.
    * @param minLatitude latitude lower bound: must be within standard +/-90 coordinate bounds.
    * @param maxLatitude latitude upper bound: must be within standard +/-90 coordinate bounds.
    * @param minLongitude longitude lower bound: must be within standard +/-180 coordinate bounds.
@@ -288,7 +288,7 @@ public class LatLonPoint extends Field {
   
   /**
    * Create a query for matching points within the specified distance of the supplied location.
-   * @param field field name. cannot be null.
+   * @param field field name. must not be null.
    * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.
    * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.
    * @param radiusMeters maximum distance from the center in meters: must be non-negative and finite.
@@ -303,7 +303,7 @@ public class LatLonPoint extends Field {
    * Create a query for matching a polygon.
    * <p>
    * The supplied {@code polyLats}/{@code polyLons} must be clockwise or counter-clockwise.
-   * @param field field name. cannot be null.
+   * @param field field name. must not be null.
    * @param polyLats latitude values for points of the polygon: must be within standard +/-90 coordinate bounds.
    * @param polyLons longitude values for points of the polygon: must be within standard +/-180 coordinate bounds.
    * @return query matching points within this polygon
@@ -327,7 +327,7 @@ public class LatLonPoint extends Field {
    * <p>
    * If a document contains multiple values for the field, the <i>closest</i> distance to the location is used.
    * 
-   * @param field field name. cannot be null.
+   * @param field field name. must not be null.
    * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.
    * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.
    * @return SortField ordering documents by distance
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery.java b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery.java
index c283c7e..1a9a11a 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery.java
@@ -56,7 +56,7 @@ final class LatLonPointDistanceQuery extends Query {
 
   public LatLonPointDistanceQuery(String field, double latitude, double longitude, double radiusMeters) {
     if (field == null) {
-      throw new IllegalArgumentException("field cannot be null");
+      throw new IllegalArgumentException("field must not be null");
     }
     if (Double.isFinite(radiusMeters) == false || radiusMeters < 0) {
       throw new IllegalArgumentException("radiusMeters: '" + radiusMeters + "' is invalid");
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery.java b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery.java
index c263ba3..454a3dd 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery.java
@@ -40,6 +40,7 @@ import org.apache.lucene.util.BitSet;
 import org.apache.lucene.util.DocIdSetBuilder;
 import org.apache.lucene.util.FixedBitSet;
 import org.apache.lucene.util.SparseFixedBitSet;
+import org.apache.lucene.spatial.util.GeoRect;
 import org.apache.lucene.spatial.util.GeoRelationUtils;
 import org.apache.lucene.spatial.util.GeoUtils;
 
@@ -60,52 +61,20 @@ final class LatLonPointInPolygonQuery extends Query {
 
   /** The lats/lons must be clockwise or counter-clockwise. */
   public LatLonPointInPolygonQuery(String field, double[] polyLats, double[] polyLons) {
-    this.field = field;
     if (field == null) {
-      throw new IllegalArgumentException("field cannot be null");
-    }
-    if (polyLats == null) {
-      throw new IllegalArgumentException("polyLats cannot be null");
-    }
-    if (polyLons == null) {
-      throw new IllegalArgumentException("polyLons cannot be null");
-    }
-    if (polyLats.length != polyLons.length) {
-      throw new IllegalArgumentException("polyLats and polyLons must be equal length");
-    }
-    if (polyLats.length < 4) {
-      throw new IllegalArgumentException("at least 4 polygon points required");
-    }
-    if (polyLats[0] != polyLats[polyLats.length-1]) {
-      throw new IllegalArgumentException("first and last points of the polygon must be the same (it must close itself): polyLats[0]=" + polyLats[0] + " polyLats[" + (polyLats.length-1) + "]=" + polyLats[polyLats.length-1]);
+      throw new IllegalArgumentException("field must not be null");
     }
-    if (polyLons[0] != polyLons[polyLons.length-1]) {
-      throw new IllegalArgumentException("first and last points of the polygon must be the same (it must close itself): polyLons[0]=" + polyLons[0] + " polyLons[" + (polyLons.length-1) + "]=" + polyLons[polyLons.length-1]);
-    }
-
+    GeoUtils.checkPolygon(polyLats,  polyLons);
+    this.field = field;
     this.polyLats = polyLats;
     this.polyLons = polyLons;
 
     // TODO: we could also compute the maximal inner bounding box, to make relations faster to compute?
-
-    double minLon = Double.POSITIVE_INFINITY;
-    double minLat = Double.POSITIVE_INFINITY;
-    double maxLon = Double.NEGATIVE_INFINITY;
-    double maxLat = Double.NEGATIVE_INFINITY;
-    for(int i=0;i<polyLats.length;i++) {
-      double lat = polyLats[i];
-      GeoUtils.checkLatitude(lat);
-      minLat = Math.min(minLat, lat);
-      maxLat = Math.max(maxLat, lat);
-      double lon = polyLons[i];
-      GeoUtils.checkLongitude(lon);
-      minLon = Math.min(minLon, lon);
-      maxLon = Math.max(maxLon, lon);
-    }
-    this.minLon = minLon;
-    this.maxLon = maxLon;
-    this.minLat = minLat;
-    this.maxLat = maxLat;
+    GeoRect box = GeoUtils.polyToBBox(polyLats, polyLons);
+    this.minLon = box.minLon;
+    this.maxLon = box.maxLon;
+    this.minLat = box.minLat;
+    this.maxLat = box.maxLat;
   }
 
   @Override
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointSortField.java b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointSortField.java
index ea1541d..7091229 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointSortField.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointSortField.java
@@ -32,7 +32,7 @@ final class LatLonPointSortField extends SortField {
   LatLonPointSortField(String field, double latitude, double longitude) {
     super(field, SortField.Type.CUSTOM);
     if (field == null) {
-      throw new IllegalArgumentException("field cannot be null");
+      throw new IllegalArgumentException("field must not be null");
     }
     GeoUtils.checkLatitude(latitude);
     GeoUtils.checkLongitude(longitude);
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/DocValuesRangeQuery.java b/lucene/sandbox/src/java/org/apache/lucene/search/DocValuesRangeQuery.java
index b1aca4b..97b199a 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/DocValuesRangeQuery.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/DocValuesRangeQuery.java
@@ -141,7 +141,7 @@ public final class DocValuesRangeQuery extends Query {
   @Override
   public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
     if (lowerVal == null && upperVal == null) {
-      throw new IllegalStateException("Both min and max values cannot be null, call rewrite first");
+      throw new IllegalStateException("Both min and max values must not be null, call rewrite first");
     }
     return new RandomAccessWeight(DocValuesRangeQuery.this) {
       
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQuery.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQuery.java
index 65a12d6..4229b28 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQuery.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQuery.java
@@ -72,10 +72,10 @@ public class GeoPointInBBoxQuery extends Query {
    */
   public GeoPointInBBoxQuery(final String field, final TermEncoding termEncoding, final double minLat, final double maxLat, final double minLon, final double maxLon) {
     if (field == null) {
-      throw new IllegalArgumentException("field cannot be null");
+      throw new IllegalArgumentException("field must not be null");
     }
     if (termEncoding == null) {
-      throw new IllegalArgumentException("termEncoding cannot be null");
+      throw new IllegalArgumentException("termEncoding must not be null");
     }
     GeoUtils.checkLatitude(minLat);
     GeoUtils.checkLatitude(maxLat);
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQuery.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQuery.java
index f43aaf2..e75030c 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQuery.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQuery.java
@@ -71,19 +71,7 @@ public final class GeoPointInPolygonQuery extends GeoPointInBBoxQuery {
   /** Common constructor, used only internally. */
   private GeoPointInPolygonQuery(final String field, TermEncoding termEncoding, GeoRect bbox, final double[] polyLats, final double[] polyLons) {
     super(field, termEncoding, bbox.minLat, bbox.maxLat, bbox.minLon, bbox.maxLon);
-    if (polyLats.length != polyLons.length) {
-      throw new IllegalArgumentException("polyLats and polyLons must be equal length");
-    }
-    if (polyLats.length < 4) {
-      throw new IllegalArgumentException("at least 4 polygon points required");
-    }
-    if (polyLats[0] != polyLats[polyLats.length-1]) {
-      throw new IllegalArgumentException("first and last points of the polygon must be the same (it must close itself): polyLats[0]=" + polyLats[0] + " polyLats[" + (polyLats.length-1) + "]=" + polyLats[polyLats.length-1]);
-    }
-    if (polyLons[0] != polyLons[polyLons.length-1]) {
-      throw new IllegalArgumentException("first and last points of the polygon must be the same (it must close itself): polyLons[0]=" + polyLons[0] + " polyLons[" + (polyLons.length-1) + "]=" + polyLons[polyLons.length-1]);
-    }
-
+    GeoUtils.checkPolygon(polyLats,  polyLons);
     this.polyLons = polyLons;
     this.polyLats = polyLats;
   }
@@ -111,8 +99,8 @@ public final class GeoPointInPolygonQuery extends GeoPointInBBoxQuery {
   @Override
   public int hashCode() {
     int result = super.hashCode();
-    result = 31 * result + (polyLats != null ? Arrays.hashCode(polyLats) : 0);
-    result = 31 * result + (polyLons != null ? Arrays.hashCode(polyLons) : 0);
+    result = 31 * result + Arrays.hashCode(polyLats);
+    result = 31 * result + Arrays.hashCode(polyLons);
     return result;
   }
 
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoUtils.java b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoUtils.java
index faa3815..ecb5046 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoUtils.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoUtils.java
@@ -24,7 +24,6 @@ import static org.apache.lucene.util.SloppyMath.asin;
 import static org.apache.lucene.util.SloppyMath.cos;
 import static org.apache.lucene.util.SloppyMath.TO_DEGREES;
 import static org.apache.lucene.util.SloppyMath.TO_RADIANS;
-import static org.apache.lucene.spatial.util.GeoEncodingUtils.TOLERANCE;
 
 /**
  * Basic reusable geo-spatial utility methods
@@ -74,6 +73,37 @@ public final class GeoUtils {
       throw new IllegalArgumentException("invalid longitude " +  longitude + "; must be between " + MIN_LON_INCL + " and " + MAX_LON_INCL);
     }
   }
+  
+  /** validates polygon values are within standard +/-180 coordinate bounds, same
+   *  number of latitude and longitude, and is closed
+   */
+  public static void checkPolygon(double[] polyLats, double[] polyLons) {
+    if (polyLats == null) {
+      throw new IllegalArgumentException("polyLats must not be null");
+    }
+    if (polyLons == null) {
+      throw new IllegalArgumentException("polyLons must not be null");
+    }
+    if (polyLats.length != polyLons.length) {
+      throw new IllegalArgumentException("polyLats and polyLons must be equal length");
+    }
+    if (polyLats.length != polyLons.length) {
+      throw new IllegalArgumentException("polyLats and polyLons must be equal length");
+    }
+    if (polyLats.length < 4) {
+      throw new IllegalArgumentException("at least 4 polygon points required");
+    }
+    if (polyLats[0] != polyLats[polyLats.length-1]) {
+      throw new IllegalArgumentException("first and last points of the polygon must be the same (it must close itself): polyLats[0]=" + polyLats[0] + " polyLats[" + (polyLats.length-1) + "]=" + polyLats[polyLats.length-1]);
+    }
+    if (polyLons[0] != polyLons[polyLons.length-1]) {
+      throw new IllegalArgumentException("first and last points of the polygon must be the same (it must close itself): polyLons[0]=" + polyLons[0] + " polyLons[" + (polyLons.length-1) + "]=" + polyLons[polyLons.length-1]);
+    }
+    for (int i = 0; i < polyLats.length; i++) {
+      checkLatitude(polyLats[i]);
+      checkLongitude(polyLons[i]);
+    }
+  }
 
   /** Compute Bounding Box for a circle using WGS-84 parameters */
   public static GeoRect circleToBBox(final double centerLat, final double centerLon, final double radiusMeters) {
@@ -108,9 +138,7 @@ public final class GeoUtils {
 
   /** Compute Bounding Box for a polygon using WGS-84 parameters */
   public static GeoRect polyToBBox(double[] polyLats, double[] polyLons) {
-    if (polyLats.length != polyLons.length) {
-      throw new IllegalArgumentException("polyLats and polyLons must be equal length");
-    }
+    checkPolygon(polyLats, polyLons);
 
     double minLon = Double.POSITIVE_INFINITY;
     double maxLon = Double.NEGATIVE_INFINITY;
@@ -118,16 +146,12 @@ public final class GeoUtils {
     double maxLat = Double.NEGATIVE_INFINITY;
 
     for (int i=0;i<polyLats.length;i++) {
-      checkLatitude(polyLats[i]);
-      checkLongitude(polyLons[i]);
       minLat = min(polyLats[i], minLat);
       maxLat = max(polyLats[i], maxLat);
       minLon = min(polyLons[i], minLon);
       maxLon = max(polyLons[i], maxLon);
     }
-    // expand bounding box by TOLERANCE factor to handle round-off error
-    return new GeoRect(max(minLat - TOLERANCE, MIN_LAT_INCL), min(maxLat + TOLERANCE, MAX_LAT_INCL),
-                       max(minLon - TOLERANCE, MIN_LON_INCL), min(maxLon + TOLERANCE, MAX_LON_INCL));
+    return new GeoRect(minLat, maxLat, minLon, maxLon);
   }
   
   // some sloppyish stuff, do we really need this to be done in a sloppy way?
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase.java b/lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase.java
index 8b71236..5958910 100644
--- a/lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase.java
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase.java
@@ -186,7 +186,14 @@ public abstract class BaseGeoPointTestCase extends LuceneTestCase {
     writer.close();
     dir.close();
   }
-  
+
+  /** null field name not allowed */
+  public void testBoxNull() {
+    IllegalArgumentException expected = expectThrows(IllegalArgumentException.class, () -> {
+      newRectQuery(null, 18, 19, -66, -65);
+    });
+    assertTrue(expected.getMessage().contains("field must not be null"));
+  }
 
   // box should not accept invalid lat/lon
   public void testBoxInvalidCoordinates() throws Exception {
@@ -215,12 +222,21 @@ public abstract class BaseGeoPointTestCase extends LuceneTestCase {
     dir.close();
   }
   
+  /** null field name not allowed */
+  public void testDistanceNull() {
+    IllegalArgumentException expected = expectThrows(IllegalArgumentException.class, () -> {
+      newDistanceQuery(null, 18, -65, 50_000);
+    });
+    assertTrue(expected.getMessage().contains("field must not be null"));
+  }
+  
   /** distance query should not accept invalid lat/lon as origin */
   public void testDistanceIllegal() throws Exception {
     expectThrows(Exception.class, () -> {
       newDistanceQuery("field", 92.0, 181.0, 120000);
     });
   }
+
   /** negative distance queries are not allowed */
   public void testDistanceNegative() {
     IllegalArgumentException expected = expectThrows(IllegalArgumentException.class, () -> {
@@ -277,6 +293,66 @@ public abstract class BaseGeoPointTestCase extends LuceneTestCase {
     writer.close();
     dir.close();
   }
+  
+  /** null field name not allowed */
+  public void testPolygonNullField() {
+    IllegalArgumentException expected = expectThrows(IllegalArgumentException.class, () -> {
+      newPolygonQuery(null, 
+          new double[] { 18, 18, 19, 19, 18 },
+          new double[] { -66, -65, -65, -66, -66 });
+    });
+    assertTrue(expected.getMessage().contains("field must not be null"));
+  }
+  
+  /** null polyLats not allowed */
+  public void testPolygonNullPolyLats() {
+    IllegalArgumentException expected = expectThrows(IllegalArgumentException.class, () -> {
+      newPolygonQuery("test", 
+          null,
+          new double[] { -66, -65, -65, -66, -66 });
+    });
+    assertTrue(expected.getMessage().contains("polyLats must not be null"));
+  }
+  
+  /** null polyLons not allowed */
+  public void testPolygonNullPolyLons() {
+    IllegalArgumentException expected = expectThrows(IllegalArgumentException.class, () -> {
+      newPolygonQuery("test", 
+          new double[] { 18, 18, 19, 19, 18 },
+          null);
+    });
+    assertTrue(expected.getMessage().contains("polyLons must not be null"));
+  }
+  
+  /** polygon needs at least 3 vertices */
+  public void testPolygonLine() {
+    IllegalArgumentException expected = expectThrows(IllegalArgumentException.class, () -> {
+      newPolygonQuery("test", 
+          new double[] { 18, 18, 18  },
+          new double[] { -66, -65, -66 });
+    });
+    assertTrue(expected.getMessage().contains("at least 4 polygon points required"));
+  }
+  
+  /** polygon needs same number of latitudes as longitudes */
+  public void testPolygonBogus() {
+    IllegalArgumentException expected = expectThrows(IllegalArgumentException.class, () -> {
+      newPolygonQuery("test", 
+          new double[] { 18, 18, 19, 19 },
+          new double[] { -66, -65, -65, -66, -66 });
+    });
+    assertTrue(expected.getMessage().contains("must be equal length"));
+  }
+  
+  /** polygon must be closed */
+  public void testPolygonNotClosed() {
+    IllegalArgumentException expected = expectThrows(IllegalArgumentException.class, () -> {
+      newPolygonQuery("test", 
+          new double[] { 18, 18, 19, 19, 19 },
+          new double[] { -66, -65, -65, -66, -67 });
+    });
+    assertTrue(expected.getMessage(), expected.getMessage().contains("it must close itself"));
+  }
 
   // A particularly tricky adversary for BKD tree:
   public void testSamePointManyTimes() throws Exception {
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils.java b/lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils.java
index 98867c6..f6fb139 100644
--- a/lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils.java
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils.java
@@ -284,4 +284,40 @@ public class TestGeoUtils extends LuceneTestCase {
     assertFalse(GeoRelationUtils.rectCrossesPolyApprox(0, 5, -5, 0.000001, py, px, yMin, yMax, xMin, xMax));
     assertTrue(GeoRelationUtils.rectWithinPolyApprox(0, 5, -5, -2, py, px, yMin, yMax, xMin, xMax));
   }
+  
+  public void testPolyToBBox() throws Exception {
+    for (int i = 0; i < 1000; i++) {
+      double[][] polygon = GeoTestUtil.nextPolygon();
+      GeoRect box = GeoUtils.polyToBBox(polygon[0], polygon[1]);
+      assertFalse(box.crossesDateline());
+      
+      for (int j = 0; j < 1000; j++) {
+        double latitude = GeoTestUtil.nextLatitude();
+        double longitude = GeoTestUtil.nextLongitude();
+        // if the point is within poly, then it should be in our bounding box
+        if (GeoRelationUtils.pointInPolygon(polygon[0], polygon[1], latitude, longitude)) {
+          assertTrue(latitude >= box.minLat && latitude <= box.maxLat);
+          assertTrue(longitude >= box.minLon && longitude <= box.maxLon);
+        }
+      }
+    }
+  }
+  
+  public void testPolyToBBoxEdgeCases() throws Exception {
+    for (int i = 0; i < 1000; i++) {
+      double[][] polygon = GeoTestUtil.nextPolygon();
+      GeoRect box = GeoUtils.polyToBBox(polygon[0], polygon[1]);
+      assertFalse(box.crossesDateline());
+      
+      for (int j = 0; j < 1000; j++) {
+        double latitude = GeoTestUtil.nextLatitudeAround(box.minLat, box.maxLat);
+        double longitude = GeoTestUtil.nextLongitudeAround(box.minLon, box.maxLon);
+        // if the point is within poly, then it should be in our bounding box
+        if (GeoRelationUtils.pointInPolygon(polygon[0], polygon[1], latitude, longitude)) {
+          assertTrue(latitude >= box.minLat && latitude <= box.maxLat);
+          assertTrue(longitude >= box.minLon && longitude <= box.maxLon);
+        }
+      }
+    }
+  }
 }

