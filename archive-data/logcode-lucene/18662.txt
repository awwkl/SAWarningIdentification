GitDiffStart: c8ad3e84b37b934b55f07e23d2fbdfd25de94c81 | Fri Dec 11 07:14:12 2009 +0000
diff --git a/build.xml b/build.xml
index c81ade1..5a372a9 100644
--- a/build.xml
+++ b/build.xml
@@ -529,8 +529,6 @@
   	
     <solr-jar destfile="${dist}/apache-solr-dataimporthandler-src-${version}.jar"
               basedir="contrib/dataimporthandler/src/main/java" />
-    <solr-jar destfile="${dist}/apache-solr-dataimporthandler-extras-src-${version}.jar"
-              basedir="contrib/dataimporthandler/src/extras/main/java" />
 
     <solr-jar destfile="${dist}/apache-solr-cell-src-${version}.jar"
               basedir="contrib/extraction/src" />
@@ -733,7 +731,6 @@
     <sign-maven-dependency-artifacts artifact.id="solr-commons-csv" gpg.passphrase="${gpg.passphrase}"/>
     <sign-maven-artifacts artifact.id="solr-core" gpg.passphrase="${gpg.passphrase}"/>
     <sign-maven-artifacts artifact.id="solr-dataimporthandler" gpg.passphrase="${gpg.passphrase}"/>
-    <sign-maven-artifacts artifact.id="solr-dataimporthandler-extras" gpg.passphrase="${gpg.passphrase}"/>
     <sign-maven-artifacts artifact.id="solr-clustering" gpg.passphrase="${gpg.passphrase}"/>
 
     <sign-maven-artifacts artifact.id="solr-cell" gpg.passphrase="${gpg.passphrase}"/>
@@ -797,15 +794,6 @@
         </artifact-attachments>
       </m2-deploy>
 
-      <m2-deploy pom.xml="contrib/dataimporthandler/solr-dataimporthandler-extras-pom.xml.template"
-                 jar.file="${dist}/apache-solr-dataimporthandler-extras-${version}.jar">
-
-        <artifact-attachments>
-          <attach file="${dist}/apache-solr-dataimporthandler-extras-src-${version}.jar" classifier="sources"/>
-          <attach file="${dist}/apache-solr-dataimporthandler-docs-${version}.jar" classifier="javadoc"/>
-        </artifact-attachments>
-      </m2-deploy>
-
       <m2-deploy pom.xml="contrib/extraction/solr-cell-pom.xml.template"
                  jar.file="${dist}/apache-solr-cell-${version}.jar">
         <artifact-attachments>
diff --git a/contrib/dataimporthandler/CHANGES.txt b/contrib/dataimporthandler/CHANGES.txt
index d1fb45d..e78a1d9 100644
--- a/contrib/dataimporthandler/CHANGES.txt
+++ b/contrib/dataimporthandler/CHANGES.txt
@@ -42,7 +42,7 @@ Other Changes
 
 Build
 ----------------------
-
+* SOLR-1643: Moved dataimporthandler extras into dataimporthandler core (shalin)
 
 Documentation
 ----------------------
diff --git a/contrib/dataimporthandler/build.xml b/contrib/dataimporthandler/build.xml
index b2832a7..aea55c0 100644
--- a/contrib/dataimporthandler/build.xml
+++ b/contrib/dataimporthandler/build.xml
@@ -37,17 +37,10 @@
   	<pathelement location="${solr-path}/build/solr" />
   	<pathelement location="${solr-path}/build/solrj" />
   	<fileset dir="${solr-path}/lib" includes="*.jar"/>
-  </path>
-
-  <path id="extras.classpath">
-  	<pathelement location="${solr-path}/build/solr" />
-  	<pathelement location="${solr-path}/build/solrj" />
-  	<pathelement location="target/classes" />
-  	<fileset dir="${solr-path}/lib" includes="*.jar"/>
-  	<fileset dir="lib/" includes="*.jar"/>
+    <fileset dir="lib/" includes="*.jar"/>
   	<fileset dir="${tikalibs-path}" includes="*.jar"/>
   </path>
-	
+
   <path id="test.classpath">
   	<path refid="common.classpath" />
   	<path refid="classpath.jetty" />
@@ -56,16 +49,6 @@
     <pathelement path="${java.class.path}"/>
   </path>
 
-  <path id="test.extras.classpath">
-  	<path refid="extras.classpath" />
-  	<path refid="classpath.jetty" />
-	  <pathelement path="target/classes" />
-	  <pathelement path="target/extras/classes" />
-  	<pathelement path="target/test-classes" />
-  	<pathelement path="target/extras/test-classes" />
-    <pathelement path="${java.class.path}"/>
-  </path>
-	
   <target name="clean">
   	<delete failonerror="false" dir="target"/>
     <delete failonerror="false">
@@ -94,18 +77,9 @@
     </solr-javac>
   </target>
 
-  <target name="compileExtras" depends="compile">
-    <solr-javac destdir="target/extras/classes"
-                classpathref="extras.classpath">
-      <src path="src/extras/main/java" />
-    </solr-javac>
-  </target>
-	
-  <target name="build" depends="compile,compileExtras">
+  <target name="build" depends="compile">
     <solr-jar destfile="target/${fullnamever}.jar" basedir="target/classes"
               manifest="${common.dir}/${dest}/META-INF/MANIFEST.MF" />
-    <solr-jar destfile="target/apache-${ant.project.name}-extras-${version}.jar" basedir="target/extras/classes"
-              manifest="${common.dir}/${dest}/META-INF/MANIFEST.MF" />
   </target>
 	
   <target name="compileTests" depends="compile">
@@ -115,16 +89,7 @@
   	</solr-javac>
   </target>
 
-  <target name="compileExtrasTests" depends="compileExtras">
-  	<solr-javac destdir="target/extras/test-classes"
-  	                classpathref="test.classpath">
-  	  <src path="src/extras/test/java" />
-  	</solr-javac>
-  </target>
-
-  <target  name="test" depends="testCore,testExtras"/>
-	
-  <target name="testCore" depends="compileTests">
+  <target name="test" depends="compileTests">
   	<mkdir dir="${junit.output.dir}"/>
   	
   	<junit printsummary="on"
@@ -147,29 +112,6 @@
     <fail if="tests.failed">Tests failed!</fail>
   </target>
 
-  <target name="testExtras" depends="compileExtrasTests">
-  	<mkdir dir="${junit.output.dir}"/>
-
-  	<junit printsummary="on"
-           haltonfailure="no"
-           errorProperty="tests.failed"
-           failureProperty="tests.failed"
-           dir="src/extras/test/resources/"
-           >
-      <formatter type="brief" usefile="false" if="junit.details"/>
-      <classpath refid="test.extras.classpath"/>
-      <formatter type="xml"/>
-      <batchtest fork="yes" todir="${junit.output.dir}" unless="testcase">
-        <fileset dir="src/extras/test/java" includes="${junit.includes}"/>
-      </batchtest>
-      <batchtest fork="yes" todir="${junit.output.dir}" if="testcase">
-        <fileset dir="src/extras/test/java" includes="**/${testcase}.java"/>
-      </batchtest>
-    </junit>
-
-    <fail if="tests.failed">Tests failed!</fail>
-  </target>
-	
   <target name="dist" depends="build">
   	<copy todir="../../build/web">
   		<fileset dir="src/main/webapp" includes="**" />
@@ -177,7 +119,6 @@
   	<mkdir dir="../../build/web/WEB-INF/lib"/>
   	<copy file="target/${fullnamever}.jar" todir="${solr-path}/build/web/WEB-INF/lib"></copy>
   	<copy file="target/${fullnamever}.jar" todir="${solr-path}/dist"></copy>
-  	<copy file="target/apache-${ant.project.name}-extras-${version}.jar" todir="${solr-path}/dist"></copy>
   </target>
 	
   <target name="javadoc">
@@ -186,7 +127,6 @@
 
       <path id="javadoc.classpath">
         <path refid="common.classpath"/>
-        <path refid="extras.classpath"/>
       </path>
 
       <invoke-javadoc
@@ -194,7 +134,6 @@
       	title="${Name} ${version} contrib-${fullnamever} API">
         <sources>
           <packageset dir="src/main/java"/>
-          <packageset dir="src/extras/main/java"/>
         </sources>
       </invoke-javadoc>
     </sequential>
diff --git a/contrib/dataimporthandler/solr-dataimporthandler-extras-pom.xml.template b/contrib/dataimporthandler/solr-dataimporthandler-extras-pom.xml.template
deleted file mode 100644
index 491dd89..0000000
--- a/contrib/dataimporthandler/solr-dataimporthandler-extras-pom.xml.template
+++ /dev/null
@@ -1,52 +0,0 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0"
-  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-
-  <!--
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-  -->
-
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>org.apache.solr</groupId>
-    <artifactId>solr-parent</artifactId>
-    <version>@maven_version@</version>
-  </parent>
-
-  <groupId>org.apache.solr</groupId>
-  <artifactId>solr-dataimporthandler-extras</artifactId>
-  <name>Apache Solr DataImportHandler Extras</name>
-  <version>@maven_version@</version>
-  <description>Apache Solr DataImportHandler Extras</description>
-  <packaging>jar</packaging>
-
-  <dependencies>
-    <dependency>
-      <groupId>javax.activation</groupId>
-      <artifactId>activation</artifactId>
-      <version>1.1</version>
-    </dependency>
-    <dependency>
-      <groupId>javax.mail</groupId>
-      <artifactId>mail</artifactId>
-      <version>1.4.1</version>
-    </dependency>
-  </dependencies>
-
-</project>
diff --git a/contrib/dataimporthandler/src/extras/main/java/org/apache/solr/handler/dataimport/MailEntityProcessor.java b/contrib/dataimporthandler/src/extras/main/java/org/apache/solr/handler/dataimport/MailEntityProcessor.java
deleted file mode 100644
index 7e464bf..0000000
--- a/contrib/dataimporthandler/src/extras/main/java/org/apache/solr/handler/dataimport/MailEntityProcessor.java
+++ /dev/null
@@ -1,599 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.solr.handler.dataimport;
-
-import com.sun.mail.imap.IMAPMessage;
-import org.apache.tika.config.TikaConfig;
-import org.apache.tika.utils.ParseUtils;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import javax.mail.*;
-import javax.mail.internet.AddressException;
-import javax.mail.internet.ContentType;
-import javax.mail.internet.InternetAddress;
-import javax.mail.internet.MimeMessage;
-import javax.mail.search.AndTerm;
-import javax.mail.search.ComparisonTerm;
-import javax.mail.search.ReceivedDateTerm;
-import javax.mail.search.SearchTerm;
-import java.io.InputStream;
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.*;
-
-/**
- * An EntityProcessor instance which can index emails along with their attachments from POP3 or IMAP sources. Refer to
- * <a href="http://wiki.apache.org/solr/DataImportHandler">http://wiki.apache.org/solr/DataImportHandler</a> for more
- * details. <b>This API is experimental and subject to change</b>
- *
- * @version $Id$
- * @since solr 1.4
- */
-public class MailEntityProcessor extends EntityProcessorBase {
-
-  public static interface CustomFilter {
-    public SearchTerm getCustomSearch(Folder folder);
-  }
-
-  public void init(Context context) {
-    super.init(context);
-    // set attributes using  XXX getXXXFromContext(attribute, defualtValue);
-    // applies variable resolver and return default if value is not found or null
-    // REQUIRED : connection and folder info
-    user = getStringFromContext("user", null);
-    password = getStringFromContext("password", null);
-    host = getStringFromContext("host", null);
-    protocol = getStringFromContext("protocol", null);
-    folderNames = getStringFromContext("folders", null);
-    // validate
-    if (host == null || protocol == null || user == null || password == null
-            || folderNames == null)
-      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,
-              "'user|password|protocol|host|folders' are required attributes");
-
-    //OPTIONAL : have defaults and are optional
-    recurse = getBoolFromContext("recurse", true);
-    String excludes = getStringFromContext("exclude", "");
-    if (excludes != null && !excludes.trim().equals("")) {
-      exclude = Arrays.asList(excludes.split(","));
-    }
-    String includes = getStringFromContext("include", "");
-    if (includes != null && !includes.trim().equals("")) {
-      include = Arrays.asList(includes.split(","));
-    }
-    batchSize = getIntFromContext("batchSize", 20);
-    customFilter = getStringFromContext("customFilter", "");
-    String s = getStringFromContext("fetchMailsSince", "");
-    if (s != null)
-      try {
-        fetchMailsSince = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(s);
-      } catch (ParseException e) {
-        throw new DataImportHandlerException(DataImportHandlerException.SEVERE, "Invalid value for fetchMailSince: " + s, e);
-      }
-
-    fetchSize = getIntFromContext("fetchSize", 32 * 1024);
-    cTimeout = getIntFromContext("connectTimeout", 30 * 1000);
-    rTimeout = getIntFromContext("readTimeout", 60 * 1000);
-    processAttachment = getBoolFromContext("processAttachement", true);
-
-    logConfig();
-  }
-
-  public Map<String, Object> nextRow() {
-    Message mail;
-    Map<String, Object> row = null;
-    do {
-      // try till there is a valid document or folders get exhausted.
-      // when mail == NULL, it means end of processing
-      mail = getNextMail();
-      if (mail != null)
-        row = getDocumentFromMail(mail);
-    } while (row == null && mail != null);    
-    return row;
-  }
-
-  private Message getNextMail() {
-    if (!connected) {
-      if (!connectToMailBox())
-        return null;
-      connected = true;
-    }
-    if (folderIter == null) {
-      createFilters();
-      folderIter = new FolderIterator(mailbox);
-    }
-    // get next message from the folder
-    // if folder is exhausted get next folder
-    // loop till a valid mail or all folders exhausted.
-    while (msgIter == null || !msgIter.hasNext()) {
-      Folder next = folderIter.hasNext() ? folderIter.next() : null;
-      if (next == null) {
-        return null;
-      }
-      msgIter = new MessageIterator(next, batchSize);
-    }
-    return msgIter.next();
-  }
-
-  private Map<String, Object> getDocumentFromMail(Message mail) {
-    Map<String, Object> row = new HashMap<String, Object>();
-    try {
-      addPartToDocument(mail, row, true);
-      return row;
-    } catch (Exception e) {
-      return null;
-    }
-  }
-
-  public void addPartToDocument(Part part, Map<String, Object> row, boolean outerMost) throws Exception {
-    if (part instanceof Message) {
-      addEnvelopToDocument(part, row);
-    }
-
-    String ct = part.getContentType();
-    ContentType ctype = new ContentType(ct);
-    if (part.isMimeType("multipart/*")) {
-      Multipart mp = (Multipart) part.getContent();
-      int count = mp.getCount();
-      if (part.isMimeType("multipart/alternative"))
-        count = 1;
-      for (int i = 0; i < count; i++)
-        addPartToDocument(mp.getBodyPart(i), row, false);
-    } else if (part.isMimeType("message/rfc822")) {
-      addPartToDocument((Part) part.getContent(), row, false);
-    } else {
-      String disp = part.getDisposition();
-      if (!processAttachment || (disp != null && disp.equalsIgnoreCase(Part.ATTACHMENT)))        return;
-      InputStream is = part.getInputStream();
-      String fileName = part.getFileName();
-      String content = ParseUtils.getStringContent(is, TikaConfig.getDefaultConfig(), ctype.getBaseType().toLowerCase());
-      if (disp != null && disp.equalsIgnoreCase(Part.ATTACHMENT)) {
-        if (row.get(ATTACHMENT) == null)
-          row.put(ATTACHMENT, new ArrayList<String>());
-        List<String> contents = (List<String>) row.get(ATTACHMENT);
-        contents.add(content);
-        row.put(ATTACHMENT, contents);
-        if (row.get(ATTACHMENT_NAMES) == null)
-          row.put(ATTACHMENT_NAMES, new ArrayList<String>());
-        List<String> names = (List<String>) row.get(ATTACHMENT_NAMES);
-        names.add(fileName);
-        row.put(ATTACHMENT_NAMES, names);
-      } else {
-        if (row.get(CONTENT) == null)
-          row.put(CONTENT, new ArrayList<String>());
-        List<String> contents = (List<String>) row.get(CONTENT);
-        contents.add(content);
-        row.put(CONTENT, contents);
-      }
-    }
-  }
-
-  private void addEnvelopToDocument(Part part, Map<String, Object> row) throws MessagingException {
-    MimeMessage mail = (MimeMessage) part;
-    Address[] adresses;
-    if ((adresses = mail.getFrom()) != null && adresses.length > 0)
-      row.put(FROM, adresses[0].toString());
-
-    List<String> to = new ArrayList<String>();
-    if ((adresses = mail.getRecipients(Message.RecipientType.TO)) != null)
-      addAddressToList(adresses, to);
-    if ((adresses = mail.getRecipients(Message.RecipientType.CC)) != null)
-      addAddressToList(adresses, to);
-    if ((adresses = mail.getRecipients(Message.RecipientType.BCC)) != null)
-      addAddressToList(adresses, to);
-    if (to.size() > 0)
-      row.put(TO_CC_BCC, to);
-
-    row.put(MESSAGE_ID, mail.getMessageID());
-    row.put(SUBJECT, mail.getSubject());
-
-    Date d = mail.getSentDate();
-    if (d != null) {
-      row.put(SENT_DATE, d);
-    }
-
-    List<String> flags = new ArrayList<String>();
-    for (Flags.Flag flag : mail.getFlags().getSystemFlags()) {
-      if (flag == Flags.Flag.ANSWERED)
-        flags.add(FLAG_ANSWERED);
-      else if (flag == Flags.Flag.DELETED)
-        flags.add(FLAG_DELETED);
-      else if (flag == Flags.Flag.DRAFT)
-        flags.add(FLAG_DRAFT);
-      else if (flag == Flags.Flag.FLAGGED)
-        flags.add(FLAG_FLAGGED);
-      else if (flag == Flags.Flag.RECENT)
-        flags.add(FLAG_RECENT);
-      else if (flag == Flags.Flag.SEEN)
-        flags.add(FLAG_SEEN);
-    }
-    flags.addAll(Arrays.asList(mail.getFlags().getUserFlags()));
-    row.put(FLAGS, flags);
-
-    String[] hdrs = mail.getHeader("X-Mailer");
-    if (hdrs != null)
-      row.put(XMAILER, hdrs[0]);
-  }
-
-
-  private void addAddressToList(Address[] adresses, List<String> to) throws AddressException {
-    for (Address address : adresses) {
-      to.add(address.toString());
-      InternetAddress ia = (InternetAddress) address;
-      if (ia.isGroup()) {
-        InternetAddress[] group = ia.getGroup(false);
-        for (InternetAddress member : group)
-          to.add(member.toString());
-      }
-    }
-  }
-
-  private boolean connectToMailBox() {
-    try {
-      Properties props = new Properties();
-      props.setProperty("mail.store.protocol", protocol);
-      props.setProperty("mail.imap.fetchsize", "" + fetchSize);
-      props.setProperty("mail.imap.timeout", "" + rTimeout);
-      props.setProperty("mail.imap.connectiontimeout", "" + cTimeout);
-      Session session = Session.getDefaultInstance(props, null);
-      mailbox = session.getStore(protocol);
-      mailbox.connect(host, user, password);
-      LOG.info("Connected to mailbox");
-      return true;
-    } catch (MessagingException e) {
-      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,
-              "Connection failed", e);
-    }
-  }
-
-  private void createFilters() {
-    if (fetchMailsSince != null) {
-      filters.add(new MailsSinceLastCheckFilter(fetchMailsSince));
-    }
-    if (customFilter != null && !customFilter.equals("")) {
-      try {
-        Class cf = Class.forName(customFilter);
-        Object obj = cf.newInstance();
-        if (obj instanceof CustomFilter) {
-          filters.add((CustomFilter) obj);
-        }
-      } catch (Exception e) {
-        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,
-                "Custom filter could not be created", e);
-      }
-    }
-  }
-
-  private void logConfig() {
-    if (!LOG.isInfoEnabled()) return;
-    StringBuffer config = new StringBuffer();
-    config.append("user : ").append(user).append(System.getProperty("line.separator"));
-    config.append("pwd : ").append(password).append(System.getProperty("line.separator"));
-    config.append("protocol : ").append(protocol).append(System.getProperty("line.separator"));
-    config.append("host : ").append(host).append(System.getProperty("line.separator"));
-    config.append("folders : ").append(folderNames).append(System.getProperty("line.separator"));
-    config.append("recurse : ").append(recurse).append(System.getProperty("line.separator"));
-    config.append("exclude : ").append(exclude.toString()).append(System.getProperty("line.separator"));
-    config.append("include : ").append(include.toString()).append(System.getProperty("line.separator"));
-    config.append("batchSize : ").append(batchSize).append(System.getProperty("line.separator"));
-    config.append("fetchSize : ").append(fetchSize).append(System.getProperty("line.separator"));
-    config.append("read timeout : ").append(rTimeout).append(System.getProperty("line.separator"));
-    config.append("conection timeout : ").append(cTimeout).append(System.getProperty("line.separator"));
-    config.append("custom filter : ").append(customFilter).append(System.getProperty("line.separator"));
-    config.append("fetch mail since : ").append(fetchMailsSince).append(System.getProperty("line.separator"));
-    LOG.info(config.toString());
-  }
-
-  class FolderIterator implements Iterator<Folder> {
-    private Store mailbox;
-    private List<String> topLevelFolders;
-    private List<Folder> folders = null;
-    private Folder lastFolder = null;
-
-    public FolderIterator(Store mailBox) {
-      this.mailbox = mailBox;
-      folders = new ArrayList<Folder>();
-      getTopLevelFolders(mailBox);
-    }
-
-    public boolean hasNext() {
-      return !folders.isEmpty();
-    }
-
-    public Folder next() {
-      try {
-        boolean hasMessages = false;
-        Folder next;
-        do {
-          if (lastFolder != null) {
-            lastFolder.close(false);
-            lastFolder = null;
-          }
-          if (folders.isEmpty()) {
-            mailbox.close();
-            return null;
-          }
-          next = folders.remove(0);
-          if (next != null) {
-            String fullName = next.getFullName();
-            if (!excludeFolder(fullName)) {
-              hasMessages = (next.getType() & Folder.HOLDS_MESSAGES) != 0;
-              next.open(Folder.READ_ONLY);
-              lastFolder = next;
-              LOG.info("Opened folder : " + fullName);
-            }
-            if (recurse && ((next.getType() & Folder.HOLDS_FOLDERS) != 0)) {
-              Folder[] children = next.list();
-              LOG.info("Added its children to list  : ");
-              for (int i = children.length - 1; i >= 0; i--) {
-                folders.add(0, children[i]);
-                LOG.info("child name : " + children[i].getFullName());
-              }
-              if (children.length == 0)
-                LOG.info("NO children : ");
-            }
-          }
-        }
-        while (!hasMessages);
-        return next;
-      } catch (MessagingException e) {
-        //throw new DataImportHandlerException(DataImportHandlerException.SEVERE,
-        //        "Folder open failed", e);
-      }
-      return null;
-    }
-
-    public void remove() {
-      throw new UnsupportedOperationException("Its read only mode...");
-    }
-
-    private void getTopLevelFolders(Store mailBox) {
-      if (folderNames != null)
-        topLevelFolders = Arrays.asList(folderNames.split(","));
-      for (int i = 0; topLevelFolders != null && i < topLevelFolders.size(); i++) {
-        try {
-          folders.add(mailbox.getFolder(topLevelFolders.get(i)));
-        } catch (MessagingException e) {
-          // skip bad ones unless its the last one and still no good folder
-          if (folders.size() == 0 && i == topLevelFolders.size() - 1)
-            throw new DataImportHandlerException(DataImportHandlerException.SEVERE,
-                    "Folder retreival failed");
-        }
-      }
-      if (topLevelFolders == null || topLevelFolders.size() == 0) {
-        try {
-          folders.add(mailBox.getDefaultFolder());
-        } catch (MessagingException e) {
-          throw new DataImportHandlerException(DataImportHandlerException.SEVERE,
-                  "Folder retreival failed");
-        }
-      }
-    }
-
-    private boolean excludeFolder(String name) {
-      for (String s : exclude) {
-        if (name.matches(s))
-          return true;
-      }
-      for (String s : include) {
-        if (name.matches(s))
-          return false;
-      }
-      return include.size() > 0;
-    }
-  }
-
-  class MessageIterator implements Iterator<Message> {
-    private Folder folder;
-    private Message[] messagesInCurBatch;
-    private int current = 0;
-    private int currentBatch = 0;
-    private int batchSize = 0;
-    private int totalInFolder = 0;
-    private boolean doBatching = true;
-
-    public MessageIterator(Folder folder, int batchSize) {
-      try {
-        this.folder = folder;
-        this.batchSize = batchSize;
-        SearchTerm st = getSearchTerm();
-        if (st != null) {
-          doBatching = false;
-          messagesInCurBatch = folder.search(st);
-          totalInFolder = messagesInCurBatch.length;
-          folder.fetch(messagesInCurBatch, fp);
-          current = 0;
-          LOG.info("Total messages : " + totalInFolder);
-          LOG.info("Search criteria applied. Batching disabled");
-        } else {
-          totalInFolder = folder.getMessageCount();
-          LOG.info("Total messages : " + totalInFolder);
-          getNextBatch(batchSize, folder);
-        }
-      } catch (MessagingException e) {
-        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,
-                "Message retreival failed", e);
-      }
-    }
-
-    private void getNextBatch(int batchSize, Folder folder) throws MessagingException {
-      // after each batch invalidate cache
-      if (messagesInCurBatch != null) {
-        for (Message m : messagesInCurBatch) {
-          if (m instanceof IMAPMessage)
-            ((IMAPMessage) m).invalidateHeaders();
-        }
-      }
-      int lastMsg = (currentBatch + 1) * batchSize;
-      lastMsg = lastMsg > totalInFolder ? totalInFolder : lastMsg;
-      messagesInCurBatch = folder.getMessages(currentBatch * batchSize + 1, lastMsg);
-      folder.fetch(messagesInCurBatch, fp);
-      current = 0;
-      currentBatch++;
-      LOG.info("Current Batch  : " + currentBatch);
-      LOG.info("Messages in this batch  : " + messagesInCurBatch.length);
-    }
-
-    public boolean hasNext() {
-      boolean hasMore = current < messagesInCurBatch.length;
-      if (!hasMore && doBatching
-              && currentBatch * batchSize < totalInFolder) {
-        // try next batch
-        try {
-          getNextBatch(batchSize, folder);
-          hasMore = current < messagesInCurBatch.length;
-        } catch (MessagingException e) {
-          throw new DataImportHandlerException(DataImportHandlerException.SEVERE,
-                  "Message retreival failed", e);
-        }
-      }
-      return hasMore;
-    }
-
-    public Message next() {
-      return hasNext() ? messagesInCurBatch[current++] : null;
-    }
-
-    public void remove() {
-      throw new UnsupportedOperationException("Its read only mode...");
-    }
-
-    private SearchTerm getSearchTerm() {
-      if (filters.size() == 0)
-        return null;
-      if (filters.size() == 1)
-        return filters.get(0).getCustomSearch(folder);
-      SearchTerm last = filters.get(0).getCustomSearch(folder);
-      for (int i = 1; i < filters.size(); i++) {
-        CustomFilter filter = filters.get(i);
-        SearchTerm st = filter.getCustomSearch(folder);
-        if (st != null) {
-          last = new AndTerm(last, st);
-        }
-      }
-      return last;
-    }
-  }
-
-  class MailsSinceLastCheckFilter implements CustomFilter {
-
-    private Date since;
-
-    public MailsSinceLastCheckFilter(Date date) {
-      since = date;
-    }
-
-    public SearchTerm getCustomSearch(Folder folder) {
-      return new ReceivedDateTerm(ComparisonTerm.GE, since);
-    }
-  }
-
-  // user settings stored in member variables
-  private String user;
-  private String password;
-  private String host;
-  private String protocol;
-
-  private String folderNames;
-  private List<String> exclude = new ArrayList<String>();
-  private List<String> include = new ArrayList<String>();
-  private boolean recurse;
-
-  private int batchSize;
-  private int fetchSize;
-  private int cTimeout;
-  private int rTimeout;
-
-  private Date fetchMailsSince;
-  private String customFilter;
-
-  private boolean processAttachment = true;
-
-  // holds the current state
-  private Store mailbox;
-  private boolean connected = false;
-  private FolderIterator folderIter;
-  private MessageIterator msgIter;
-  private List<CustomFilter> filters = new ArrayList<CustomFilter>();
-  private static FetchProfile fp = new FetchProfile();
-  private static final Logger LOG = LoggerFactory.getLogger(DataImporter.class);
-
-  // diagnostics
-  private int rowCount = 0;
-
-  static {
-    fp.add(FetchProfile.Item.ENVELOPE);
-    fp.add(FetchProfile.Item.FLAGS);
-    fp.add("X-Mailer");
-  }
-
-  // Fields To Index
-  // single valued
-  private static final String MESSAGE_ID = "messageId";
-  private static final String SUBJECT = "subject";
-  private static final String FROM = "from";
-  private static final String SENT_DATE = "sentDate";
-  private static final String XMAILER = "xMailer";
-  // multi valued
-  private static final String TO_CC_BCC = "allTo";
-  private static final String FLAGS = "flags";
-  private static final String CONTENT = "content";
-  private static final String ATTACHMENT = "attachment";
-  private static final String ATTACHMENT_NAMES = "attachmentNames";
-  // flag values
-  private static final String FLAG_ANSWERED = "answered";
-  private static final String FLAG_DELETED = "deleted";
-  private static final String FLAG_DRAFT = "draft";
-  private static final String FLAG_FLAGGED = "flagged";
-  private static final String FLAG_RECENT = "recent";
-  private static final String FLAG_SEEN = "seen";
-
-  private int getIntFromContext(String prop, int ifNull) {
-    int v = ifNull;
-    try {
-      String val = context.getEntityAttribute(prop);
-      if (val != null) {
-        val = context.replaceTokens(val);
-        v = Integer.valueOf(val);
-      }
-    } catch (NumberFormatException e) {
-      //do nothing
-    }
-    return v;
-  }
-
-  private boolean getBoolFromContext(String prop, boolean ifNull) {
-    boolean v = ifNull;
-    String val = context.getEntityAttribute(prop);
-    if (val != null) {
-      val = context.replaceTokens(val);
-      v = Boolean.valueOf(val);
-    }
-    return v;
-  }
-
-  private String getStringFromContext(String prop, String ifNull) {
-    String v = ifNull;
-    String val = context.getEntityAttribute(prop);
-    if (val != null) {
-      val = context.replaceTokens(val);
-      v = val;
-    }
-    return v;
-  }
-}
diff --git a/contrib/dataimporthandler/src/extras/test/java/org/apache/solr/handler/dataimport/TestMailEntityProcessor.java b/contrib/dataimporthandler/src/extras/test/java/org/apache/solr/handler/dataimport/TestMailEntityProcessor.java
deleted file mode 100644
index 5a5220e..0000000
--- a/contrib/dataimporthandler/src/extras/test/java/org/apache/solr/handler/dataimport/TestMailEntityProcessor.java
+++ /dev/null
@@ -1,211 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.solr.handler.dataimport;
-
-import junit.framework.Assert;
-import org.apache.solr.common.SolrInputDocument;
-import org.junit.Ignore;
-import org.junit.Test;
-
-import java.text.ParseException;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-// Test mailbox is like this: foldername(mailcount)
-// top1(2) -> child11(6)
-//         -> child12(0)
-// top2(2) -> child21(1)
-//                 -> grandchild211(2)
-//                 -> grandchild212(1)
-//         -> child22(2)
-
-/**
- * Test for MailEntityProcessor. The tests are marked as ignored because we'd need a mail server (real or mocked) for
- * these to work.
- *
- * TODO: Find a way to make the tests actually test code
- *
- * @version $Id$
- * @see org.apache.solr.handler.dataimport.MailEntityProcessor
- * @since solr 1.4
- */
-public class TestMailEntityProcessor {
-
-  // Credentials
-  private static final String user = "user";
-  private static final String password = "password";
-  private static final String host = "host";
-  private static final String protocol = "imaps";
-
-  private static Map<String, String> paramMap = new HashMap<String, String>();
-
-  @Test
-  @Ignore
-  public void testConnection() {
-    // also tests recurse = false and default settings
-    paramMap.put("folders", "top2");
-    paramMap.put("recurse", "false");
-    paramMap.put("processAttachement", "false");
-    DataImporter di = new DataImporter();
-    di.loadAndInit(getConfigFromMap(paramMap));
-    DataConfig.Entity ent = di.getConfig().document.entities.get(0);
-    ent.isDocRoot = true;
-    DataImporter.RequestParams rp = new DataImporter.RequestParams();
-    rp.command = "full-import";
-    SolrWriterImpl swi = new SolrWriterImpl();
-    di.runCmd(rp, swi);
-    Assert.assertEquals("top1 did not return 2 messages", swi.docs.size(), 2);
-  }
-
-  @Test
-  @Ignore
-  public void testRecursion() {
-    paramMap.put("folders", "top2");
-    paramMap.put("recurse", "true");
-    paramMap.put("processAttachement", "false");
-    DataImporter di = new DataImporter();
-    di.loadAndInit(getConfigFromMap(paramMap));
-    DataConfig.Entity ent = di.getConfig().document.entities.get(0);
-    ent.isDocRoot = true;
-    DataImporter.RequestParams rp = new DataImporter.RequestParams();
-    rp.command = "full-import";
-    SolrWriterImpl swi = new SolrWriterImpl();
-    di.runCmd(rp, swi);
-    Assert.assertEquals("top2 and its children did not return 8 messages", swi.docs.size(), 8);
-  }
-
-  @Test
-  @Ignore
-  public void testExclude() {
-    paramMap.put("folders", "top2");
-    paramMap.put("recurse", "true");
-    paramMap.put("processAttachement", "false");
-    paramMap.put("exclude", ".*grandchild.*");
-    DataImporter di = new DataImporter();
-    di.loadAndInit(getConfigFromMap(paramMap));
-    DataConfig.Entity ent = di.getConfig().document.entities.get(0);
-    ent.isDocRoot = true;
-    DataImporter.RequestParams rp = new DataImporter.RequestParams();
-    rp.command = "full-import";
-    SolrWriterImpl swi = new SolrWriterImpl();
-    di.runCmd(rp, swi);
-    Assert.assertEquals("top2 and its direct children did not return 5 messages", swi.docs.size(), 5);
-  }
-
-  @Test
-  @Ignore
-  public void testInclude() {
-    paramMap.put("folders", "top2");
-    paramMap.put("recurse", "true");
-    paramMap.put("processAttachement", "false");
-    paramMap.put("include", ".*grandchild.*");
-    DataImporter di = new DataImporter();
-    di.loadAndInit(getConfigFromMap(paramMap));
-    DataConfig.Entity ent = di.getConfig().document.entities.get(0);
-    ent.isDocRoot = true;
-    DataImporter.RequestParams rp = new DataImporter.RequestParams();
-    rp.command = "full-import";
-    SolrWriterImpl swi = new SolrWriterImpl();
-    di.runCmd(rp, swi);
-    Assert.assertEquals("top2 and its direct children did not return 3 messages", swi.docs.size(), 3);
-  }
-
-  @Test
-  @Ignore
-  public void testIncludeAndExclude() {
-    paramMap.put("folders", "top1,top2");
-    paramMap.put("recurse", "true");
-    paramMap.put("processAttachement", "false");
-    paramMap.put("exclude", ".*top1.*");
-    paramMap.put("include", ".*grandchild.*");
-    DataImporter di = new DataImporter();
-    di.loadAndInit(getConfigFromMap(paramMap));
-    DataConfig.Entity ent = di.getConfig().document.entities.get(0);
-    ent.isDocRoot = true;
-    DataImporter.RequestParams rp = new DataImporter.RequestParams();
-    rp.command = "full-import";
-    SolrWriterImpl swi = new SolrWriterImpl();
-    di.runCmd(rp, swi);
-    Assert.assertEquals("top2 and its direct children did not return 3 messages", swi.docs.size(), 3);
-  }
-
-  @Test
-  @Ignore
-  public void testFetchTimeSince() throws ParseException {
-    paramMap.put("folders", "top1/child11");
-    paramMap.put("recurse", "true");
-    paramMap.put("processAttachement", "false");
-    paramMap.put("fetchMailsSince", "2008-12-26 00:00:00");
-    DataImporter di = new DataImporter();
-    di.loadAndInit(getConfigFromMap(paramMap));
-    DataConfig.Entity ent = di.getConfig().document.entities.get(0);
-    ent.isDocRoot = true;
-    DataImporter.RequestParams rp = new DataImporter.RequestParams();
-    rp.command = "full-import";
-    SolrWriterImpl swi = new SolrWriterImpl();
-    di.runCmd(rp, swi);
-    Assert.assertEquals("top2 and its direct children did not return 3 messages", swi.docs.size(), 3);
-  }
-
-  private String getConfigFromMap(Map<String, String> params) {
-    String conf =
-            "<dataConfig>" +
-                    "<document>" +
-                    "<entity processor=\"org.apache.solr.handler.dataimport.MailEntityProcessor\" " +
-                    "someconfig" +
-                    "/>" +
-                    "</document>" +
-                    "</dataConfig>";
-    params.put("user", user);
-    params.put("password", password);
-    params.put("host", host);
-    params.put("protocol", protocol);
-    StringBuilder attribs = new StringBuilder("");
-    for (String key : params.keySet())
-      attribs.append(" ").append(key).append("=" + "\"").append(params.get(key)).append("\"");
-    attribs.append(" ");
-    return conf.replace("someconfig", attribs.toString());
-  }
-
-  static class SolrWriterImpl extends SolrWriter {
-    List<SolrInputDocument> docs = new ArrayList<SolrInputDocument>();
-    Boolean deleteAllCalled;
-    Boolean commitCalled;
-
-    public SolrWriterImpl() {
-      super(null, ".");
-    }
-
-    public boolean upload(SolrInputDocument doc) {
-      return docs.add(doc);
-    }
-
-    public void log(int event, String name, Object row) {
-      // Do nothing
-    }
-
-    public void doDeleteAll() {
-      deleteAllCalled = Boolean.TRUE;
-    }
-
-    public void commit(boolean b) {
-      commitCalled = Boolean.TRUE;
-    }
-  }
-}
diff --git a/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/MailEntityProcessor.java b/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/MailEntityProcessor.java
new file mode 100644
index 0000000..7e464bf
--- /dev/null
+++ b/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/MailEntityProcessor.java
@@ -0,0 +1,599 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.handler.dataimport;
+
+import com.sun.mail.imap.IMAPMessage;
+import org.apache.tika.config.TikaConfig;
+import org.apache.tika.utils.ParseUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.mail.*;
+import javax.mail.internet.AddressException;
+import javax.mail.internet.ContentType;
+import javax.mail.internet.InternetAddress;
+import javax.mail.internet.MimeMessage;
+import javax.mail.search.AndTerm;
+import javax.mail.search.ComparisonTerm;
+import javax.mail.search.ReceivedDateTerm;
+import javax.mail.search.SearchTerm;
+import java.io.InputStream;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.*;
+
+/**
+ * An EntityProcessor instance which can index emails along with their attachments from POP3 or IMAP sources. Refer to
+ * <a href="http://wiki.apache.org/solr/DataImportHandler">http://wiki.apache.org/solr/DataImportHandler</a> for more
+ * details. <b>This API is experimental and subject to change</b>
+ *
+ * @version $Id$
+ * @since solr 1.4
+ */
+public class MailEntityProcessor extends EntityProcessorBase {
+
+  public static interface CustomFilter {
+    public SearchTerm getCustomSearch(Folder folder);
+  }
+
+  public void init(Context context) {
+    super.init(context);
+    // set attributes using  XXX getXXXFromContext(attribute, defualtValue);
+    // applies variable resolver and return default if value is not found or null
+    // REQUIRED : connection and folder info
+    user = getStringFromContext("user", null);
+    password = getStringFromContext("password", null);
+    host = getStringFromContext("host", null);
+    protocol = getStringFromContext("protocol", null);
+    folderNames = getStringFromContext("folders", null);
+    // validate
+    if (host == null || protocol == null || user == null || password == null
+            || folderNames == null)
+      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,
+              "'user|password|protocol|host|folders' are required attributes");
+
+    //OPTIONAL : have defaults and are optional
+    recurse = getBoolFromContext("recurse", true);
+    String excludes = getStringFromContext("exclude", "");
+    if (excludes != null && !excludes.trim().equals("")) {
+      exclude = Arrays.asList(excludes.split(","));
+    }
+    String includes = getStringFromContext("include", "");
+    if (includes != null && !includes.trim().equals("")) {
+      include = Arrays.asList(includes.split(","));
+    }
+    batchSize = getIntFromContext("batchSize", 20);
+    customFilter = getStringFromContext("customFilter", "");
+    String s = getStringFromContext("fetchMailsSince", "");
+    if (s != null)
+      try {
+        fetchMailsSince = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(s);
+      } catch (ParseException e) {
+        throw new DataImportHandlerException(DataImportHandlerException.SEVERE, "Invalid value for fetchMailSince: " + s, e);
+      }
+
+    fetchSize = getIntFromContext("fetchSize", 32 * 1024);
+    cTimeout = getIntFromContext("connectTimeout", 30 * 1000);
+    rTimeout = getIntFromContext("readTimeout", 60 * 1000);
+    processAttachment = getBoolFromContext("processAttachement", true);
+
+    logConfig();
+  }
+
+  public Map<String, Object> nextRow() {
+    Message mail;
+    Map<String, Object> row = null;
+    do {
+      // try till there is a valid document or folders get exhausted.
+      // when mail == NULL, it means end of processing
+      mail = getNextMail();
+      if (mail != null)
+        row = getDocumentFromMail(mail);
+    } while (row == null && mail != null);    
+    return row;
+  }
+
+  private Message getNextMail() {
+    if (!connected) {
+      if (!connectToMailBox())
+        return null;
+      connected = true;
+    }
+    if (folderIter == null) {
+      createFilters();
+      folderIter = new FolderIterator(mailbox);
+    }
+    // get next message from the folder
+    // if folder is exhausted get next folder
+    // loop till a valid mail or all folders exhausted.
+    while (msgIter == null || !msgIter.hasNext()) {
+      Folder next = folderIter.hasNext() ? folderIter.next() : null;
+      if (next == null) {
+        return null;
+      }
+      msgIter = new MessageIterator(next, batchSize);
+    }
+    return msgIter.next();
+  }
+
+  private Map<String, Object> getDocumentFromMail(Message mail) {
+    Map<String, Object> row = new HashMap<String, Object>();
+    try {
+      addPartToDocument(mail, row, true);
+      return row;
+    } catch (Exception e) {
+      return null;
+    }
+  }
+
+  public void addPartToDocument(Part part, Map<String, Object> row, boolean outerMost) throws Exception {
+    if (part instanceof Message) {
+      addEnvelopToDocument(part, row);
+    }
+
+    String ct = part.getContentType();
+    ContentType ctype = new ContentType(ct);
+    if (part.isMimeType("multipart/*")) {
+      Multipart mp = (Multipart) part.getContent();
+      int count = mp.getCount();
+      if (part.isMimeType("multipart/alternative"))
+        count = 1;
+      for (int i = 0; i < count; i++)
+        addPartToDocument(mp.getBodyPart(i), row, false);
+    } else if (part.isMimeType("message/rfc822")) {
+      addPartToDocument((Part) part.getContent(), row, false);
+    } else {
+      String disp = part.getDisposition();
+      if (!processAttachment || (disp != null && disp.equalsIgnoreCase(Part.ATTACHMENT)))        return;
+      InputStream is = part.getInputStream();
+      String fileName = part.getFileName();
+      String content = ParseUtils.getStringContent(is, TikaConfig.getDefaultConfig(), ctype.getBaseType().toLowerCase());
+      if (disp != null && disp.equalsIgnoreCase(Part.ATTACHMENT)) {
+        if (row.get(ATTACHMENT) == null)
+          row.put(ATTACHMENT, new ArrayList<String>());
+        List<String> contents = (List<String>) row.get(ATTACHMENT);
+        contents.add(content);
+        row.put(ATTACHMENT, contents);
+        if (row.get(ATTACHMENT_NAMES) == null)
+          row.put(ATTACHMENT_NAMES, new ArrayList<String>());
+        List<String> names = (List<String>) row.get(ATTACHMENT_NAMES);
+        names.add(fileName);
+        row.put(ATTACHMENT_NAMES, names);
+      } else {
+        if (row.get(CONTENT) == null)
+          row.put(CONTENT, new ArrayList<String>());
+        List<String> contents = (List<String>) row.get(CONTENT);
+        contents.add(content);
+        row.put(CONTENT, contents);
+      }
+    }
+  }
+
+  private void addEnvelopToDocument(Part part, Map<String, Object> row) throws MessagingException {
+    MimeMessage mail = (MimeMessage) part;
+    Address[] adresses;
+    if ((adresses = mail.getFrom()) != null && adresses.length > 0)
+      row.put(FROM, adresses[0].toString());
+
+    List<String> to = new ArrayList<String>();
+    if ((adresses = mail.getRecipients(Message.RecipientType.TO)) != null)
+      addAddressToList(adresses, to);
+    if ((adresses = mail.getRecipients(Message.RecipientType.CC)) != null)
+      addAddressToList(adresses, to);
+    if ((adresses = mail.getRecipients(Message.RecipientType.BCC)) != null)
+      addAddressToList(adresses, to);
+    if (to.size() > 0)
+      row.put(TO_CC_BCC, to);
+
+    row.put(MESSAGE_ID, mail.getMessageID());
+    row.put(SUBJECT, mail.getSubject());
+
+    Date d = mail.getSentDate();
+    if (d != null) {
+      row.put(SENT_DATE, d);
+    }
+
+    List<String> flags = new ArrayList<String>();
+    for (Flags.Flag flag : mail.getFlags().getSystemFlags()) {
+      if (flag == Flags.Flag.ANSWERED)
+        flags.add(FLAG_ANSWERED);
+      else if (flag == Flags.Flag.DELETED)
+        flags.add(FLAG_DELETED);
+      else if (flag == Flags.Flag.DRAFT)
+        flags.add(FLAG_DRAFT);
+      else if (flag == Flags.Flag.FLAGGED)
+        flags.add(FLAG_FLAGGED);
+      else if (flag == Flags.Flag.RECENT)
+        flags.add(FLAG_RECENT);
+      else if (flag == Flags.Flag.SEEN)
+        flags.add(FLAG_SEEN);
+    }
+    flags.addAll(Arrays.asList(mail.getFlags().getUserFlags()));
+    row.put(FLAGS, flags);
+
+    String[] hdrs = mail.getHeader("X-Mailer");
+    if (hdrs != null)
+      row.put(XMAILER, hdrs[0]);
+  }
+
+
+  private void addAddressToList(Address[] adresses, List<String> to) throws AddressException {
+    for (Address address : adresses) {
+      to.add(address.toString());
+      InternetAddress ia = (InternetAddress) address;
+      if (ia.isGroup()) {
+        InternetAddress[] group = ia.getGroup(false);
+        for (InternetAddress member : group)
+          to.add(member.toString());
+      }
+    }
+  }
+
+  private boolean connectToMailBox() {
+    try {
+      Properties props = new Properties();
+      props.setProperty("mail.store.protocol", protocol);
+      props.setProperty("mail.imap.fetchsize", "" + fetchSize);
+      props.setProperty("mail.imap.timeout", "" + rTimeout);
+      props.setProperty("mail.imap.connectiontimeout", "" + cTimeout);
+      Session session = Session.getDefaultInstance(props, null);
+      mailbox = session.getStore(protocol);
+      mailbox.connect(host, user, password);
+      LOG.info("Connected to mailbox");
+      return true;
+    } catch (MessagingException e) {
+      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,
+              "Connection failed", e);
+    }
+  }
+
+  private void createFilters() {
+    if (fetchMailsSince != null) {
+      filters.add(new MailsSinceLastCheckFilter(fetchMailsSince));
+    }
+    if (customFilter != null && !customFilter.equals("")) {
+      try {
+        Class cf = Class.forName(customFilter);
+        Object obj = cf.newInstance();
+        if (obj instanceof CustomFilter) {
+          filters.add((CustomFilter) obj);
+        }
+      } catch (Exception e) {
+        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,
+                "Custom filter could not be created", e);
+      }
+    }
+  }
+
+  private void logConfig() {
+    if (!LOG.isInfoEnabled()) return;
+    StringBuffer config = new StringBuffer();
+    config.append("user : ").append(user).append(System.getProperty("line.separator"));
+    config.append("pwd : ").append(password).append(System.getProperty("line.separator"));
+    config.append("protocol : ").append(protocol).append(System.getProperty("line.separator"));
+    config.append("host : ").append(host).append(System.getProperty("line.separator"));
+    config.append("folders : ").append(folderNames).append(System.getProperty("line.separator"));
+    config.append("recurse : ").append(recurse).append(System.getProperty("line.separator"));
+    config.append("exclude : ").append(exclude.toString()).append(System.getProperty("line.separator"));
+    config.append("include : ").append(include.toString()).append(System.getProperty("line.separator"));
+    config.append("batchSize : ").append(batchSize).append(System.getProperty("line.separator"));
+    config.append("fetchSize : ").append(fetchSize).append(System.getProperty("line.separator"));
+    config.append("read timeout : ").append(rTimeout).append(System.getProperty("line.separator"));
+    config.append("conection timeout : ").append(cTimeout).append(System.getProperty("line.separator"));
+    config.append("custom filter : ").append(customFilter).append(System.getProperty("line.separator"));
+    config.append("fetch mail since : ").append(fetchMailsSince).append(System.getProperty("line.separator"));
+    LOG.info(config.toString());
+  }
+
+  class FolderIterator implements Iterator<Folder> {
+    private Store mailbox;
+    private List<String> topLevelFolders;
+    private List<Folder> folders = null;
+    private Folder lastFolder = null;
+
+    public FolderIterator(Store mailBox) {
+      this.mailbox = mailBox;
+      folders = new ArrayList<Folder>();
+      getTopLevelFolders(mailBox);
+    }
+
+    public boolean hasNext() {
+      return !folders.isEmpty();
+    }
+
+    public Folder next() {
+      try {
+        boolean hasMessages = false;
+        Folder next;
+        do {
+          if (lastFolder != null) {
+            lastFolder.close(false);
+            lastFolder = null;
+          }
+          if (folders.isEmpty()) {
+            mailbox.close();
+            return null;
+          }
+          next = folders.remove(0);
+          if (next != null) {
+            String fullName = next.getFullName();
+            if (!excludeFolder(fullName)) {
+              hasMessages = (next.getType() & Folder.HOLDS_MESSAGES) != 0;
+              next.open(Folder.READ_ONLY);
+              lastFolder = next;
+              LOG.info("Opened folder : " + fullName);
+            }
+            if (recurse && ((next.getType() & Folder.HOLDS_FOLDERS) != 0)) {
+              Folder[] children = next.list();
+              LOG.info("Added its children to list  : ");
+              for (int i = children.length - 1; i >= 0; i--) {
+                folders.add(0, children[i]);
+                LOG.info("child name : " + children[i].getFullName());
+              }
+              if (children.length == 0)
+                LOG.info("NO children : ");
+            }
+          }
+        }
+        while (!hasMessages);
+        return next;
+      } catch (MessagingException e) {
+        //throw new DataImportHandlerException(DataImportHandlerException.SEVERE,
+        //        "Folder open failed", e);
+      }
+      return null;
+    }
+
+    public void remove() {
+      throw new UnsupportedOperationException("Its read only mode...");
+    }
+
+    private void getTopLevelFolders(Store mailBox) {
+      if (folderNames != null)
+        topLevelFolders = Arrays.asList(folderNames.split(","));
+      for (int i = 0; topLevelFolders != null && i < topLevelFolders.size(); i++) {
+        try {
+          folders.add(mailbox.getFolder(topLevelFolders.get(i)));
+        } catch (MessagingException e) {
+          // skip bad ones unless its the last one and still no good folder
+          if (folders.size() == 0 && i == topLevelFolders.size() - 1)
+            throw new DataImportHandlerException(DataImportHandlerException.SEVERE,
+                    "Folder retreival failed");
+        }
+      }
+      if (topLevelFolders == null || topLevelFolders.size() == 0) {
+        try {
+          folders.add(mailBox.getDefaultFolder());
+        } catch (MessagingException e) {
+          throw new DataImportHandlerException(DataImportHandlerException.SEVERE,
+                  "Folder retreival failed");
+        }
+      }
+    }
+
+    private boolean excludeFolder(String name) {
+      for (String s : exclude) {
+        if (name.matches(s))
+          return true;
+      }
+      for (String s : include) {
+        if (name.matches(s))
+          return false;
+      }
+      return include.size() > 0;
+    }
+  }
+
+  class MessageIterator implements Iterator<Message> {
+    private Folder folder;
+    private Message[] messagesInCurBatch;
+    private int current = 0;
+    private int currentBatch = 0;
+    private int batchSize = 0;
+    private int totalInFolder = 0;
+    private boolean doBatching = true;
+
+    public MessageIterator(Folder folder, int batchSize) {
+      try {
+        this.folder = folder;
+        this.batchSize = batchSize;
+        SearchTerm st = getSearchTerm();
+        if (st != null) {
+          doBatching = false;
+          messagesInCurBatch = folder.search(st);
+          totalInFolder = messagesInCurBatch.length;
+          folder.fetch(messagesInCurBatch, fp);
+          current = 0;
+          LOG.info("Total messages : " + totalInFolder);
+          LOG.info("Search criteria applied. Batching disabled");
+        } else {
+          totalInFolder = folder.getMessageCount();
+          LOG.info("Total messages : " + totalInFolder);
+          getNextBatch(batchSize, folder);
+        }
+      } catch (MessagingException e) {
+        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,
+                "Message retreival failed", e);
+      }
+    }
+
+    private void getNextBatch(int batchSize, Folder folder) throws MessagingException {
+      // after each batch invalidate cache
+      if (messagesInCurBatch != null) {
+        for (Message m : messagesInCurBatch) {
+          if (m instanceof IMAPMessage)
+            ((IMAPMessage) m).invalidateHeaders();
+        }
+      }
+      int lastMsg = (currentBatch + 1) * batchSize;
+      lastMsg = lastMsg > totalInFolder ? totalInFolder : lastMsg;
+      messagesInCurBatch = folder.getMessages(currentBatch * batchSize + 1, lastMsg);
+      folder.fetch(messagesInCurBatch, fp);
+      current = 0;
+      currentBatch++;
+      LOG.info("Current Batch  : " + currentBatch);
+      LOG.info("Messages in this batch  : " + messagesInCurBatch.length);
+    }
+
+    public boolean hasNext() {
+      boolean hasMore = current < messagesInCurBatch.length;
+      if (!hasMore && doBatching
+              && currentBatch * batchSize < totalInFolder) {
+        // try next batch
+        try {
+          getNextBatch(batchSize, folder);
+          hasMore = current < messagesInCurBatch.length;
+        } catch (MessagingException e) {
+          throw new DataImportHandlerException(DataImportHandlerException.SEVERE,
+                  "Message retreival failed", e);
+        }
+      }
+      return hasMore;
+    }
+
+    public Message next() {
+      return hasNext() ? messagesInCurBatch[current++] : null;
+    }
+
+    public void remove() {
+      throw new UnsupportedOperationException("Its read only mode...");
+    }
+
+    private SearchTerm getSearchTerm() {
+      if (filters.size() == 0)
+        return null;
+      if (filters.size() == 1)
+        return filters.get(0).getCustomSearch(folder);
+      SearchTerm last = filters.get(0).getCustomSearch(folder);
+      for (int i = 1; i < filters.size(); i++) {
+        CustomFilter filter = filters.get(i);
+        SearchTerm st = filter.getCustomSearch(folder);
+        if (st != null) {
+          last = new AndTerm(last, st);
+        }
+      }
+      return last;
+    }
+  }
+
+  class MailsSinceLastCheckFilter implements CustomFilter {
+
+    private Date since;
+
+    public MailsSinceLastCheckFilter(Date date) {
+      since = date;
+    }
+
+    public SearchTerm getCustomSearch(Folder folder) {
+      return new ReceivedDateTerm(ComparisonTerm.GE, since);
+    }
+  }
+
+  // user settings stored in member variables
+  private String user;
+  private String password;
+  private String host;
+  private String protocol;
+
+  private String folderNames;
+  private List<String> exclude = new ArrayList<String>();
+  private List<String> include = new ArrayList<String>();
+  private boolean recurse;
+
+  private int batchSize;
+  private int fetchSize;
+  private int cTimeout;
+  private int rTimeout;
+
+  private Date fetchMailsSince;
+  private String customFilter;
+
+  private boolean processAttachment = true;
+
+  // holds the current state
+  private Store mailbox;
+  private boolean connected = false;
+  private FolderIterator folderIter;
+  private MessageIterator msgIter;
+  private List<CustomFilter> filters = new ArrayList<CustomFilter>();
+  private static FetchProfile fp = new FetchProfile();
+  private static final Logger LOG = LoggerFactory.getLogger(DataImporter.class);
+
+  // diagnostics
+  private int rowCount = 0;
+
+  static {
+    fp.add(FetchProfile.Item.ENVELOPE);
+    fp.add(FetchProfile.Item.FLAGS);
+    fp.add("X-Mailer");
+  }
+
+  // Fields To Index
+  // single valued
+  private static final String MESSAGE_ID = "messageId";
+  private static final String SUBJECT = "subject";
+  private static final String FROM = "from";
+  private static final String SENT_DATE = "sentDate";
+  private static final String XMAILER = "xMailer";
+  // multi valued
+  private static final String TO_CC_BCC = "allTo";
+  private static final String FLAGS = "flags";
+  private static final String CONTENT = "content";
+  private static final String ATTACHMENT = "attachment";
+  private static final String ATTACHMENT_NAMES = "attachmentNames";
+  // flag values
+  private static final String FLAG_ANSWERED = "answered";
+  private static final String FLAG_DELETED = "deleted";
+  private static final String FLAG_DRAFT = "draft";
+  private static final String FLAG_FLAGGED = "flagged";
+  private static final String FLAG_RECENT = "recent";
+  private static final String FLAG_SEEN = "seen";
+
+  private int getIntFromContext(String prop, int ifNull) {
+    int v = ifNull;
+    try {
+      String val = context.getEntityAttribute(prop);
+      if (val != null) {
+        val = context.replaceTokens(val);
+        v = Integer.valueOf(val);
+      }
+    } catch (NumberFormatException e) {
+      //do nothing
+    }
+    return v;
+  }
+
+  private boolean getBoolFromContext(String prop, boolean ifNull) {
+    boolean v = ifNull;
+    String val = context.getEntityAttribute(prop);
+    if (val != null) {
+      val = context.replaceTokens(val);
+      v = Boolean.valueOf(val);
+    }
+    return v;
+  }
+
+  private String getStringFromContext(String prop, String ifNull) {
+    String v = ifNull;
+    String val = context.getEntityAttribute(prop);
+    if (val != null) {
+      val = context.replaceTokens(val);
+      v = val;
+    }
+    return v;
+  }
+}
diff --git a/contrib/dataimporthandler/src/test/java/org/apache/solr/handler/dataimport/TestMailEntityProcessor.java b/contrib/dataimporthandler/src/test/java/org/apache/solr/handler/dataimport/TestMailEntityProcessor.java
new file mode 100644
index 0000000..5a5220e
--- /dev/null
+++ b/contrib/dataimporthandler/src/test/java/org/apache/solr/handler/dataimport/TestMailEntityProcessor.java
@@ -0,0 +1,211 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.handler.dataimport;
+
+import junit.framework.Assert;
+import org.apache.solr.common.SolrInputDocument;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import java.text.ParseException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+// Test mailbox is like this: foldername(mailcount)
+// top1(2) -> child11(6)
+//         -> child12(0)
+// top2(2) -> child21(1)
+//                 -> grandchild211(2)
+//                 -> grandchild212(1)
+//         -> child22(2)
+
+/**
+ * Test for MailEntityProcessor. The tests are marked as ignored because we'd need a mail server (real or mocked) for
+ * these to work.
+ *
+ * TODO: Find a way to make the tests actually test code
+ *
+ * @version $Id$
+ * @see org.apache.solr.handler.dataimport.MailEntityProcessor
+ * @since solr 1.4
+ */
+public class TestMailEntityProcessor {
+
+  // Credentials
+  private static final String user = "user";
+  private static final String password = "password";
+  private static final String host = "host";
+  private static final String protocol = "imaps";
+
+  private static Map<String, String> paramMap = new HashMap<String, String>();
+
+  @Test
+  @Ignore
+  public void testConnection() {
+    // also tests recurse = false and default settings
+    paramMap.put("folders", "top2");
+    paramMap.put("recurse", "false");
+    paramMap.put("processAttachement", "false");
+    DataImporter di = new DataImporter();
+    di.loadAndInit(getConfigFromMap(paramMap));
+    DataConfig.Entity ent = di.getConfig().document.entities.get(0);
+    ent.isDocRoot = true;
+    DataImporter.RequestParams rp = new DataImporter.RequestParams();
+    rp.command = "full-import";
+    SolrWriterImpl swi = new SolrWriterImpl();
+    di.runCmd(rp, swi);
+    Assert.assertEquals("top1 did not return 2 messages", swi.docs.size(), 2);
+  }
+
+  @Test
+  @Ignore
+  public void testRecursion() {
+    paramMap.put("folders", "top2");
+    paramMap.put("recurse", "true");
+    paramMap.put("processAttachement", "false");
+    DataImporter di = new DataImporter();
+    di.loadAndInit(getConfigFromMap(paramMap));
+    DataConfig.Entity ent = di.getConfig().document.entities.get(0);
+    ent.isDocRoot = true;
+    DataImporter.RequestParams rp = new DataImporter.RequestParams();
+    rp.command = "full-import";
+    SolrWriterImpl swi = new SolrWriterImpl();
+    di.runCmd(rp, swi);
+    Assert.assertEquals("top2 and its children did not return 8 messages", swi.docs.size(), 8);
+  }
+
+  @Test
+  @Ignore
+  public void testExclude() {
+    paramMap.put("folders", "top2");
+    paramMap.put("recurse", "true");
+    paramMap.put("processAttachement", "false");
+    paramMap.put("exclude", ".*grandchild.*");
+    DataImporter di = new DataImporter();
+    di.loadAndInit(getConfigFromMap(paramMap));
+    DataConfig.Entity ent = di.getConfig().document.entities.get(0);
+    ent.isDocRoot = true;
+    DataImporter.RequestParams rp = new DataImporter.RequestParams();
+    rp.command = "full-import";
+    SolrWriterImpl swi = new SolrWriterImpl();
+    di.runCmd(rp, swi);
+    Assert.assertEquals("top2 and its direct children did not return 5 messages", swi.docs.size(), 5);
+  }
+
+  @Test
+  @Ignore
+  public void testInclude() {
+    paramMap.put("folders", "top2");
+    paramMap.put("recurse", "true");
+    paramMap.put("processAttachement", "false");
+    paramMap.put("include", ".*grandchild.*");
+    DataImporter di = new DataImporter();
+    di.loadAndInit(getConfigFromMap(paramMap));
+    DataConfig.Entity ent = di.getConfig().document.entities.get(0);
+    ent.isDocRoot = true;
+    DataImporter.RequestParams rp = new DataImporter.RequestParams();
+    rp.command = "full-import";
+    SolrWriterImpl swi = new SolrWriterImpl();
+    di.runCmd(rp, swi);
+    Assert.assertEquals("top2 and its direct children did not return 3 messages", swi.docs.size(), 3);
+  }
+
+  @Test
+  @Ignore
+  public void testIncludeAndExclude() {
+    paramMap.put("folders", "top1,top2");
+    paramMap.put("recurse", "true");
+    paramMap.put("processAttachement", "false");
+    paramMap.put("exclude", ".*top1.*");
+    paramMap.put("include", ".*grandchild.*");
+    DataImporter di = new DataImporter();
+    di.loadAndInit(getConfigFromMap(paramMap));
+    DataConfig.Entity ent = di.getConfig().document.entities.get(0);
+    ent.isDocRoot = true;
+    DataImporter.RequestParams rp = new DataImporter.RequestParams();
+    rp.command = "full-import";
+    SolrWriterImpl swi = new SolrWriterImpl();
+    di.runCmd(rp, swi);
+    Assert.assertEquals("top2 and its direct children did not return 3 messages", swi.docs.size(), 3);
+  }
+
+  @Test
+  @Ignore
+  public void testFetchTimeSince() throws ParseException {
+    paramMap.put("folders", "top1/child11");
+    paramMap.put("recurse", "true");
+    paramMap.put("processAttachement", "false");
+    paramMap.put("fetchMailsSince", "2008-12-26 00:00:00");
+    DataImporter di = new DataImporter();
+    di.loadAndInit(getConfigFromMap(paramMap));
+    DataConfig.Entity ent = di.getConfig().document.entities.get(0);
+    ent.isDocRoot = true;
+    DataImporter.RequestParams rp = new DataImporter.RequestParams();
+    rp.command = "full-import";
+    SolrWriterImpl swi = new SolrWriterImpl();
+    di.runCmd(rp, swi);
+    Assert.assertEquals("top2 and its direct children did not return 3 messages", swi.docs.size(), 3);
+  }
+
+  private String getConfigFromMap(Map<String, String> params) {
+    String conf =
+            "<dataConfig>" +
+                    "<document>" +
+                    "<entity processor=\"org.apache.solr.handler.dataimport.MailEntityProcessor\" " +
+                    "someconfig" +
+                    "/>" +
+                    "</document>" +
+                    "</dataConfig>";
+    params.put("user", user);
+    params.put("password", password);
+    params.put("host", host);
+    params.put("protocol", protocol);
+    StringBuilder attribs = new StringBuilder("");
+    for (String key : params.keySet())
+      attribs.append(" ").append(key).append("=" + "\"").append(params.get(key)).append("\"");
+    attribs.append(" ");
+    return conf.replace("someconfig", attribs.toString());
+  }
+
+  static class SolrWriterImpl extends SolrWriter {
+    List<SolrInputDocument> docs = new ArrayList<SolrInputDocument>();
+    Boolean deleteAllCalled;
+    Boolean commitCalled;
+
+    public SolrWriterImpl() {
+      super(null, ".");
+    }
+
+    public boolean upload(SolrInputDocument doc) {
+      return docs.add(doc);
+    }
+
+    public void log(int event, String name, Object row) {
+      // Do nothing
+    }
+
+    public void doDeleteAll() {
+      deleteAllCalled = Boolean.TRUE;
+    }
+
+    public void commit(boolean b) {
+      commitCalled = Boolean.TRUE;
+    }
+  }
+}

