GitDiffStart: a993ae9032337ca8d5b2c7a4d58bf41a6f5053f5 | Tue Jun 28 23:32:27 2011 +0000
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/docvalues/BoolDocValues.java b/modules/queries/src/java/org/apache/lucene/queries/function/docvalues/BoolDocValues.java
new file mode 100644
index 0000000..f958295
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/docvalues/BoolDocValues.java
@@ -0,0 +1,81 @@
+package org.apache.lucene.queries.function.docvalues;
+
+import org.apache.lucene.common.mutable.MutableValue;
+import org.apache.lucene.common.mutable.MutableValueBool;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+
+
+public abstract class BoolDocValues extends DocValues {
+  protected final ValueSource vs;
+
+  public BoolDocValues(ValueSource vs) {
+    this.vs = vs;
+  }
+
+  @Override
+  public abstract boolean boolVal(int doc);
+
+  @Override
+  public byte byteVal(int doc) {
+    return boolVal(doc) ? (byte)1 : (byte)0;
+  }
+
+  @Override
+  public short shortVal(int doc) {
+    return boolVal(doc) ? (short)1 : (short)0;
+  }
+
+  @Override
+  public float floatVal(int doc) {
+    return boolVal(doc) ? (float)1 : (float)0;
+  }
+
+  @Override
+  public int intVal(int doc) {
+    return boolVal(doc) ? 1 : 0;
+  }
+
+  @Override
+  public long longVal(int doc) {
+    return boolVal(doc) ? (long)1 : (long)0;
+  }
+
+  @Override
+  public double doubleVal(int doc) {
+    return boolVal(doc) ? (double)1 : (double)0;
+  }
+
+  @Override
+  public String strVal(int doc) {
+    return Boolean.toString(boolVal(doc));
+  }
+
+  @Override
+  public Object objectVal(int doc) {
+    return exists(doc) ? boolVal(doc) : null;
+  }
+
+  @Override
+  public String toString(int doc) {
+    return vs.description() + '=' + strVal(doc);
+  }
+
+  @Override
+  public ValueFiller getValueFiller() {
+    return new ValueFiller() {
+      private final MutableValueBool mval = new MutableValueBool();
+
+      @Override
+      public MutableValue getValue() {
+        return mval;
+      }
+
+      @Override
+      public void fillValue(int doc) {
+        mval.value = boolVal(doc);
+        mval.exists = exists(doc);
+      }
+    };
+  }
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/docvalues/DoubleDocValues.java b/modules/queries/src/java/org/apache/lucene/queries/function/docvalues/DoubleDocValues.java
new file mode 100644
index 0000000..292af4c
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/docvalues/DoubleDocValues.java
@@ -0,0 +1,81 @@
+package org.apache.lucene.queries.function.docvalues;
+
+import org.apache.lucene.common.mutable.MutableValue;
+import org.apache.lucene.common.mutable.MutableValueDouble;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+
+public abstract class DoubleDocValues extends DocValues {
+  protected final ValueSource vs;
+
+  public DoubleDocValues(ValueSource vs) {
+    this.vs = vs;
+  }
+
+  @Override
+  public byte byteVal(int doc) {
+    return (byte)doubleVal(doc);
+  }
+
+  @Override
+  public short shortVal(int doc) {
+    return (short)doubleVal(doc);
+  }
+
+  @Override
+  public float floatVal(int doc) {
+    return (float)doubleVal(doc);
+  }
+
+  @Override
+  public int intVal(int doc) {
+    return (int)doubleVal(doc);
+  }
+
+  @Override
+  public long longVal(int doc) {
+    return (long)doubleVal(doc);
+  }
+
+  @Override
+  public boolean boolVal(int doc) {
+    return doubleVal(doc) != 0;
+  }
+
+  @Override
+  public abstract double doubleVal(int doc);
+
+  @Override
+  public String strVal(int doc) {
+    return Double.toString(doubleVal(doc));
+  }
+
+  @Override
+  public Object objectVal(int doc) {
+    return exists(doc) ? doubleVal(doc) : null;
+  }
+
+  @Override
+  public String toString(int doc) {
+    return vs.description() + '=' + strVal(doc);
+  }
+
+  @Override
+  public ValueFiller getValueFiller() {
+    return new ValueFiller() {
+      private final MutableValueDouble mval = new MutableValueDouble();
+
+      @Override
+      public MutableValue getValue() {
+        return mval;
+      }
+
+      @Override
+      public void fillValue(int doc) {
+        mval.value = doubleVal(doc);
+        mval.exists = exists(doc);
+      }
+    };
+  }
+
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/docvalues/FloatDocValues.java b/modules/queries/src/java/org/apache/lucene/queries/function/docvalues/FloatDocValues.java
new file mode 100644
index 0000000..312de6b
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/docvalues/FloatDocValues.java
@@ -0,0 +1,75 @@
+package org.apache.lucene.queries.function.docvalues;
+
+import org.apache.lucene.common.mutable.MutableValue;
+import org.apache.lucene.common.mutable.MutableValueFloat;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+
+public abstract class FloatDocValues extends DocValues {
+  protected final ValueSource vs;
+
+  public FloatDocValues(ValueSource vs) {
+    this.vs = vs;
+  }
+
+  @Override
+  public byte byteVal(int doc) {
+    return (byte)floatVal(doc);
+  }
+
+  @Override
+  public short shortVal(int doc) {
+    return (short)floatVal(doc);
+  }
+
+  @Override
+  public abstract float floatVal(int doc);
+
+  @Override
+  public int intVal(int doc) {
+    return (int)floatVal(doc);
+  }
+
+  @Override
+  public long longVal(int doc) {
+    return (long)floatVal(doc);
+  }
+
+  @Override
+  public double doubleVal(int doc) {
+    return (double)floatVal(doc);
+  }
+
+  @Override
+  public String strVal(int doc) {
+    return Float.toString(floatVal(doc));
+  }
+
+  @Override
+  public Object objectVal(int doc) {
+    return exists(doc) ? floatVal(doc) : null;
+  }
+
+  @Override
+  public String toString(int doc) {
+    return vs.description() + '=' + strVal(doc);
+  }
+
+  @Override
+  public ValueFiller getValueFiller() {
+    return new ValueFiller() {
+      private final MutableValueFloat mval = new MutableValueFloat();
+
+      @Override
+      public MutableValue getValue() {
+        return mval;
+      }
+
+      @Override
+      public void fillValue(int doc) {
+        mval.value = floatVal(doc);
+        mval.exists = exists(doc);
+      }
+    };
+  }
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/docvalues/IntDocValues.java b/modules/queries/src/java/org/apache/lucene/queries/function/docvalues/IntDocValues.java
new file mode 100644
index 0000000..dd1e1b3
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/docvalues/IntDocValues.java
@@ -0,0 +1,76 @@
+package org.apache.lucene.queries.function.docvalues;
+
+import org.apache.lucene.common.mutable.MutableValue;
+import org.apache.lucene.common.mutable.MutableValueInt;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+
+
+public abstract class IntDocValues extends DocValues {
+  protected final ValueSource vs;
+
+  public IntDocValues(ValueSource vs) {
+    this.vs = vs;
+  }
+
+  @Override
+  public byte byteVal(int doc) {
+    return (byte)intVal(doc);
+  }
+
+  @Override
+  public short shortVal(int doc) {
+    return (short)intVal(doc);
+  }
+
+  @Override
+  public float floatVal(int doc) {
+    return (float)intVal(doc);
+  }
+
+  @Override
+  public abstract int intVal(int doc);
+
+  @Override
+  public long longVal(int doc) {
+    return (long)intVal(doc);
+  }
+
+  @Override
+  public double doubleVal(int doc) {
+    return (double)intVal(doc);
+  }
+
+  @Override
+  public String strVal(int doc) {
+    return Integer.toString(intVal(doc));
+  }
+
+  @Override
+  public Object objectVal(int doc) {
+    return exists(doc) ? intVal(doc) : null;
+  }
+
+  @Override
+  public String toString(int doc) {
+    return vs.description() + '=' + strVal(doc);
+  }
+
+  @Override
+  public ValueFiller getValueFiller() {
+    return new ValueFiller() {
+      private final MutableValueInt mval = new MutableValueInt();
+
+      @Override
+      public MutableValue getValue() {
+        return mval;
+      }
+
+      @Override
+      public void fillValue(int doc) {
+        mval.value = intVal(doc);
+        mval.exists = exists(doc);
+      }
+    };
+  }
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/docvalues/LongDocValues.java b/modules/queries/src/java/org/apache/lucene/queries/function/docvalues/LongDocValues.java
new file mode 100644
index 0000000..8fbe1d9
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/docvalues/LongDocValues.java
@@ -0,0 +1,81 @@
+package org.apache.lucene.queries.function.docvalues;
+
+import org.apache.lucene.common.mutable.MutableValue;
+import org.apache.lucene.common.mutable.MutableValueLong;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+
+
+public abstract class LongDocValues extends DocValues {
+  protected final ValueSource vs;
+
+  public LongDocValues(ValueSource vs) {
+    this.vs = vs;
+  }
+
+  @Override
+  public byte byteVal(int doc) {
+    return (byte)longVal(doc);
+  }
+
+  @Override
+  public short shortVal(int doc) {
+    return (short)longVal(doc);
+  }
+
+  @Override
+  public float floatVal(int doc) {
+    return (float)longVal(doc);
+  }
+
+  @Override
+  public int intVal(int doc) {
+    return (int)longVal(doc);
+  }
+
+  @Override
+  public abstract long longVal(int doc);
+
+  @Override
+  public double doubleVal(int doc) {
+    return (double)longVal(doc);
+  }
+
+  @Override
+  public boolean boolVal(int doc) {
+    return longVal(doc) != 0;
+  }
+
+  @Override
+  public String strVal(int doc) {
+    return Long.toString(longVal(doc));
+  }
+
+  @Override
+  public Object objectVal(int doc) {
+    return exists(doc) ? longVal(doc) : null;
+  }
+
+  @Override
+  public String toString(int doc) {
+    return vs.description() + '=' + strVal(doc);
+  }
+
+  @Override
+  public ValueFiller getValueFiller() {
+    return new ValueFiller() {
+      private final MutableValueLong mval = new MutableValueLong();
+
+      @Override
+      public MutableValue getValue() {
+        return mval;
+      }
+
+      @Override
+      public void fillValue(int doc) {
+        mval.value = longVal(doc);
+        mval.exists = exists(doc);
+      }
+    };
+  }
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/docvalues/StrDocValues.java b/modules/queries/src/java/org/apache/lucene/queries/function/docvalues/StrDocValues.java
new file mode 100644
index 0000000..57e7a34
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/docvalues/StrDocValues.java
@@ -0,0 +1,50 @@
+package org.apache.lucene.queries.function.docvalues;
+
+import org.apache.lucene.common.mutable.MutableValue;
+import org.apache.lucene.common.mutable.MutableValueStr;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.util.BytesRef;
+
+public abstract class StrDocValues extends DocValues {
+  protected final ValueSource vs;
+
+  public StrDocValues(ValueSource vs) {
+    this.vs = vs;
+  }
+
+  @Override
+  public abstract String strVal(int doc);
+
+  @Override
+  public Object objectVal(int doc) {
+    return exists(doc) ? strVal(doc) : null;
+  }
+
+  @Override
+  public boolean boolVal(int doc) {
+    return exists(doc);
+  }
+
+  @Override
+  public String toString(int doc) {
+    return vs.description() + "='" + strVal(doc) + "'";
+  }
+
+  @Override
+  public ValueFiller getValueFiller() {
+    return new ValueFiller() {
+      private final MutableValueStr mval = new MutableValueStr();
+
+      @Override
+      public MutableValue getValue() {
+        return mval;
+      }
+
+      @Override
+      public void fillValue(int doc) {
+        mval.exists = bytesVal(doc, mval.value);
+      }
+    };
+  }
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/docvalues/StringIndexDocValues.java b/modules/queries/src/java/org/apache/lucene/queries/function/docvalues/StringIndexDocValues.java
new file mode 100755
index 0000000..d00eb75
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/docvalues/StringIndexDocValues.java
@@ -0,0 +1,165 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.docvalues;
+
+import org.apache.lucene.common.mutable.MutableValue;
+import org.apache.lucene.common.mutable.MutableValueStr;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.ValueSourceScorer;
+import org.apache.lucene.search.FieldCache;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.CharsRef;
+
+import java.io.IOException;
+
+/** Internal class, subject to change.
+ *  Serves as base class for DocValues based on StringIndex 
+ **/
+public abstract class StringIndexDocValues extends DocValues {
+  protected final FieldCache.DocTermsIndex termsIndex;
+  protected final ValueSource vs;
+  protected final MutableValueStr val = new MutableValueStr();
+  protected final BytesRef spare = new BytesRef();
+  protected final CharsRef spareChars = new CharsRef();
+
+  public StringIndexDocValues(ValueSource vs, AtomicReaderContext context, String field) throws IOException {
+    try {
+      termsIndex = FieldCache.DEFAULT.getTermsIndex(context.reader, field);
+    } catch (RuntimeException e) {
+      throw new StringIndexException(field, e);
+    }
+    this.vs = vs;
+  }
+
+  public FieldCache.DocTermsIndex getDocTermsIndex() {
+    return termsIndex;
+  }
+
+  protected abstract String toTerm(String readableValue);
+
+  @Override
+  public boolean exists(int doc) {
+    return termsIndex.getOrd(doc) != 0;
+  }
+
+
+  @Override
+  public boolean bytesVal(int doc, BytesRef target) {
+    int ord=termsIndex.getOrd(doc);
+    if (ord==0) {
+      target.length = 0;
+      return false;
+    }
+    termsIndex.lookup(ord, target);
+    return true;
+  }
+
+  @Override
+  public String strVal(int doc) {
+    int ord=termsIndex.getOrd(doc);
+    if (ord==0) return null;
+    termsIndex.lookup(ord, spare);
+    spare.utf8ToChars(spareChars);
+    return spareChars.toString();
+  }
+
+  @Override
+  public boolean boolVal(int doc) {
+    return exists(doc);
+  }
+
+  @Override
+  public abstract Object objectVal(int doc);  // force subclasses to override
+
+  @Override
+  public ValueSourceScorer getRangeScorer(IndexReader reader, String lowerVal, String upperVal, boolean includeLower, boolean includeUpper) {
+    // TODO: are lowerVal and upperVal in indexed form or not?
+    lowerVal = lowerVal == null ? null : toTerm(lowerVal);
+    upperVal = upperVal == null ? null : toTerm(upperVal);
+
+    final BytesRef spare = new BytesRef();
+
+    int lower = Integer.MIN_VALUE;
+    if (lowerVal != null) {
+      lower = termsIndex.binarySearchLookup(new BytesRef(lowerVal), spare);
+      if (lower < 0) {
+        lower = -lower-1;
+      } else if (!includeLower) {
+        lower++;
+      }
+    }
+
+    int upper = Integer.MAX_VALUE;
+    if (upperVal != null) {
+      upper = termsIndex.binarySearchLookup(new BytesRef(upperVal), spare);
+      if (upper < 0) {
+        upper = -upper-2;
+      } else if (!includeUpper) {
+        upper--;
+      }
+    }
+
+    final int ll = lower;
+    final int uu = upper;
+
+    return new ValueSourceScorer(reader, this) {
+      @Override
+      public boolean matchesValue(int doc) {
+        int ord = termsIndex.getOrd(doc);
+        return ord >= ll && ord <= uu;
+      }
+    };
+  }
+
+  @Override
+  public String toString(int doc) {
+    return vs.description() + '=' + strVal(doc);
+  }
+
+  @Override
+  public ValueFiller getValueFiller() {
+    return new ValueFiller() {
+      private final MutableValueStr mval = new MutableValueStr();
+
+      @Override
+      public MutableValue getValue() {
+        return mval;
+      }
+
+      @Override
+      public void fillValue(int doc) {
+        int ord = termsIndex.getOrd(doc);
+        mval.exists = ord != 0;
+        mval.value = termsIndex.lookup(ord, mval.value);
+      }
+    };
+  }
+
+  public static final class StringIndexException extends RuntimeException {
+    public StringIndexException(final String fieldName,
+                                final RuntimeException cause) {
+      super("Can't initialize StringIndex to generate (function) " +
+              "DocValues for field: " + fieldName, cause);
+    }
+  }
+
+
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/BoolFunction.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/BoolFunction.java
new file mode 100644
index 0000000..93f1e28
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/BoolFunction.java
@@ -0,0 +1,25 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.queries.function.ValueSource;
+
+
+public abstract class BoolFunction extends ValueSource {
+  // TODO: placeholder to return type, among other common future functionality
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/ByteFieldSource.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/ByteFieldSource.java
new file mode 100644
index 0000000..8a136f2
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/ByteFieldSource.java
@@ -0,0 +1,99 @@
+package org.apache.lucene.queries.function.valuesource;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.search.cache.ByteValuesCreator;
+import org.apache.lucene.search.cache.CachedArray.ByteValues;
+
+import java.io.IOException;
+import java.util.Map;
+
+/**
+ * Obtains int field values from the {@link org.apache.lucene.search.FieldCache}
+ * using <code>getInts()</code>
+ * and makes those values available as other numeric types, casting as needed. *
+ *
+ *
+ */
+
+public class ByteFieldSource extends NumericFieldCacheSource<ByteValues> {
+
+  public ByteFieldSource(ByteValuesCreator creator) {
+    super(creator);
+  }
+
+  @Override
+  public String description() {
+    return "byte(" + field + ')';
+  }
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    final ByteValues vals = cache.getBytes(readerContext.reader, field, creator);
+    final byte[] arr = vals.values;
+    
+    return new DocValues() {
+      @Override
+      public byte byteVal(int doc) {
+        return arr[doc];
+      }
+
+      @Override
+      public short shortVal(int doc) {
+        return (short) arr[doc];
+      }
+
+      @Override
+      public float floatVal(int doc) {
+        return (float) arr[doc];
+      }
+
+      @Override
+      public int intVal(int doc) {
+        return (int) arr[doc];
+      }
+
+      @Override
+      public long longVal(int doc) {
+        return (long) arr[doc];
+      }
+
+      @Override
+      public double doubleVal(int doc) {
+        return (double) arr[doc];
+      }
+
+      @Override
+      public String strVal(int doc) {
+        return Byte.toString(arr[doc]);
+      }
+
+      @Override
+      public String toString(int doc) {
+        return description() + '=' + byteVal(doc);
+      }
+
+      @Override
+      public Object objectVal(int doc) {
+        return arr[doc];  // TODO: valid?
+      }
+
+    };
+  }
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/ConstNumberSource.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/ConstNumberSource.java
new file mode 100755
index 0000000..425ce52
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/ConstNumberSource.java
@@ -0,0 +1,32 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.queries.function.ValueSource;
+
+/**
+ * <code>ConstNumberSource</code> is the base class for all constant numbers
+ */
+public abstract class ConstNumberSource extends ValueSource {
+  public abstract int getInt();
+  public abstract long getLong();
+  public abstract float getFloat();
+  public abstract double getDouble();  
+  public abstract Number getNumber();  
+  public abstract boolean getBool();
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/ConstValueSource.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/ConstValueSource.java
new file mode 100755
index 0000000..8694695
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/ConstValueSource.java
@@ -0,0 +1,119 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.docvalues.FloatDocValues;
+
+import java.io.IOException;
+import java.util.Map;
+
+/**
+ * <code>ConstValueSource</code> returns a constant for all documents
+ */
+public class ConstValueSource extends ConstNumberSource {
+  final float constant;
+  private final double dv;
+
+  public ConstValueSource(float constant) {
+    this.constant = constant;
+    this.dv = constant;
+  }
+
+  @Override
+  public String description() {
+    return "const(" + constant + ")";
+  }
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    return new FloatDocValues(this) {
+      @Override
+      public float floatVal(int doc) {
+        return constant;
+      }
+      @Override
+      public int intVal(int doc) {
+        return (int)constant;
+      }
+      @Override
+      public long longVal(int doc) {
+        return (long)constant;
+      }
+      @Override
+      public double doubleVal(int doc) {
+        return dv;
+      }
+      @Override
+      public String toString(int doc) {
+        return description();
+      }
+      @Override
+      public Object objectVal(int doc) {
+        return constant;
+      }
+      @Override
+      public boolean boolVal(int doc) {
+        return constant != 0.0f;
+      }
+    };
+  }
+
+  @Override
+  public int hashCode() {
+    return Float.floatToIntBits(constant) * 31;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (!(o instanceof ConstValueSource)) return false;
+    ConstValueSource other = (ConstValueSource)o;
+    return  this.constant == other.constant;
+  }
+
+  @Override
+  public int getInt() {
+    return (int)constant;
+  }
+
+  @Override
+  public long getLong() {
+    return (long)constant;
+  }
+
+  @Override
+  public float getFloat() {
+    return constant;
+  }
+
+  @Override
+  public double getDouble() {
+    return dv;
+  }
+
+  @Override
+  public Number getNumber() {
+    return constant;
+  }
+
+  @Override
+  public boolean getBool() {
+    return constant != 0.0f;
+  }
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/DefFunction.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/DefFunction.java
new file mode 100644
index 0000000..1b133a1
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/DefFunction.java
@@ -0,0 +1,126 @@
+package org.apache.lucene.queries.function.valuesource;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.util.BytesRef;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+
+public class DefFunction extends MultiFunction {
+  public DefFunction(List<ValueSource> sources) {
+    super(sources);
+  }
+
+  @Override
+  protected String name() {
+    return "def";
+  }
+
+
+  @Override
+  public DocValues getValues(Map fcontext, AtomicReaderContext readerContext) throws IOException {
+
+
+    return new Values(valsArr(sources, fcontext, readerContext)) {
+      final int upto = valsArr.length - 1;
+
+      private DocValues get(int doc) {
+        for (int i=0; i<upto; i++) {
+          DocValues vals = valsArr[i];
+          if (vals.exists(doc)) {
+            return vals;
+          }
+        }
+        return valsArr[upto];
+      }
+
+      @Override
+      public byte byteVal(int doc) {
+        return get(doc).byteVal(doc);
+      }
+
+      @Override
+      public short shortVal(int doc) {
+        return get(doc).shortVal(doc);
+      }
+
+      @Override
+      public float floatVal(int doc) {
+        return get(doc).floatVal(doc);
+      }
+
+      @Override
+      public int intVal(int doc) {
+        return get(doc).intVal(doc);
+      }
+
+      @Override
+      public long longVal(int doc) {
+        return get(doc).longVal(doc);
+      }
+
+      @Override
+      public double doubleVal(int doc) {
+        return get(doc).doubleVal(doc);
+      }
+
+      @Override
+      public String strVal(int doc) {
+        return get(doc).strVal(doc);
+      }
+
+      @Override
+      public boolean boolVal(int doc) {
+        return get(doc).boolVal(doc);
+      }
+
+      @Override
+      public boolean bytesVal(int doc, BytesRef target) {
+        return get(doc).bytesVal(doc, target);
+      }
+
+      @Override
+      public Object objectVal(int doc) {
+        return get(doc).objectVal(doc);
+      }
+
+      @Override
+      public boolean exists(int doc) {
+        // return true if any source is exists?
+        for (DocValues vals : valsArr) {
+          if (vals.exists(doc)) {
+            return true;
+          }
+        }
+        return false;
+      }
+
+      @Override
+      public ValueFiller getValueFiller() {
+        // TODO: need ValueSource.type() to determine correct type
+        return super.getValueFiller();
+      }
+    };
+  }
+}
\ No newline at end of file
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/DivFloatFunction.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/DivFloatFunction.java
new file mode 100755
index 0000000..23e4fe9
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/DivFloatFunction.java
@@ -0,0 +1,43 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+
+/** Function to divide "a" by "b"
+ */
+public class DivFloatFunction extends DualFloatFunction {
+ /**
+   * @param   a  the numerator.
+   * @param   b  the denominator.
+   */
+  public DivFloatFunction(ValueSource a, ValueSource b) {
+    super(a,b);
+  }
+
+  @Override
+  protected String name() {
+    return "div";
+  }
+
+  @Override
+  protected float func(int doc, DocValues aVals, DocValues bVals) {
+    return aVals.floatVal(doc) / bVals.floatVal(doc);
+  }
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/DocFreqValueSource.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/DocFreqValueSource.java
new file mode 100755
index 0000000..6a76f32
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/DocFreqValueSource.java
@@ -0,0 +1,172 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.DoubleDocValues;
+import org.apache.lucene.queries.function.docvalues.IntDocValues;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.util.BytesRef;
+
+import java.io.IOException;
+import java.util.Map;
+
+
+class ConstIntDocValues extends IntDocValues {
+  final int ival;
+  final float fval;
+  final double dval;
+  final long lval;
+  final String sval;
+  final ValueSource parent;
+
+  ConstIntDocValues(int val, ValueSource parent) {
+    super(parent);
+    ival = val;
+    fval = val;
+    dval = val;
+    lval = val;
+    sval = Integer.toString(val);
+    this.parent = parent;
+  }
+
+  @Override
+  public float floatVal(int doc) {
+    return fval;
+  }
+  @Override
+  public int intVal(int doc) {
+    return ival;
+  }
+  @Override
+  public long longVal(int doc) {
+    return lval;
+  }
+  @Override
+  public double doubleVal(int doc) {
+    return dval;
+  }
+  @Override
+  public String strVal(int doc) {
+    return sval;
+  }
+  @Override
+  public String toString(int doc) {
+    return parent.description() + '=' + sval;
+  }
+}
+
+class ConstDoubleDocValues extends DoubleDocValues {
+  final int ival;
+  final float fval;
+  final double dval;
+  final long lval;
+  final String sval;
+  final ValueSource parent;
+
+  ConstDoubleDocValues(double val, ValueSource parent) {
+    super(parent);
+    ival = (int)val;
+    fval = (float)val;
+    dval = val;
+    lval = (long)val;
+    sval = Double.toString(val);
+    this.parent = parent;
+  }
+
+  @Override
+  public float floatVal(int doc) {
+    return fval;
+  }
+  @Override
+  public int intVal(int doc) {
+    return ival;
+  }
+  @Override
+  public long longVal(int doc) {
+    return lval;
+  }
+  @Override
+  public double doubleVal(int doc) {
+    return dval;
+  }
+  @Override
+  public String strVal(int doc) {
+    return sval;
+  }
+  @Override
+  public String toString(int doc) {
+    return parent.description() + '=' + sval;
+  }
+}
+
+
+/**
+ * <code>DocFreqValueSource</code> returns the number of documents containing the term.
+ * @lucene.internal
+ */
+public class DocFreqValueSource extends ValueSource {
+  protected String field;
+  protected String indexedField;
+  protected String val;
+  protected BytesRef indexedBytes;
+
+  public DocFreqValueSource(String field, String val, String indexedField, BytesRef indexedBytes) {
+    this.field = field;
+    this.val = val;
+    this.indexedField = indexedField;
+    this.indexedBytes = indexedBytes;
+  }
+
+  public String name() {
+    return "docfreq";
+  }
+
+  @Override
+  public String description() {
+    return name() + '(' + field + ',' + val + ')';
+  }
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    IndexSearcher searcher = (IndexSearcher)context.get("searcher");
+    int docfreq = searcher.docFreq(new Term(indexedField, indexedBytes));
+    return new ConstIntDocValues(docfreq, this);
+  }
+
+  @Override
+  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
+    context.put("searcher",searcher);
+  }
+
+  @Override
+  public int hashCode() {
+    return getClass().hashCode() + indexedField.hashCode()*29 + indexedBytes.hashCode();
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this.getClass() != o.getClass()) return false;
+    DocFreqValueSource other = (DocFreqValueSource)o;
+    return this.indexedField.equals(other.indexedField) && this.indexedBytes.equals(other.indexedBytes);
+  }
+}
+
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/DoubleConstValueSource.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/DoubleConstValueSource.java
new file mode 100755
index 0000000..35f3362
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/DoubleConstValueSource.java
@@ -0,0 +1,125 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.docvalues.DoubleDocValues;
+
+import java.io.IOException;
+import java.util.Map;
+
+public class DoubleConstValueSource extends ConstNumberSource {
+  final double constant;
+  private final float fv;
+  private final long lv;
+
+  public DoubleConstValueSource(double constant) {
+    this.constant = constant;
+    this.fv = (float)constant;
+    this.lv = (long)constant;
+  }
+
+  @Override
+  public String description() {
+    return "const(" + constant + ")";
+  }
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    return new DoubleDocValues(this) {
+      @Override
+      public float floatVal(int doc) {
+        return fv;
+      }
+
+      @Override
+      public int intVal(int doc) {
+        return (int) lv;
+      }
+
+      @Override
+      public long longVal(int doc) {
+        return lv;
+      }
+
+      @Override
+      public double doubleVal(int doc) {
+        return constant;
+      }
+
+      @Override
+      public String strVal(int doc) {
+        return Double.toString(constant);
+      }
+
+      @Override
+      public Object objectVal(int doc) {
+        return constant;
+      }
+
+      @Override
+      public String toString(int doc) {
+        return description();
+      }
+    };
+  }
+
+  @Override
+  public int hashCode() {
+    long bits = Double.doubleToRawLongBits(constant);
+    return (int)(bits ^ (bits >>> 32));
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (!(o instanceof DoubleConstValueSource)) return false;
+    DoubleConstValueSource other = (DoubleConstValueSource) o;
+    return this.constant == other.constant;
+  }
+
+  @Override
+  public int getInt() {
+    return (int)lv;
+  }
+
+  @Override
+  public long getLong() {
+    return lv;
+  }
+
+  @Override
+  public float getFloat() {
+    return fv;
+  }
+
+  @Override
+  public double getDouble() {
+    return constant;
+  }
+
+  @Override
+  public Number getNumber() {
+    return constant;
+  }
+
+  @Override
+  public boolean getBool() {
+    return constant != 0;
+  }
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/DoubleFieldSource.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/DoubleFieldSource.java
new file mode 100644
index 0000000..fb5c441
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/DoubleFieldSource.java
@@ -0,0 +1,151 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.common.mutable.MutableValue;
+import org.apache.lucene.common.mutable.MutableValueDouble;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSourceScorer;
+import org.apache.lucene.queries.function.docvalues.DoubleDocValues;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.search.cache.DoubleValuesCreator;
+import org.apache.lucene.search.cache.CachedArray.DoubleValues;
+
+import java.io.IOException;
+import java.util.Map;
+
+/**
+ * Obtains float field values from the {@link org.apache.lucene.search.FieldCache}
+ * using <code>getFloats()</code>
+ * and makes those values available as other numeric types, casting as needed.
+ *
+ *
+ */
+
+public class DoubleFieldSource extends NumericFieldCacheSource<DoubleValues> {
+
+  public DoubleFieldSource(DoubleValuesCreator creator) {
+    super(creator);
+  }
+
+  @Override
+  public String description() {
+    return "double(" + field + ')';
+  }
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    final DoubleValues vals = cache.getDoubles(readerContext.reader, field, creator);
+    final double[] arr = vals.values;
+    final Bits valid = vals.valid;
+    
+    return new DoubleDocValues(this) {
+      @Override
+      public double doubleVal(int doc) {
+        return arr[doc];
+      }
+
+      @Override
+      public boolean exists(int doc) {
+        return valid.get(doc);
+      }
+
+      @Override
+      public ValueSourceScorer getRangeScorer(IndexReader reader, String lowerVal, String upperVal, boolean includeLower, boolean includeUpper) {
+        double lower,upper;
+
+        if (lowerVal==null) {
+          lower = Double.NEGATIVE_INFINITY;
+        } else {
+          lower = Double.parseDouble(lowerVal);
+        }
+
+         if (upperVal==null) {
+          upper = Double.POSITIVE_INFINITY;
+        } else {
+          upper = Double.parseDouble(upperVal);
+        }
+
+        final double l = lower;
+        final double u = upper;
+
+
+        if (includeLower && includeUpper) {
+          return new ValueSourceScorer(reader, this) {
+            @Override
+            public boolean matchesValue(int doc) {
+              double docVal = doubleVal(doc);
+              return docVal >= l && docVal <= u;
+            }
+          };
+        }
+        else if (includeLower && !includeUpper) {
+          return new ValueSourceScorer(reader, this) {
+            @Override
+            public boolean matchesValue(int doc) {
+              double docVal = doubleVal(doc);
+              return docVal >= l && docVal < u;
+            }
+          };
+        }
+        else if (!includeLower && includeUpper) {
+          return new ValueSourceScorer(reader, this) {
+            @Override
+            public boolean matchesValue(int doc) {
+              double docVal = doubleVal(doc);
+              return docVal > l && docVal <= u;
+            }
+          };
+        }
+        else {
+          return new ValueSourceScorer(reader, this) {
+            @Override
+            public boolean matchesValue(int doc) {
+              double docVal = doubleVal(doc);
+              return docVal > l && docVal < u;
+            }
+          };
+        }
+      }
+
+      @Override
+      public ValueFiller getValueFiller() {
+        return new ValueFiller() {
+          private final double[] doubleArr = arr;
+          private final MutableValueDouble mval = new MutableValueDouble();
+
+          @Override
+          public MutableValue getValue() {
+            return mval;
+          }
+
+          @Override
+          public void fillValue(int doc) {
+            mval.value = doubleArr[doc];
+            mval.exists = valid.get(doc);
+          }
+        };
+      }
+
+
+      };
+
+  }
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/DualFloatFunction.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/DualFloatFunction.java
new file mode 100755
index 0000000..3d2f12c
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/DualFloatFunction.java
@@ -0,0 +1,89 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.FloatDocValues;
+import org.apache.lucene.search.IndexSearcher;
+
+import java.io.IOException;
+import java.util.Map;
+
+public abstract class DualFloatFunction extends ValueSource {
+  protected final ValueSource a;
+  protected final ValueSource b;
+
+ /**
+   * @param   a  the base.
+   * @param   b  the exponent.
+   */
+  public DualFloatFunction(ValueSource a, ValueSource b) {
+    this.a = a;
+    this.b = b;
+  }
+
+  protected abstract String name();
+  protected abstract float func(int doc, DocValues aVals, DocValues bVals);
+
+  @Override
+  public String description() {
+    return name() + "(" + a.description() + "," + b.description() + ")";
+  }
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    final DocValues aVals =  a.getValues(context, readerContext);
+    final DocValues bVals =  b.getValues(context, readerContext);
+    return new FloatDocValues(this) {
+      @Override
+      public float floatVal(int doc) {
+	return func(doc, aVals, bVals);
+      }
+      @Override
+      public String toString(int doc) {
+	return name() + '(' + aVals.toString(doc) + ',' + bVals.toString(doc) + ')';
+      }
+    };
+  }
+
+  @Override
+  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
+    a.createWeight(context,searcher);
+    b.createWeight(context,searcher);
+  }
+
+  @Override
+  public int hashCode() {
+    int h = a.hashCode();
+    h ^= (h << 13) | (h >>> 20);
+    h += b.hashCode();
+    h ^= (h << 23) | (h >>> 10);
+    h += name().hashCode();
+    return h;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this.getClass() != o.getClass()) return false;
+    DualFloatFunction other = (DualFloatFunction)o;
+    return this.a.equals(other.a)
+        && this.b.equals(other.b);
+  }
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/FieldCacheSource.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/FieldCacheSource.java
new file mode 100644
index 0000000..20944ee
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/FieldCacheSource.java
@@ -0,0 +1,63 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.search.FieldCache;
+
+/**
+ * A base class for ValueSource implementations that retrieve values for
+ * a single field from the {@link org.apache.lucene.search.FieldCache}.
+ *
+ *
+ */
+public abstract class FieldCacheSource extends ValueSource {
+  protected String field;
+  protected FieldCache cache = FieldCache.DEFAULT;
+
+  public FieldCacheSource(String field) {
+    this.field=field;
+  }
+
+  public FieldCache getFieldCache() {
+    return cache;
+  }
+
+  public String getField() {
+    return field;
+  }
+
+  @Override
+  public String description() {
+    return field;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (!(o instanceof FieldCacheSource)) return false;
+    FieldCacheSource other = (FieldCacheSource)o;
+    return this.field.equals(other.field)
+           && this.cache == other.cache;
+  }
+
+  @Override
+  public int hashCode() {
+    return cache.hashCode() + field.hashCode();
+  };
+
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/FloatFieldSource.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/FloatFieldSource.java
new file mode 100644
index 0000000..87a5db5
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/FloatFieldSource.java
@@ -0,0 +1,94 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import java.io.IOException;
+import java.util.Map;
+
+import org.apache.lucene.common.mutable.MutableValue;
+import org.apache.lucene.common.mutable.MutableValueFloat;
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.docvalues.FloatDocValues;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.search.cache.FloatValuesCreator;
+import org.apache.lucene.search.cache.CachedArray.FloatValues;
+
+/**
+ * Obtains float field values from the {@link org.apache.lucene.search.FieldCache}
+ * using <code>getFloats()</code>
+ * and makes those values available as other numeric types, casting as needed.
+ *
+ *
+ */
+
+public class FloatFieldSource extends NumericFieldCacheSource<FloatValues> {
+
+  public FloatFieldSource(FloatValuesCreator creator) {
+    super(creator);
+  }
+
+  @Override
+  public String description() {
+    return "float(" + field + ')';
+  }
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    final FloatValues vals = cache.getFloats(readerContext.reader, field, creator);
+    final float[] arr = vals.values;
+    final Bits valid = vals.valid;
+    
+    return new FloatDocValues(this) {
+      @Override
+      public float floatVal(int doc) {
+        return arr[doc];
+      }
+
+      @Override
+      public Object objectVal(int doc) {
+        return valid.get(doc) ? arr[doc] : null;
+      }
+
+      @Override
+      public boolean exists(int doc) {
+        return valid.get(doc);
+      }
+
+      @Override
+      public ValueFiller getValueFiller() {
+        return new ValueFiller() {
+          private final float[] floatArr = arr;
+          private final MutableValueFloat mval = new MutableValueFloat();
+
+          @Override
+          public MutableValue getValue() {
+            return mval;
+          }
+
+          @Override
+          public void fillValue(int doc) {
+            mval.value = floatArr[doc];
+            mval.exists = valid.get(doc);
+          }
+        };
+      }
+
+    };
+  }
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/IDFValueSource.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/IDFValueSource.java
new file mode 100755
index 0000000..23ccd22
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/IDFValueSource.java
@@ -0,0 +1,51 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.index.*;
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Similarity;
+import org.apache.lucene.util.BytesRef;
+
+import java.io.IOException;
+import java.util.Map;
+
+/** @lucene.internal */
+public class IDFValueSource extends DocFreqValueSource {
+  public IDFValueSource(String field, String val, String indexedField, BytesRef indexedBytes) {
+    super(field, val, indexedField, indexedBytes);
+  }
+
+  @Override
+  public String name() {
+    return "idf";
+  }
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    IndexSearcher searcher = (IndexSearcher)context.get("searcher");
+    Similarity sim = searcher.getSimilarityProvider().get(field);
+    // todo: we need docFreq that takes a BytesRef
+    int docfreq = searcher.docFreq(new Term(indexedField, indexedBytes.utf8ToString()));
+    float idf = sim.idf(docfreq, searcher.maxDoc());
+    return new ConstDoubleDocValues(idf, this);
+  }
+}
+
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/IfFunction.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/IfFunction.java
new file mode 100644
index 0000000..ee47a69
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/IfFunction.java
@@ -0,0 +1,150 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.search.Explanation;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.util.BytesRef;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.Map;
+
+
+public class IfFunction extends BoolFunction {
+  private ValueSource ifSource;
+  private ValueSource trueSource;
+  private ValueSource falseSource;
+
+
+  public IfFunction(ValueSource ifSource, ValueSource trueSource, ValueSource falseSource) {
+    this.ifSource = ifSource;
+    this.trueSource = trueSource;
+    this.falseSource = falseSource;
+  }
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    final DocValues ifVals = ifSource.getValues(context, readerContext);
+    final DocValues trueVals = trueSource.getValues(context, readerContext);
+    final DocValues falseVals = falseSource.getValues(context, readerContext);
+
+    return new DocValues() {
+      @Override
+      public byte byteVal(int doc) {
+        return ifVals.boolVal(doc) ? trueVals.byteVal(doc) : falseVals.byteVal(doc);
+      }
+
+      @Override
+      public short shortVal(int doc) {
+        return ifVals.boolVal(doc) ? trueVals.shortVal(doc) : falseVals.shortVal(doc);
+      }
+
+      @Override
+      public float floatVal(int doc) {
+        return ifVals.boolVal(doc) ? trueVals.floatVal(doc) : falseVals.floatVal(doc);
+      }
+
+      @Override
+      public int intVal(int doc) {
+        return ifVals.boolVal(doc) ? trueVals.intVal(doc) : falseVals.intVal(doc);
+      }
+
+      @Override
+      public long longVal(int doc) {
+        return ifVals.boolVal(doc) ? trueVals.longVal(doc) : falseVals.longVal(doc);
+      }
+
+      @Override
+      public double doubleVal(int doc) {
+        return ifVals.boolVal(doc) ? trueVals.doubleVal(doc) : falseVals.doubleVal(doc);
+      }
+
+      @Override
+      public String strVal(int doc) {
+        return ifVals.boolVal(doc) ? trueVals.strVal(doc) : falseVals.strVal(doc);
+      }
+
+      @Override
+      public boolean boolVal(int doc) {
+        return ifVals.boolVal(doc) ? trueVals.boolVal(doc) : falseVals.boolVal(doc);
+      }
+
+      @Override
+      public boolean bytesVal(int doc, BytesRef target) {
+        return ifVals.boolVal(doc) ? trueVals.bytesVal(doc, target) : falseVals.bytesVal(doc, target);
+      }
+
+      @Override
+      public Object objectVal(int doc) {
+        return ifVals.boolVal(doc) ? trueVals.objectVal(doc) : falseVals.objectVal(doc);
+      }
+
+      @Override
+      public boolean exists(int doc) {
+        return true; // TODO: flow through to any sub-sources?
+      }
+
+      @Override
+      public ValueFiller getValueFiller() {
+        // TODO: we need types of trueSource / falseSource to handle this
+        // for now, use float.
+        return super.getValueFiller();
+      }
+
+      @Override
+      public String toString(int doc) {
+        return "if(" + ifVals.toString(doc) + ',' + trueVals.toString(doc) + ',' + falseVals.toString(doc) + ')';
+      }
+    };
+
+  }
+
+  @Override
+  public String description() {
+    return "if(" + ifSource.description() + ',' + trueSource.description() + ',' + falseSource + ')';
+  }
+
+  @Override
+  public int hashCode() {
+    int h = ifSource.hashCode();
+    h = h * 31 + trueSource.hashCode();
+    h = h * 31 + falseSource.hashCode();
+    return h;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (!(o instanceof IfFunction)) return false;
+    IfFunction other = (IfFunction)o;
+    return ifSource.equals(other.ifSource)
+        && trueSource.equals(other.trueSource)
+        && falseSource.equals(other.falseSource);
+  }
+
+  @Override
+  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
+    ifSource.createWeight(context, searcher);
+    trueSource.createWeight(context, searcher);
+    falseSource.createWeight(context, searcher);
+  }
+}
\ No newline at end of file
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/IntFieldSource.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/IntFieldSource.java
new file mode 100644
index 0000000..d9498d3
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/IntFieldSource.java
@@ -0,0 +1,158 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.common.mutable.MutableValue;
+import org.apache.lucene.common.mutable.MutableValueInt;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSourceScorer;
+import org.apache.lucene.queries.function.docvalues.IntDocValues;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.search.cache.IntValuesCreator;
+import org.apache.lucene.search.cache.CachedArray.IntValues;
+
+import java.io.IOException;
+import java.util.Map;
+
+/**
+ * Obtains int field values from the {@link org.apache.lucene.search.FieldCache}
+ * using <code>getInts()</code>
+ * and makes those values available as other numeric types, casting as needed. *
+ *
+ */
+
+public class IntFieldSource extends NumericFieldCacheSource<IntValues> {
+
+  public IntFieldSource(IntValuesCreator creator) {
+    super(creator);
+  }
+
+  @Override
+  public String description() {
+    return "int(" + field + ')';
+  }
+
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    final IntValues vals = cache.getInts(readerContext.reader, field, creator);
+    final int[] arr = vals.values;
+    final Bits valid = vals.valid;
+    
+    return new IntDocValues(this) {
+      final MutableValueInt val = new MutableValueInt();
+      
+      @Override
+      public float floatVal(int doc) {
+        return (float)arr[doc];
+      }
+
+      @Override
+      public int intVal(int doc) {
+        return arr[doc];
+      }
+
+      @Override
+      public long longVal(int doc) {
+        return (long)arr[doc];
+      }
+
+      @Override
+      public double doubleVal(int doc) {
+        return (double)arr[doc];
+      }
+
+      @Override
+      public String strVal(int doc) {
+        return Float.toString(arr[doc]);
+      }
+
+      @Override
+      public Object objectVal(int doc) {
+        return valid.get(doc) ? arr[doc] : null;
+      }
+
+      @Override
+      public boolean exists(int doc) {
+        return valid.get(doc);
+      }
+
+      @Override
+      public String toString(int doc) {
+        return description() + '=' + intVal(doc);
+      }
+
+      @Override
+      public ValueSourceScorer getRangeScorer(IndexReader reader, String lowerVal, String upperVal, boolean includeLower, boolean includeUpper) {
+        int lower,upper;
+
+        // instead of using separate comparison functions, adjust the endpoints.
+
+        if (lowerVal==null) {
+          lower = Integer.MIN_VALUE;
+        } else {
+          lower = Integer.parseInt(lowerVal);
+          if (!includeLower && lower < Integer.MAX_VALUE) lower++;
+        }
+
+         if (upperVal==null) {
+          upper = Integer.MAX_VALUE;
+        } else {
+          upper = Integer.parseInt(upperVal);
+          if (!includeUpper && upper > Integer.MIN_VALUE) upper--;
+        }
+
+        final int ll = lower;
+        final int uu = upper;
+
+        return new ValueSourceScorer(reader, this) {
+          @Override
+          public boolean matchesValue(int doc) {
+            int val = arr[doc];
+            // only check for deleted if it's the default value
+            // if (val==0 && reader.isDeleted(doc)) return false;
+            return val >= ll && val <= uu;
+          }
+        };
+      }
+
+      @Override
+      public ValueFiller getValueFiller() {
+        return new ValueFiller() {
+          private final int[] intArr = arr;
+          private final MutableValueInt mval = new MutableValueInt();
+
+          @Override
+          public MutableValue getValue() {
+            return mval;
+          }
+
+          @Override
+          public void fillValue(int doc) {
+            mval.value = intArr[doc];
+            mval.exists = valid.get(doc);
+          }
+        };
+      }
+
+      
+    };
+  }
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/JoinDocFreqValueSource.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/JoinDocFreqValueSource.java
new file mode 100644
index 0000000..8cd7754
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/JoinDocFreqValueSource.java
@@ -0,0 +1,89 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import java.io.IOException;
+import java.util.Map;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.docvalues.IntDocValues;
+import org.apache.lucene.search.FieldCache.DocTerms;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.ReaderUtil;
+
+/**
+ * Use a field value and find the Document Frequency within another field.
+ * 
+ * @since solr 4.0
+ */
+public class JoinDocFreqValueSource extends FieldCacheSource {
+
+  public static final String NAME = "joindf";
+  
+  protected final String qfield;
+  
+  public JoinDocFreqValueSource(String field, String qfield) {
+    super(field);
+    this.qfield = qfield;
+  }
+
+  @Override
+  public String description() {
+    return NAME + "(" + field +":("+qfield+"))";
+  }
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException
+  {
+    final DocTerms terms = cache.getTerms(readerContext.reader, field, true );
+    final IndexReader top = ReaderUtil.getTopLevelContext(readerContext).reader;
+    
+    return new IntDocValues(this) {
+      BytesRef ref = new BytesRef();
+
+      @Override
+      public int intVal(int doc) 
+      {
+        try {
+          terms.getTerm(doc, ref);
+          int v = top.docFreq( qfield, ref ); 
+          //System.out.println( NAME+"["+field+"="+ref.utf8ToString()+"=("+qfield+":"+v+")]" );
+          return v;
+        } 
+        catch (IOException e) {
+          throw new RuntimeException("caught exception in function "+description()+" : doc="+doc, e);
+        }
+      }
+    };
+  }
+  
+  @Override
+  public boolean equals(Object o) {
+    if (o.getClass() !=  JoinDocFreqValueSource.class) return false;
+    JoinDocFreqValueSource other = (JoinDocFreqValueSource)o;
+    if( !qfield.equals( other.qfield ) ) return false;
+    return super.equals(other);
+  }
+
+  @Override
+  public int hashCode() {
+    return qfield.hashCode() + super.hashCode();
+  };
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/LinearFloatFunction.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/LinearFloatFunction.java
new file mode 100644
index 0000000..01edb26
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/LinearFloatFunction.java
@@ -0,0 +1,90 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.FloatDocValues;
+import org.apache.lucene.search.IndexSearcher;
+
+import java.io.IOException;
+import java.util.Map;
+
+/**
+ * <code>LinearFloatFunction</code> implements a linear function over
+ * another {@link ValueSource}.
+ * <br>
+ * Normally Used as an argument to a {@link org.apache.lucene.queries.function.FunctionQuery}
+ *
+ *
+ */
+public class LinearFloatFunction extends ValueSource {
+  protected final ValueSource source;
+  protected final float slope;
+  protected final float intercept;
+
+  public LinearFloatFunction(ValueSource source, float slope, float intercept) {
+    this.source = source;
+    this.slope = slope;
+    this.intercept = intercept;
+  }
+  
+  @Override
+  public String description() {
+    return slope + "*float(" + source.description() + ")+" + intercept;
+  }
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    final DocValues vals =  source.getValues(context, readerContext);
+    return new FloatDocValues(this) {
+      @Override
+      public float floatVal(int doc) {
+        return vals.floatVal(doc) * slope + intercept;
+      }
+      @Override
+      public String toString(int doc) {
+        return slope + "*float(" + vals.toString(doc) + ")+" + intercept;
+      }
+    };
+  }
+
+  @Override
+  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
+    source.createWeight(context, searcher);
+  }
+
+  @Override
+  public int hashCode() {
+    int h = Float.floatToIntBits(slope);
+    h = (h >>> 2) | (h << 30);
+    h += Float.floatToIntBits(intercept);
+    h ^= (h << 14) | (h >>> 19);
+    return h + source.hashCode();
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (LinearFloatFunction.class != o.getClass()) return false;
+    LinearFloatFunction other = (LinearFloatFunction)o;
+    return  this.slope == other.slope
+         && this.intercept == other.intercept
+         && this.source.equals(other.source);
+  }
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/LiteralValueSource.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/LiteralValueSource.java
new file mode 100644
index 0000000..d4eed85
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/LiteralValueSource.java
@@ -0,0 +1,91 @@
+package org.apache.lucene.queries.function.valuesource;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.StrDocValues;
+import org.apache.lucene.util.BytesRef;
+
+import java.util.Map;
+import java.io.IOException;
+
+
+/**
+ * Pass a the field value through as a String, no matter the type // Q: doesn't this mean it's a "string"?
+ *
+ **/
+public class LiteralValueSource extends ValueSource {
+  protected final String string;
+  protected final BytesRef bytesRef;
+
+  public LiteralValueSource(String string) {
+    this.string = string;
+    this.bytesRef = new BytesRef(string);
+  }
+
+  /** returns the literal value */
+  public String getValue() {
+    return string;
+  }
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+
+    return new StrDocValues(this) {
+      @Override
+      public String strVal(int doc) {
+        return string;
+      }
+
+      @Override
+      public boolean bytesVal(int doc, BytesRef target) {
+        target.copy(bytesRef);
+        return true;
+      }
+
+      @Override
+      public String toString(int doc) {
+        return string;
+      }
+    };
+  }
+
+  @Override
+  public String description() {
+    return "literal(" + string + ")";
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (!(o instanceof LiteralValueSource)) return false;
+
+    LiteralValueSource that = (LiteralValueSource) o;
+
+    if (!string.equals(that.string)) return false;
+
+    return true;
+  }
+
+  public static final int hash = LiteralValueSource.class.hashCode();
+  @Override
+  public int hashCode() {
+    return hash + string.hashCode();
+  }
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/LongFieldSource.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/LongFieldSource.java
new file mode 100644
index 0000000..3b3bb00
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/LongFieldSource.java
@@ -0,0 +1,144 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.common.mutable.MutableValue;
+import org.apache.lucene.common.mutable.MutableValueLong;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSourceScorer;
+import org.apache.lucene.queries.function.docvalues.LongDocValues;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.search.cache.LongValuesCreator;
+import org.apache.lucene.search.cache.CachedArray.LongValues;
+
+
+import java.io.IOException;
+import java.util.Map;
+
+/**
+ * Obtains float field values from the {@link org.apache.lucene.search.FieldCache}
+ * using <code>getFloats()</code>
+ * and makes those values available as other numeric types, casting as needed.
+ *
+ *
+ */
+
+public class LongFieldSource extends NumericFieldCacheSource<LongValues> {
+
+  public LongFieldSource(LongValuesCreator creator) {
+    super(creator);
+  }
+
+  @Override
+  public String description() {
+    return "long(" + field + ')';
+  }
+
+  public long externalToLong(String extVal) {
+    return Long.parseLong(extVal);
+  }
+
+  public Object longToObject(long val) {
+    return val;
+  }
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    final LongValues vals = cache.getLongs(readerContext.reader, field, creator);
+    final long[] arr = vals.values;
+    final Bits valid = vals.valid;
+    
+    return new LongDocValues(this) {
+      @Override
+      public long longVal(int doc) {
+        return arr[doc];
+      }
+
+      @Override
+      public boolean exists(int doc) {
+        return valid.get(doc);
+      }
+
+      @Override
+      public Object objectVal(int doc) {
+        return valid.get(doc) ? longToObject(arr[doc]) : null;
+      }
+
+      @Override
+      public ValueSourceScorer getRangeScorer(IndexReader reader, String lowerVal, String upperVal, boolean includeLower, boolean includeUpper) {
+        long lower,upper;
+
+        // instead of using separate comparison functions, adjust the endpoints.
+
+        if (lowerVal==null) {
+          lower = Long.MIN_VALUE;
+        } else {
+          lower = externalToLong(lowerVal);
+          if (!includeLower && lower < Long.MAX_VALUE) lower++;
+        }
+
+         if (upperVal==null) {
+          upper = Long.MAX_VALUE;
+        } else {
+          upper = externalToLong(upperVal);
+          if (!includeUpper && upper > Long.MIN_VALUE) upper--;
+        }
+
+        final long ll = lower;
+        final long uu = upper;
+
+        return new ValueSourceScorer(reader, this) {
+          @Override
+          public boolean matchesValue(int doc) {
+            long val = arr[doc];
+            // only check for deleted if it's the default value
+            // if (val==0 && reader.isDeleted(doc)) return false;
+            return val >= ll && val <= uu;
+          }
+        };
+      }
+
+      @Override
+      public ValueFiller getValueFiller() {
+        return new ValueFiller() {
+          private final long[] longArr = arr;
+          private final MutableValueLong mval = newMutableValueLong();
+
+          @Override
+          public MutableValue getValue() {
+            return mval;
+          }
+
+          @Override
+          public void fillValue(int doc) {
+            mval.value = longArr[doc];
+            mval.exists = valid.get(doc);
+          }
+        };
+      }
+
+    };
+  }
+
+  protected MutableValueLong newMutableValueLong() {
+    return new MutableValueLong();  
+  }
+
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/MaxDocValueSource.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/MaxDocValueSource.java
new file mode 100755
index 0000000..d0c448b
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/MaxDocValueSource.java
@@ -0,0 +1,57 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.search.IndexSearcher;
+
+import java.io.IOException;
+import java.util.Map;
+
+public class MaxDocValueSource extends ValueSource {
+  public String name() {
+    return "maxdoc";
+  }
+
+  @Override
+  public String description() {
+    return name() + "()";
+  }
+
+  @Override
+  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
+    context.put("searcher",searcher);
+  }
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    IndexSearcher searcher = (IndexSearcher)context.get("searcher");
+    return new ConstIntDocValues(searcher.maxDoc(), this);
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    return this.getClass() == o.getClass();
+  }
+
+  @Override
+  public int hashCode() {
+    return this.getClass().hashCode();
+  }
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/MultiBoolFunction.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/MultiBoolFunction.java
new file mode 100644
index 0000000..9292a19
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/MultiBoolFunction.java
@@ -0,0 +1,108 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.BoolDocValues;
+import org.apache.lucene.search.IndexSearcher;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.Map;
+
+
+public abstract class MultiBoolFunction extends BoolFunction {
+  protected final List<ValueSource> sources;
+
+  public MultiBoolFunction(List<ValueSource> sources) {
+    this.sources = sources;
+  }
+
+  protected abstract String name();
+
+  protected abstract boolean func(int doc, DocValues[] vals);
+
+  @Override
+  public BoolDocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    final DocValues[] vals =  new DocValues[sources.size()];
+    int i=0;
+    for (ValueSource source : sources) {
+      vals[i++] = source.getValues(context, readerContext);
+    }
+
+    return new BoolDocValues(this) {
+      @Override
+      public boolean boolVal(int doc) {
+	      return func(doc, vals);
+      }
+
+      @Override
+      public String toString(int doc) {
+        StringBuilder sb = new StringBuilder(name());
+        sb.append('(');
+        boolean first = true;
+        for (DocValues dv : vals) {
+          if (first) {
+            first = false;
+          } else {
+            sb.append(',');
+          }
+          sb.append(dv.toString(doc));
+        }
+        return sb.toString();
+      }
+    };
+  }
+
+  @Override
+  public String description() {
+    StringBuilder sb = new StringBuilder(name());
+    sb.append('(');
+    boolean first = true;
+    for (ValueSource source : sources) {
+      if (first) {
+        first = false;
+      } else {
+        sb.append(',');
+      }
+      sb.append(source.description());
+    }
+    return sb.toString();
+  }
+
+  @Override
+  public int hashCode() {
+    return sources.hashCode() + name().hashCode();
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this.getClass() != o.getClass()) return false;
+    MultiBoolFunction other = (MultiBoolFunction)o;
+    return this.sources.equals(other.sources);
+  }
+
+  @Override
+  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
+    for (ValueSource source : sources) {
+      source.createWeight(context, searcher);
+    }
+  }
+}
\ No newline at end of file
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/MultiFloatFunction.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/MultiFloatFunction.java
new file mode 100644
index 0000000..369ae1c
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/MultiFloatFunction.java
@@ -0,0 +1,110 @@
+package org.apache.lucene.queries.function.valuesource;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.FloatDocValues;
+import org.apache.lucene.search.IndexSearcher;
+
+import java.util.Map;
+import java.util.Arrays;
+import java.io.IOException;
+
+
+/**
+ *
+ *
+ **/ // a simple function of multiple sources
+public abstract class MultiFloatFunction extends ValueSource {
+  protected final ValueSource[] sources;
+
+  public MultiFloatFunction(ValueSource[] sources) {
+    this.sources = sources;
+  }
+
+  abstract protected String name();
+  abstract protected float func(int doc, DocValues[] valsArr);
+
+  @Override
+  public String description() {
+    StringBuilder sb = new StringBuilder();
+    sb.append(name()).append('(');
+    boolean firstTime=true;
+    for (ValueSource source : sources) {
+      if (firstTime) {
+        firstTime=false;
+      } else {
+        sb.append(',');
+      }
+      sb.append(source);
+    }
+    sb.append(')');
+    return sb.toString();
+  }
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    final DocValues[] valsArr = new DocValues[sources.length];
+    for (int i=0; i<sources.length; i++) {
+      valsArr[i] = sources[i].getValues(context, readerContext);
+    }
+
+    return new FloatDocValues(this) {
+      @Override
+      public float floatVal(int doc) {
+        return func(doc, valsArr);
+      }
+       @Override
+      public String toString(int doc) {
+        StringBuilder sb = new StringBuilder();
+        sb.append(name()).append('(');
+        boolean firstTime=true;
+        for (DocValues vals : valsArr) {
+          if (firstTime) {
+            firstTime=false;
+          } else {
+            sb.append(',');
+          }
+          sb.append(vals.toString(doc));
+        }
+        sb.append(')');
+        return sb.toString();
+      }
+    };
+  }
+
+  @Override
+  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
+    for (ValueSource source : sources)
+      source.createWeight(context, searcher);
+  }
+
+  @Override
+  public int hashCode() {
+    return Arrays.hashCode(sources) + name().hashCode();
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this.getClass() != o.getClass()) return false;
+    MultiFloatFunction other = (MultiFloatFunction)o;
+    return this.name().equals(other.name())
+            && Arrays.equals(this.sources, other.sources);
+  }
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/MultiFunction.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/MultiFunction.java
new file mode 100644
index 0000000..73ffd21
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/MultiFunction.java
@@ -0,0 +1,124 @@
+package org.apache.lucene.queries.function.valuesource;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.util.BytesRef;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+
+
+public abstract class MultiFunction extends ValueSource {
+  protected final List<ValueSource> sources;
+
+  public MultiFunction(List<ValueSource> sources) {
+    this.sources = sources;
+  }
+
+  abstract protected String name();
+
+  @Override
+  public String description() {
+    return description(name(), sources);
+  }
+
+  public static String description(String name, List<ValueSource> sources) {
+    StringBuilder sb = new StringBuilder();
+    sb.append(name).append('(');
+    boolean firstTime=true;
+    for (ValueSource source : sources) {
+      if (firstTime) {
+        firstTime=false;
+      } else {
+        sb.append(',');
+      }
+      sb.append(source);
+    }
+    sb.append(')');
+    return sb.toString();
+  }
+
+  public static DocValues[] valsArr(List<ValueSource> sources, Map fcontext, AtomicReaderContext readerContext) throws IOException {
+    final DocValues[] valsArr = new DocValues[sources.size()];
+    int i=0;
+    for (ValueSource source : sources) {
+      valsArr[i++] = source.getValues(fcontext, readerContext);
+    }
+    return valsArr;
+  }
+
+  public class Values extends DocValues {
+    final DocValues[] valsArr;
+
+    public Values(DocValues[] valsArr) {
+      this.valsArr = valsArr;
+    }
+
+    @Override
+    public String toString(int doc) {
+      return MultiFunction.toString(name(), valsArr, doc);
+    }
+
+    @Override
+    public ValueFiller getValueFiller() {
+      // TODO: need ValueSource.type() to determine correct type
+      return super.getValueFiller();
+    }
+  }
+
+
+  public static String toString(String name, DocValues[] valsArr, int doc) {
+    StringBuilder sb = new StringBuilder();
+    sb.append(name).append('(');
+    boolean firstTime=true;
+    for (DocValues vals : valsArr) {
+      if (firstTime) {
+        firstTime=false;
+      } else {
+        sb.append(',');
+      }
+      sb.append(vals.toString(doc));
+    }
+    sb.append(')');
+    return sb.toString();
+  }
+
+  @Override
+  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
+    for (ValueSource source : sources)
+      source.createWeight(context, searcher);
+  }
+
+  @Override
+  public int hashCode() {
+    return sources.hashCode() + name().hashCode();
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this.getClass() != o.getClass()) return false;
+    MultiFunction other = (MultiFunction)o;
+    return this.sources.equals(other.sources);
+  }
+}
+
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/MultiValueSource.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/MultiValueSource.java
new file mode 100644
index 0000000..13c899f
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/MultiValueSource.java
@@ -0,0 +1,29 @@
+package org.apache.lucene.queries.function.valuesource;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queries.function.ValueSource;
+
+
+/**
+ * A {@link ValueSource} that abstractly represents {@link ValueSource}s for
+ * poly fields, and other things.
+ **/
+public abstract class MultiValueSource extends ValueSource {
+
+  public abstract int dimension();
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/NormValueSource.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/NormValueSource.java
new file mode 100755
index 0000000..5a515ad
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/NormValueSource.java
@@ -0,0 +1,78 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.FloatDocValues;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Similarity;
+import java.io.IOException;
+import java.util.Map;
+
+public class NormValueSource extends ValueSource {
+  protected String field;
+  public NormValueSource(String field) {
+    this.field = field;
+  }
+
+  public String name() {
+    return "norm";
+  }
+
+  @Override
+  public String description() {
+    return name() + '(' + field + ')';
+  }
+
+  @Override
+  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
+    context.put("searcher",searcher);
+  }
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    IndexSearcher searcher = (IndexSearcher)context.get("searcher");
+    final Similarity similarity = searcher.getSimilarityProvider().get(field);
+    final byte[] norms = readerContext.reader.norms(field);
+    if (norms == null) {
+      return new ConstDoubleDocValues(0.0, this);
+    }
+
+    return new FloatDocValues(this) {
+      @Override
+      public float floatVal(int doc) {
+        return similarity.decodeNormValue(norms[doc]);
+      }
+    };
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this.getClass() != o.getClass()) return false;
+    return this.field.equals(((NormValueSource)o).field);
+  }
+
+  @Override
+  public int hashCode() {
+    return this.getClass().hashCode() + field.hashCode();
+  }
+}
+
+
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/NumDocsValueSource.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/NumDocsValueSource.java
new file mode 100755
index 0000000..768ade0
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/NumDocsValueSource.java
@@ -0,0 +1,52 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.util.ReaderUtil;
+
+import java.io.IOException;
+import java.util.Map;
+
+public class NumDocsValueSource extends ValueSource {
+  public String name() {
+    return "numdocs";
+  }
+
+  @Override
+  public String description() {
+    return name() + "()";
+  }
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    // Searcher has no numdocs so we must use the reader instead
+    return new ConstIntDocValues(ReaderUtil.getTopLevelContext(readerContext).reader.numDocs(), this);
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    return this.getClass() == o.getClass();
+  }
+
+  @Override
+  public int hashCode() {
+    return this.getClass().hashCode();
+  }
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/NumericFieldCacheSource.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/NumericFieldCacheSource.java
new file mode 100644
index 0000000..c0b17de
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/NumericFieldCacheSource.java
@@ -0,0 +1,50 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.search.cache.CachedArray;
+import org.apache.lucene.search.cache.CachedArrayCreator;
+
+/**
+ * 
+ *
+ */
+public abstract class NumericFieldCacheSource<T extends CachedArray> extends FieldCacheSource {
+  protected final CachedArrayCreator<T> creator;
+
+  public NumericFieldCacheSource( CachedArrayCreator<T> creator ) {
+    super( creator.field );
+    this.creator = creator;
+  }
+
+  @Override
+  public final boolean equals(Object o) {
+    if (o.getClass() != this.getClass()) return false;
+    NumericFieldCacheSource other = (NumericFieldCacheSource) o;
+    return super.equals(other)
+            && this.creator == null ? other.creator == null :
+            this.creator.getClass() == other.creator.getClass();
+  }
+
+  @Override
+  public final int hashCode() {
+    int h = creator == null ? this.getClass().hashCode() : creator.getClass().hashCode();
+    h += super.hashCode();
+    return h;
+  }
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/OrdFieldSource.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/OrdFieldSource.java
new file mode 100644
index 0000000..431bc86
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/OrdFieldSource.java
@@ -0,0 +1,122 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.common.mutable.MutableValue;
+import org.apache.lucene.common.mutable.MutableValueInt;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.IntDocValues;
+import org.apache.lucene.search.FieldCache;
+import org.apache.lucene.util.ReaderUtil;
+
+import java.io.IOException;
+import java.util.Map;
+
+/**
+ * Obtains the ordinal of the field value from the default Lucene {@link org.apache.lucene.search.FieldCache} using getStringIndex().
+ * <br>
+ * The native lucene index order is used to assign an ordinal value for each field value.
+ * <br>Field values (terms) are lexicographically ordered by unicode value, and numbered starting at 1.
+ * <br>
+ * Example:<br>
+ *  If there were only three field values: "apple","banana","pear"
+ * <br>then ord("apple")=1, ord("banana")=2, ord("pear")=3
+ * <p>
+ * WARNING: ord() depends on the position in an index and can thus change when other documents are inserted or deleted,
+ *  or if a MultiSearcher is used.
+ * <br>WARNING: as of Solr 1.4, ord() and rord() can cause excess memory use since they must use a FieldCache entry
+ * at the top level reader, while sorting and function queries now use entries at the segment level.  Hence sorting
+ * or using a different function query, in addition to ord()/rord() will double memory use.
+ *
+ */
+
+public class OrdFieldSource extends ValueSource {
+  protected String field;
+
+  public OrdFieldSource(String field) {
+    this.field = field;
+  }
+
+  @Override
+  public String description() {
+    return "ord(" + field + ')';
+  }
+
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    final int off = readerContext.docBase;
+    final IndexReader topReader = ReaderUtil.getTopLevelContext(readerContext).reader;
+    final FieldCache.DocTermsIndex sindex = FieldCache.DEFAULT.getTermsIndex(topReader, field);
+    return new IntDocValues(this) {
+      protected String toTerm(String readableValue) {
+        return readableValue;
+      }
+      @Override
+      public int intVal(int doc) {
+        return sindex.getOrd(doc+off);
+      }
+      @Override
+      public int ordVal(int doc) {
+        return sindex.getOrd(doc+off);
+      }
+      @Override
+      public int numOrd() {
+        return sindex.numOrd();
+      }
+
+      @Override
+      public boolean exists(int doc) {
+        return sindex.getOrd(doc+off) != 0;
+      }
+
+      @Override
+      public ValueFiller getValueFiller() {
+        return new ValueFiller() {
+          private final MutableValueInt mval = new MutableValueInt();
+
+          @Override
+          public MutableValue getValue() {
+            return mval;
+          }
+
+          @Override
+          public void fillValue(int doc) {
+            mval.value = sindex.getOrd(doc);
+            mval.exists = mval.value!=0;
+          }
+        };
+      }
+    };
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    return o.getClass() == OrdFieldSource.class && this.field.equals(((OrdFieldSource)o).field);
+  }
+
+  private static final int hcode = OrdFieldSource.class.hashCode();
+  @Override
+  public int hashCode() {
+    return hcode + field.hashCode();
+  };
+
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/PowFloatFunction.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/PowFloatFunction.java
new file mode 100755
index 0000000..ec2ae94
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/PowFloatFunction.java
@@ -0,0 +1,45 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+
+/** Function to raise the base "a" to the power "b"
+ */
+public class PowFloatFunction extends DualFloatFunction {
+ /**
+   * @param   a  the base.
+   * @param   b  the exponent.
+   */
+  public PowFloatFunction(ValueSource a, ValueSource b) {
+    super(a,b);
+  }
+
+  @Override
+  protected String name() {
+    return "pow";
+  }
+
+  @Override
+  protected float func(int doc, DocValues aVals, DocValues bVals) {
+    return (float)Math.pow(aVals.floatVal(doc), bVals.floatVal(doc));
+  }
+}
+
+
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/ProductFloatFunction.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/ProductFloatFunction.java
new file mode 100755
index 0000000..5aa0254
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/ProductFloatFunction.java
@@ -0,0 +1,44 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+
+/**
+ * <code>ProductFloatFunction</code> returns the product of it's components.
+ */
+public class ProductFloatFunction extends MultiFloatFunction {
+  public ProductFloatFunction(ValueSource[] sources) {
+    super(sources);
+  }
+
+  @Override
+  protected String name() {
+    return "product";
+  }
+
+  @Override
+  protected float func(int doc, DocValues[] valsArr) {
+    float val = 1.0f;
+    for (DocValues vals : valsArr) {
+      val *= vals.floatVal(doc);
+    }
+    return val;
+  }
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/QueryValueSource.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/QueryValueSource.java
new file mode 100755
index 0000000..7842371
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/QueryValueSource.java
@@ -0,0 +1,251 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.common.mutable.MutableValue;
+import org.apache.lucene.common.mutable.MutableValueFloat;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.FloatDocValues;
+import org.apache.lucene.search.*;
+import org.apache.lucene.search.Weight.ScorerContext;
+import org.apache.lucene.util.ReaderUtil;
+
+import java.io.IOException;
+import java.util.Map;
+
+/**
+ * <code>QueryValueSource</code> returns the relevance score of the query
+ */
+public class QueryValueSource extends ValueSource {
+  final Query q;
+  final float defVal;
+
+  public QueryValueSource(Query q, float defVal) {
+    this.q = q;
+    this.defVal = defVal;
+  }
+
+  public Query getQuery() { return q; }
+  public float getDefaultValue() { return defVal; }
+
+  @Override
+  public String description() {
+    return "query(" + q + ",def=" + defVal + ")";
+  }
+
+  @Override
+  public DocValues getValues(Map fcontext, AtomicReaderContext readerContext) throws IOException {
+    return new QueryDocValues(this, readerContext, fcontext);
+  }
+
+  @Override
+  public int hashCode() {
+    return q.hashCode() * 29;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (QueryValueSource.class != o.getClass()) return false;
+    QueryValueSource other = (QueryValueSource)o;
+    return this.q.equals(other.q) && this.defVal==other.defVal;
+  }
+
+  @Override
+  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
+    Weight w = searcher.createNormalizedWeight(q);
+    context.put(this, w);
+  }
+}
+
+
+class QueryDocValues extends FloatDocValues {
+  final AtomicReaderContext readerContext;
+  final Weight weight;
+  final float defVal;
+  final Map fcontext;
+  final Query q;
+
+  Scorer scorer;
+  int scorerDoc; // the document the scorer is on
+  boolean noMatches=false;
+
+  // the last document requested... start off with high value
+  // to trigger a scorer reset on first access.
+  int lastDocRequested=Integer.MAX_VALUE;
+  
+
+  public QueryDocValues(QueryValueSource vs, AtomicReaderContext readerContext, Map fcontext) throws IOException {
+    super(vs);
+
+    this.readerContext = readerContext;
+    this.defVal = vs.defVal;
+    this.q = vs.q;
+    this.fcontext = fcontext;
+
+    Weight w = fcontext==null ? null : (Weight)fcontext.get(vs);
+    if (w == null) {
+      IndexSearcher weightSearcher;
+      if(fcontext == null) {
+        weightSearcher = new IndexSearcher(ReaderUtil.getTopLevelContext(readerContext));
+      } else {
+        weightSearcher = (IndexSearcher)fcontext.get("searcher");
+        if (weightSearcher == null) {
+          weightSearcher = new IndexSearcher(ReaderUtil.getTopLevelContext(readerContext));
+        }
+      }
+      vs.createWeight(fcontext, weightSearcher);
+      w = (Weight)fcontext.get(vs);
+    }
+    weight = w;
+  }
+
+  @Override
+  public float floatVal(int doc) {
+    try {
+      if (doc < lastDocRequested) {
+        if (noMatches) return defVal;
+        scorer = weight.scorer(readerContext, ScorerContext.def());
+        if (scorer==null) {
+          noMatches = true;
+          return defVal;
+        }
+        scorerDoc = -1;
+      }
+      lastDocRequested = doc;
+
+      if (scorerDoc < doc) {
+        scorerDoc = scorer.advance(doc);
+      }
+
+      if (scorerDoc > doc) {
+        // query doesn't match this document... either because we hit the
+        // end, or because the next doc is after this doc.
+        return defVal;
+      }
+
+      // a match!
+      return scorer.score();
+    } catch (IOException e) {
+      throw new RuntimeException("caught exception in QueryDocVals("+q+") doc="+doc, e);
+    }
+  }
+
+  @Override
+  public boolean exists(int doc) {
+    try {
+      if (doc < lastDocRequested) {
+        if (noMatches) return false;
+        scorer = weight.scorer(readerContext, ScorerContext.def());
+        scorerDoc = -1;
+        if (scorer==null) {
+          noMatches = true;
+          return false;
+        }
+      }
+      lastDocRequested = doc;
+
+      if (scorerDoc < doc) {
+        scorerDoc = scorer.advance(doc);
+      }
+
+      if (scorerDoc > doc) {
+        // query doesn't match this document... either because we hit the
+        // end, or because the next doc is after this doc.
+        return false;
+      }
+
+      // a match!
+      return true;
+    } catch (IOException e) {
+      throw new RuntimeException("caught exception in QueryDocVals("+q+") doc="+doc, e);
+    }
+  }
+
+   @Override
+  public Object objectVal(int doc) {
+     try {
+       return exists(doc) ? scorer.score() : null;
+     } catch (IOException e) {
+       throw new RuntimeException("caught exception in QueryDocVals("+q+") doc="+doc, e);
+     }
+   }
+
+  @Override
+  public ValueFiller getValueFiller() {
+    //
+    // TODO: if we want to support more than one value-filler or a value-filler in conjunction with
+    // the DocValues, then members like "scorer" should be per ValueFiller instance.
+    // Or we can say that the user should just instantiate multiple DocValues.
+    //
+    return new ValueFiller() {
+      private final MutableValueFloat mval = new MutableValueFloat();
+
+      @Override
+      public MutableValue getValue() {
+        return mval;
+      }
+
+      @Override
+      public void fillValue(int doc) {
+        try {
+          if (noMatches) {
+            mval.value = defVal;
+            mval.exists = false;
+            return;
+          }
+          scorer = weight.scorer(readerContext, ScorerContext.def());
+          scorerDoc = -1;
+          if (scorer==null) {
+            noMatches = true;
+            mval.value = defVal;
+            mval.exists = false;
+            return;
+          }
+          lastDocRequested = doc;
+
+          if (scorerDoc < doc) {
+            scorerDoc = scorer.advance(doc);
+          }
+
+          if (scorerDoc > doc) {
+            // query doesn't match this document... either because we hit the
+            // end, or because the next doc is after this doc.
+            mval.value = defVal;
+            mval.exists = false;
+            return;
+          }
+
+          // a match!
+          mval.value = scorer.score();
+          mval.exists = true;
+          return;
+        } catch (IOException e) {
+          throw new RuntimeException("caught exception in QueryDocVals("+q+") doc="+doc, e);
+        }
+      }
+    };
+  }
+
+  @Override
+  public String toString(int doc) {
+    return "query(" + q + ",def=" + defVal + ")=" + floatVal(doc);
+  }
+}
\ No newline at end of file
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/RangeMapFloatFunction.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/RangeMapFloatFunction.java
new file mode 100755
index 0000000..95203a7
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/RangeMapFloatFunction.java
@@ -0,0 +1,102 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.FloatDocValues;
+import org.apache.lucene.search.IndexSearcher;
+
+import java.io.IOException;
+import java.util.Map;
+
+/**
+ * <code>LinearFloatFunction</code> implements a linear function over
+ * another {@link org.apache.lucene.queries.function.ValueSource}.
+ * <br>
+ * Normally Used as an argument to a {@link org.apache.lucene.queries.function.FunctionQuery}
+ *
+ *
+ */
+public class RangeMapFloatFunction extends ValueSource {
+  protected final ValueSource source;
+  protected final float min;
+  protected final float max;
+  protected final float target;
+  protected final Float defaultVal;
+
+  public RangeMapFloatFunction(ValueSource source, float min, float max, float target, Float def) {
+    this.source = source;
+    this.min = min;
+    this.max = max;
+    this.target = target;
+    this.defaultVal = def;
+  }
+
+  @Override
+  public String description() {
+    return "map(" + source.description() + "," + min + "," + max + "," + target + ")";
+  }
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    final DocValues vals =  source.getValues(context, readerContext);
+    return new FloatDocValues(this) {
+      @Override
+      public float floatVal(int doc) {
+        float val = vals.floatVal(doc);
+        return (val>=min && val<=max) ? target : (defaultVal == null ? val : defaultVal);
+      }
+      @Override
+      public String toString(int doc) {
+        return "map(" + vals.toString(doc) + ",min=" + min + ",max=" + max + ",target=" + target + ")";
+      }
+    };
+  }
+
+  @Override
+  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
+    source.createWeight(context, searcher);
+  }
+
+  @Override
+  public int hashCode() {
+    int h = source.hashCode();
+    h ^= (h << 10) | (h >>> 23);
+    h += Float.floatToIntBits(min);
+    h ^= (h << 14) | (h >>> 19);
+    h += Float.floatToIntBits(max);
+    h ^= (h << 13) | (h >>> 20);
+    h += Float.floatToIntBits(target);
+    if (defaultVal != null)
+      h += defaultVal.hashCode();
+    return h;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (RangeMapFloatFunction.class != o.getClass()) return false;
+    RangeMapFloatFunction other = (RangeMapFloatFunction)o;
+    return  this.min == other.min
+         && this.max == other.max
+         && this.target == other.target
+         && this.source.equals(other.source)
+         && (this.defaultVal == other.defaultVal || (this.defaultVal != null && this.defaultVal.equals(other.defaultVal)));
+  }
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/ReciprocalFloatFunction.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/ReciprocalFloatFunction.java
new file mode 100644
index 0000000..98596e6
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/ReciprocalFloatFunction.java
@@ -0,0 +1,108 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.FloatDocValues;
+import org.apache.lucene.search.IndexSearcher;
+
+import java.io.IOException;
+import java.util.Map;
+
+/**
+ * <code>ReciprocalFloatFunction</code> implements a reciprocal function f(x) = a/(mx+b), based on
+ * the float value of a field or function as exported by {@link org.apache.lucene.queries.function.ValueSource}.
+ * <br>
+ *
+ * When a and b are equal, and x>=0, this function has a maximum value of 1 that drops as x increases.
+ * Increasing the value of a and b together results in a movement of the entire function to a flatter part of the curve.
+ * <p>These properties make this an idea function for boosting more recent documents.
+ * <p>Example:<code>  recip(ms(NOW,mydatefield),3.16e-11,1,1)</code>
+ * <p>A multiplier of 3.16e-11 changes the units from milliseconds to years (since there are about 3.16e10 milliseconds
+ * per year).  Thus, a very recent date will yield a value close to 1/(0+1) or 1,
+ * a date a year in the past will get a multiplier of about 1/(1+1) or 1/2,
+ * and date two years old will yield 1/(2+1) or 1/3.
+ *
+ * @see org.apache.lucene.queries.function.FunctionQuery
+ *
+ *
+ */
+public class ReciprocalFloatFunction extends ValueSource {
+  protected final ValueSource source;
+  protected final float m;
+  protected final float a;
+  protected final float b;
+
+  /**
+   *  f(source) = a/(m*float(source)+b)
+   */
+  public ReciprocalFloatFunction(ValueSource source, float m, float a, float b) {
+    this.source=source;
+    this.m=m;
+    this.a=a;
+    this.b=b;
+  }
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    final DocValues vals = source.getValues(context, readerContext);
+    return new FloatDocValues(this) {
+      @Override
+      public float floatVal(int doc) {
+        return a/(m*vals.floatVal(doc) + b);
+      }
+      @Override
+      public String toString(int doc) {
+        return Float.toString(a) + "/("
+                + m + "*float(" + vals.toString(doc) + ')'
+                + '+' + b + ')';
+      }
+    };
+  }
+
+  @Override
+  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
+    source.createWeight(context, searcher);
+  }
+
+  @Override
+  public String description() {
+    return Float.toString(a) + "/("
+           + m + "*float(" + source.description() + ")"
+           + "+" + b + ')';
+  }
+
+  @Override
+  public int hashCode() {
+    int h = Float.floatToIntBits(a) + Float.floatToIntBits(m);
+    h ^= (h << 13) | (h >>> 20);
+    return h + (Float.floatToIntBits(b)) + source.hashCode();
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (ReciprocalFloatFunction.class != o.getClass()) return false;
+    ReciprocalFloatFunction other = (ReciprocalFloatFunction)o;
+    return this.m == other.m
+            && this.a == other.a
+            && this.b == other.b
+            && this.source.equals(other.source);
+  }
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/ReverseOrdFieldSource.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/ReverseOrdFieldSource.java
new file mode 100644
index 0000000..d3d8861
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/ReverseOrdFieldSource.java
@@ -0,0 +1,93 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.IntDocValues;
+import org.apache.lucene.search.FieldCache;
+import org.apache.lucene.util.ReaderUtil;
+
+import java.io.IOException;
+import java.util.Map;
+
+/**
+ * Obtains the ordinal of the field value from the default Lucene {@link org.apache.lucene.search.FieldCache} using getTermsIndex()
+ * and reverses the order.
+ * <br>
+ * The native lucene index order is used to assign an ordinal value for each field value.
+ * <br>Field values (terms) are lexicographically ordered by unicode value, and numbered starting at 1.
+ * <br>
+ * Example of reverse ordinal (rord):<br>
+ *  If there were only three field values: "apple","banana","pear"
+ * <br>then rord("apple")=3, rord("banana")=2, ord("pear")=1
+ * <p>
+ *  WARNING: ord() depends on the position in an index and can thus change when other documents are inserted or deleted,
+ *  or if a MultiSearcher is used.
+ * <br>
+ *  WARNING: as of Solr 1.4, ord() and rord() can cause excess memory use since they must use a FieldCache entry
+ * at the top level reader, while sorting and function queries now use entries at the segment level.  Hence sorting
+ * or using a different function query, in addition to ord()/rord() will double memory use.
+ * 
+ *
+ */
+
+public class ReverseOrdFieldSource extends ValueSource {
+  public String field;
+
+  public ReverseOrdFieldSource(String field) {
+    this.field = field;
+  }
+
+  @Override
+  public String description() {
+    return "rord("+field+')';
+  }
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    final IndexReader topReader = ReaderUtil.getTopLevelContext(readerContext).reader;
+    final int off = readerContext.docBase;
+
+    final FieldCache.DocTermsIndex sindex = FieldCache.DEFAULT.getTermsIndex(topReader, field);
+    final int end = sindex.numOrd();
+
+    return new IntDocValues(this) {
+     @Override
+      public int intVal(int doc) {
+        return (end - sindex.getOrd(doc+off));
+      }
+    };
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (o.getClass() !=  ReverseOrdFieldSource.class) return false;
+    ReverseOrdFieldSource other = (ReverseOrdFieldSource)o;
+    return this.field.equals(other.field);
+  }
+
+  private static final int hcode = ReverseOrdFieldSource.class.hashCode();
+  @Override
+  public int hashCode() {
+    return hcode + field.hashCode();
+  };
+
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/ScaleFloatFunction.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/ScaleFloatFunction.java
new file mode 100755
index 0000000..6e2330a
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/ScaleFloatFunction.java
@@ -0,0 +1,152 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.FloatDocValues;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.util.ReaderUtil;
+
+import java.io.IOException;
+import java.util.Map;
+
+/**
+ * Scales values to be between min and max.
+ * <p>This implementation currently traverses all of the source values to obtain
+ * their min and max.
+ * <p>This implementation currently cannot distinguish when documents have been
+ * deleted or documents that have no value, and 0.0 values will be used for
+ * these cases.  This means that if values are normally all greater than 0.0, one can
+ * still end up with 0.0 as the min value to map from.  In these cases, an
+ * appropriate map() function could be used as a workaround to change 0.0
+ * to a value in the real range.
+ */
+public class ScaleFloatFunction extends ValueSource {
+  protected final ValueSource source;
+  protected final float min;
+  protected final float max;
+
+  public ScaleFloatFunction(ValueSource source, float min, float max) {
+    this.source = source;
+    this.min = min;
+    this.max = max;
+  }
+
+  @Override
+  public String description() {
+    return "scale(" + source.description() + "," + min + "," + max + ")";
+  }
+
+  private static class ScaleInfo {
+    float minVal;
+    float maxVal;
+  }
+
+  private ScaleInfo createScaleInfo(Map context, AtomicReaderContext readerContext) throws IOException {
+    final AtomicReaderContext[] leaves = ReaderUtil.leaves(ReaderUtil.getTopLevelContext(readerContext));
+
+    float minVal = Float.POSITIVE_INFINITY;
+    float maxVal = Float.NEGATIVE_INFINITY;
+
+    for (AtomicReaderContext leaf : leaves) {
+      int maxDoc = leaf.reader.maxDoc();
+      DocValues vals =  source.getValues(context, leaf);
+      for (int i=0; i<maxDoc; i++) {
+
+      float val = vals.floatVal(i);
+      if ((Float.floatToRawIntBits(val) & (0xff<<23)) == 0xff<<23) {
+        // if the exponent in the float is all ones, then this is +Inf, -Inf or NaN
+        // which don't make sense to factor into the scale function
+        continue;
+      }
+      if (val < minVal) {
+        minVal = val;
+      }
+      if (val > maxVal) {
+        maxVal = val;
+      }
+    }
+    }
+
+    if (minVal == Float.POSITIVE_INFINITY) {
+    // must have been an empty index
+      minVal = maxVal = 0;
+    }
+
+    ScaleInfo scaleInfo = new ScaleInfo();
+    scaleInfo.minVal = minVal;
+    scaleInfo.maxVal = maxVal;
+    context.put(this.source, scaleInfo);
+    return scaleInfo;
+  }
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+
+    ScaleInfo scaleInfo = (ScaleInfo)context.get(source);
+    if (scaleInfo == null) {
+      scaleInfo = createScaleInfo(context, readerContext);
+    }
+
+    final float scale = (scaleInfo.maxVal-scaleInfo.minVal==0) ? 0 : (max-min)/(scaleInfo.maxVal-scaleInfo.minVal);
+    final float minSource = scaleInfo.minVal;
+    final float maxSource = scaleInfo.maxVal;
+
+    final DocValues vals =  source.getValues(context, readerContext);
+
+    return new FloatDocValues(this) {
+      @Override
+      public float floatVal(int doc) {
+	return (vals.floatVal(doc) - minSource) * scale + min;
+      }
+      @Override
+      public String toString(int doc) {
+	return "scale(" + vals.toString(doc) + ",toMin=" + min + ",toMax=" + max
+                + ",fromMin=" + minSource
+                + ",fromMax=" + maxSource
+                + ")";
+      }
+    };
+  }
+
+  @Override
+  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
+    source.createWeight(context, searcher);
+  }
+
+  @Override
+  public int hashCode() {
+    int h = Float.floatToIntBits(min);
+    h = h*29;
+    h += Float.floatToIntBits(max);
+    h = h*29;
+    h += source.hashCode();
+    return h;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (ScaleFloatFunction.class != o.getClass()) return false;
+    ScaleFloatFunction other = (ScaleFloatFunction)o;
+    return this.min == other.min
+         && this.max == other.max
+         && this.source.equals(other.source);
+  }
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/ShortFieldSource.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/ShortFieldSource.java
new file mode 100644
index 0000000..2284175
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/ShortFieldSource.java
@@ -0,0 +1,92 @@
+package org.apache.lucene.queries.function.valuesource;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.search.cache.ShortValuesCreator;
+import org.apache.lucene.search.cache.CachedArray.ShortValues;
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+
+import java.io.IOException;
+import java.util.Map;
+
+
+/**
+ *
+ *
+ **/
+public class ShortFieldSource extends NumericFieldCacheSource<ShortValues> {
+
+  public ShortFieldSource(ShortValuesCreator creator) {
+    super(creator);
+  }
+
+
+  @Override
+  public String description() {
+    return "short(" + field + ')';
+  }
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    final ShortValues vals = cache.getShorts(readerContext.reader, field, creator);
+    final short[] arr = vals.values;
+    
+    return new DocValues() {
+      @Override
+      public byte byteVal(int doc) {
+        return (byte) arr[doc];
+      }
+
+      @Override
+      public short shortVal(int doc) {
+        return arr[doc];
+      }
+
+      @Override
+      public float floatVal(int doc) {
+        return (float) arr[doc];
+      }
+
+      @Override
+      public int intVal(int doc) {
+        return (int) arr[doc];
+      }
+
+      @Override
+      public long longVal(int doc) {
+        return (long) arr[doc];
+      }
+
+      @Override
+      public double doubleVal(int doc) {
+        return (double) arr[doc];
+      }
+
+      @Override
+      public String strVal(int doc) {
+        return Short.toString(arr[doc]);
+      }
+
+      @Override
+      public String toString(int doc) {
+        return description() + '=' + shortVal(doc);
+      }
+
+    };
+  }
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/SimpleBoolFunction.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/SimpleBoolFunction.java
new file mode 100644
index 0000000..10fb3bb
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/SimpleBoolFunction.java
@@ -0,0 +1,77 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.BoolDocValues;
+import org.apache.lucene.search.IndexSearcher;
+
+import java.io.IOException;
+import java.util.Map;
+
+
+public abstract class SimpleBoolFunction extends BoolFunction {
+  protected final ValueSource source;
+
+  public SimpleBoolFunction(ValueSource source) {
+    this.source = source;
+  }
+
+  protected abstract String name();
+
+  protected abstract boolean func(int doc, DocValues vals);
+
+  @Override
+  public BoolDocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    final DocValues vals =  source.getValues(context, readerContext);
+    return new BoolDocValues(this) {
+      @Override
+      public boolean boolVal(int doc) {
+	      return func(doc, vals);
+      }
+      @Override
+      public String toString(int doc) {
+	      return name() + '(' + vals.toString(doc) + ')';
+      }
+    };
+  }
+
+  @Override
+  public String description() {
+    return name() + '(' + source.description() + ')';
+  }
+
+  @Override
+  public int hashCode() {
+    return source.hashCode() + name().hashCode();
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this.getClass() != o.getClass()) return false;
+    SimpleBoolFunction other = (SimpleBoolFunction)o;
+    return this.source.equals(other.source);
+  }
+
+  @Override
+  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
+    source.createWeight(context, searcher);
+  }
+}
\ No newline at end of file
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/SimpleFloatFunction.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/SimpleFloatFunction.java
new file mode 100755
index 0000000..174f5d3
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/SimpleFloatFunction.java
@@ -0,0 +1,51 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.FloatDocValues;
+
+import java.io.IOException;
+import java.util.Map;
+
+/** A simple float function with a single argument
+ */
+ public abstract class SimpleFloatFunction extends SingleFunction {
+  public SimpleFloatFunction(ValueSource source) {
+    super(source);
+  }
+
+  protected abstract float func(int doc, DocValues vals);
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    final DocValues vals =  source.getValues(context, readerContext);
+    return new FloatDocValues(this) {
+      @Override
+      public float floatVal(int doc) {
+	return func(doc, vals);
+      }
+      @Override
+      public String toString(int doc) {
+	return name() + '(' + vals.toString(doc) + ')';
+      }
+    };
+  }
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/SingleFunction.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/SingleFunction.java
new file mode 100755
index 0000000..2e95e4c
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/SingleFunction.java
@@ -0,0 +1,59 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.search.IndexSearcher;
+
+import java.io.IOException;
+import java.util.Map;
+
+/** A function with a single argument
+ */
+ public abstract class SingleFunction extends ValueSource {
+  protected final ValueSource source;
+
+  public SingleFunction(ValueSource source) {
+    this.source = source;
+  }
+
+  protected abstract String name();
+
+  @Override
+  public String description() {
+    return name() + '(' + source.description() + ')';
+  }
+
+  @Override
+  public int hashCode() {
+    return source.hashCode() + name().hashCode();
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this.getClass() != o.getClass()) return false;
+    SingleFunction other = (SingleFunction)o;
+    return this.name().equals(other.name())
+         && this.source.equals(other.source);
+  }
+
+  @Override
+  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
+    source.createWeight(context, searcher);
+  }
+}
\ No newline at end of file
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/SumFloatFunction.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/SumFloatFunction.java
new file mode 100755
index 0000000..19cf942
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/SumFloatFunction.java
@@ -0,0 +1,44 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+
+/**
+ * <code>SumFloatFunction</code> returns the sum of it's components.
+ */
+public class SumFloatFunction extends MultiFloatFunction {
+  public SumFloatFunction(ValueSource[] sources) {
+    super(sources);
+  }
+
+  @Override  
+  protected String name() {
+    return "sum";
+  }
+
+  @Override
+  protected float func(int doc, DocValues[] valsArr) {
+    float val = 0.0f;
+    for (DocValues vals : valsArr) {
+      val += vals.floatVal(doc);
+    }
+    return val;
+  }
+}
\ No newline at end of file
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/TFValueSource.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/TFValueSource.java
new file mode 100755
index 0000000..d868456
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/TFValueSource.java
@@ -0,0 +1,111 @@
+package org.apache.lucene.queries.function.valuesource;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.*;
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.docvalues.FloatDocValues;
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Similarity;
+import org.apache.lucene.util.BytesRef;
+
+import java.io.IOException;
+import java.util.Map;
+
+public class TFValueSource extends TermFreqValueSource {
+  public TFValueSource(String field, String val, String indexedField, BytesRef indexedBytes) {
+    super(field, val, indexedField, indexedBytes);
+  }
+
+  @Override
+  public String name() {
+    return "tf";
+  }
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    Fields fields = readerContext.reader.fields();
+    final Terms terms = fields.terms(field);
+    final Similarity similarity = ((IndexSearcher)context.get("searcher")).getSimilarityProvider().get(field);
+
+    return new FloatDocValues(this) {
+      DocsEnum docs ;
+      int atDoc;
+      int lastDocRequested = -1;
+
+      { reset(); }
+
+      public void reset() throws IOException {
+        // no one should call us for deleted docs?
+        docs = terms==null ? null : terms.docs(null, indexedBytes, null);
+        if (docs == null) {
+          docs = new DocsEnum() {
+            @Override
+            public int freq() {
+              return 0;
+            }
+
+            @Override
+            public int docID() {
+              return DocIdSetIterator.NO_MORE_DOCS;
+            }
+
+            @Override
+            public int nextDoc() throws IOException {
+              return DocIdSetIterator.NO_MORE_DOCS;
+            }
+
+            @Override
+            public int advance(int target) throws IOException {
+              return DocIdSetIterator.NO_MORE_DOCS;
+            }
+          };
+        }
+        atDoc = -1;
+      }
+
+      @Override
+      public float floatVal(int doc) {
+        try {
+          if (doc < lastDocRequested) {
+            // out-of-order access.... reset
+            reset();
+          }
+          lastDocRequested = doc;
+
+          if (atDoc < doc) {
+            atDoc = docs.advance(doc);
+          }
+
+          if (atDoc > doc) {
+            // term doesn't match this document... either because we hit the
+            // end, or because the next doc is after this doc.
+            return similarity.tf(0);
+          }
+
+          // a match!
+          return similarity.tf(docs.freq());
+        } catch (IOException e) {
+          throw new RuntimeException("caught exception in function "+description()+" : doc="+doc, e);
+        }
+      }
+    };
+  }
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/TermFreqValueSource.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/TermFreqValueSource.java
new file mode 100755
index 0000000..b6e53aa
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/TermFreqValueSource.java
@@ -0,0 +1,110 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.queries.function.valuesource;
+
+import org.apache.lucene.index.*;
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.docvalues.IntDocValues;
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.util.BytesRef;
+
+import java.io.IOException;
+import java.util.Map;
+
+public class TermFreqValueSource extends DocFreqValueSource {
+  public TermFreqValueSource(String field, String val, String indexedField, BytesRef indexedBytes) {
+    super(field, val, indexedField, indexedBytes);
+  }
+
+  @Override
+  public String name() {
+    return "termfreq";
+  }
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    Fields fields = readerContext.reader.fields();
+    final Terms terms = fields.terms(field);
+
+    return new IntDocValues(this) {
+      DocsEnum docs ;
+      int atDoc;
+      int lastDocRequested = -1;
+
+      { reset(); }
+
+      public void reset() throws IOException {
+        // no one should call us for deleted docs?
+        docs = terms == null ? null : terms.docs(null, indexedBytes, null);
+        if (docs == null) {
+          docs = new DocsEnum() {
+            @Override
+            public int freq() {
+              return 0;
+            }
+
+            @Override
+            public int docID() {
+              return DocIdSetIterator.NO_MORE_DOCS;
+            }
+
+            @Override
+            public int nextDoc() throws IOException {
+              return DocIdSetIterator.NO_MORE_DOCS;
+            }
+
+            @Override
+            public int advance(int target) throws IOException {
+              return DocIdSetIterator.NO_MORE_DOCS;
+            }
+          };
+        }
+        atDoc = -1;
+      }
+
+      @Override
+      public int intVal(int doc) {
+        try {
+          if (doc < lastDocRequested) {
+            // out-of-order access.... reset
+            reset();
+          }
+          lastDocRequested = doc;
+
+          if (atDoc < doc) {
+            atDoc = docs.advance(doc);
+          }
+
+          if (atDoc > doc) {
+            // term doesn't match this document... either because we hit the
+            // end, or because the next doc is after this doc.
+            return 0;
+          }
+
+          // a match!
+          return docs.freq();
+        } catch (IOException e) {
+          throw new RuntimeException("caught exception in function "+description()+" : doc="+doc, e);
+        }
+      }
+    };
+  }
+}
+
+
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/VectorValueSource.java b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/VectorValueSource.java
new file mode 100644
index 0000000..d53c262
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/valuesource/VectorValueSource.java
@@ -0,0 +1,222 @@
+package org.apache.lucene.queries.function.valuesource;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.search.IndexSearcher;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.Map;
+
+
+/**
+ * Converts individual ValueSource instances to leverage the DocValues *Val functions that work with multiple values,
+ * i.e. {@link org.apache.lucene.queries.function.DocValues#doubleVal(int, double[])}
+ */
+//Not crazy about the name, but...
+public class VectorValueSource extends MultiValueSource {
+  protected final List<ValueSource> sources;
+
+
+  public VectorValueSource(List<ValueSource> sources) {
+    this.sources = sources;
+  }
+
+  public List<ValueSource> getSources() {
+    return sources;
+  }
+
+  @Override
+  public int dimension() {
+    return sources.size();
+  }
+
+  public String name() {
+    return "vector";
+  }
+
+  @Override
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    int size = sources.size();
+
+    // special-case x,y and lat,lon since it's so common
+    if (size==2) {
+      final DocValues x = sources.get(0).getValues(context, readerContext);
+      final DocValues y = sources.get(1).getValues(context, readerContext);
+      return new DocValues() {
+        @Override
+        public void byteVal(int doc, byte[] vals) {
+          vals[0] = x.byteVal(doc);
+          vals[1] = y.byteVal(doc);
+        }
+
+        @Override
+        public void shortVal(int doc, short[] vals) {
+          vals[0] = x.shortVal(doc);
+          vals[1] = y.shortVal(doc);
+        }
+        @Override
+        public void intVal(int doc, int[] vals) {
+          vals[0] = x.intVal(doc);
+          vals[1] = y.intVal(doc);
+        }
+        @Override
+        public void longVal(int doc, long[] vals) {
+          vals[0] = x.longVal(doc);
+          vals[1] = y.longVal(doc);
+        }
+        @Override
+        public void floatVal(int doc, float[] vals) {
+          vals[0] = x.floatVal(doc);
+          vals[1] = y.floatVal(doc);
+        }
+        @Override
+        public void doubleVal(int doc, double[] vals) {
+          vals[0] = x.doubleVal(doc);
+          vals[1] = y.doubleVal(doc);
+        }
+        @Override
+        public void strVal(int doc, String[] vals) {
+          vals[0] = x.strVal(doc);
+          vals[1] = y.strVal(doc);
+        }
+        @Override
+        public String toString(int doc) {
+          return name() + "(" + x.toString(doc) + "," + y.toString(doc) + ")";
+        }
+      };
+    }
+
+
+    final DocValues[] valsArr = new DocValues[size];
+    for (int i = 0; i < size; i++) {
+      valsArr[i] = sources.get(i).getValues(context, readerContext);
+    }
+
+    return new DocValues() {
+      @Override
+      public void byteVal(int doc, byte[] vals) {
+        for (int i = 0; i < valsArr.length; i++) {
+          vals[i] = valsArr[i].byteVal(doc);
+        }
+      }
+
+      @Override
+      public void shortVal(int doc, short[] vals) {
+        for (int i = 0; i < valsArr.length; i++) {
+          vals[i] = valsArr[i].shortVal(doc);
+        }
+      }
+
+      @Override
+      public void floatVal(int doc, float[] vals) {
+        for (int i = 0; i < valsArr.length; i++) {
+          vals[i] = valsArr[i].floatVal(doc);
+        }
+      }
+
+      @Override
+      public void intVal(int doc, int[] vals) {
+        for (int i = 0; i < valsArr.length; i++) {
+          vals[i] = valsArr[i].intVal(doc);
+        }
+      }
+
+      @Override
+      public void longVal(int doc, long[] vals) {
+        for (int i = 0; i < valsArr.length; i++) {
+          vals[i] = valsArr[i].longVal(doc);
+        }
+      }
+
+      @Override
+      public void doubleVal(int doc, double[] vals) {
+        for (int i = 0; i < valsArr.length; i++) {
+          vals[i] = valsArr[i].doubleVal(doc);
+        }
+      }
+
+      @Override
+      public void strVal(int doc, String[] vals) {
+        for (int i = 0; i < valsArr.length; i++) {
+          vals[i] = valsArr[i].strVal(doc);
+        }
+      }
+
+      @Override
+      public String toString(int doc) {
+        StringBuilder sb = new StringBuilder();
+        sb.append(name()).append('(');
+        boolean firstTime = true;
+        for (DocValues vals : valsArr) {
+          if (firstTime) {
+            firstTime = false;
+          } else {
+            sb.append(',');
+          }
+          sb.append(vals.toString(doc));
+        }
+        sb.append(')');
+        return sb.toString();
+      }
+    };
+  }
+
+  @Override
+  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
+    for (ValueSource source : sources)
+      source.createWeight(context, searcher);
+  }
+
+
+  @Override
+  public String description() {
+    StringBuilder sb = new StringBuilder();
+    sb.append(name()).append('(');
+    boolean firstTime = true;
+    for (ValueSource source : sources) {
+      if (firstTime) {
+        firstTime = false;
+      } else {
+        sb.append(',');
+      }
+      sb.append(source);
+    }
+    sb.append(")");
+    return sb.toString();
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (!(o instanceof VectorValueSource)) return false;
+
+    VectorValueSource that = (VectorValueSource) o;
+
+    if (!sources.equals(that.sources)) return false;
+
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    return sources.hashCode();
+  }
+}
diff --git a/solr/src/java/org/apache/solr/schema/BoolField.java b/solr/src/java/org/apache/solr/schema/BoolField.java
index a4e800b..a57b101 100644
--- a/solr/src/java/org/apache/solr/schema/BoolField.java
+++ b/solr/src/java/org/apache/solr/schema/BoolField.java
@@ -22,6 +22,8 @@ import org.apache.lucene.common.mutable.MutableValueBool;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.queries.function.DocValues;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.BoolDocValues;
+import org.apache.lucene.queries.function.valuesource.OrdFieldSource;
 import org.apache.lucene.search.FieldCache;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.util.BytesRef;
diff --git a/solr/src/java/org/apache/solr/schema/ByteField.java b/solr/src/java/org/apache/solr/schema/ByteField.java
index 2cc1664..ec35f53 100644
--- a/solr/src/java/org/apache/solr/schema/ByteField.java
+++ b/solr/src/java/org/apache/solr/schema/ByteField.java
@@ -18,13 +18,13 @@ package org.apache.solr.schema;
 
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.valuesource.ByteFieldSource;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.cache.ByteValuesCreator;
 import org.apache.lucene.search.cache.CachedArrayCreator;
 
 import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.QParser;
-import org.apache.solr.search.function.ByteFieldSource;
 
 import java.io.IOException;
 import java.util.Map;
diff --git a/solr/src/java/org/apache/solr/schema/DateField.java b/solr/src/java/org/apache/solr/schema/DateField.java
index 7b9f9cc..edf3abd 100644
--- a/solr/src/java/org/apache/solr/schema/DateField.java
+++ b/solr/src/java/org/apache/solr/schema/DateField.java
@@ -21,6 +21,8 @@ import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.lucene.queries.function.DocValues;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.StringIndexDocValues;
+import org.apache.lucene.queries.function.valuesource.FieldCacheSource;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.TermRangeQuery;
diff --git a/solr/src/java/org/apache/solr/schema/DoubleField.java b/solr/src/java/org/apache/solr/schema/DoubleField.java
index 324ec17..1782633 100644
--- a/solr/src/java/org/apache/solr/schema/DoubleField.java
+++ b/solr/src/java/org/apache/solr/schema/DoubleField.java
@@ -19,12 +19,12 @@ package org.apache.solr.schema;
 
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.valuesource.DoubleFieldSource;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.cache.CachedArrayCreator;
 import org.apache.lucene.search.cache.DoubleValuesCreator;
 import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.QParser;
-import org.apache.solr.search.function.DoubleFieldSource;
 
 import java.io.IOException;
 import java.util.Map;
diff --git a/solr/src/java/org/apache/solr/schema/FloatField.java b/solr/src/java/org/apache/solr/schema/FloatField.java
index 0921b47..59be59a 100644
--- a/solr/src/java/org/apache/solr/schema/FloatField.java
+++ b/solr/src/java/org/apache/solr/schema/FloatField.java
@@ -18,11 +18,11 @@
 package org.apache.solr.schema;
 
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.valuesource.FloatFieldSource;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.cache.CachedArrayCreator;
 import org.apache.lucene.search.cache.FloatValuesCreator;
 import org.apache.solr.search.QParser;
-import org.apache.solr.search.function.FloatFieldSource;
 import org.apache.lucene.document.Fieldable;
 import org.apache.solr.response.TextResponseWriter;
 
diff --git a/solr/src/java/org/apache/solr/schema/GeoHashField.java b/solr/src/java/org/apache/solr/schema/GeoHashField.java
index 8ead0de..f28878c 100644
--- a/solr/src/java/org/apache/solr/schema/GeoHashField.java
+++ b/solr/src/java/org/apache/solr/schema/GeoHashField.java
@@ -19,6 +19,7 @@ package org.apache.solr.schema;
 
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.valuesource.LiteralValueSource;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.spatial.geohash.GeoHashUtils;
@@ -29,7 +30,6 @@ import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.QParser;
 import org.apache.solr.search.SolrConstantScoreQuery;
 import org.apache.solr.search.SpatialOptions;
-import org.apache.solr.search.function.LiteralValueSource;
 import org.apache.solr.search.function.ValueSourceRangeFilter;
 import org.apache.solr.search.function.distance.GeohashHaversineFunction;
 
diff --git a/solr/src/java/org/apache/solr/schema/IntField.java b/solr/src/java/org/apache/solr/schema/IntField.java
index d37a36f..f52b7f9 100644
--- a/solr/src/java/org/apache/solr/schema/IntField.java
+++ b/solr/src/java/org/apache/solr/schema/IntField.java
@@ -18,11 +18,11 @@
 package org.apache.solr.schema;
 
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.valuesource.IntFieldSource;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.cache.CachedArrayCreator;
 import org.apache.lucene.search.cache.IntValuesCreator;
 import org.apache.solr.search.QParser;
-import org.apache.solr.search.function.IntFieldSource;
 import org.apache.lucene.document.Fieldable;
 import org.apache.solr.response.TextResponseWriter;
 
diff --git a/solr/src/java/org/apache/solr/schema/LatLonType.java b/solr/src/java/org/apache/solr/schema/LatLonType.java
index d32aa3b..1782fa9 100644
--- a/solr/src/java/org/apache/solr/schema/LatLonType.java
+++ b/solr/src/java/org/apache/solr/schema/LatLonType.java
@@ -22,6 +22,7 @@ import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.lucene.queries.function.DocValues;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.valuesource.VectorValueSource;
 import org.apache.lucene.search.*;
 import org.apache.lucene.spatial.DistanceUtils;
 import org.apache.lucene.spatial.tier.InvalidGeoException;
@@ -30,7 +31,6 @@ import org.apache.solr.common.SolrException;
 import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.QParser;
 import org.apache.solr.search.SpatialOptions;
-import org.apache.solr.search.function.VectorValueSource;
 
 import java.io.IOException;
 import java.util.ArrayList;
diff --git a/solr/src/java/org/apache/solr/schema/LongField.java b/solr/src/java/org/apache/solr/schema/LongField.java
index 32861eb..6a2e1e5 100644
--- a/solr/src/java/org/apache/solr/schema/LongField.java
+++ b/solr/src/java/org/apache/solr/schema/LongField.java
@@ -19,12 +19,12 @@ package org.apache.solr.schema;
 
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.valuesource.LongFieldSource;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.cache.CachedArrayCreator;
 import org.apache.lucene.search.cache.LongValuesCreator;
 import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.QParser;
-import org.apache.solr.search.function.LongFieldSource;
 
 import java.io.IOException;
 import java.util.Map;
diff --git a/solr/src/java/org/apache/solr/schema/PointType.java b/solr/src/java/org/apache/solr/schema/PointType.java
index 9208706..9cfbfb2 100644
--- a/solr/src/java/org/apache/solr/schema/PointType.java
+++ b/solr/src/java/org/apache/solr/schema/PointType.java
@@ -20,6 +20,7 @@ package org.apache.solr.schema;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.valuesource.VectorValueSource;
 import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.Query;
@@ -32,7 +33,6 @@ import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.QParser;
 import org.apache.solr.search.SpatialOptions;
-import org.apache.solr.search.function.VectorValueSource;
 
 import java.io.IOException;
 import java.util.Map;
diff --git a/solr/src/java/org/apache/solr/schema/RandomSortField.java b/solr/src/java/org/apache/solr/schema/RandomSortField.java
index 992eed5..9b75624 100644
--- a/solr/src/java/org/apache/solr/schema/RandomSortField.java
+++ b/solr/src/java/org/apache/solr/schema/RandomSortField.java
@@ -25,11 +25,11 @@ import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.lucene.queries.function.DocValues;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.IntDocValues;
 import org.apache.lucene.search.*;
 import org.apache.lucene.util.ReaderUtil;
 import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.QParser;
-import org.apache.solr.search.function.IntDocValues;
 
 /**
  * Utility Field used for random sorting.  It should not be passed a value.
diff --git a/solr/src/java/org/apache/solr/schema/ShortField.java b/solr/src/java/org/apache/solr/schema/ShortField.java
index c7edada..523760c 100644
--- a/solr/src/java/org/apache/solr/schema/ShortField.java
+++ b/solr/src/java/org/apache/solr/schema/ShortField.java
@@ -18,13 +18,13 @@ package org.apache.solr.schema;
 
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.valuesource.ShortFieldSource;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.cache.CachedArrayCreator;
 import org.apache.lucene.search.cache.ShortValuesCreator;
 
 import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.QParser;
-import org.apache.solr.search.function.ShortFieldSource;
 
 import java.io.IOException;
 import java.util.Map;
diff --git a/solr/src/java/org/apache/solr/schema/SortableDoubleField.java b/solr/src/java/org/apache/solr/schema/SortableDoubleField.java
index 95fd101..3e9bffe 100644
--- a/solr/src/java/org/apache/solr/schema/SortableDoubleField.java
+++ b/solr/src/java/org/apache/solr/schema/SortableDoubleField.java
@@ -21,12 +21,12 @@ import org.apache.lucene.common.mutable.MutableValue;
 import org.apache.lucene.common.mutable.MutableValueDouble;
 import org.apache.lucene.queries.function.DocValues;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.StringIndexDocValues;
+import org.apache.lucene.queries.function.valuesource.FieldCacheSource;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.CharsRef;
 import org.apache.solr.search.QParser;
-import org.apache.solr.search.function.FieldCacheSource;
-import org.apache.solr.search.function.StringIndexDocValues;
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.solr.util.NumberUtils;
diff --git a/solr/src/java/org/apache/solr/schema/SortableFloatField.java b/solr/src/java/org/apache/solr/schema/SortableFloatField.java
index ad9ac33..fac243d 100644
--- a/solr/src/java/org/apache/solr/schema/SortableFloatField.java
+++ b/solr/src/java/org/apache/solr/schema/SortableFloatField.java
@@ -21,12 +21,12 @@ import org.apache.lucene.common.mutable.MutableValue;
 import org.apache.lucene.common.mutable.MutableValueFloat;
 import org.apache.lucene.queries.function.DocValues;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.StringIndexDocValues;
+import org.apache.lucene.queries.function.valuesource.FieldCacheSource;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.CharsRef;
 import org.apache.solr.search.QParser;
-import org.apache.solr.search.function.FieldCacheSource;
-import org.apache.solr.search.function.StringIndexDocValues;
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.solr.util.NumberUtils;
diff --git a/solr/src/java/org/apache/solr/schema/SortableIntField.java b/solr/src/java/org/apache/solr/schema/SortableIntField.java
index 576068c..2bd5e4a 100644
--- a/solr/src/java/org/apache/solr/schema/SortableIntField.java
+++ b/solr/src/java/org/apache/solr/schema/SortableIntField.java
@@ -21,12 +21,12 @@ import org.apache.lucene.common.mutable.MutableValue;
 import org.apache.lucene.common.mutable.MutableValueInt;
 import org.apache.lucene.queries.function.DocValues;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.StringIndexDocValues;
+import org.apache.lucene.queries.function.valuesource.FieldCacheSource;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.CharsRef;
 import org.apache.solr.search.QParser;
-import org.apache.solr.search.function.FieldCacheSource;
-import org.apache.solr.search.function.StringIndexDocValues;
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.solr.util.NumberUtils;
diff --git a/solr/src/java/org/apache/solr/schema/SortableLongField.java b/solr/src/java/org/apache/solr/schema/SortableLongField.java
index d86d2df..66b4673 100644
--- a/solr/src/java/org/apache/solr/schema/SortableLongField.java
+++ b/solr/src/java/org/apache/solr/schema/SortableLongField.java
@@ -21,12 +21,12 @@ import org.apache.lucene.common.mutable.MutableValue;
 import org.apache.lucene.common.mutable.MutableValueLong;
 import org.apache.lucene.queries.function.DocValues;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.StringIndexDocValues;
+import org.apache.lucene.queries.function.valuesource.FieldCacheSource;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.CharsRef;
 import org.apache.solr.search.QParser;
-import org.apache.solr.search.function.FieldCacheSource;
-import org.apache.solr.search.function.StringIndexDocValues;
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.solr.util.NumberUtils;
diff --git a/solr/src/java/org/apache/solr/schema/StrFieldSource.java b/solr/src/java/org/apache/solr/schema/StrFieldSource.java
index da80ad6..b02d078 100755
--- a/solr/src/java/org/apache/solr/schema/StrFieldSource.java
+++ b/solr/src/java/org/apache/solr/schema/StrFieldSource.java
@@ -19,8 +19,8 @@ package org.apache.solr.schema;
 
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.lucene.queries.function.DocValues;
-import org.apache.solr.search.function.FieldCacheSource;
-import org.apache.solr.search.function.StringIndexDocValues;
+import org.apache.lucene.queries.function.docvalues.StringIndexDocValues;
+import org.apache.lucene.queries.function.valuesource.FieldCacheSource;
 
 import java.io.IOException;
 import java.util.Map;
diff --git a/solr/src/java/org/apache/solr/schema/TrieField.java b/solr/src/java/org/apache/solr/schema/TrieField.java
index 1c4adc6..d30cb53 100644
--- a/solr/src/java/org/apache/solr/schema/TrieField.java
+++ b/solr/src/java/org/apache/solr/schema/TrieField.java
@@ -22,6 +22,10 @@ import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.NumericField;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.valuesource.DoubleFieldSource;
+import org.apache.lucene.queries.function.valuesource.FloatFieldSource;
+import org.apache.lucene.queries.function.valuesource.IntFieldSource;
+import org.apache.lucene.queries.function.valuesource.LongFieldSource;
 import org.apache.lucene.search.*;
 import org.apache.lucene.search.cache.CachedArrayCreator;
 import org.apache.lucene.search.cache.DoubleValuesCreator;
diff --git a/solr/src/java/org/apache/solr/search/BoostQParserPlugin.java b/solr/src/java/org/apache/solr/search/BoostQParserPlugin.java
index a9832e6..3e7bb14 100755
--- a/solr/src/java/org/apache/solr/search/BoostQParserPlugin.java
+++ b/solr/src/java/org/apache/solr/search/BoostQParserPlugin.java
@@ -18,13 +18,13 @@ package org.apache.solr.search;
 
 import org.apache.lucene.queries.function.FunctionQuery;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.valuesource.QueryValueSource;
 import org.apache.lucene.queryParser.ParseException;
 import org.apache.lucene.search.Query;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.search.function.BoostedQuery;
-import org.apache.solr.search.function.QueryValueSource;
 
 /**
  * Create a boosted query from the input value.  The main value is the query to be boosted.
@@ -34,7 +34,8 @@ import org.apache.solr.search.function.QueryValueSource;
  * The query to be boosted may be of any type.
  *
  * <p>Example: <code>{!boost b=recip(ms(NOW,mydatefield),3.16e-11,1,1)}foo</code> creates a query "foo"
- * which is boosted by the date boosting function referenced in {@link org.apache.solr.search.function.ReciprocalFloatFunction}
+ * which is boosted by the date boosting function referenced in
+ * {@link org.apache.lucene.queries.function.valuesource.ReciprocalFloatFunction}
  */
 public class BoostQParserPlugin extends QParserPlugin {
   public static String NAME = "boost";
diff --git a/solr/src/java/org/apache/solr/search/ExtendedDismaxQParserPlugin.java b/solr/src/java/org/apache/solr/search/ExtendedDismaxQParserPlugin.java
index 857222d..44480ec 100755
--- a/solr/src/java/org/apache/solr/search/ExtendedDismaxQParserPlugin.java
+++ b/solr/src/java/org/apache/solr/search/ExtendedDismaxQParserPlugin.java
@@ -24,6 +24,8 @@ package org.apache.solr.search;
 
 import org.apache.lucene.queries.function.FunctionQuery;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.valuesource.ProductFloatFunction;
+import org.apache.lucene.queries.function.valuesource.QueryValueSource;
 import org.apache.lucene.queryParser.ParseException;
 import org.apache.lucene.queryParser.QueryParser;
 import org.apache.lucene.search.*;
@@ -37,8 +39,6 @@ import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.schema.FieldType;
 import org.apache.solr.search.QueryUtils;
 import org.apache.solr.search.function.BoostedQuery;
-import org.apache.solr.search.function.ProductFloatFunction;
-import org.apache.solr.search.function.QueryValueSource;
 import org.apache.solr.util.SolrPluginUtils;
 import org.apache.solr.analysis.*;
 
diff --git a/solr/src/java/org/apache/solr/search/FunctionQParser.java b/solr/src/java/org/apache/solr/search/FunctionQParser.java
index 312599c..d7ef606 100755
--- a/solr/src/java/org/apache/solr/search/FunctionQParser.java
+++ b/solr/src/java/org/apache/solr/search/FunctionQParser.java
@@ -18,6 +18,7 @@ package org.apache.solr.search;
 
 import org.apache.lucene.queries.function.FunctionQuery;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.valuesource.*;
 import org.apache.lucene.queryParser.ParseException;
 import org.apache.lucene.search.Query;
 import org.apache.solr.common.params.SolrParams;
diff --git a/solr/src/java/org/apache/solr/search/FunctionRangeQParserPlugin.java b/solr/src/java/org/apache/solr/search/FunctionRangeQParserPlugin.java
index 1e55271..11be096 100755
--- a/solr/src/java/org/apache/solr/search/FunctionRangeQParserPlugin.java
+++ b/solr/src/java/org/apache/solr/search/FunctionRangeQParserPlugin.java
@@ -21,6 +21,7 @@ import org.apache.lucene.queries.function.DocValues;
 import org.apache.lucene.queries.function.FunctionQuery;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.queries.function.ValueSourceScorer;
+import org.apache.lucene.queries.function.valuesource.QueryValueSource;
 import org.apache.lucene.queryParser.ParseException;
 import org.apache.lucene.search.*;
 import org.apache.solr.common.params.SolrParams;
diff --git a/solr/src/java/org/apache/solr/search/Grouping.java b/solr/src/java/org/apache/solr/search/Grouping.java
index b2bd8ad..5079286 100755
--- a/solr/src/java/org/apache/solr/search/Grouping.java
+++ b/solr/src/java/org/apache/solr/search/Grouping.java
@@ -24,6 +24,7 @@ import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.lucene.queries.function.DocValues;
 import org.apache.lucene.queries.function.FunctionQuery;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.valuesource.QueryValueSource;
 import org.apache.lucene.queryParser.ParseException;
 import org.apache.lucene.search.*;
 import org.apache.lucene.search.grouping.*;
@@ -33,7 +34,6 @@ import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.schema.*;
-import org.apache.solr.search.function.QueryValueSource;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
diff --git a/solr/src/java/org/apache/solr/search/QueryParsing.java b/solr/src/java/org/apache/solr/search/QueryParsing.java
index 0ad984a..4ccfd0e 100644
--- a/solr/src/java/org/apache/solr/search/QueryParsing.java
+++ b/solr/src/java/org/apache/solr/search/QueryParsing.java
@@ -19,6 +19,7 @@ package org.apache.solr.search;
 
 import org.apache.lucene.index.Term;
 import org.apache.lucene.queries.function.FunctionQuery;
+import org.apache.lucene.queries.function.valuesource.QueryValueSource;
 import org.apache.lucene.queryParser.ParseException;
 import org.apache.lucene.queryParser.QueryParser.Operator;
 import org.apache.lucene.search.BooleanClause;
@@ -44,7 +45,6 @@ import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.schema.FieldType;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.schema.SchemaField;
-import org.apache.solr.search.function.QueryValueSource;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashMap;
diff --git a/solr/src/java/org/apache/solr/search/ReturnFields.java b/solr/src/java/org/apache/solr/search/ReturnFields.java
index c71d2c3..03aaa4b 100644
--- a/solr/src/java/org/apache/solr/search/ReturnFields.java
+++ b/solr/src/java/org/apache/solr/search/ReturnFields.java
@@ -21,6 +21,7 @@ import java.util.*;
 import org.apache.commons.io.FilenameUtils;
 import org.apache.lucene.queries.function.FunctionQuery;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.valuesource.QueryValueSource;
 import org.apache.lucene.queryParser.ParseException;
 import org.apache.lucene.search.Query;
 import org.apache.solr.common.SolrException;
@@ -35,7 +36,6 @@ import org.apache.solr.response.transform.RenameFieldsTransformer;
 import org.apache.solr.response.transform.ScoreAugmenter;
 import org.apache.solr.response.transform.TransformerFactory;
 import org.apache.solr.response.transform.ValueSourceAugmenter;
-import org.apache.solr.search.function.QueryValueSource;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
diff --git a/solr/src/java/org/apache/solr/search/ValueSourceParser.java b/solr/src/java/org/apache/solr/search/ValueSourceParser.java
index a8f3b7e..19055cd 100755
--- a/solr/src/java/org/apache/solr/search/ValueSourceParser.java
+++ b/solr/src/java/org/apache/solr/search/ValueSourceParser.java
@@ -20,6 +20,10 @@ import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.queries.function.DocValues;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.BoolDocValues;
+import org.apache.lucene.queries.function.docvalues.DoubleDocValues;
+import org.apache.lucene.queries.function.docvalues.LongDocValues;
+import org.apache.lucene.queries.function.valuesource.*;
 import org.apache.lucene.queryParser.ParseException;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.IndexSearcher;
diff --git a/solr/src/java/org/apache/solr/search/function/BoolDocValues.java b/solr/src/java/org/apache/solr/search/function/BoolDocValues.java
deleted file mode 100644
index 97cc3a0..0000000
--- a/solr/src/java/org/apache/solr/search/function/BoolDocValues.java
+++ /dev/null
@@ -1,81 +0,0 @@
-package org.apache.solr.search.function;
-
-import org.apache.lucene.common.mutable.MutableValue;
-import org.apache.lucene.common.mutable.MutableValueBool;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-
-
-public abstract class BoolDocValues extends DocValues {
-  protected final ValueSource vs;
-
-  public BoolDocValues(ValueSource vs) {
-    this.vs = vs;
-  }
-
-  @Override
-  public abstract boolean boolVal(int doc);
-
-  @Override
-  public byte byteVal(int doc) {
-    return boolVal(doc) ? (byte)1 : (byte)0;
-  }
-
-  @Override
-  public short shortVal(int doc) {
-    return boolVal(doc) ? (short)1 : (short)0;
-  }
-
-  @Override
-  public float floatVal(int doc) {
-    return boolVal(doc) ? (float)1 : (float)0;
-  }
-
-  @Override
-  public int intVal(int doc) {
-    return boolVal(doc) ? 1 : 0;
-  }
-
-  @Override
-  public long longVal(int doc) {
-    return boolVal(doc) ? (long)1 : (long)0;
-  }
-
-  @Override
-  public double doubleVal(int doc) {
-    return boolVal(doc) ? (double)1 : (double)0;
-  }
-
-  @Override
-  public String strVal(int doc) {
-    return Boolean.toString(boolVal(doc));
-  }
-
-  @Override
-  public Object objectVal(int doc) {
-    return exists(doc) ? boolVal(doc) : null;
-  }
-
-  @Override
-  public String toString(int doc) {
-    return vs.description() + '=' + strVal(doc);
-  }
-
-  @Override
-  public ValueFiller getValueFiller() {
-    return new ValueFiller() {
-      private final MutableValueBool mval = new MutableValueBool();
-
-      @Override
-      public MutableValue getValue() {
-        return mval;
-      }
-
-      @Override
-      public void fillValue(int doc) {
-        mval.value = boolVal(doc);
-        mval.exists = exists(doc);
-      }
-    };
-  }
-}
diff --git a/solr/src/java/org/apache/solr/search/function/BoolFunction.java b/solr/src/java/org/apache/solr/search/function/BoolFunction.java
deleted file mode 100644
index 782b2fb..0000000
--- a/solr/src/java/org/apache/solr/search/function/BoolFunction.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.queries.function.ValueSource;
-
-
-public abstract class BoolFunction extends ValueSource {
-  // TODO: placeholder to return type, among other common future functionality
-}
diff --git a/solr/src/java/org/apache/solr/search/function/ByteFieldSource.java b/solr/src/java/org/apache/solr/search/function/ByteFieldSource.java
deleted file mode 100644
index 111f406..0000000
--- a/solr/src/java/org/apache/solr/search/function/ByteFieldSource.java
+++ /dev/null
@@ -1,99 +0,0 @@
-package org.apache.solr.search.function;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.search.cache.ByteValuesCreator;
-import org.apache.lucene.search.cache.CachedArray.ByteValues;
-
-import java.io.IOException;
-import java.util.Map;
-
-/**
- * Obtains int field values from the {@link org.apache.lucene.search.FieldCache}
- * using <code>getInts()</code>
- * and makes those values available as other numeric types, casting as needed. *
- *
- *
- */
-
-public class ByteFieldSource extends NumericFieldCacheSource<ByteValues> {
-
-  public ByteFieldSource(ByteValuesCreator creator) {
-    super(creator);
-  }
-
-  @Override
-  public String description() {
-    return "byte(" + field + ')';
-  }
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    final ByteValues vals = cache.getBytes(readerContext.reader, field, creator);
-    final byte[] arr = vals.values;
-    
-    return new DocValues() {
-      @Override
-      public byte byteVal(int doc) {
-        return arr[doc];
-      }
-
-      @Override
-      public short shortVal(int doc) {
-        return (short) arr[doc];
-      }
-
-      @Override
-      public float floatVal(int doc) {
-        return (float) arr[doc];
-      }
-
-      @Override
-      public int intVal(int doc) {
-        return (int) arr[doc];
-      }
-
-      @Override
-      public long longVal(int doc) {
-        return (long) arr[doc];
-      }
-
-      @Override
-      public double doubleVal(int doc) {
-        return (double) arr[doc];
-      }
-
-      @Override
-      public String strVal(int doc) {
-        return Byte.toString(arr[doc]);
-      }
-
-      @Override
-      public String toString(int doc) {
-        return description() + '=' + byteVal(doc);
-      }
-
-      @Override
-      public Object objectVal(int doc) {
-        return arr[doc];  // TODO: valid?
-      }
-
-    };
-  }
-}
diff --git a/solr/src/java/org/apache/solr/search/function/ConstNumberSource.java b/solr/src/java/org/apache/solr/search/function/ConstNumberSource.java
deleted file mode 100755
index 859b567..0000000
--- a/solr/src/java/org/apache/solr/search/function/ConstNumberSource.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.queries.function.ValueSource;
-
-/**
- * <code>ConstNumberSource</code> is the base class for all constant numbers
- */
-public abstract class ConstNumberSource extends ValueSource {
-  public abstract int getInt();
-  public abstract long getLong();
-  public abstract float getFloat();
-  public abstract double getDouble();  
-  public abstract Number getNumber();  
-  public abstract boolean getBool();
-}
diff --git a/solr/src/java/org/apache/solr/search/function/ConstValueSource.java b/solr/src/java/org/apache/solr/search/function/ConstValueSource.java
deleted file mode 100755
index 2e88639..0000000
--- a/solr/src/java/org/apache/solr/search/function/ConstValueSource.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-
-import java.io.IOException;
-import java.util.Map;
-
-/**
- * <code>ConstValueSource</code> returns a constant for all documents
- */
-public class ConstValueSource extends ConstNumberSource {
-  final float constant;
-  private final double dv;
-
-  public ConstValueSource(float constant) {
-    this.constant = constant;
-    this.dv = constant;
-  }
-
-  @Override
-  public String description() {
-    return "const(" + constant + ")";
-  }
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    return new FloatDocValues(this) {
-      @Override
-      public float floatVal(int doc) {
-        return constant;
-      }
-      @Override
-      public int intVal(int doc) {
-        return (int)constant;
-      }
-      @Override
-      public long longVal(int doc) {
-        return (long)constant;
-      }
-      @Override
-      public double doubleVal(int doc) {
-        return dv;
-      }
-      @Override
-      public String toString(int doc) {
-        return description();
-      }
-      @Override
-      public Object objectVal(int doc) {
-        return constant;
-      }
-      @Override
-      public boolean boolVal(int doc) {
-        return constant != 0.0f;
-      }
-    };
-  }
-
-  @Override
-  public int hashCode() {
-    return Float.floatToIntBits(constant) * 31;
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (!(o instanceof ConstValueSource)) return false;
-    ConstValueSource other = (ConstValueSource)o;
-    return  this.constant == other.constant;
-  }
-
-  @Override
-  public int getInt() {
-    return (int)constant;
-  }
-
-  @Override
-  public long getLong() {
-    return (long)constant;
-  }
-
-  @Override
-  public float getFloat() {
-    return constant;
-  }
-
-  @Override
-  public double getDouble() {
-    return dv;
-  }
-
-  @Override
-  public Number getNumber() {
-    return constant;
-  }
-
-  @Override
-  public boolean getBool() {
-    return constant != 0.0f;
-  }
-}
diff --git a/solr/src/java/org/apache/solr/search/function/DefFunction.java b/solr/src/java/org/apache/solr/search/function/DefFunction.java
deleted file mode 100644
index f7d4ceb..0000000
--- a/solr/src/java/org/apache/solr/search/function/DefFunction.java
+++ /dev/null
@@ -1,126 +0,0 @@
-package org.apache.solr.search.function;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.util.BytesRef;
-
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-
-public class DefFunction extends MultiFunction {
-  public DefFunction(List<ValueSource> sources) {
-    super(sources);
-  }
-
-  @Override
-  protected String name() {
-    return "def";
-  }
-
-
-  @Override
-  public DocValues getValues(Map fcontext, AtomicReaderContext readerContext) throws IOException {
-
-
-    return new Values(valsArr(sources, fcontext, readerContext)) {
-      final int upto = valsArr.length - 1;
-
-      private DocValues get(int doc) {
-        for (int i=0; i<upto; i++) {
-          DocValues vals = valsArr[i];
-          if (vals.exists(doc)) {
-            return vals;
-          }
-        }
-        return valsArr[upto];
-      }
-
-      @Override
-      public byte byteVal(int doc) {
-        return get(doc).byteVal(doc);
-      }
-
-      @Override
-      public short shortVal(int doc) {
-        return get(doc).shortVal(doc);
-      }
-
-      @Override
-      public float floatVal(int doc) {
-        return get(doc).floatVal(doc);
-      }
-
-      @Override
-      public int intVal(int doc) {
-        return get(doc).intVal(doc);
-      }
-
-      @Override
-      public long longVal(int doc) {
-        return get(doc).longVal(doc);
-      }
-
-      @Override
-      public double doubleVal(int doc) {
-        return get(doc).doubleVal(doc);
-      }
-
-      @Override
-      public String strVal(int doc) {
-        return get(doc).strVal(doc);
-      }
-
-      @Override
-      public boolean boolVal(int doc) {
-        return get(doc).boolVal(doc);
-      }
-
-      @Override
-      public boolean bytesVal(int doc, BytesRef target) {
-        return get(doc).bytesVal(doc, target);
-      }
-
-      @Override
-      public Object objectVal(int doc) {
-        return get(doc).objectVal(doc);
-      }
-
-      @Override
-      public boolean exists(int doc) {
-        // return true if any source is exists?
-        for (DocValues vals : valsArr) {
-          if (vals.exists(doc)) {
-            return true;
-          }
-        }
-        return false;
-      }
-
-      @Override
-      public ValueFiller getValueFiller() {
-        // TODO: need ValueSource.type() to determine correct type
-        return super.getValueFiller();
-      }
-    };
-  }
-}
\ No newline at end of file
diff --git a/solr/src/java/org/apache/solr/search/function/DivFloatFunction.java b/solr/src/java/org/apache/solr/search/function/DivFloatFunction.java
deleted file mode 100755
index 59de812..0000000
--- a/solr/src/java/org/apache/solr/search/function/DivFloatFunction.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-
-/** Function to divide "a" by "b"
- */
-public class DivFloatFunction extends DualFloatFunction {
- /**
-   * @param   a  the numerator.
-   * @param   b  the denominator.
-   */
-  public DivFloatFunction(ValueSource a, ValueSource b) {
-    super(a,b);
-  }
-
-  @Override
-  protected String name() {
-    return "div";
-  }
-
-  @Override
-  protected float func(int doc, DocValues aVals, DocValues bVals) {
-    return aVals.floatVal(doc) / bVals.floatVal(doc);
-  }
-}
diff --git a/solr/src/java/org/apache/solr/search/function/DocFreqValueSource.java b/solr/src/java/org/apache/solr/search/function/DocFreqValueSource.java
deleted file mode 100755
index 1cce8a6..0000000
--- a/solr/src/java/org/apache/solr/search/function/DocFreqValueSource.java
+++ /dev/null
@@ -1,171 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.util.BytesRef;
-import org.apache.solr.search.*;
-
-import java.io.IOException;
-import java.util.Map;
-
-
-class ConstIntDocValues extends IntDocValues {
-  final int ival;
-  final float fval;
-  final double dval;
-  final long lval;
-  final String sval;
-  final ValueSource parent;
-
-  ConstIntDocValues(int val, ValueSource parent) {
-    super(parent);
-    ival = val;
-    fval = val;
-    dval = val;
-    lval = val;
-    sval = Integer.toString(val);
-    this.parent = parent;
-  }
-
-  @Override
-  public float floatVal(int doc) {
-    return fval;
-  }
-  @Override
-  public int intVal(int doc) {
-    return ival;
-  }
-  @Override
-  public long longVal(int doc) {
-    return lval;
-  }
-  @Override
-  public double doubleVal(int doc) {
-    return dval;
-  }
-  @Override
-  public String strVal(int doc) {
-    return sval;
-  }
-  @Override
-  public String toString(int doc) {
-    return parent.description() + '=' + sval;
-  }
-}
-
-class ConstDoubleDocValues extends DoubleDocValues {
-  final int ival;
-  final float fval;
-  final double dval;
-  final long lval;
-  final String sval;
-  final ValueSource parent;
-
-  ConstDoubleDocValues(double val, ValueSource parent) {
-    super(parent);
-    ival = (int)val;
-    fval = (float)val;
-    dval = val;
-    lval = (long)val;
-    sval = Double.toString(val);
-    this.parent = parent;
-  }
-
-  @Override
-  public float floatVal(int doc) {
-    return fval;
-  }
-  @Override
-  public int intVal(int doc) {
-    return ival;
-  }
-  @Override
-  public long longVal(int doc) {
-    return lval;
-  }
-  @Override
-  public double doubleVal(int doc) {
-    return dval;
-  }
-  @Override
-  public String strVal(int doc) {
-    return sval;
-  }
-  @Override
-  public String toString(int doc) {
-    return parent.description() + '=' + sval;
-  }
-}
-
-
-/**
- * <code>DocFreqValueSource</code> returns the number of documents containing the term.
- * @lucene.internal
- */
-public class DocFreqValueSource extends ValueSource {
-  protected String field;
-  protected String indexedField;
-  protected String val;
-  protected BytesRef indexedBytes;
-
-  public DocFreqValueSource(String field, String val, String indexedField, BytesRef indexedBytes) {
-    this.field = field;
-    this.val = val;
-    this.indexedField = indexedField;
-    this.indexedBytes = indexedBytes;
-  }
-
-  public String name() {
-    return "docfreq";
-  }
-
-  @Override
-  public String description() {
-    return name() + '(' + field + ',' + val + ')';
-  }
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    IndexSearcher searcher = (IndexSearcher)context.get("searcher");
-    int docfreq = searcher.docFreq(new Term(indexedField, indexedBytes));
-    return new ConstIntDocValues(docfreq, this);
-  }
-
-  @Override
-  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
-    context.put("searcher",searcher);
-  }
-
-  @Override
-  public int hashCode() {
-    return getClass().hashCode() + indexedField.hashCode()*29 + indexedBytes.hashCode();
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (this.getClass() != o.getClass()) return false;
-    DocFreqValueSource other = (DocFreqValueSource)o;
-    return this.indexedField.equals(other.indexedField) && this.indexedBytes.equals(other.indexedBytes);
-  }
-}
-
diff --git a/solr/src/java/org/apache/solr/search/function/DoubleConstValueSource.java b/solr/src/java/org/apache/solr/search/function/DoubleConstValueSource.java
deleted file mode 100755
index b6a5f0d..0000000
--- a/solr/src/java/org/apache/solr/search/function/DoubleConstValueSource.java
+++ /dev/null
@@ -1,124 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-
-import java.io.IOException;
-import java.util.Map;
-
-public class DoubleConstValueSource extends ConstNumberSource {
-  final double constant;
-  private final float fv;
-  private final long lv;
-
-  public DoubleConstValueSource(double constant) {
-    this.constant = constant;
-    this.fv = (float)constant;
-    this.lv = (long)constant;
-  }
-
-  @Override
-  public String description() {
-    return "const(" + constant + ")";
-  }
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    return new DoubleDocValues(this) {
-      @Override
-      public float floatVal(int doc) {
-        return fv;
-      }
-
-      @Override
-      public int intVal(int doc) {
-        return (int) lv;
-      }
-
-      @Override
-      public long longVal(int doc) {
-        return lv;
-      }
-
-      @Override
-      public double doubleVal(int doc) {
-        return constant;
-      }
-
-      @Override
-      public String strVal(int doc) {
-        return Double.toString(constant);
-      }
-
-      @Override
-      public Object objectVal(int doc) {
-        return constant;
-      }
-
-      @Override
-      public String toString(int doc) {
-        return description();
-      }
-    };
-  }
-
-  @Override
-  public int hashCode() {
-    long bits = Double.doubleToRawLongBits(constant);
-    return (int)(bits ^ (bits >>> 32));
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (!(o instanceof DoubleConstValueSource)) return false;
-    DoubleConstValueSource other = (DoubleConstValueSource) o;
-    return this.constant == other.constant;
-  }
-
-  @Override
-  public int getInt() {
-    return (int)lv;
-  }
-
-  @Override
-  public long getLong() {
-    return lv;
-  }
-
-  @Override
-  public float getFloat() {
-    return fv;
-  }
-
-  @Override
-  public double getDouble() {
-    return constant;
-  }
-
-  @Override
-  public Number getNumber() {
-    return constant;
-  }
-
-  @Override
-  public boolean getBool() {
-    return constant != 0;
-  }
-}
diff --git a/solr/src/java/org/apache/solr/search/function/DoubleDocValues.java b/solr/src/java/org/apache/solr/search/function/DoubleDocValues.java
deleted file mode 100644
index 1bb1ce6..0000000
--- a/solr/src/java/org/apache/solr/search/function/DoubleDocValues.java
+++ /dev/null
@@ -1,81 +0,0 @@
-package org.apache.solr.search.function;
-
-import org.apache.lucene.common.mutable.MutableValue;
-import org.apache.lucene.common.mutable.MutableValueDouble;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-
-public abstract class DoubleDocValues extends DocValues {
-  protected final ValueSource vs;
-
-  public DoubleDocValues(ValueSource vs) {
-    this.vs = vs;
-  }
-
-  @Override
-  public byte byteVal(int doc) {
-    return (byte)doubleVal(doc);
-  }
-
-  @Override
-  public short shortVal(int doc) {
-    return (short)doubleVal(doc);
-  }
-
-  @Override
-  public float floatVal(int doc) {
-    return (float)doubleVal(doc);
-  }
-
-  @Override
-  public int intVal(int doc) {
-    return (int)doubleVal(doc);
-  }
-
-  @Override
-  public long longVal(int doc) {
-    return (long)doubleVal(doc);
-  }
-
-  @Override
-  public boolean boolVal(int doc) {
-    return doubleVal(doc) != 0;
-  }
-
-  @Override
-  public abstract double doubleVal(int doc);
-
-  @Override
-  public String strVal(int doc) {
-    return Double.toString(doubleVal(doc));
-  }
-
-  @Override
-  public Object objectVal(int doc) {
-    return exists(doc) ? doubleVal(doc) : null;
-  }
-
-  @Override
-  public String toString(int doc) {
-    return vs.description() + '=' + strVal(doc);
-  }
-
-  @Override
-  public ValueFiller getValueFiller() {
-    return new ValueFiller() {
-      private final MutableValueDouble mval = new MutableValueDouble();
-
-      @Override
-      public MutableValue getValue() {
-        return mval;
-      }
-
-      @Override
-      public void fillValue(int doc) {
-        mval.value = doubleVal(doc);
-        mval.exists = exists(doc);
-      }
-    };
-  }
-
-}
diff --git a/solr/src/java/org/apache/solr/search/function/DoubleFieldSource.java b/solr/src/java/org/apache/solr/search/function/DoubleFieldSource.java
deleted file mode 100644
index 57bcc0a..0000000
--- a/solr/src/java/org/apache/solr/search/function/DoubleFieldSource.java
+++ /dev/null
@@ -1,150 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.common.mutable.MutableValue;
-import org.apache.lucene.common.mutable.MutableValueDouble;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSourceScorer;
-import org.apache.lucene.util.Bits;
-import org.apache.lucene.search.cache.DoubleValuesCreator;
-import org.apache.lucene.search.cache.CachedArray.DoubleValues;
-
-import java.io.IOException;
-import java.util.Map;
-
-/**
- * Obtains float field values from the {@link org.apache.lucene.search.FieldCache}
- * using <code>getFloats()</code>
- * and makes those values available as other numeric types, casting as needed.
- *
- *
- */
-
-public class DoubleFieldSource extends NumericFieldCacheSource<DoubleValues> {
-
-  public DoubleFieldSource(DoubleValuesCreator creator) {
-    super(creator);
-  }
-
-  @Override
-  public String description() {
-    return "double(" + field + ')';
-  }
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    final DoubleValues vals = cache.getDoubles(readerContext.reader, field, creator);
-    final double[] arr = vals.values;
-    final Bits valid = vals.valid;
-    
-    return new DoubleDocValues(this) {
-      @Override
-      public double doubleVal(int doc) {
-        return arr[doc];
-      }
-
-      @Override
-      public boolean exists(int doc) {
-        return valid.get(doc);
-      }
-
-      @Override
-      public ValueSourceScorer getRangeScorer(IndexReader reader, String lowerVal, String upperVal, boolean includeLower, boolean includeUpper) {
-        double lower,upper;
-
-        if (lowerVal==null) {
-          lower = Double.NEGATIVE_INFINITY;
-        } else {
-          lower = Double.parseDouble(lowerVal);
-        }
-
-         if (upperVal==null) {
-          upper = Double.POSITIVE_INFINITY;
-        } else {
-          upper = Double.parseDouble(upperVal);
-        }
-
-        final double l = lower;
-        final double u = upper;
-
-
-        if (includeLower && includeUpper) {
-          return new ValueSourceScorer(reader, this) {
-            @Override
-            public boolean matchesValue(int doc) {
-              double docVal = doubleVal(doc);
-              return docVal >= l && docVal <= u;
-            }
-          };
-        }
-        else if (includeLower && !includeUpper) {
-          return new ValueSourceScorer(reader, this) {
-            @Override
-            public boolean matchesValue(int doc) {
-              double docVal = doubleVal(doc);
-              return docVal >= l && docVal < u;
-            }
-          };
-        }
-        else if (!includeLower && includeUpper) {
-          return new ValueSourceScorer(reader, this) {
-            @Override
-            public boolean matchesValue(int doc) {
-              double docVal = doubleVal(doc);
-              return docVal > l && docVal <= u;
-            }
-          };
-        }
-        else {
-          return new ValueSourceScorer(reader, this) {
-            @Override
-            public boolean matchesValue(int doc) {
-              double docVal = doubleVal(doc);
-              return docVal > l && docVal < u;
-            }
-          };
-        }
-      }
-
-      @Override
-      public ValueFiller getValueFiller() {
-        return new ValueFiller() {
-          private final double[] doubleArr = arr;
-          private final MutableValueDouble mval = new MutableValueDouble();
-
-          @Override
-          public MutableValue getValue() {
-            return mval;
-          }
-
-          @Override
-          public void fillValue(int doc) {
-            mval.value = doubleArr[doc];
-            mval.exists = valid.get(doc);
-          }
-        };
-      }
-
-
-      };
-
-  }
-}
diff --git a/solr/src/java/org/apache/solr/search/function/DualFloatFunction.java b/solr/src/java/org/apache/solr/search/function/DualFloatFunction.java
deleted file mode 100755
index 1cb170b..0000000
--- a/solr/src/java/org/apache/solr/search/function/DualFloatFunction.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.search.IndexSearcher;
-
-import java.io.IOException;
-import java.util.Map;
-
-public abstract class DualFloatFunction extends ValueSource {
-  protected final ValueSource a;
-  protected final ValueSource b;
-
- /**
-   * @param   a  the base.
-   * @param   b  the exponent.
-   */
-  public DualFloatFunction(ValueSource a, ValueSource b) {
-    this.a = a;
-    this.b = b;
-  }
-
-  protected abstract String name();
-  protected abstract float func(int doc, DocValues aVals, DocValues bVals);
-
-  @Override
-  public String description() {
-    return name() + "(" + a.description() + "," + b.description() + ")";
-  }
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    final DocValues aVals =  a.getValues(context, readerContext);
-    final DocValues bVals =  b.getValues(context, readerContext);
-    return new FloatDocValues(this) {
-      @Override
-      public float floatVal(int doc) {
-	return func(doc, aVals, bVals);
-      }
-      @Override
-      public String toString(int doc) {
-	return name() + '(' + aVals.toString(doc) + ',' + bVals.toString(doc) + ')';
-      }
-    };
-  }
-
-  @Override
-  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
-    a.createWeight(context,searcher);
-    b.createWeight(context,searcher);
-  }
-
-  @Override
-  public int hashCode() {
-    int h = a.hashCode();
-    h ^= (h << 13) | (h >>> 20);
-    h += b.hashCode();
-    h ^= (h << 23) | (h >>> 10);
-    h += name().hashCode();
-    return h;
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (this.getClass() != o.getClass()) return false;
-    DualFloatFunction other = (DualFloatFunction)o;
-    return this.a.equals(other.a)
-        && this.b.equals(other.b);
-  }
-}
diff --git a/solr/src/java/org/apache/solr/search/function/FieldCacheSource.java b/solr/src/java/org/apache/solr/search/function/FieldCacheSource.java
deleted file mode 100644
index a48961b..0000000
--- a/solr/src/java/org/apache/solr/search/function/FieldCacheSource.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.search.FieldCache;
-
-/**
- * A base class for ValueSource implementations that retrieve values for
- * a single field from the {@link org.apache.lucene.search.FieldCache}.
- *
- *
- */
-public abstract class FieldCacheSource extends ValueSource {
-  protected String field;
-  protected FieldCache cache = FieldCache.DEFAULT;
-
-  public FieldCacheSource(String field) {
-    this.field=field;
-  }
-
-  public FieldCache getFieldCache() {
-    return cache;
-  }
-
-  public String getField() {
-    return field;
-  }
-
-  @Override
-  public String description() {
-    return field;
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (!(o instanceof FieldCacheSource)) return false;
-    FieldCacheSource other = (FieldCacheSource)o;
-    return this.field.equals(other.field)
-           && this.cache == other.cache;
-  }
-
-  @Override
-  public int hashCode() {
-    return cache.hashCode() + field.hashCode();
-  };
-
-}
diff --git a/solr/src/java/org/apache/solr/search/function/FileFloatSource.java b/solr/src/java/org/apache/solr/search/function/FileFloatSource.java
index 8675aee..55bee03 100755
--- a/solr/src/java/org/apache/solr/search/function/FileFloatSource.java
+++ b/solr/src/java/org/apache/solr/search/function/FileFloatSource.java
@@ -35,6 +35,7 @@ import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.lucene.index.IndexReader.ReaderContext;
 import org.apache.lucene.queries.function.DocValues;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.FloatDocValues;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.ReaderUtil;
 import org.apache.solr.core.SolrCore;
diff --git a/solr/src/java/org/apache/solr/search/function/FloatDocValues.java b/solr/src/java/org/apache/solr/search/function/FloatDocValues.java
deleted file mode 100644
index 55a9da7..0000000
--- a/solr/src/java/org/apache/solr/search/function/FloatDocValues.java
+++ /dev/null
@@ -1,75 +0,0 @@
-package org.apache.solr.search.function;
-
-import org.apache.lucene.common.mutable.MutableValue;
-import org.apache.lucene.common.mutable.MutableValueFloat;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-
-public abstract class FloatDocValues extends DocValues {
-  protected final ValueSource vs;
-
-  public FloatDocValues(ValueSource vs) {
-    this.vs = vs;
-  }
-
-  @Override
-  public byte byteVal(int doc) {
-    return (byte)floatVal(doc);
-  }
-
-  @Override
-  public short shortVal(int doc) {
-    return (short)floatVal(doc);
-  }
-
-  @Override
-  public abstract float floatVal(int doc);
-
-  @Override
-  public int intVal(int doc) {
-    return (int)floatVal(doc);
-  }
-
-  @Override
-  public long longVal(int doc) {
-    return (long)floatVal(doc);
-  }
-
-  @Override
-  public double doubleVal(int doc) {
-    return (double)floatVal(doc);
-  }
-
-  @Override
-  public String strVal(int doc) {
-    return Float.toString(floatVal(doc));
-  }
-
-  @Override
-  public Object objectVal(int doc) {
-    return exists(doc) ? floatVal(doc) : null;
-  }
-
-  @Override
-  public String toString(int doc) {
-    return vs.description() + '=' + strVal(doc);
-  }
-
-  @Override
-  public ValueFiller getValueFiller() {
-    return new ValueFiller() {
-      private final MutableValueFloat mval = new MutableValueFloat();
-
-      @Override
-      public MutableValue getValue() {
-        return mval;
-      }
-
-      @Override
-      public void fillValue(int doc) {
-        mval.value = floatVal(doc);
-        mval.exists = exists(doc);
-      }
-    };
-  }
-}
diff --git a/solr/src/java/org/apache/solr/search/function/FloatFieldSource.java b/solr/src/java/org/apache/solr/search/function/FloatFieldSource.java
deleted file mode 100644
index 33794ba..0000000
--- a/solr/src/java/org/apache/solr/search/function/FloatFieldSource.java
+++ /dev/null
@@ -1,93 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import java.io.IOException;
-import java.util.Map;
-
-import org.apache.lucene.common.mutable.MutableValue;
-import org.apache.lucene.common.mutable.MutableValueFloat;
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.util.Bits;
-import org.apache.lucene.search.cache.FloatValuesCreator;
-import org.apache.lucene.search.cache.CachedArray.FloatValues;
-
-/**
- * Obtains float field values from the {@link org.apache.lucene.search.FieldCache}
- * using <code>getFloats()</code>
- * and makes those values available as other numeric types, casting as needed.
- *
- *
- */
-
-public class FloatFieldSource extends NumericFieldCacheSource<FloatValues> {
-
-  public FloatFieldSource(FloatValuesCreator creator) {
-    super(creator);
-  }
-
-  @Override
-  public String description() {
-    return "float(" + field + ')';
-  }
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    final FloatValues vals = cache.getFloats(readerContext.reader, field, creator);
-    final float[] arr = vals.values;
-    final Bits valid = vals.valid;
-    
-    return new FloatDocValues(this) {
-      @Override
-      public float floatVal(int doc) {
-        return arr[doc];
-      }
-
-      @Override
-      public Object objectVal(int doc) {
-        return valid.get(doc) ? arr[doc] : null;
-      }
-
-      @Override
-      public boolean exists(int doc) {
-        return valid.get(doc);
-      }
-
-      @Override
-      public ValueFiller getValueFiller() {
-        return new ValueFiller() {
-          private final float[] floatArr = arr;
-          private final MutableValueFloat mval = new MutableValueFloat();
-
-          @Override
-          public MutableValue getValue() {
-            return mval;
-          }
-
-          @Override
-          public void fillValue(int doc) {
-            mval.value = floatArr[doc];
-            mval.exists = valid.get(doc);
-          }
-        };
-      }
-
-    };
-  }
-}
diff --git a/solr/src/java/org/apache/solr/search/function/IDFValueSource.java b/solr/src/java/org/apache/solr/search/function/IDFValueSource.java
deleted file mode 100755
index 99d4fe3..0000000
--- a/solr/src/java/org/apache/solr/search/function/IDFValueSource.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.index.*;
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Similarity;
-import org.apache.lucene.util.BytesRef;
-
-import java.io.IOException;
-import java.util.Map;
-
-/** @lucene.internal */
-public class IDFValueSource extends DocFreqValueSource {
-  public IDFValueSource(String field, String val, String indexedField, BytesRef indexedBytes) {
-    super(field, val, indexedField, indexedBytes);
-  }
-
-  @Override
-  public String name() {
-    return "idf";
-  }
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    IndexSearcher searcher = (IndexSearcher)context.get("searcher");
-    Similarity sim = searcher.getSimilarityProvider().get(field);
-    // todo: we need docFreq that takes a BytesRef
-    int docfreq = searcher.docFreq(new Term(indexedField, indexedBytes.utf8ToString()));
-    float idf = sim.idf(docfreq, searcher.maxDoc());
-    return new ConstDoubleDocValues(idf, this);
-  }
-}
-
diff --git a/solr/src/java/org/apache/solr/search/function/IfFunction.java b/solr/src/java/org/apache/solr/search/function/IfFunction.java
deleted file mode 100644
index 296af74..0000000
--- a/solr/src/java/org/apache/solr/search/function/IfFunction.java
+++ /dev/null
@@ -1,150 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.search.Explanation;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.util.BytesRef;
-
-import java.io.IOException;
-import java.util.List;
-import java.util.Map;
-
-
-public class IfFunction extends BoolFunction {
-  private ValueSource ifSource;
-  private ValueSource trueSource;
-  private ValueSource falseSource;
-
-
-  public IfFunction(ValueSource ifSource, ValueSource trueSource, ValueSource falseSource) {
-    this.ifSource = ifSource;
-    this.trueSource = trueSource;
-    this.falseSource = falseSource;
-  }
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    final DocValues ifVals = ifSource.getValues(context, readerContext);
-    final DocValues trueVals = trueSource.getValues(context, readerContext);
-    final DocValues falseVals = falseSource.getValues(context, readerContext);
-
-    return new DocValues() {
-      @Override
-      public byte byteVal(int doc) {
-        return ifVals.boolVal(doc) ? trueVals.byteVal(doc) : falseVals.byteVal(doc);
-      }
-
-      @Override
-      public short shortVal(int doc) {
-        return ifVals.boolVal(doc) ? trueVals.shortVal(doc) : falseVals.shortVal(doc);
-      }
-
-      @Override
-      public float floatVal(int doc) {
-        return ifVals.boolVal(doc) ? trueVals.floatVal(doc) : falseVals.floatVal(doc);
-      }
-
-      @Override
-      public int intVal(int doc) {
-        return ifVals.boolVal(doc) ? trueVals.intVal(doc) : falseVals.intVal(doc);
-      }
-
-      @Override
-      public long longVal(int doc) {
-        return ifVals.boolVal(doc) ? trueVals.longVal(doc) : falseVals.longVal(doc);
-      }
-
-      @Override
-      public double doubleVal(int doc) {
-        return ifVals.boolVal(doc) ? trueVals.doubleVal(doc) : falseVals.doubleVal(doc);
-      }
-
-      @Override
-      public String strVal(int doc) {
-        return ifVals.boolVal(doc) ? trueVals.strVal(doc) : falseVals.strVal(doc);
-      }
-
-      @Override
-      public boolean boolVal(int doc) {
-        return ifVals.boolVal(doc) ? trueVals.boolVal(doc) : falseVals.boolVal(doc);
-      }
-
-      @Override
-      public boolean bytesVal(int doc, BytesRef target) {
-        return ifVals.boolVal(doc) ? trueVals.bytesVal(doc, target) : falseVals.bytesVal(doc, target);
-      }
-
-      @Override
-      public Object objectVal(int doc) {
-        return ifVals.boolVal(doc) ? trueVals.objectVal(doc) : falseVals.objectVal(doc);
-      }
-
-      @Override
-      public boolean exists(int doc) {
-        return true; // TODO: flow through to any sub-sources?
-      }
-
-      @Override
-      public ValueFiller getValueFiller() {
-        // TODO: we need types of trueSource / falseSource to handle this
-        // for now, use float.
-        return super.getValueFiller();
-      }
-
-      @Override
-      public String toString(int doc) {
-        return "if(" + ifVals.toString(doc) + ',' + trueVals.toString(doc) + ',' + falseVals.toString(doc) + ')';
-      }
-    };
-
-  }
-
-  @Override
-  public String description() {
-    return "if(" + ifSource.description() + ',' + trueSource.description() + ',' + falseSource + ')';
-  }
-
-  @Override
-  public int hashCode() {
-    int h = ifSource.hashCode();
-    h = h * 31 + trueSource.hashCode();
-    h = h * 31 + falseSource.hashCode();
-    return h;
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (!(o instanceof IfFunction)) return false;
-    IfFunction other = (IfFunction)o;
-    return ifSource.equals(other.ifSource)
-        && trueSource.equals(other.trueSource)
-        && falseSource.equals(other.falseSource);
-  }
-
-  @Override
-  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
-    ifSource.createWeight(context, searcher);
-    trueSource.createWeight(context, searcher);
-    falseSource.createWeight(context, searcher);
-  }
-}
\ No newline at end of file
diff --git a/solr/src/java/org/apache/solr/search/function/IntDocValues.java b/solr/src/java/org/apache/solr/search/function/IntDocValues.java
deleted file mode 100644
index 26aeca3..0000000
--- a/solr/src/java/org/apache/solr/search/function/IntDocValues.java
+++ /dev/null
@@ -1,76 +0,0 @@
-package org.apache.solr.search.function;
-
-import org.apache.lucene.common.mutable.MutableValue;
-import org.apache.lucene.common.mutable.MutableValueInt;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-
-
-public abstract class IntDocValues extends DocValues {
-  protected final ValueSource vs;
-
-  public IntDocValues(ValueSource vs) {
-    this.vs = vs;
-  }
-
-  @Override
-  public byte byteVal(int doc) {
-    return (byte)intVal(doc);
-  }
-
-  @Override
-  public short shortVal(int doc) {
-    return (short)intVal(doc);
-  }
-
-  @Override
-  public float floatVal(int doc) {
-    return (float)intVal(doc);
-  }
-
-  @Override
-  public abstract int intVal(int doc);
-
-  @Override
-  public long longVal(int doc) {
-    return (long)intVal(doc);
-  }
-
-  @Override
-  public double doubleVal(int doc) {
-    return (double)intVal(doc);
-  }
-
-  @Override
-  public String strVal(int doc) {
-    return Integer.toString(intVal(doc));
-  }
-
-  @Override
-  public Object objectVal(int doc) {
-    return exists(doc) ? intVal(doc) : null;
-  }
-
-  @Override
-  public String toString(int doc) {
-    return vs.description() + '=' + strVal(doc);
-  }
-
-  @Override
-  public ValueFiller getValueFiller() {
-    return new ValueFiller() {
-      private final MutableValueInt mval = new MutableValueInt();
-
-      @Override
-      public MutableValue getValue() {
-        return mval;
-      }
-
-      @Override
-      public void fillValue(int doc) {
-        mval.value = intVal(doc);
-        mval.exists = exists(doc);
-      }
-    };
-  }
-}
diff --git a/solr/src/java/org/apache/solr/search/function/IntFieldSource.java b/solr/src/java/org/apache/solr/search/function/IntFieldSource.java
deleted file mode 100644
index 609580f..0000000
--- a/solr/src/java/org/apache/solr/search/function/IntFieldSource.java
+++ /dev/null
@@ -1,157 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.common.mutable.MutableValue;
-import org.apache.lucene.common.mutable.MutableValueInt;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSourceScorer;
-import org.apache.lucene.util.Bits;
-import org.apache.lucene.search.cache.IntValuesCreator;
-import org.apache.lucene.search.cache.CachedArray.IntValues;
-
-import java.io.IOException;
-import java.util.Map;
-
-/**
- * Obtains int field values from the {@link org.apache.lucene.search.FieldCache}
- * using <code>getInts()</code>
- * and makes those values available as other numeric types, casting as needed. *
- *
- */
-
-public class IntFieldSource extends NumericFieldCacheSource<IntValues> {
-
-  public IntFieldSource(IntValuesCreator creator) {
-    super(creator);
-  }
-
-  @Override
-  public String description() {
-    return "int(" + field + ')';
-  }
-
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    final IntValues vals = cache.getInts(readerContext.reader, field, creator);
-    final int[] arr = vals.values;
-    final Bits valid = vals.valid;
-    
-    return new IntDocValues(this) {
-      final MutableValueInt val = new MutableValueInt();
-      
-      @Override
-      public float floatVal(int doc) {
-        return (float)arr[doc];
-      }
-
-      @Override
-      public int intVal(int doc) {
-        return arr[doc];
-      }
-
-      @Override
-      public long longVal(int doc) {
-        return (long)arr[doc];
-      }
-
-      @Override
-      public double doubleVal(int doc) {
-        return (double)arr[doc];
-      }
-
-      @Override
-      public String strVal(int doc) {
-        return Float.toString(arr[doc]);
-      }
-
-      @Override
-      public Object objectVal(int doc) {
-        return valid.get(doc) ? arr[doc] : null;
-      }
-
-      @Override
-      public boolean exists(int doc) {
-        return valid.get(doc);
-      }
-
-      @Override
-      public String toString(int doc) {
-        return description() + '=' + intVal(doc);
-      }
-
-      @Override
-      public ValueSourceScorer getRangeScorer(IndexReader reader, String lowerVal, String upperVal, boolean includeLower, boolean includeUpper) {
-        int lower,upper;
-
-        // instead of using separate comparison functions, adjust the endpoints.
-
-        if (lowerVal==null) {
-          lower = Integer.MIN_VALUE;
-        } else {
-          lower = Integer.parseInt(lowerVal);
-          if (!includeLower && lower < Integer.MAX_VALUE) lower++;
-        }
-
-         if (upperVal==null) {
-          upper = Integer.MAX_VALUE;
-        } else {
-          upper = Integer.parseInt(upperVal);
-          if (!includeUpper && upper > Integer.MIN_VALUE) upper--;
-        }
-
-        final int ll = lower;
-        final int uu = upper;
-
-        return new ValueSourceScorer(reader, this) {
-          @Override
-          public boolean matchesValue(int doc) {
-            int val = arr[doc];
-            // only check for deleted if it's the default value
-            // if (val==0 && reader.isDeleted(doc)) return false;
-            return val >= ll && val <= uu;
-          }
-        };
-      }
-
-      @Override
-      public ValueFiller getValueFiller() {
-        return new ValueFiller() {
-          private final int[] intArr = arr;
-          private final MutableValueInt mval = new MutableValueInt();
-
-          @Override
-          public MutableValue getValue() {
-            return mval;
-          }
-
-          @Override
-          public void fillValue(int doc) {
-            mval.value = intArr[doc];
-            mval.exists = valid.get(doc);
-          }
-        };
-      }
-
-      
-    };
-  }
-}
diff --git a/solr/src/java/org/apache/solr/search/function/JoinDocFreqValueSource.java b/solr/src/java/org/apache/solr/search/function/JoinDocFreqValueSource.java
deleted file mode 100644
index f37aa22..0000000
--- a/solr/src/java/org/apache/solr/search/function/JoinDocFreqValueSource.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import java.io.IOException;
-import java.util.Map;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.search.FieldCache.DocTerms;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.ReaderUtil;
-import org.apache.solr.common.SolrException;
-
-/**
- * Use a field value and find the Document Frequency within another field.
- * 
- * @since solr 4.0
- */
-public class JoinDocFreqValueSource extends FieldCacheSource {
-
-  public static final String NAME = "joindf";
-  
-  protected final String qfield;
-  
-  public JoinDocFreqValueSource(String field, String qfield) {
-    super(field);
-    this.qfield = qfield;
-  }
-
-  @Override
-  public String description() {
-    return NAME + "(" + field +":("+qfield+"))";
-  }
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException
-  {
-    final DocTerms terms = cache.getTerms(readerContext.reader, field, true );
-    final IndexReader top = ReaderUtil.getTopLevelContext(readerContext).reader;
-    
-    return new IntDocValues(this) {
-      BytesRef ref = new BytesRef();
-
-      @Override
-      public int intVal(int doc) 
-      {
-        try {
-          terms.getTerm(doc, ref);
-          int v = top.docFreq( qfield, ref ); 
-          //System.out.println( NAME+"["+field+"="+ref.utf8ToString()+"=("+qfield+":"+v+")]" );
-          return v;
-        } 
-        catch (IOException e) {
-          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "caught exception in function "+description()+" : doc="+doc, e);
-        }
-      }
-    };
-  }
-  
-  @Override
-  public boolean equals(Object o) {
-    if (o.getClass() !=  JoinDocFreqValueSource.class) return false;
-    JoinDocFreqValueSource other = (JoinDocFreqValueSource)o;
-    if( !qfield.equals( other.qfield ) ) return false;
-    return super.equals(other);
-  }
-
-  @Override
-  public int hashCode() {
-    return qfield.hashCode() + super.hashCode();
-  };
-}
diff --git a/solr/src/java/org/apache/solr/search/function/LinearFloatFunction.java b/solr/src/java/org/apache/solr/search/function/LinearFloatFunction.java
deleted file mode 100644
index b120a9a..0000000
--- a/solr/src/java/org/apache/solr/search/function/LinearFloatFunction.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.search.IndexSearcher;
-
-import java.io.IOException;
-import java.util.Map;
-
-/**
- * <code>LinearFloatFunction</code> implements a linear function over
- * another {@link ValueSource}.
- * <br>
- * Normally Used as an argument to a {@link org.apache.lucene.queries.function.FunctionQuery}
- *
- *
- */
-public class LinearFloatFunction extends ValueSource {
-  protected final ValueSource source;
-  protected final float slope;
-  protected final float intercept;
-
-  public LinearFloatFunction(ValueSource source, float slope, float intercept) {
-    this.source = source;
-    this.slope = slope;
-    this.intercept = intercept;
-  }
-  
-  @Override
-  public String description() {
-    return slope + "*float(" + source.description() + ")+" + intercept;
-  }
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    final DocValues vals =  source.getValues(context, readerContext);
-    return new FloatDocValues(this) {
-      @Override
-      public float floatVal(int doc) {
-        return vals.floatVal(doc) * slope + intercept;
-      }
-      @Override
-      public String toString(int doc) {
-        return slope + "*float(" + vals.toString(doc) + ")+" + intercept;
-      }
-    };
-  }
-
-  @Override
-  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
-    source.createWeight(context, searcher);
-  }
-
-  @Override
-  public int hashCode() {
-    int h = Float.floatToIntBits(slope);
-    h = (h >>> 2) | (h << 30);
-    h += Float.floatToIntBits(intercept);
-    h ^= (h << 14) | (h >>> 19);
-    return h + source.hashCode();
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (LinearFloatFunction.class != o.getClass()) return false;
-    LinearFloatFunction other = (LinearFloatFunction)o;
-    return  this.slope == other.slope
-         && this.intercept == other.intercept
-         && this.source.equals(other.source);
-  }
-}
diff --git a/solr/src/java/org/apache/solr/search/function/LiteralValueSource.java b/solr/src/java/org/apache/solr/search/function/LiteralValueSource.java
deleted file mode 100644
index 2b76fd3..0000000
--- a/solr/src/java/org/apache/solr/search/function/LiteralValueSource.java
+++ /dev/null
@@ -1,90 +0,0 @@
-package org.apache.solr.search.function;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.util.BytesRef;
-
-import java.util.Map;
-import java.io.IOException;
-
-
-/**
- * Pass a the field value through as a String, no matter the type // Q: doesn't this mean it's a "string"?
- *
- **/
-public class LiteralValueSource extends ValueSource {
-  protected final String string;
-  protected final BytesRef bytesRef;
-
-  public LiteralValueSource(String string) {
-    this.string = string;
-    this.bytesRef = new BytesRef(string);
-  }
-
-  /** returns the literal value */
-  public String getValue() {
-    return string;
-  }
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-
-    return new StrDocValues(this) {
-      @Override
-      public String strVal(int doc) {
-        return string;
-      }
-
-      @Override
-      public boolean bytesVal(int doc, BytesRef target) {
-        target.copy(bytesRef);
-        return true;
-      }
-
-      @Override
-      public String toString(int doc) {
-        return string;
-      }
-    };
-  }
-
-  @Override
-  public String description() {
-    return "literal(" + string + ")";
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (this == o) return true;
-    if (!(o instanceof LiteralValueSource)) return false;
-
-    LiteralValueSource that = (LiteralValueSource) o;
-
-    if (!string.equals(that.string)) return false;
-
-    return true;
-  }
-
-  public static final int hash = LiteralValueSource.class.hashCode();
-  @Override
-  public int hashCode() {
-    return hash + string.hashCode();
-  }
-}
diff --git a/solr/src/java/org/apache/solr/search/function/LongDocValues.java b/solr/src/java/org/apache/solr/search/function/LongDocValues.java
deleted file mode 100644
index 3525941..0000000
--- a/solr/src/java/org/apache/solr/search/function/LongDocValues.java
+++ /dev/null
@@ -1,81 +0,0 @@
-package org.apache.solr.search.function;
-
-import org.apache.lucene.common.mutable.MutableValue;
-import org.apache.lucene.common.mutable.MutableValueLong;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-
-
-public abstract class LongDocValues extends DocValues {
-  protected final ValueSource vs;
-
-  public LongDocValues(ValueSource vs) {
-    this.vs = vs;
-  }
-
-  @Override
-  public byte byteVal(int doc) {
-    return (byte)longVal(doc);
-  }
-
-  @Override
-  public short shortVal(int doc) {
-    return (short)longVal(doc);
-  }
-
-  @Override
-  public float floatVal(int doc) {
-    return (float)longVal(doc);
-  }
-
-  @Override
-  public int intVal(int doc) {
-    return (int)longVal(doc);
-  }
-
-  @Override
-  public abstract long longVal(int doc);
-
-  @Override
-  public double doubleVal(int doc) {
-    return (double)longVal(doc);
-  }
-
-  @Override
-  public boolean boolVal(int doc) {
-    return longVal(doc) != 0;
-  }
-
-  @Override
-  public String strVal(int doc) {
-    return Long.toString(longVal(doc));
-  }
-
-  @Override
-  public Object objectVal(int doc) {
-    return exists(doc) ? longVal(doc) : null;
-  }
-
-  @Override
-  public String toString(int doc) {
-    return vs.description() + '=' + strVal(doc);
-  }
-
-  @Override
-  public ValueFiller getValueFiller() {
-    return new ValueFiller() {
-      private final MutableValueLong mval = new MutableValueLong();
-
-      @Override
-      public MutableValue getValue() {
-        return mval;
-      }
-
-      @Override
-      public void fillValue(int doc) {
-        mval.value = longVal(doc);
-        mval.exists = exists(doc);
-      }
-    };
-  }
-}
diff --git a/solr/src/java/org/apache/solr/search/function/LongFieldSource.java b/solr/src/java/org/apache/solr/search/function/LongFieldSource.java
deleted file mode 100644
index 6e5ada4..0000000
--- a/solr/src/java/org/apache/solr/search/function/LongFieldSource.java
+++ /dev/null
@@ -1,143 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.common.mutable.MutableValue;
-import org.apache.lucene.common.mutable.MutableValueLong;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSourceScorer;
-import org.apache.lucene.util.Bits;
-import org.apache.lucene.search.cache.LongValuesCreator;
-import org.apache.lucene.search.cache.CachedArray.LongValues;
-
-
-import java.io.IOException;
-import java.util.Map;
-
-/**
- * Obtains float field values from the {@link org.apache.lucene.search.FieldCache}
- * using <code>getFloats()</code>
- * and makes those values available as other numeric types, casting as needed.
- *
- *
- */
-
-public class LongFieldSource extends NumericFieldCacheSource<LongValues> {
-
-  public LongFieldSource(LongValuesCreator creator) {
-    super(creator);
-  }
-
-  @Override
-  public String description() {
-    return "long(" + field + ')';
-  }
-
-  public long externalToLong(String extVal) {
-    return Long.parseLong(extVal);
-  }
-
-  public Object longToObject(long val) {
-    return val;
-  }
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    final LongValues vals = cache.getLongs(readerContext.reader, field, creator);
-    final long[] arr = vals.values;
-    final Bits valid = vals.valid;
-    
-    return new LongDocValues(this) {
-      @Override
-      public long longVal(int doc) {
-        return arr[doc];
-      }
-
-      @Override
-      public boolean exists(int doc) {
-        return valid.get(doc);
-      }
-
-      @Override
-      public Object objectVal(int doc) {
-        return valid.get(doc) ? longToObject(arr[doc]) : null;
-      }
-
-      @Override
-      public ValueSourceScorer getRangeScorer(IndexReader reader, String lowerVal, String upperVal, boolean includeLower, boolean includeUpper) {
-        long lower,upper;
-
-        // instead of using separate comparison functions, adjust the endpoints.
-
-        if (lowerVal==null) {
-          lower = Long.MIN_VALUE;
-        } else {
-          lower = externalToLong(lowerVal);
-          if (!includeLower && lower < Long.MAX_VALUE) lower++;
-        }
-
-         if (upperVal==null) {
-          upper = Long.MAX_VALUE;
-        } else {
-          upper = externalToLong(upperVal);
-          if (!includeUpper && upper > Long.MIN_VALUE) upper--;
-        }
-
-        final long ll = lower;
-        final long uu = upper;
-
-        return new ValueSourceScorer(reader, this) {
-          @Override
-          public boolean matchesValue(int doc) {
-            long val = arr[doc];
-            // only check for deleted if it's the default value
-            // if (val==0 && reader.isDeleted(doc)) return false;
-            return val >= ll && val <= uu;
-          }
-        };
-      }
-
-      @Override
-      public ValueFiller getValueFiller() {
-        return new ValueFiller() {
-          private final long[] longArr = arr;
-          private final MutableValueLong mval = newMutableValueLong();
-
-          @Override
-          public MutableValue getValue() {
-            return mval;
-          }
-
-          @Override
-          public void fillValue(int doc) {
-            mval.value = longArr[doc];
-            mval.exists = valid.get(doc);
-          }
-        };
-      }
-
-    };
-  }
-
-  protected MutableValueLong newMutableValueLong() {
-    return new MutableValueLong();  
-  }
-
-}
diff --git a/solr/src/java/org/apache/solr/search/function/MaxDocValueSource.java b/solr/src/java/org/apache/solr/search/function/MaxDocValueSource.java
deleted file mode 100755
index 908693f..0000000
--- a/solr/src/java/org/apache/solr/search/function/MaxDocValueSource.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.solr.search.function;
-
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.search.IndexSearcher;
-
-import java.io.IOException;
-import java.util.Map;
-
-public class MaxDocValueSource extends ValueSource {
-  public String name() {
-    return "maxdoc";
-  }
-
-  @Override
-  public String description() {
-    return name() + "()";
-  }
-
-  @Override
-  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
-    context.put("searcher",searcher);
-  }
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    IndexSearcher searcher = (IndexSearcher)context.get("searcher");
-    return new ConstIntDocValues(searcher.maxDoc(), this);
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    return this.getClass() == o.getClass();
-  }
-
-  @Override
-  public int hashCode() {
-    return this.getClass().hashCode();
-  }
-}
diff --git a/solr/src/java/org/apache/solr/search/function/MultiBoolFunction.java b/solr/src/java/org/apache/solr/search/function/MultiBoolFunction.java
deleted file mode 100644
index 002f787..0000000
--- a/solr/src/java/org/apache/solr/search/function/MultiBoolFunction.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.search.IndexSearcher;
-
-import java.io.IOException;
-import java.util.List;
-import java.util.Map;
-
-
-public abstract class MultiBoolFunction extends BoolFunction {
-  protected final List<ValueSource> sources;
-
-  public MultiBoolFunction(List<ValueSource> sources) {
-    this.sources = sources;
-  }
-
-  protected abstract String name();
-
-  protected abstract boolean func(int doc, DocValues[] vals);
-
-  @Override
-  public BoolDocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    final DocValues[] vals =  new DocValues[sources.size()];
-    int i=0;
-    for (ValueSource source : sources) {
-      vals[i++] = source.getValues(context, readerContext);
-    }
-
-    return new BoolDocValues(this) {
-      @Override
-      public boolean boolVal(int doc) {
-	      return func(doc, vals);
-      }
-
-      @Override
-      public String toString(int doc) {
-        StringBuilder sb = new StringBuilder(name());
-        sb.append('(');
-        boolean first = true;
-        for (DocValues dv : vals) {
-          if (first) {
-            first = false;
-          } else {
-            sb.append(',');
-          }
-          sb.append(dv.toString(doc));
-        }
-        return sb.toString();
-      }
-    };
-  }
-
-  @Override
-  public String description() {
-    StringBuilder sb = new StringBuilder(name());
-    sb.append('(');
-    boolean first = true;
-    for (ValueSource source : sources) {
-      if (first) {
-        first = false;
-      } else {
-        sb.append(',');
-      }
-      sb.append(source.description());
-    }
-    return sb.toString();
-  }
-
-  @Override
-  public int hashCode() {
-    return sources.hashCode() + name().hashCode();
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (this.getClass() != o.getClass()) return false;
-    MultiBoolFunction other = (MultiBoolFunction)o;
-    return this.sources.equals(other.sources);
-  }
-
-  @Override
-  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
-    for (ValueSource source : sources) {
-      source.createWeight(context, searcher);
-    }
-  }
-}
\ No newline at end of file
diff --git a/solr/src/java/org/apache/solr/search/function/MultiFloatFunction.java b/solr/src/java/org/apache/solr/search/function/MultiFloatFunction.java
deleted file mode 100644
index 3b93933..0000000
--- a/solr/src/java/org/apache/solr/search/function/MultiFloatFunction.java
+++ /dev/null
@@ -1,109 +0,0 @@
-package org.apache.solr.search.function;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.search.IndexSearcher;
-
-import java.util.Map;
-import java.util.Arrays;
-import java.io.IOException;
-
-
-/**
- *
- *
- **/ // a simple function of multiple sources
-public abstract class MultiFloatFunction extends ValueSource {
-  protected final ValueSource[] sources;
-
-  public MultiFloatFunction(ValueSource[] sources) {
-    this.sources = sources;
-  }
-
-  abstract protected String name();
-  abstract protected float func(int doc, DocValues[] valsArr);
-
-  @Override
-  public String description() {
-    StringBuilder sb = new StringBuilder();
-    sb.append(name()).append('(');
-    boolean firstTime=true;
-    for (ValueSource source : sources) {
-      if (firstTime) {
-        firstTime=false;
-      } else {
-        sb.append(',');
-      }
-      sb.append(source);
-    }
-    sb.append(')');
-    return sb.toString();
-  }
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    final DocValues[] valsArr = new DocValues[sources.length];
-    for (int i=0; i<sources.length; i++) {
-      valsArr[i] = sources[i].getValues(context, readerContext);
-    }
-
-    return new FloatDocValues(this) {
-      @Override
-      public float floatVal(int doc) {
-        return func(doc, valsArr);
-      }
-       @Override
-      public String toString(int doc) {
-        StringBuilder sb = new StringBuilder();
-        sb.append(name()).append('(');
-        boolean firstTime=true;
-        for (DocValues vals : valsArr) {
-          if (firstTime) {
-            firstTime=false;
-          } else {
-            sb.append(',');
-          }
-          sb.append(vals.toString(doc));
-        }
-        sb.append(')');
-        return sb.toString();
-      }
-    };
-  }
-
-  @Override
-  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
-    for (ValueSource source : sources)
-      source.createWeight(context, searcher);
-  }
-
-  @Override
-  public int hashCode() {
-    return Arrays.hashCode(sources) + name().hashCode();
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (this.getClass() != o.getClass()) return false;
-    MultiFloatFunction other = (MultiFloatFunction)o;
-    return this.name().equals(other.name())
-            && Arrays.equals(this.sources, other.sources);
-  }
-}
diff --git a/solr/src/java/org/apache/solr/search/function/MultiFunction.java b/solr/src/java/org/apache/solr/search/function/MultiFunction.java
deleted file mode 100644
index 89b93d6..0000000
--- a/solr/src/java/org/apache/solr/search/function/MultiFunction.java
+++ /dev/null
@@ -1,124 +0,0 @@
-package org.apache.solr.search.function;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.util.BytesRef;
-
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-
-
-public abstract class MultiFunction extends ValueSource {
-  protected final List<ValueSource> sources;
-
-  public MultiFunction(List<ValueSource> sources) {
-    this.sources = sources;
-  }
-
-  abstract protected String name();
-
-  @Override
-  public String description() {
-    return description(name(), sources);
-  }
-
-  public static String description(String name, List<ValueSource> sources) {
-    StringBuilder sb = new StringBuilder();
-    sb.append(name).append('(');
-    boolean firstTime=true;
-    for (ValueSource source : sources) {
-      if (firstTime) {
-        firstTime=false;
-      } else {
-        sb.append(',');
-      }
-      sb.append(source);
-    }
-    sb.append(')');
-    return sb.toString();
-  }
-
-  public static DocValues[] valsArr(List<ValueSource> sources, Map fcontext, AtomicReaderContext readerContext) throws IOException {
-    final DocValues[] valsArr = new DocValues[sources.size()];
-    int i=0;
-    for (ValueSource source : sources) {
-      valsArr[i++] = source.getValues(fcontext, readerContext);
-    }
-    return valsArr;
-  }
-
-  public class Values extends DocValues {
-    final DocValues[] valsArr;
-
-    public Values(DocValues[] valsArr) {
-      this.valsArr = valsArr;
-    }
-
-    @Override
-    public String toString(int doc) {
-      return MultiFunction.toString(name(), valsArr, doc);
-    }
-
-    @Override
-    public ValueFiller getValueFiller() {
-      // TODO: need ValueSource.type() to determine correct type
-      return super.getValueFiller();
-    }
-  }
-
-
-  public static String toString(String name, DocValues[] valsArr, int doc) {
-    StringBuilder sb = new StringBuilder();
-    sb.append(name).append('(');
-    boolean firstTime=true;
-    for (DocValues vals : valsArr) {
-      if (firstTime) {
-        firstTime=false;
-      } else {
-        sb.append(',');
-      }
-      sb.append(vals.toString(doc));
-    }
-    sb.append(')');
-    return sb.toString();
-  }
-
-  @Override
-  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
-    for (ValueSource source : sources)
-      source.createWeight(context, searcher);
-  }
-
-  @Override
-  public int hashCode() {
-    return sources.hashCode() + name().hashCode();
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (this.getClass() != o.getClass()) return false;
-    MultiFunction other = (MultiFunction)o;
-    return this.sources.equals(other.sources);
-  }
-}
-
diff --git a/solr/src/java/org/apache/solr/search/function/MultiValueSource.java b/solr/src/java/org/apache/solr/search/function/MultiValueSource.java
deleted file mode 100644
index ed90b84..0000000
--- a/solr/src/java/org/apache/solr/search/function/MultiValueSource.java
+++ /dev/null
@@ -1,29 +0,0 @@
-package org.apache.solr.search.function;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queries.function.ValueSource;
-
-
-/**
- * A {@link ValueSource} that abstractly represents {@link ValueSource}s for
- * poly fields, and other things.
- **/
-public abstract class MultiValueSource extends ValueSource {
-
-  public abstract int dimension();
-}
diff --git a/solr/src/java/org/apache/solr/search/function/NormValueSource.java b/solr/src/java/org/apache/solr/search/function/NormValueSource.java
deleted file mode 100755
index 8e44de7..0000000
--- a/solr/src/java/org/apache/solr/search/function/NormValueSource.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Similarity;
-import java.io.IOException;
-import java.util.Map;
-
-public class NormValueSource extends ValueSource {
-  protected String field;
-  public NormValueSource(String field) {
-    this.field = field;
-  }
-
-  public String name() {
-    return "norm";
-  }
-
-  @Override
-  public String description() {
-    return name() + '(' + field + ')';
-  }
-
-  @Override
-  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
-    context.put("searcher",searcher);
-  }
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    IndexSearcher searcher = (IndexSearcher)context.get("searcher");
-    final Similarity similarity = searcher.getSimilarityProvider().get(field);
-    final byte[] norms = readerContext.reader.norms(field);
-    if (norms == null) {
-      return new ConstDoubleDocValues(0.0, this);
-    }
-
-    return new FloatDocValues(this) {
-      @Override
-      public float floatVal(int doc) {
-        return similarity.decodeNormValue(norms[doc]);
-      }
-    };
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (this.getClass() != o.getClass()) return false;
-    return this.field.equals(((NormValueSource)o).field);
-  }
-
-  @Override
-  public int hashCode() {
-    return this.getClass().hashCode() + field.hashCode();
-  }
-}
-
-
diff --git a/solr/src/java/org/apache/solr/search/function/NumDocsValueSource.java b/solr/src/java/org/apache/solr/search/function/NumDocsValueSource.java
deleted file mode 100755
index cb5cbc8..0000000
--- a/solr/src/java/org/apache/solr/search/function/NumDocsValueSource.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.solr.search.function;
-
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.util.ReaderUtil;
-
-import java.io.IOException;
-import java.util.Map;
-
-public class NumDocsValueSource extends ValueSource {
-  public String name() {
-    return "numdocs";
-  }
-
-  @Override
-  public String description() {
-    return name() + "()";
-  }
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    // Searcher has no numdocs so we must use the reader instead
-    return new ConstIntDocValues(ReaderUtil.getTopLevelContext(readerContext).reader.numDocs(), this);
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    return this.getClass() == o.getClass();
-  }
-
-  @Override
-  public int hashCode() {
-    return this.getClass().hashCode();
-  }
-}
diff --git a/solr/src/java/org/apache/solr/search/function/NumericFieldCacheSource.java b/solr/src/java/org/apache/solr/search/function/NumericFieldCacheSource.java
deleted file mode 100644
index f7fde5c..0000000
--- a/solr/src/java/org/apache/solr/search/function/NumericFieldCacheSource.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.search.cache.CachedArray;
-import org.apache.lucene.search.cache.CachedArrayCreator;
-
-/**
- * 
- *
- */
-public abstract class NumericFieldCacheSource<T extends CachedArray> extends FieldCacheSource {
-  protected final CachedArrayCreator<T> creator;
-
-  public NumericFieldCacheSource( CachedArrayCreator<T> creator ) {
-    super( creator.field );
-    this.creator = creator;
-  }
-
-  @Override
-  public final boolean equals(Object o) {
-    if (o.getClass() != this.getClass()) return false;
-    NumericFieldCacheSource other = (NumericFieldCacheSource) o;
-    return super.equals(other)
-            && this.creator == null ? other.creator == null :
-            this.creator.getClass() == other.creator.getClass();
-  }
-
-  @Override
-  public final int hashCode() {
-    int h = creator == null ? this.getClass().hashCode() : creator.getClass().hashCode();
-    h += super.hashCode();
-    return h;
-  }
-}
diff --git a/solr/src/java/org/apache/solr/search/function/OrdFieldSource.java b/solr/src/java/org/apache/solr/search/function/OrdFieldSource.java
deleted file mode 100644
index 9b54f6d..0000000
--- a/solr/src/java/org/apache/solr/search/function/OrdFieldSource.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.common.mutable.MutableValue;
-import org.apache.lucene.common.mutable.MutableValueInt;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.search.FieldCache;
-import org.apache.lucene.util.ReaderUtil;
-
-import java.io.IOException;
-import java.util.Map;
-
-/**
- * Obtains the ordinal of the field value from the default Lucene {@link org.apache.lucene.search.FieldCache} using getStringIndex().
- * <br>
- * The native lucene index order is used to assign an ordinal value for each field value.
- * <br>Field values (terms) are lexicographically ordered by unicode value, and numbered starting at 1.
- * <br>
- * Example:<br>
- *  If there were only three field values: "apple","banana","pear"
- * <br>then ord("apple")=1, ord("banana")=2, ord("pear")=3
- * <p>
- * WARNING: ord() depends on the position in an index and can thus change when other documents are inserted or deleted,
- *  or if a MultiSearcher is used.
- * <br>WARNING: as of Solr 1.4, ord() and rord() can cause excess memory use since they must use a FieldCache entry
- * at the top level reader, while sorting and function queries now use entries at the segment level.  Hence sorting
- * or using a different function query, in addition to ord()/rord() will double memory use.
- *
- */
-
-public class OrdFieldSource extends ValueSource {
-  protected String field;
-
-  public OrdFieldSource(String field) {
-    this.field = field;
-  }
-
-  @Override
-  public String description() {
-    return "ord(" + field + ')';
-  }
-
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    final int off = readerContext.docBase;
-    final IndexReader topReader = ReaderUtil.getTopLevelContext(readerContext).reader;
-    final FieldCache.DocTermsIndex sindex = FieldCache.DEFAULT.getTermsIndex(topReader, field);
-    return new IntDocValues(this) {
-      protected String toTerm(String readableValue) {
-        return readableValue;
-      }
-      @Override
-      public int intVal(int doc) {
-        return sindex.getOrd(doc+off);
-      }
-      @Override
-      public int ordVal(int doc) {
-        return sindex.getOrd(doc+off);
-      }
-      @Override
-      public int numOrd() {
-        return sindex.numOrd();
-      }
-
-      @Override
-      public boolean exists(int doc) {
-        return sindex.getOrd(doc+off) != 0;
-      }
-
-      @Override
-      public ValueFiller getValueFiller() {
-        return new ValueFiller() {
-          private final MutableValueInt mval = new MutableValueInt();
-
-          @Override
-          public MutableValue getValue() {
-            return mval;
-          }
-
-          @Override
-          public void fillValue(int doc) {
-            mval.value = sindex.getOrd(doc);
-            mval.exists = mval.value!=0;
-          }
-        };
-      }
-    };
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    return o.getClass() == OrdFieldSource.class && this.field.equals(((OrdFieldSource)o).field);
-  }
-
-  private static final int hcode = OrdFieldSource.class.hashCode();
-  @Override
-  public int hashCode() {
-    return hcode + field.hashCode();
-  };
-
-}
diff --git a/solr/src/java/org/apache/solr/search/function/PowFloatFunction.java b/solr/src/java/org/apache/solr/search/function/PowFloatFunction.java
deleted file mode 100755
index c9acfb6..0000000
--- a/solr/src/java/org/apache/solr/search/function/PowFloatFunction.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-
-/** Function to raise the base "a" to the power "b"
- */
-public class PowFloatFunction extends DualFloatFunction {
- /**
-   * @param   a  the base.
-   * @param   b  the exponent.
-   */
-  public PowFloatFunction(ValueSource a, ValueSource b) {
-    super(a,b);
-  }
-
-  @Override
-  protected String name() {
-    return "pow";
-  }
-
-  @Override
-  protected float func(int doc, DocValues aVals, DocValues bVals) {
-    return (float)Math.pow(aVals.floatVal(doc), bVals.floatVal(doc));
-  }
-}
-
-
diff --git a/solr/src/java/org/apache/solr/search/function/ProductFloatFunction.java b/solr/src/java/org/apache/solr/search/function/ProductFloatFunction.java
deleted file mode 100755
index 1d831bb..0000000
--- a/solr/src/java/org/apache/solr/search/function/ProductFloatFunction.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-
-/**
- * <code>ProductFloatFunction</code> returns the product of it's components.
- */
-public class ProductFloatFunction extends MultiFloatFunction {
-  public ProductFloatFunction(ValueSource[] sources) {
-    super(sources);
-  }
-
-  @Override
-  protected String name() {
-    return "product";
-  }
-
-  @Override
-  protected float func(int doc, DocValues[] valsArr) {
-    float val = 1.0f;
-    for (DocValues vals : valsArr) {
-      val *= vals.floatVal(doc);
-    }
-    return val;
-  }
-}
diff --git a/solr/src/java/org/apache/solr/search/function/QueryValueSource.java b/solr/src/java/org/apache/solr/search/function/QueryValueSource.java
deleted file mode 100755
index dff0d03..0000000
--- a/solr/src/java/org/apache/solr/search/function/QueryValueSource.java
+++ /dev/null
@@ -1,251 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.common.mutable.MutableValue;
-import org.apache.lucene.common.mutable.MutableValueFloat;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.search.*;
-import org.apache.lucene.search.Weight.ScorerContext;
-import org.apache.lucene.util.ReaderUtil;
-import org.apache.solr.common.SolrException;
-
-import java.io.IOException;
-import java.util.Map;
-
-/**
- * <code>QueryValueSource</code> returns the relevance score of the query
- */
-public class QueryValueSource extends ValueSource {
-  final Query q;
-  final float defVal;
-
-  public QueryValueSource(Query q, float defVal) {
-    this.q = q;
-    this.defVal = defVal;
-  }
-
-  public Query getQuery() { return q; }
-  public float getDefaultValue() { return defVal; }
-
-  @Override
-  public String description() {
-    return "query(" + q + ",def=" + defVal + ")";
-  }
-
-  @Override
-  public DocValues getValues(Map fcontext, AtomicReaderContext readerContext) throws IOException {
-    return new QueryDocValues(this, readerContext, fcontext);
-  }
-
-  @Override
-  public int hashCode() {
-    return q.hashCode() * 29;
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (QueryValueSource.class != o.getClass()) return false;
-    QueryValueSource other = (QueryValueSource)o;
-    return this.q.equals(other.q) && this.defVal==other.defVal;
-  }
-
-  @Override
-  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
-    Weight w = searcher.createNormalizedWeight(q);
-    context.put(this, w);
-  }
-}
-
-
-class QueryDocValues extends FloatDocValues {
-  final AtomicReaderContext readerContext;
-  final Weight weight;
-  final float defVal;
-  final Map fcontext;
-  final Query q;
-
-  Scorer scorer;
-  int scorerDoc; // the document the scorer is on
-  boolean noMatches=false;
-
-  // the last document requested... start off with high value
-  // to trigger a scorer reset on first access.
-  int lastDocRequested=Integer.MAX_VALUE;
-  
-
-  public QueryDocValues(QueryValueSource vs, AtomicReaderContext readerContext, Map fcontext) throws IOException {
-    super(vs);
-
-    this.readerContext = readerContext;
-    this.defVal = vs.defVal;
-    this.q = vs.q;
-    this.fcontext = fcontext;
-
-    Weight w = fcontext==null ? null : (Weight)fcontext.get(vs);
-    if (w == null) {
-      IndexSearcher weightSearcher;
-      if(fcontext == null) {
-        weightSearcher = new IndexSearcher(ReaderUtil.getTopLevelContext(readerContext));
-      } else {
-        weightSearcher = (IndexSearcher)fcontext.get("searcher");
-        if (weightSearcher == null) {
-          weightSearcher = new IndexSearcher(ReaderUtil.getTopLevelContext(readerContext));
-        }
-      }
-      vs.createWeight(fcontext, weightSearcher);
-      w = (Weight)fcontext.get(vs);
-    }
-    weight = w;
-  }
-
-  @Override
-  public float floatVal(int doc) {
-    try {
-      if (doc < lastDocRequested) {
-        if (noMatches) return defVal;
-        scorer = weight.scorer(readerContext, ScorerContext.def());
-        if (scorer==null) {
-          noMatches = true;
-          return defVal;
-        }
-        scorerDoc = -1;
-      }
-      lastDocRequested = doc;
-
-      if (scorerDoc < doc) {
-        scorerDoc = scorer.advance(doc);
-      }
-
-      if (scorerDoc > doc) {
-        // query doesn't match this document... either because we hit the
-        // end, or because the next doc is after this doc.
-        return defVal;
-      }
-
-      // a match!
-      return scorer.score();
-    } catch (IOException e) {
-      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "caught exception in QueryDocVals("+q+") doc="+doc, e);
-    }
-  }
-
-  @Override
-  public boolean exists(int doc) {
-    try {
-      if (doc < lastDocRequested) {
-        if (noMatches) return false;
-        scorer = weight.scorer(readerContext, ScorerContext.def());
-        scorerDoc = -1;
-        if (scorer==null) {
-          noMatches = true;
-          return false;
-        }
-      }
-      lastDocRequested = doc;
-
-      if (scorerDoc < doc) {
-        scorerDoc = scorer.advance(doc);
-      }
-
-      if (scorerDoc > doc) {
-        // query doesn't match this document... either because we hit the
-        // end, or because the next doc is after this doc.
-        return false;
-      }
-
-      // a match!
-      return true;
-    } catch (IOException e) {
-      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "caught exception in QueryDocVals("+q+") doc="+doc, e);
-    }
-  }
-
-   @Override
-  public Object objectVal(int doc) {
-     try {
-       return exists(doc) ? scorer.score() : null;
-     } catch (IOException e) {
-       throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "caught exception in QueryDocVals("+q+") doc="+doc, e);
-     }
-   }
-
-  @Override
-  public ValueFiller getValueFiller() {
-    //
-    // TODO: if we want to support more than one value-filler or a value-filler in conjunction with
-    // the DocValues, then members like "scorer" should be per ValueFiller instance.
-    // Or we can say that the user should just instantiate multiple DocValues.
-    //
-    return new ValueFiller() {
-      private final MutableValueFloat mval = new MutableValueFloat();
-
-      @Override
-      public MutableValue getValue() {
-        return mval;
-      }
-
-      @Override
-      public void fillValue(int doc) {
-        try {
-          if (noMatches) {
-            mval.value = defVal;
-            mval.exists = false;
-            return;
-          }
-          scorer = weight.scorer(readerContext, ScorerContext.def());
-          scorerDoc = -1;
-          if (scorer==null) {
-            noMatches = true;
-            mval.value = defVal;
-            mval.exists = false;
-            return;
-          }
-          lastDocRequested = doc;
-
-          if (scorerDoc < doc) {
-            scorerDoc = scorer.advance(doc);
-          }
-
-          if (scorerDoc > doc) {
-            // query doesn't match this document... either because we hit the
-            // end, or because the next doc is after this doc.
-            mval.value = defVal;
-            mval.exists = false;
-            return;
-          }
-
-          // a match!
-          mval.value = scorer.score();
-          mval.exists = true;
-          return;
-        } catch (IOException e) {
-          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "caught exception in QueryDocVals("+q+") doc="+doc, e);
-        }
-      }
-    };
-  }
-
-  @Override
-  public String toString(int doc) {
-    return "query(" + q + ",def=" + defVal + ")=" + floatVal(doc);
-  }
-}
\ No newline at end of file
diff --git a/solr/src/java/org/apache/solr/search/function/RangeMapFloatFunction.java b/solr/src/java/org/apache/solr/search/function/RangeMapFloatFunction.java
deleted file mode 100755
index 3217be1..0000000
--- a/solr/src/java/org/apache/solr/search/function/RangeMapFloatFunction.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.search.IndexSearcher;
-
-import java.io.IOException;
-import java.util.Map;
-
-/**
- * <code>LinearFloatFunction</code> implements a linear function over
- * another {@link org.apache.lucene.queries.function.ValueSource}.
- * <br>
- * Normally Used as an argument to a {@link org.apache.lucene.queries.function.FunctionQuery}
- *
- *
- */
-public class RangeMapFloatFunction extends ValueSource {
-  protected final ValueSource source;
-  protected final float min;
-  protected final float max;
-  protected final float target;
-  protected final Float defaultVal;
-
-  public RangeMapFloatFunction(ValueSource source, float min, float max, float target, Float def) {
-    this.source = source;
-    this.min = min;
-    this.max = max;
-    this.target = target;
-    this.defaultVal = def;
-  }
-
-  @Override
-  public String description() {
-    return "map(" + source.description() + "," + min + "," + max + "," + target + ")";
-  }
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    final DocValues vals =  source.getValues(context, readerContext);
-    return new FloatDocValues(this) {
-      @Override
-      public float floatVal(int doc) {
-        float val = vals.floatVal(doc);
-        return (val>=min && val<=max) ? target : (defaultVal == null ? val : defaultVal);
-      }
-      @Override
-      public String toString(int doc) {
-        return "map(" + vals.toString(doc) + ",min=" + min + ",max=" + max + ",target=" + target + ")";
-      }
-    };
-  }
-
-  @Override
-  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
-    source.createWeight(context, searcher);
-  }
-
-  @Override
-  public int hashCode() {
-    int h = source.hashCode();
-    h ^= (h << 10) | (h >>> 23);
-    h += Float.floatToIntBits(min);
-    h ^= (h << 14) | (h >>> 19);
-    h += Float.floatToIntBits(max);
-    h ^= (h << 13) | (h >>> 20);
-    h += Float.floatToIntBits(target);
-    if (defaultVal != null)
-      h += defaultVal.hashCode();
-    return h;
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (RangeMapFloatFunction.class != o.getClass()) return false;
-    RangeMapFloatFunction other = (RangeMapFloatFunction)o;
-    return  this.min == other.min
-         && this.max == other.max
-         && this.target == other.target
-         && this.source.equals(other.source)
-         && (this.defaultVal == other.defaultVal || (this.defaultVal != null && this.defaultVal.equals(other.defaultVal)));
-  }
-}
diff --git a/solr/src/java/org/apache/solr/search/function/ReciprocalFloatFunction.java b/solr/src/java/org/apache/solr/search/function/ReciprocalFloatFunction.java
deleted file mode 100644
index 9e64037..0000000
--- a/solr/src/java/org/apache/solr/search/function/ReciprocalFloatFunction.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.search.IndexSearcher;
-
-import java.io.IOException;
-import java.util.Map;
-
-/**
- * <code>ReciprocalFloatFunction</code> implements a reciprocal function f(x) = a/(mx+b), based on
- * the float value of a field or function as exported by {@link org.apache.lucene.queries.function.ValueSource}.
- * <br>
- *
- * When a and b are equal, and x>=0, this function has a maximum value of 1 that drops as x increases.
- * Increasing the value of a and b together results in a movement of the entire function to a flatter part of the curve.
- * <p>These properties make this an idea function for boosting more recent documents.
- * <p>Example:<code>  recip(ms(NOW,mydatefield),3.16e-11,1,1)</code>
- * <p>A multiplier of 3.16e-11 changes the units from milliseconds to years (since there are about 3.16e10 milliseconds
- * per year).  Thus, a very recent date will yield a value close to 1/(0+1) or 1,
- * a date a year in the past will get a multiplier of about 1/(1+1) or 1/2,
- * and date two years old will yield 1/(2+1) or 1/3.
- *
- * @see org.apache.lucene.queries.function.FunctionQuery
- *
- *
- */
-public class ReciprocalFloatFunction extends ValueSource {
-  protected final ValueSource source;
-  protected final float m;
-  protected final float a;
-  protected final float b;
-
-  /**
-   *  f(source) = a/(m*float(source)+b)
-   */
-  public ReciprocalFloatFunction(ValueSource source, float m, float a, float b) {
-    this.source=source;
-    this.m=m;
-    this.a=a;
-    this.b=b;
-  }
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    final DocValues vals = source.getValues(context, readerContext);
-    return new FloatDocValues(this) {
-      @Override
-      public float floatVal(int doc) {
-        return a/(m*vals.floatVal(doc) + b);
-      }
-      @Override
-      public String toString(int doc) {
-        return Float.toString(a) + "/("
-                + m + "*float(" + vals.toString(doc) + ')'
-                + '+' + b + ')';
-      }
-    };
-  }
-
-  @Override
-  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
-    source.createWeight(context, searcher);
-  }
-
-  @Override
-  public String description() {
-    return Float.toString(a) + "/("
-           + m + "*float(" + source.description() + ")"
-           + "+" + b + ')';
-  }
-
-  @Override
-  public int hashCode() {
-    int h = Float.floatToIntBits(a) + Float.floatToIntBits(m);
-    h ^= (h << 13) | (h >>> 20);
-    return h + (Float.floatToIntBits(b)) + source.hashCode();
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (ReciprocalFloatFunction.class != o.getClass()) return false;
-    ReciprocalFloatFunction other = (ReciprocalFloatFunction)o;
-    return this.m == other.m
-            && this.a == other.a
-            && this.b == other.b
-            && this.source.equals(other.source);
-  }
-}
diff --git a/solr/src/java/org/apache/solr/search/function/ReverseOrdFieldSource.java b/solr/src/java/org/apache/solr/search/function/ReverseOrdFieldSource.java
deleted file mode 100644
index 33b391c..0000000
--- a/solr/src/java/org/apache/solr/search/function/ReverseOrdFieldSource.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.search.FieldCache;
-import org.apache.lucene.util.ReaderUtil;
-
-import java.io.IOException;
-import java.util.Map;
-
-/**
- * Obtains the ordinal of the field value from the default Lucene {@link org.apache.lucene.search.FieldCache} using getTermsIndex()
- * and reverses the order.
- * <br>
- * The native lucene index order is used to assign an ordinal value for each field value.
- * <br>Field values (terms) are lexicographically ordered by unicode value, and numbered starting at 1.
- * <br>
- * Example of reverse ordinal (rord):<br>
- *  If there were only three field values: "apple","banana","pear"
- * <br>then rord("apple")=3, rord("banana")=2, ord("pear")=1
- * <p>
- *  WARNING: ord() depends on the position in an index and can thus change when other documents are inserted or deleted,
- *  or if a MultiSearcher is used.
- * <br>
- *  WARNING: as of Solr 1.4, ord() and rord() can cause excess memory use since they must use a FieldCache entry
- * at the top level reader, while sorting and function queries now use entries at the segment level.  Hence sorting
- * or using a different function query, in addition to ord()/rord() will double memory use.
- * 
- *
- */
-
-public class ReverseOrdFieldSource extends ValueSource {
-  public String field;
-
-  public ReverseOrdFieldSource(String field) {
-    this.field = field;
-  }
-
-  @Override
-  public String description() {
-    return "rord("+field+')';
-  }
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    final IndexReader topReader = ReaderUtil.getTopLevelContext(readerContext).reader;
-    final int off = readerContext.docBase;
-
-    final FieldCache.DocTermsIndex sindex = FieldCache.DEFAULT.getTermsIndex(topReader, field);
-    final int end = sindex.numOrd();
-
-    return new IntDocValues(this) {
-     @Override
-      public int intVal(int doc) {
-        return (end - sindex.getOrd(doc+off));
-      }
-    };
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (o.getClass() !=  ReverseOrdFieldSource.class) return false;
-    ReverseOrdFieldSource other = (ReverseOrdFieldSource)o;
-    return this.field.equals(other.field);
-  }
-
-  private static final int hcode = ReverseOrdFieldSource.class.hashCode();
-  @Override
-  public int hashCode() {
-    return hcode + field.hashCode();
-  };
-
-}
diff --git a/solr/src/java/org/apache/solr/search/function/ScaleFloatFunction.java b/solr/src/java/org/apache/solr/search/function/ScaleFloatFunction.java
deleted file mode 100755
index 1d5ef6c..0000000
--- a/solr/src/java/org/apache/solr/search/function/ScaleFloatFunction.java
+++ /dev/null
@@ -1,151 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.util.ReaderUtil;
-
-import java.io.IOException;
-import java.util.Map;
-
-/**
- * Scales values to be between min and max.
- * <p>This implementation currently traverses all of the source values to obtain
- * their min and max.
- * <p>This implementation currently cannot distinguish when documents have been
- * deleted or documents that have no value, and 0.0 values will be used for
- * these cases.  This means that if values are normally all greater than 0.0, one can
- * still end up with 0.0 as the min value to map from.  In these cases, an
- * appropriate map() function could be used as a workaround to change 0.0
- * to a value in the real range.
- */
-public class ScaleFloatFunction extends ValueSource {
-  protected final ValueSource source;
-  protected final float min;
-  protected final float max;
-
-  public ScaleFloatFunction(ValueSource source, float min, float max) {
-    this.source = source;
-    this.min = min;
-    this.max = max;
-  }
-
-  @Override
-  public String description() {
-    return "scale(" + source.description() + "," + min + "," + max + ")";
-  }
-
-  private static class ScaleInfo {
-    float minVal;
-    float maxVal;
-  }
-
-  private ScaleInfo createScaleInfo(Map context, AtomicReaderContext readerContext) throws IOException {
-    final AtomicReaderContext[] leaves = ReaderUtil.leaves(ReaderUtil.getTopLevelContext(readerContext));
-
-    float minVal = Float.POSITIVE_INFINITY;
-    float maxVal = Float.NEGATIVE_INFINITY;
-
-    for (AtomicReaderContext leaf : leaves) {
-      int maxDoc = leaf.reader.maxDoc();
-      DocValues vals =  source.getValues(context, leaf);
-      for (int i=0; i<maxDoc; i++) {
-
-      float val = vals.floatVal(i);
-      if ((Float.floatToRawIntBits(val) & (0xff<<23)) == 0xff<<23) {
-        // if the exponent in the float is all ones, then this is +Inf, -Inf or NaN
-        // which don't make sense to factor into the scale function
-        continue;
-      }
-      if (val < minVal) {
-        minVal = val;
-      }
-      if (val > maxVal) {
-        maxVal = val;
-      }
-    }
-    }
-
-    if (minVal == Float.POSITIVE_INFINITY) {
-    // must have been an empty index
-      minVal = maxVal = 0;
-    }
-
-    ScaleInfo scaleInfo = new ScaleInfo();
-    scaleInfo.minVal = minVal;
-    scaleInfo.maxVal = maxVal;
-    context.put(this.source, scaleInfo);
-    return scaleInfo;
-  }
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-
-    ScaleInfo scaleInfo = (ScaleInfo)context.get(source);
-    if (scaleInfo == null) {
-      scaleInfo = createScaleInfo(context, readerContext);
-    }
-
-    final float scale = (scaleInfo.maxVal-scaleInfo.minVal==0) ? 0 : (max-min)/(scaleInfo.maxVal-scaleInfo.minVal);
-    final float minSource = scaleInfo.minVal;
-    final float maxSource = scaleInfo.maxVal;
-
-    final DocValues vals =  source.getValues(context, readerContext);
-
-    return new FloatDocValues(this) {
-      @Override
-      public float floatVal(int doc) {
-	return (vals.floatVal(doc) - minSource) * scale + min;
-      }
-      @Override
-      public String toString(int doc) {
-	return "scale(" + vals.toString(doc) + ",toMin=" + min + ",toMax=" + max
-                + ",fromMin=" + minSource
-                + ",fromMax=" + maxSource
-                + ")";
-      }
-    };
-  }
-
-  @Override
-  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
-    source.createWeight(context, searcher);
-  }
-
-  @Override
-  public int hashCode() {
-    int h = Float.floatToIntBits(min);
-    h = h*29;
-    h += Float.floatToIntBits(max);
-    h = h*29;
-    h += source.hashCode();
-    return h;
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (ScaleFloatFunction.class != o.getClass()) return false;
-    ScaleFloatFunction other = (ScaleFloatFunction)o;
-    return this.min == other.min
-         && this.max == other.max
-         && this.source.equals(other.source);
-  }
-}
diff --git a/solr/src/java/org/apache/solr/search/function/ShortFieldSource.java b/solr/src/java/org/apache/solr/search/function/ShortFieldSource.java
deleted file mode 100644
index 51934ef..0000000
--- a/solr/src/java/org/apache/solr/search/function/ShortFieldSource.java
+++ /dev/null
@@ -1,92 +0,0 @@
-package org.apache.solr.search.function;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.search.cache.ShortValuesCreator;
-import org.apache.lucene.search.cache.CachedArray.ShortValues;
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-
-import java.io.IOException;
-import java.util.Map;
-
-
-/**
- *
- *
- **/
-public class ShortFieldSource extends NumericFieldCacheSource<ShortValues> {
-
-  public ShortFieldSource(ShortValuesCreator creator) {
-    super(creator);
-  }
-
-
-  @Override
-  public String description() {
-    return "short(" + field + ')';
-  }
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    final ShortValues vals = cache.getShorts(readerContext.reader, field, creator);
-    final short[] arr = vals.values;
-    
-    return new DocValues() {
-      @Override
-      public byte byteVal(int doc) {
-        return (byte) arr[doc];
-      }
-
-      @Override
-      public short shortVal(int doc) {
-        return arr[doc];
-      }
-
-      @Override
-      public float floatVal(int doc) {
-        return (float) arr[doc];
-      }
-
-      @Override
-      public int intVal(int doc) {
-        return (int) arr[doc];
-      }
-
-      @Override
-      public long longVal(int doc) {
-        return (long) arr[doc];
-      }
-
-      @Override
-      public double doubleVal(int doc) {
-        return (double) arr[doc];
-      }
-
-      @Override
-      public String strVal(int doc) {
-        return Short.toString(arr[doc]);
-      }
-
-      @Override
-      public String toString(int doc) {
-        return description() + '=' + shortVal(doc);
-      }
-
-    };
-  }
-}
diff --git a/solr/src/java/org/apache/solr/search/function/SimpleBoolFunction.java b/solr/src/java/org/apache/solr/search/function/SimpleBoolFunction.java
deleted file mode 100644
index cc1f22d..0000000
--- a/solr/src/java/org/apache/solr/search/function/SimpleBoolFunction.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.search.IndexSearcher;
-
-import java.io.IOException;
-import java.util.Map;
-
-
-public abstract class SimpleBoolFunction extends BoolFunction {
-  protected final ValueSource source;
-
-  public SimpleBoolFunction(ValueSource source) {
-    this.source = source;
-  }
-
-  protected abstract String name();
-
-  protected abstract boolean func(int doc, DocValues vals);
-
-  @Override
-  public BoolDocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    final DocValues vals =  source.getValues(context, readerContext);
-    return new BoolDocValues(this) {
-      @Override
-      public boolean boolVal(int doc) {
-	      return func(doc, vals);
-      }
-      @Override
-      public String toString(int doc) {
-	      return name() + '(' + vals.toString(doc) + ')';
-      }
-    };
-  }
-
-  @Override
-  public String description() {
-    return name() + '(' + source.description() + ')';
-  }
-
-  @Override
-  public int hashCode() {
-    return source.hashCode() + name().hashCode();
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (this.getClass() != o.getClass()) return false;
-    SimpleBoolFunction other = (SimpleBoolFunction)o;
-    return this.source.equals(other.source);
-  }
-
-  @Override
-  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
-    source.createWeight(context, searcher);
-  }
-}
\ No newline at end of file
diff --git a/solr/src/java/org/apache/solr/search/function/SimpleFloatFunction.java b/solr/src/java/org/apache/solr/search/function/SimpleFloatFunction.java
deleted file mode 100755
index 080f3e5..0000000
--- a/solr/src/java/org/apache/solr/search/function/SimpleFloatFunction.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-
-import java.io.IOException;
-import java.util.Map;
-
-/** A simple float function with a single argument
- */
- public abstract class SimpleFloatFunction extends SingleFunction {
-  public SimpleFloatFunction(ValueSource source) {
-    super(source);
-  }
-
-  protected abstract float func(int doc, DocValues vals);
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    final DocValues vals =  source.getValues(context, readerContext);
-    return new FloatDocValues(this) {
-      @Override
-      public float floatVal(int doc) {
-	return func(doc, vals);
-      }
-      @Override
-      public String toString(int doc) {
-	return name() + '(' + vals.toString(doc) + ')';
-      }
-    };
-  }
-}
diff --git a/solr/src/java/org/apache/solr/search/function/SingleFunction.java b/solr/src/java/org/apache/solr/search/function/SingleFunction.java
deleted file mode 100755
index 860d8a3..0000000
--- a/solr/src/java/org/apache/solr/search/function/SingleFunction.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.search.IndexSearcher;
-
-import java.io.IOException;
-import java.util.Map;
-
-/** A function with a single argument
- */
- public abstract class SingleFunction extends ValueSource {
-  protected final ValueSource source;
-
-  public SingleFunction(ValueSource source) {
-    this.source = source;
-  }
-
-  protected abstract String name();
-
-  @Override
-  public String description() {
-    return name() + '(' + source.description() + ')';
-  }
-
-  @Override
-  public int hashCode() {
-    return source.hashCode() + name().hashCode();
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (this.getClass() != o.getClass()) return false;
-    SingleFunction other = (SingleFunction)o;
-    return this.name().equals(other.name())
-         && this.source.equals(other.source);
-  }
-
-  @Override
-  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
-    source.createWeight(context, searcher);
-  }
-}
\ No newline at end of file
diff --git a/solr/src/java/org/apache/solr/search/function/StrDocValues.java b/solr/src/java/org/apache/solr/search/function/StrDocValues.java
deleted file mode 100644
index 556b403..0000000
--- a/solr/src/java/org/apache/solr/search/function/StrDocValues.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package org.apache.solr.search.function;
-
-import org.apache.lucene.common.mutable.MutableValue;
-import org.apache.lucene.common.mutable.MutableValueStr;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.util.BytesRef;
-
-public abstract class StrDocValues extends DocValues {
-  protected final ValueSource vs;
-
-  public StrDocValues(ValueSource vs) {
-    this.vs = vs;
-  }
-
-  @Override
-  public abstract String strVal(int doc);
-
-  @Override
-  public Object objectVal(int doc) {
-    return exists(doc) ? strVal(doc) : null;
-  }
-
-  @Override
-  public boolean boolVal(int doc) {
-    return exists(doc);
-  }
-
-  @Override
-  public String toString(int doc) {
-    return vs.description() + "='" + strVal(doc) + "'";
-  }
-
-  @Override
-  public ValueFiller getValueFiller() {
-    return new ValueFiller() {
-      private final MutableValueStr mval = new MutableValueStr();
-
-      @Override
-      public MutableValue getValue() {
-        return mval;
-      }
-
-      @Override
-      public void fillValue(int doc) {
-        mval.exists = bytesVal(doc, mval.value);
-      }
-    };
-  }
-}
diff --git a/solr/src/java/org/apache/solr/search/function/StringIndexDocValues.java b/solr/src/java/org/apache/solr/search/function/StringIndexDocValues.java
deleted file mode 100755
index 3051775..0000000
--- a/solr/src/java/org/apache/solr/search/function/StringIndexDocValues.java
+++ /dev/null
@@ -1,165 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.common.mutable.MutableValue;
-import org.apache.lucene.common.mutable.MutableValueStr;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.queries.function.ValueSourceScorer;
-import org.apache.lucene.search.FieldCache;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CharsRef;
-
-import java.io.IOException;
-
-/** Internal class, subject to change.
- *  Serves as base class for DocValues based on StringIndex 
- **/
-public abstract class StringIndexDocValues extends DocValues {
-  protected final FieldCache.DocTermsIndex termsIndex;
-  protected final ValueSource vs;
-  protected final MutableValueStr val = new MutableValueStr();
-  protected final BytesRef spare = new BytesRef();
-  protected final CharsRef spareChars = new CharsRef();
-
-  public StringIndexDocValues(ValueSource vs, AtomicReaderContext context, String field) throws IOException {
-    try {
-      termsIndex = FieldCache.DEFAULT.getTermsIndex(context.reader, field);
-    } catch (RuntimeException e) {
-      throw new StringIndexException(field, e);
-    }
-    this.vs = vs;
-  }
-
-  public FieldCache.DocTermsIndex getDocTermsIndex() {
-    return termsIndex;
-  }
-
-  protected abstract String toTerm(String readableValue);
-
-  @Override
-  public boolean exists(int doc) {
-    return termsIndex.getOrd(doc) != 0;
-  }
-
-
-  @Override
-  public boolean bytesVal(int doc, BytesRef target) {
-    int ord=termsIndex.getOrd(doc);
-    if (ord==0) {
-      target.length = 0;
-      return false;
-    }
-    termsIndex.lookup(ord, target);
-    return true;
-  }
-
-  @Override
-  public String strVal(int doc) {
-    int ord=termsIndex.getOrd(doc);
-    if (ord==0) return null;
-    termsIndex.lookup(ord, spare);
-    spare.utf8ToChars(spareChars);
-    return spareChars.toString();
-  }
-
-  @Override
-  public boolean boolVal(int doc) {
-    return exists(doc);
-  }
-
-  @Override
-  public abstract Object objectVal(int doc);  // force subclasses to override
-
-  @Override
-  public ValueSourceScorer getRangeScorer(IndexReader reader, String lowerVal, String upperVal, boolean includeLower, boolean includeUpper) {
-    // TODO: are lowerVal and upperVal in indexed form or not?
-    lowerVal = lowerVal == null ? null : toTerm(lowerVal);
-    upperVal = upperVal == null ? null : toTerm(upperVal);
-
-    final BytesRef spare = new BytesRef();
-
-    int lower = Integer.MIN_VALUE;
-    if (lowerVal != null) {
-      lower = termsIndex.binarySearchLookup(new BytesRef(lowerVal), spare);
-      if (lower < 0) {
-        lower = -lower-1;
-      } else if (!includeLower) {
-        lower++;
-      }
-    }
-
-    int upper = Integer.MAX_VALUE;
-    if (upperVal != null) {
-      upper = termsIndex.binarySearchLookup(new BytesRef(upperVal), spare);
-      if (upper < 0) {
-        upper = -upper-2;
-      } else if (!includeUpper) {
-        upper--;
-      }
-    }
-
-    final int ll = lower;
-    final int uu = upper;
-
-    return new ValueSourceScorer(reader, this) {
-      @Override
-      public boolean matchesValue(int doc) {
-        int ord = termsIndex.getOrd(doc);
-        return ord >= ll && ord <= uu;
-      }
-    };
-  }
-
-  @Override
-  public String toString(int doc) {
-    return vs.description() + '=' + strVal(doc);
-  }
-
-  @Override
-  public ValueFiller getValueFiller() {
-    return new ValueFiller() {
-      private final MutableValueStr mval = new MutableValueStr();
-
-      @Override
-      public MutableValue getValue() {
-        return mval;
-      }
-
-      @Override
-      public void fillValue(int doc) {
-        int ord = termsIndex.getOrd(doc);
-        mval.exists = ord != 0;
-        mval.value = termsIndex.lookup(ord, mval.value);
-      }
-    };
-  }
-
-  public static final class StringIndexException extends RuntimeException {
-    public StringIndexException(final String fieldName,
-                                final RuntimeException cause) {
-      super("Can't initialize StringIndex to generate (function) " +
-              "DocValues for field: " + fieldName, cause);
-    }
-  }
-
-
-}
diff --git a/solr/src/java/org/apache/solr/search/function/SumFloatFunction.java b/solr/src/java/org/apache/solr/search/function/SumFloatFunction.java
deleted file mode 100755
index f64cd46..0000000
--- a/solr/src/java/org/apache/solr/search/function/SumFloatFunction.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-
-/**
- * <code>SumFloatFunction</code> returns the sum of it's components.
- */
-public class SumFloatFunction extends MultiFloatFunction {
-  public SumFloatFunction(ValueSource[] sources) {
-    super(sources);
-  }
-
-  @Override  
-  protected String name() {
-    return "sum";
-  }
-
-  @Override
-  protected float func(int doc, DocValues[] valsArr) {
-    float val = 0.0f;
-    for (DocValues vals : valsArr) {
-      val += vals.floatVal(doc);
-    }
-    return val;
-  }
-}
\ No newline at end of file
diff --git a/solr/src/java/org/apache/solr/search/function/TFValueSource.java b/solr/src/java/org/apache/solr/search/function/TFValueSource.java
deleted file mode 100755
index 66d7f27..0000000
--- a/solr/src/java/org/apache/solr/search/function/TFValueSource.java
+++ /dev/null
@@ -1,111 +0,0 @@
-package org.apache.solr.search.function;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.index.*;
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.search.DocIdSetIterator;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Similarity;
-import org.apache.lucene.util.BytesRef;
-import org.apache.solr.common.SolrException;
-
-import java.io.IOException;
-import java.util.Map;
-
-public class TFValueSource extends TermFreqValueSource {
-  public TFValueSource(String field, String val, String indexedField, BytesRef indexedBytes) {
-    super(field, val, indexedField, indexedBytes);
-  }
-
-  @Override
-  public String name() {
-    return "tf";
-  }
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    Fields fields = readerContext.reader.fields();
-    final Terms terms = fields.terms(field);
-    final Similarity similarity = ((IndexSearcher)context.get("searcher")).getSimilarityProvider().get(field);
-
-    return new FloatDocValues(this) {
-      DocsEnum docs ;
-      int atDoc;
-      int lastDocRequested = -1;
-
-      { reset(); }
-
-      public void reset() throws IOException {
-        // no one should call us for deleted docs?
-        docs = terms==null ? null : terms.docs(null, indexedBytes, null);
-        if (docs == null) {
-          docs = new DocsEnum() {
-            @Override
-            public int freq() {
-              return 0;
-            }
-
-            @Override
-            public int docID() {
-              return DocIdSetIterator.NO_MORE_DOCS;
-            }
-
-            @Override
-            public int nextDoc() throws IOException {
-              return DocIdSetIterator.NO_MORE_DOCS;
-            }
-
-            @Override
-            public int advance(int target) throws IOException {
-              return DocIdSetIterator.NO_MORE_DOCS;
-            }
-          };
-        }
-        atDoc = -1;
-      }
-
-      @Override
-      public float floatVal(int doc) {
-        try {
-          if (doc < lastDocRequested) {
-            // out-of-order access.... reset
-            reset();
-          }
-          lastDocRequested = doc;
-
-          if (atDoc < doc) {
-            atDoc = docs.advance(doc);
-          }
-
-          if (atDoc > doc) {
-            // term doesn't match this document... either because we hit the
-            // end, or because the next doc is after this doc.
-            return similarity.tf(0);
-          }
-
-          // a match!
-          return similarity.tf(docs.freq());
-        } catch (IOException e) {
-          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "caught exception in function "+description()+" : doc="+doc, e);
-        }
-      }
-    };
-  }
-}
diff --git a/solr/src/java/org/apache/solr/search/function/TermFreqValueSource.java b/solr/src/java/org/apache/solr/search/function/TermFreqValueSource.java
deleted file mode 100755
index 2b94e49..0000000
--- a/solr/src/java/org/apache/solr/search/function/TermFreqValueSource.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.index.*;
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.search.DocIdSetIterator;
-import org.apache.lucene.util.BytesRef;
-import org.apache.solr.common.SolrException;
-
-import java.io.IOException;
-import java.util.Map;
-
-public class TermFreqValueSource extends DocFreqValueSource {
-  public TermFreqValueSource(String field, String val, String indexedField, BytesRef indexedBytes) {
-    super(field, val, indexedField, indexedBytes);
-  }
-
-  @Override
-  public String name() {
-    return "termfreq";
-  }
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    Fields fields = readerContext.reader.fields();
-    final Terms terms = fields.terms(field);
-
-    return new IntDocValues(this) {
-      DocsEnum docs ;
-      int atDoc;
-      int lastDocRequested = -1;
-
-      { reset(); }
-
-      public void reset() throws IOException {
-        // no one should call us for deleted docs?
-        docs = terms == null ? null : terms.docs(null, indexedBytes, null);
-        if (docs == null) {
-          docs = new DocsEnum() {
-            @Override
-            public int freq() {
-              return 0;
-            }
-
-            @Override
-            public int docID() {
-              return DocIdSetIterator.NO_MORE_DOCS;
-            }
-
-            @Override
-            public int nextDoc() throws IOException {
-              return DocIdSetIterator.NO_MORE_DOCS;
-            }
-
-            @Override
-            public int advance(int target) throws IOException {
-              return DocIdSetIterator.NO_MORE_DOCS;
-            }
-          };
-        }
-        atDoc = -1;
-      }
-
-      @Override
-      public int intVal(int doc) {
-        try {
-          if (doc < lastDocRequested) {
-            // out-of-order access.... reset
-            reset();
-          }
-          lastDocRequested = doc;
-
-          if (atDoc < doc) {
-            atDoc = docs.advance(doc);
-          }
-
-          if (atDoc > doc) {
-            // term doesn't match this document... either because we hit the
-            // end, or because the next doc is after this doc.
-            return 0;
-          }
-
-          // a match!
-          return docs.freq();
-        } catch (IOException e) {
-          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "caught exception in function "+description()+" : doc="+doc, e);
-        }
-      }
-    };
-  }
-}
-
-
diff --git a/solr/src/java/org/apache/solr/search/function/VectorValueSource.java b/solr/src/java/org/apache/solr/search/function/VectorValueSource.java
deleted file mode 100644
index b57592f..0000000
--- a/solr/src/java/org/apache/solr/search/function/VectorValueSource.java
+++ /dev/null
@@ -1,223 +0,0 @@
-package org.apache.solr.search.function;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.solr.search.function.MultiValueSource;
-
-import java.io.IOException;
-import java.util.List;
-import java.util.Map;
-
-
-/**
- * Converts individual ValueSource instances to leverage the DocValues *Val functions that work with multiple values,
- * i.e. {@link org.apache.lucene.queries.function.DocValues#doubleVal(int, double[])}
- */
-//Not crazy about the name, but...
-public class VectorValueSource extends MultiValueSource {
-  protected final List<ValueSource> sources;
-
-
-  public VectorValueSource(List<ValueSource> sources) {
-    this.sources = sources;
-  }
-
-  public List<ValueSource> getSources() {
-    return sources;
-  }
-
-  @Override
-  public int dimension() {
-    return sources.size();
-  }
-
-  public String name() {
-    return "vector";
-  }
-
-  @Override
-  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    int size = sources.size();
-
-    // special-case x,y and lat,lon since it's so common
-    if (size==2) {
-      final DocValues x = sources.get(0).getValues(context, readerContext);
-      final DocValues y = sources.get(1).getValues(context, readerContext);
-      return new DocValues() {
-        @Override
-        public void byteVal(int doc, byte[] vals) {
-          vals[0] = x.byteVal(doc);
-          vals[1] = y.byteVal(doc);
-        }
-
-        @Override
-        public void shortVal(int doc, short[] vals) {
-          vals[0] = x.shortVal(doc);
-          vals[1] = y.shortVal(doc);
-        }
-        @Override
-        public void intVal(int doc, int[] vals) {
-          vals[0] = x.intVal(doc);
-          vals[1] = y.intVal(doc);
-        }
-        @Override
-        public void longVal(int doc, long[] vals) {
-          vals[0] = x.longVal(doc);
-          vals[1] = y.longVal(doc);
-        }
-        @Override
-        public void floatVal(int doc, float[] vals) {
-          vals[0] = x.floatVal(doc);
-          vals[1] = y.floatVal(doc);
-        }
-        @Override
-        public void doubleVal(int doc, double[] vals) {
-          vals[0] = x.doubleVal(doc);
-          vals[1] = y.doubleVal(doc);
-        }
-        @Override
-        public void strVal(int doc, String[] vals) {
-          vals[0] = x.strVal(doc);
-          vals[1] = y.strVal(doc);
-        }
-        @Override
-        public String toString(int doc) {
-          return name() + "(" + x.toString(doc) + "," + y.toString(doc) + ")";
-        }
-      };
-    }
-
-
-    final DocValues[] valsArr = new DocValues[size];
-    for (int i = 0; i < size; i++) {
-      valsArr[i] = sources.get(i).getValues(context, readerContext);
-    }
-
-    return new DocValues() {
-      @Override
-      public void byteVal(int doc, byte[] vals) {
-        for (int i = 0; i < valsArr.length; i++) {
-          vals[i] = valsArr[i].byteVal(doc);
-        }
-      }
-
-      @Override
-      public void shortVal(int doc, short[] vals) {
-        for (int i = 0; i < valsArr.length; i++) {
-          vals[i] = valsArr[i].shortVal(doc);
-        }
-      }
-
-      @Override
-      public void floatVal(int doc, float[] vals) {
-        for (int i = 0; i < valsArr.length; i++) {
-          vals[i] = valsArr[i].floatVal(doc);
-        }
-      }
-
-      @Override
-      public void intVal(int doc, int[] vals) {
-        for (int i = 0; i < valsArr.length; i++) {
-          vals[i] = valsArr[i].intVal(doc);
-        }
-      }
-
-      @Override
-      public void longVal(int doc, long[] vals) {
-        for (int i = 0; i < valsArr.length; i++) {
-          vals[i] = valsArr[i].longVal(doc);
-        }
-      }
-
-      @Override
-      public void doubleVal(int doc, double[] vals) {
-        for (int i = 0; i < valsArr.length; i++) {
-          vals[i] = valsArr[i].doubleVal(doc);
-        }
-      }
-
-      @Override
-      public void strVal(int doc, String[] vals) {
-        for (int i = 0; i < valsArr.length; i++) {
-          vals[i] = valsArr[i].strVal(doc);
-        }
-      }
-
-      @Override
-      public String toString(int doc) {
-        StringBuilder sb = new StringBuilder();
-        sb.append(name()).append('(');
-        boolean firstTime = true;
-        for (DocValues vals : valsArr) {
-          if (firstTime) {
-            firstTime = false;
-          } else {
-            sb.append(',');
-          }
-          sb.append(vals.toString(doc));
-        }
-        sb.append(')');
-        return sb.toString();
-      }
-    };
-  }
-
-  @Override
-  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
-    for (ValueSource source : sources)
-      source.createWeight(context, searcher);
-  }
-
-
-  @Override
-  public String description() {
-    StringBuilder sb = new StringBuilder();
-    sb.append(name()).append('(');
-    boolean firstTime = true;
-    for (ValueSource source : sources) {
-      if (firstTime) {
-        firstTime = false;
-      } else {
-        sb.append(',');
-      }
-      sb.append(source);
-    }
-    sb.append(")");
-    return sb.toString();
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (this == o) return true;
-    if (!(o instanceof VectorValueSource)) return false;
-
-    VectorValueSource that = (VectorValueSource) o;
-
-    if (!sources.equals(that.sources)) return false;
-
-    return true;
-  }
-
-  @Override
-  public int hashCode() {
-    return sources.hashCode();
-  }
-}
diff --git a/solr/src/java/org/apache/solr/search/function/distance/GeohashHaversineFunction.java b/solr/src/java/org/apache/solr/search/function/distance/GeohashHaversineFunction.java
index 725e8ff..ca80dbb 100644
--- a/solr/src/java/org/apache/solr/search/function/distance/GeohashHaversineFunction.java
+++ b/solr/src/java/org/apache/solr/search/function/distance/GeohashHaversineFunction.java
@@ -19,8 +19,8 @@ package org.apache.solr.search.function.distance;
 
 import org.apache.lucene.queries.function.DocValues;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.DoubleDocValues;
 import org.apache.lucene.spatial.DistanceUtils;
-import org.apache.solr.search.function.DoubleDocValues;
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.spatial.geohash.GeoHashUtils;
diff --git a/solr/src/java/org/apache/solr/search/function/distance/HaversineConstFunction.java b/solr/src/java/org/apache/solr/search/function/distance/HaversineConstFunction.java
index d97f605..dba15dd 100755
--- a/solr/src/java/org/apache/solr/search/function/distance/HaversineConstFunction.java
+++ b/solr/src/java/org/apache/solr/search/function/distance/HaversineConstFunction.java
@@ -19,6 +19,11 @@ package org.apache.solr.search.function.distance;
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.lucene.queries.function.DocValues;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.DoubleDocValues;
+import org.apache.lucene.queries.function.valuesource.ConstNumberSource;
+import org.apache.lucene.queries.function.valuesource.DoubleConstValueSource;
+import org.apache.lucene.queries.function.valuesource.MultiValueSource;
+import org.apache.lucene.queries.function.valuesource.VectorValueSource;
 import org.apache.lucene.queryParser.ParseException;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.spatial.DistanceUtils;
diff --git a/solr/src/java/org/apache/solr/search/function/distance/HaversineFunction.java b/solr/src/java/org/apache/solr/search/function/distance/HaversineFunction.java
index 7e3fcfa..1febdaf 100644
--- a/solr/src/java/org/apache/solr/search/function/distance/HaversineFunction.java
+++ b/solr/src/java/org/apache/solr/search/function/distance/HaversineFunction.java
@@ -19,11 +19,11 @@ package org.apache.solr.search.function.distance;
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.lucene.queries.function.DocValues;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.DoubleDocValues;
+import org.apache.lucene.queries.function.valuesource.MultiValueSource;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.spatial.DistanceUtils;
 import org.apache.solr.common.SolrException;
-import org.apache.solr.search.function.DoubleDocValues;
-import org.apache.solr.search.function.MultiValueSource;
 
 import java.io.IOException;
 import java.util.Map;
diff --git a/solr/src/java/org/apache/solr/search/function/distance/SquaredEuclideanFunction.java b/solr/src/java/org/apache/solr/search/function/distance/SquaredEuclideanFunction.java
index 9102af0..ad9cdb8 100644
--- a/solr/src/java/org/apache/solr/search/function/distance/SquaredEuclideanFunction.java
+++ b/solr/src/java/org/apache/solr/search/function/distance/SquaredEuclideanFunction.java
@@ -17,8 +17,8 @@ package org.apache.solr.search.function.distance;
  */
 
 import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.valuesource.MultiValueSource;
 import org.apache.lucene.spatial.DistanceUtils;
-import org.apache.solr.search.function.MultiValueSource;
 
 
 /**
diff --git a/solr/src/java/org/apache/solr/search/function/distance/StringDistanceFunction.java b/solr/src/java/org/apache/solr/search/function/distance/StringDistanceFunction.java
index ed4ee68..33ce483 100644
--- a/solr/src/java/org/apache/solr/search/function/distance/StringDistanceFunction.java
+++ b/solr/src/java/org/apache/solr/search/function/distance/StringDistanceFunction.java
@@ -20,8 +20,8 @@ package org.apache.solr.search.function.distance;
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.lucene.queries.function.DocValues;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.FloatDocValues;
 import org.apache.lucene.search.spell.StringDistance;
-import org.apache.solr.search.function.FloatDocValues;
 
 import java.io.IOException;
 import java.util.Map;
diff --git a/solr/src/java/org/apache/solr/search/function/distance/VectorDistanceFunction.java b/solr/src/java/org/apache/solr/search/function/distance/VectorDistanceFunction.java
index 66d657e..f550577 100644
--- a/solr/src/java/org/apache/solr/search/function/distance/VectorDistanceFunction.java
+++ b/solr/src/java/org/apache/solr/search/function/distance/VectorDistanceFunction.java
@@ -19,11 +19,11 @@ package org.apache.solr.search.function.distance;
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.lucene.queries.function.DocValues;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.DoubleDocValues;
+import org.apache.lucene.queries.function.valuesource.MultiValueSource;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.spatial.DistanceUtils;
 import org.apache.solr.common.SolrException;
-import org.apache.solr.search.function.DoubleDocValues;
-import org.apache.solr.search.function.MultiValueSource;
 
 import java.io.IOException;
 import java.util.Map;
diff --git a/solr/src/test/org/apache/solr/core/DummyValueSourceParser.java b/solr/src/test/org/apache/solr/core/DummyValueSourceParser.java
index c1f263c..4e714dd 100644
--- a/solr/src/test/org/apache/solr/core/DummyValueSourceParser.java
+++ b/solr/src/test/org/apache/solr/core/DummyValueSourceParser.java
@@ -18,11 +18,11 @@ package org.apache.solr.core;
 
 import org.apache.lucene.queries.function.DocValues;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.valuesource.SimpleFloatFunction;
 import org.apache.lucene.queryParser.ParseException;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.search.FunctionQParser;
 import org.apache.solr.search.ValueSourceParser;
-import org.apache.solr.search.function.SimpleFloatFunction;
 
 
 /**
diff --git a/solr/src/test/org/apache/solr/search/function/NvlValueSourceParser.java b/solr/src/test/org/apache/solr/search/function/NvlValueSourceParser.java
index 303b284..726c548 100755
--- a/solr/src/test/org/apache/solr/search/function/NvlValueSourceParser.java
+++ b/solr/src/test/org/apache/solr/search/function/NvlValueSourceParser.java
@@ -19,6 +19,7 @@ package org.apache.solr.search.function;
 
 import org.apache.lucene.queries.function.DocValues;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.valuesource.SimpleFloatFunction;
 import org.apache.lucene.queryParser.ParseException;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.search.FunctionQParser;

