GitDiffStart: a43843701d9dbf790f9104a2ce1f6f38e98e8370 | Thu Mar 5 11:29:24 2015 +0000
diff --git a/solr/CHANGES.txt b/solr/CHANGES.txt
index 7590238..92c0b1a 100644
--- a/solr/CHANGES.txt
+++ b/solr/CHANGES.txt
@@ -133,6 +133,9 @@ New Features
   
 * SOLR-7164: BBoxField defaults sub fields to not-stored (ryan)
 
+* SOLR-7155: All SolrClient methods now take an optional 'collection' argument
+  (Alan Woodward)
+
 Bug Fixes
 ----------------------
 
diff --git a/solr/core/src/java/org/apache/solr/client/solrj/embedded/EmbeddedSolrServer.java b/solr/core/src/java/org/apache/solr/client/solrj/embedded/EmbeddedSolrServer.java
index adc271c..ca5542c 100644
--- a/solr/core/src/java/org/apache/solr/client/solrj/embedded/EmbeddedSolrServer.java
+++ b/solr/core/src/java/org/apache/solr/client/solrj/embedded/EmbeddedSolrServer.java
@@ -86,13 +86,16 @@ public class EmbeddedSolrServer extends SolrClient
   }
   
   @Override
-  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException 
+  public NamedList<Object> request(SolrRequest request, String coreName) throws SolrServerException, IOException
   {
     String path = request.getPath();
     if( path == null || !path.startsWith( "/" ) ) {
       path = "/select";
     }
 
+    if (coreName == null)
+      coreName = this.coreName;
+
     // Check for cores action
     SolrCore core =  coreContainer.getCore( coreName );
     if( core == null ) {
diff --git a/solr/core/src/test/org/apache/solr/update/MockStreamingSolrClients.java b/solr/core/src/test/org/apache/solr/update/MockStreamingSolrClients.java
index 7786578..c40d4ee 100644
--- a/solr/core/src/test/org/apache/solr/update/MockStreamingSolrClients.java
+++ b/solr/core/src/test/org/apache/solr/update/MockStreamingSolrClients.java
@@ -72,7 +72,7 @@ public class MockStreamingSolrClients extends StreamingSolrClients {
     }
     
     @Override
-    public NamedList<Object> request(SolrRequest request)
+    public NamedList<Object> request(SolrRequest request, String collection)
         throws SolrServerException, IOException {
       if (exp != null) {
         if (LuceneTestCase.random().nextBoolean()) {
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/SolrClient.java b/solr/solrj/src/java/org/apache/solr/client/solrj/SolrClient.java
index d9d9966..c1b6ac5 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/SolrClient.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/SolrClient.java
@@ -41,6 +41,7 @@ import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
+import java.util.Iterator;
 import java.util.List;
 
 /**
@@ -51,271 +52,943 @@ import java.util.List;
 public abstract class SolrClient implements Serializable, Closeable {
 
   private static final long serialVersionUID = 1L;
+
   private DocumentObjectBinder binder;
 
   /**
    * Adds a collection of documents
+   *
+   * @param collection the Solr collection to add documents to
    * @param docs  the collection of documents
-   * @throws IOException If there is a low-level I/O error.
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} from the server
+   *
+   * @throws IOException         if there is a communication error with the server
+   * @throws SolrServerException if there is an error on the server
+   *
+   * @since Solr 5.1
+   */
+  public UpdateResponse add(String collection, Collection<SolrInputDocument> docs) throws SolrServerException, IOException {
+    return add(collection, docs, -1);
+  }
+
+  /**
+   * Adds a collection of documents
+   *
+   * @param docs  the collection of documents
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} from the server
+   *
+   * @throws IOException         if there is a communication error with the server
+   * @throws SolrServerException if there is an error on the server
    */
   public UpdateResponse add(Collection<SolrInputDocument> docs) throws SolrServerException, IOException {
-    return add(docs, -1);
+    return add(null, docs);
   }
 
   /**
    * Adds a collection of documents, specifying max time before they become committed
+   *
+   * @param collection the Solr collection to add documents to
    * @param docs  the collection of documents
-   * @param commitWithinMs  max time (in ms) before a commit will happen 
-   * @throws IOException If there is a low-level I/O error.
-   * @since solr 3.5
+   * @param commitWithinMs  max time (in ms) before a commit will happen
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} from the server
+   *
+   * @throws IOException         if there is a communication error with the server
+   * @throws SolrServerException if there is an error on the server
+   *
+   * @since Solr 5.1
    */
-  public UpdateResponse add(Collection<SolrInputDocument> docs, int commitWithinMs) throws SolrServerException, IOException {
+  public UpdateResponse add(String collection, Collection<SolrInputDocument> docs, int commitWithinMs) throws SolrServerException, IOException {
     UpdateRequest req = new UpdateRequest();
     req.add(docs);
     req.setCommitWithin(commitWithinMs);
-    return req.process(this);
+    return req.process(this, collection);
   }
 
   /**
-   * Adds a collection of beans
-   * @param beans  the collection of beans
-   * @throws IOException If there is a low-level I/O error.
+   * Adds a collection of documents, specifying max time before they become committed
+   *
+   * @param docs  the collection of documents
+   * @param commitWithinMs  max time (in ms) before a commit will happen
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} from the server
+   *
+   * @throws IOException         if there is a communication error with the server
+   * @throws SolrServerException if there is an error on the server
+   *
+   * @since Solr 3.5
    */
-  public UpdateResponse addBeans(Collection<?> beans) throws SolrServerException, IOException {
-    return addBeans(beans, -1);
+  public UpdateResponse add(Collection<SolrInputDocument> docs, int commitWithinMs) throws SolrServerException, IOException {
+    return add(null, docs, commitWithinMs);
   }
 
   /**
-   * Adds a collection of beans specifying max time before they become committed
-   * @param beans  the collection of beans
-   * @param commitWithinMs  max time (in ms) before a commit will happen 
-   * @throws IOException If there is a low-level I/O error.
-   * @since solr 3.5
+   * Adds a single document
+   *
+   * @param collection the Solr collection to add the document to
+   * @param doc  the input document
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} from the server
+   *
+   * @throws IOException         if there is a communication error with the server
+   * @throws SolrServerException if there is an error on the server
    */
-  public UpdateResponse addBeans(Collection<?> beans, int commitWithinMs) throws SolrServerException, IOException {
-    DocumentObjectBinder binder = this.getBinder();
-    ArrayList<SolrInputDocument> docs =  new ArrayList<>(beans.size());
-    for (Object bean : beans) {
-      docs.add(binder.toSolrInputDocument(bean));
-    }
-    return add(docs, commitWithinMs);
+  public UpdateResponse add(String collection, SolrInputDocument doc) throws SolrServerException, IOException {
+    return add(collection, doc, -1);
   }
 
   /**
    * Adds a single document
+   *
    * @param doc  the input document
-   * @throws IOException If there is a low-level I/O error.
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} from the server
+   *
+   * @throws IOException         if there is a communication error with the server
+   * @throws SolrServerException if there is an error on the server
    */
   public UpdateResponse add(SolrInputDocument doc) throws SolrServerException, IOException {
-    return add(doc, -1);
+    return add(null, doc);
   }
 
   /**
    * Adds a single document specifying max time before it becomes committed
+   *
+   * @param collection the Solr collection to add the document to
    * @param doc  the input document
-   * @param commitWithinMs  max time (in ms) before a commit will happen 
-   * @throws IOException If there is a low-level I/O error.
-   * @since solr 3.5
+   * @param commitWithinMs  max time (in ms) before a commit will happen
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} from the server
+   *
+   * @throws IOException         if there is a communication error with the server
+   * @throws SolrServerException if there is an error on the server
+   *
+   * @since solr 5.1
    */
-  public UpdateResponse add(SolrInputDocument doc, int commitWithinMs) throws SolrServerException, IOException {
+  public UpdateResponse add(String collection, SolrInputDocument doc, int commitWithinMs) throws SolrServerException, IOException {
     UpdateRequest req = new UpdateRequest();
     req.add(doc);
     req.setCommitWithin(commitWithinMs);
-    return req.process(this);
+    return req.process(this, collection);
+  }
+
+  /**
+   * Adds a single document specifying max time before it becomes committed
+   *
+   * @param doc  the input document
+   * @param commitWithinMs  max time (in ms) before a commit will happen
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} from the server
+   *
+   * @throws IOException         if there is a communication error with the server
+   * @throws SolrServerException if there is an error on the server
+   *
+   * @since solr 3.5
+   */
+  public UpdateResponse add(SolrInputDocument doc, int commitWithinMs) throws SolrServerException, IOException {
+    return add(null, doc, commitWithinMs);
+  }
+
+  /**
+   * Adds the documents supplied by the given iterator.
+   *
+   * @param collection the Solr collection to add the documents to
+   * @param docIterator
+   *          the iterator which returns SolrInputDocument instances
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} from the server
+   *
+   * @throws IOException         if there is a communication error with the server
+   * @throws SolrServerException if there is an error on the server
+   */
+  public UpdateResponse add(String collection, Iterator<SolrInputDocument> docIterator)
+      throws SolrServerException, IOException {
+    UpdateRequest req = new UpdateRequest();
+    req.setDocIterator(docIterator);
+    return req.process(this, collection);
+  }
+
+  /**
+   * Adds the documents supplied by the given iterator.
+   *
+   * @param docIterator
+   *          the iterator which returns SolrInputDocument instances
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} from the server
+   *
+   * @throws IOException         if there is a communication error with the server
+   * @throws SolrServerException if there is an error on the server
+   */
+  public UpdateResponse add(Iterator<SolrInputDocument> docIterator) throws SolrServerException, IOException {
+    return add(null, docIterator);
   }
 
   /**
    * Adds a single bean
+   *
+   * The bean is converted to a {@link SolrInputDocument} by the client's
+   * {@link org.apache.solr.client.solrj.beans.DocumentObjectBinder}
+   *
+   * @param collection to Solr collection to add documents to
    * @param obj  the input bean
-   * @throws IOException If there is a low-level I/O error.
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} from the server
+   *
+   * @throws IOException         if there is a communication error with the server
+   * @throws SolrServerException if there is an error on the server
+   */
+  public UpdateResponse addBean(String collection, Object obj) throws IOException, SolrServerException {
+    return addBean(collection, obj, -1);
+  }
+
+  /**
+   * Adds a single bean
+   *
+   * The bean is converted to a {@link SolrInputDocument} by the client's
+   * {@link org.apache.solr.client.solrj.beans.DocumentObjectBinder}
+   *
+   * @param obj  the input bean
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} from the server
+   *
+   * @throws IOException         if there is a communication error with the server
+   * @throws SolrServerException if there is an error on the server
    */
   public UpdateResponse addBean(Object obj) throws IOException, SolrServerException {
-    return addBean(obj, -1);
+    return addBean(null, obj, -1);
   }
 
   /**
    * Adds a single bean specifying max time before it becomes committed
+   *
+   * The bean is converted to a {@link SolrInputDocument} by the client's
+   * {@link org.apache.solr.client.solrj.beans.DocumentObjectBinder}
+   *
+   * @param collection to Solr collection to add documents to
    * @param obj  the input bean
-   * @param commitWithinMs  max time (in ms) before a commit will happen 
-   * @throws IOException If there is a low-level I/O error.
-   * @since solr 3.5
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} from the server
+   *
+   * @throws IOException         if there is a communication error with the server
+   * @throws SolrServerException if there is an error on the server
+   */
+  public UpdateResponse addBean(String collection, Object obj, int commitWithinMs) throws IOException, SolrServerException {
+    return add(collection, getBinder().toSolrInputDocument(obj), commitWithinMs);
+  }
+
+  /**
+   * Adds a single bean specifying max time before it becomes committed
+   *
+   * The bean is converted to a {@link SolrInputDocument} by the client's
+   * {@link org.apache.solr.client.solrj.beans.DocumentObjectBinder}
+   *
+   * @param obj  the input bean
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} from the server
+   *
+   * @throws IOException         if there is a communication error with the server
+   * @throws SolrServerException if there is an error on the server
    */
   public UpdateResponse addBean(Object obj, int commitWithinMs) throws IOException, SolrServerException {
-    return add(getBinder().toSolrInputDocument(obj),commitWithinMs);
+    return add(null, getBinder().toSolrInputDocument(obj), commitWithinMs);
+  }
+
+  /**
+   * Adds a collection of beans
+   *
+   * The beans are converted to {@link SolrInputDocument}s by the client's
+   * {@link org.apache.solr.client.solrj.beans.DocumentObjectBinder}
+   *
+   * @param collection the Solr collection to add documents to
+   * @param beans  the collection of beans
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} from the server
+   *
+   * @throws IOException         if there is a communication error with the server
+   * @throws SolrServerException if there is an error on the server
+   */
+  public UpdateResponse addBeans(String collection, Collection<?> beans) throws SolrServerException, IOException {
+    return addBeans(collection, beans, -1);
+  }
+
+  /**
+   * Adds a collection of beans
+   *
+   * The beans are converted to {@link SolrInputDocument}s by the client's
+   * {@link org.apache.solr.client.solrj.beans.DocumentObjectBinder}
+   *
+   * @param beans  the collection of beans
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} from the server
+   *
+   * @throws IOException         if there is a communication error with the server
+   * @throws SolrServerException if there is an error on the server
+   */
+  public UpdateResponse addBeans(Collection<?> beans) throws SolrServerException, IOException {
+    return addBeans(null, beans, -1);
+  }
+
+  /**
+   * Adds a collection of beans specifying max time before they become committed
+   *
+   * The beans are converted to {@link SolrInputDocument}s by the client's
+   * {@link org.apache.solr.client.solrj.beans.DocumentObjectBinder}
+   *
+   * @param collection the Solr collection to add documents to
+   * @param beans  the collection of beans
+   * @param commitWithinMs  max time (in ms) before a commit will happen
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} from the server
+   *
+   * @throws IOException         if there is a communication error with the server
+   * @throws SolrServerException if there is an error on the server
+   *
+   * @see SolrClient#getBinder()
+   *
+   * @since solr 5.1
+   */
+  public UpdateResponse addBeans(String collection, Collection<?> beans, int commitWithinMs) throws SolrServerException, IOException {
+    DocumentObjectBinder binder = this.getBinder();
+    ArrayList<SolrInputDocument> docs =  new ArrayList<>(beans.size());
+    for (Object bean : beans) {
+      docs.add(binder.toSolrInputDocument(bean));
+    }
+    return add(collection, docs, commitWithinMs);
+  }
+
+  /**
+   * Adds a collection of beans specifying max time before they become committed
+   *
+   * The beans are converted to {@link SolrInputDocument}s by the client's
+   * {@link org.apache.solr.client.solrj.beans.DocumentObjectBinder}
+   *
+   * @param beans  the collection of beans
+   * @param commitWithinMs  max time (in ms) before a commit will happen
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} from the server
+   *
+   * @throws IOException         if there is a communication error with the server
+   * @throws SolrServerException if there is an error on the server
+   *
+   * @see SolrClient#getBinder()
+   *
+   * @since solr 3.5
+   */
+  public UpdateResponse addBeans(Collection<?> beans, int commitWithinMs) throws SolrServerException, IOException {
+    return addBeans(null, beans, commitWithinMs);
+  }
+
+  /**
+   * Adds the beans supplied by the given iterator.
+   *
+   * @param collection the Solr collection to add the documents to
+   * @param beanIterator
+   *          the iterator which returns Beans
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} from the server
+   *
+   * @throws IOException         if there is a communication error with the server
+   * @throws SolrServerException if there is an error on the server
+   */
+  public UpdateResponse addBeans(String collection, final Iterator<?> beanIterator)
+      throws SolrServerException, IOException {
+    UpdateRequest req = new UpdateRequest();
+    req.setDocIterator(new Iterator<SolrInputDocument>() {
+
+      @Override
+      public boolean hasNext() {
+        return beanIterator.hasNext();
+      }
+
+      @Override
+      public SolrInputDocument next() {
+        Object o = beanIterator.next();
+        if (o == null) return null;
+        return getBinder().toSolrInputDocument(o);
+      }
+
+      @Override
+      public void remove() {
+        beanIterator.remove();
+      }
+    });
+    return req.process(this, collection);
+  }
+
+  /**
+   * Adds the beans supplied by the given iterator.
+   *
+   * @param beanIterator
+   *          the iterator which returns Beans
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} from the server
+   *
+   * @throws IOException         if there is a communication error with the server
+   * @throws SolrServerException if there is an error on the server
+   */
+  public UpdateResponse addBeans(final Iterator<?> beanIterator) throws SolrServerException, IOException {
+    return addBeans(null, beanIterator);
   }
 
   /**
    * Performs an explicit commit, causing pending documents to be committed for indexing
-   * <p>
+   *
+   * waitFlush=true and waitSearcher=true to be inline with the defaults for plain HTTP access
+   *
+   * @param collection the Solr collection to send the commit to
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} containing the response
+   *         from the server
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
+   */
+  public UpdateResponse commit(String collection) throws SolrServerException, IOException {
+    return commit(collection, true, true);
+  }
+
+  /**
+   * Performs an explicit commit, causing pending documents to be committed for indexing
+   *
    * waitFlush=true and waitSearcher=true to be inline with the defaults for plain HTTP access
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} containing the response
+   *         from the server
+   *
    * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
    */
   public UpdateResponse commit() throws SolrServerException, IOException {
-    return commit(true, true);
+    return commit(null, true, true);
+  }
+
+  /**
+   * Performs an explicit commit, causing pending documents to be committed for indexing
+   *
+   * @param collection the Solr collection to send the commit to
+   * @param waitFlush  block until index changes are flushed to disk
+   * @param waitSearcher  block until a new searcher is opened and registered as the
+   *                      main query searcher, making the changes visible
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} containing the response
+   *         from the server
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
+   */
+  public UpdateResponse commit(String collection, boolean waitFlush, boolean waitSearcher)
+      throws SolrServerException, IOException {
+    return new UpdateRequest()
+        .setAction(UpdateRequest.ACTION.COMMIT, waitFlush, waitSearcher)
+        .process(this, collection);
+  }
+
+  /**
+   * Performs an explicit commit, causing pending documents to be committed for indexing
+   *
+   * @param waitFlush  block until index changes are flushed to disk
+   * @param waitSearcher  block until a new searcher is opened and registered as the
+   *                      main query searcher, making the changes visible
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} containing the response
+   *         from the server
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
+   */
+  public UpdateResponse commit(boolean waitFlush, boolean waitSearcher) throws SolrServerException, IOException {
+    return commit(null, waitFlush, waitSearcher);
+  }
+
+  /**
+   * Performs an explicit commit, causing pending documents to be committed for indexing
+   *
+   * @param collection the Solr collection to send the commit to
+   * @param waitFlush  block until index changes are flushed to disk
+   * @param waitSearcher  block until a new searcher is opened and registered as the
+   *                      main query searcher, making the changes visible
+   * @param softCommit makes index changes visible while neither fsync-ing index files
+   *                   nor writing a new index descriptor
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} containing the response
+   *         from the server
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
+   */
+  public UpdateResponse commit(String collection, boolean waitFlush, boolean waitSearcher, boolean softCommit)
+      throws SolrServerException, IOException {
+    return new UpdateRequest()
+        .setAction(UpdateRequest.ACTION.COMMIT, waitFlush, waitSearcher, softCommit)
+        .process(this, collection);
+  }
+
+  /**
+   * Performs an explicit commit, causing pending documents to be committed for indexing
+   *
+   * @param waitFlush  block until index changes are flushed to disk
+   * @param waitSearcher  block until a new searcher is opened and registered as the
+   *                      main query searcher, making the changes visible
+   * @param softCommit makes index changes visible while neither fsync-ing index files
+   *                   nor writing a new index descriptor
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} containing the response
+   *         from the server
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
+   */
+  public UpdateResponse commit(boolean waitFlush, boolean waitSearcher, boolean softCommit)
+      throws SolrServerException, IOException {
+    return commit(null, waitFlush, waitSearcher, softCommit);
   }
 
   /**
    * Performs an explicit optimize, causing a merge of all segments to one.
-   * <p>
+   *
    * waitFlush=true and waitSearcher=true to be inline with the defaults for plain HTTP access
-   * <p>
+   *
+   * Note: In most cases it is not required to do explicit optimize
+   *
+   * @param collection the Solr collection to send the optimize to
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} containing the response
+   *         from the server
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
+   */
+  public UpdateResponse optimize(String collection) throws SolrServerException, IOException {
+    return optimize(collection, true, true, 1);
+  }
+
+  /**
+   * Performs an explicit optimize, causing a merge of all segments to one.
+   *
+   * waitFlush=true and waitSearcher=true to be inline with the defaults for plain HTTP access
+   *
    * Note: In most cases it is not required to do explicit optimize
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} containing the response
+   *         from the server
+   *
    * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
    */
   public UpdateResponse optimize() throws SolrServerException, IOException {
-    return optimize(true, true, 1);
+    return optimize(null, true, true, 1);
   }
 
   /**
-   * Performs an explicit commit, causing pending documents to be committed for indexing
+   * Performs an explicit optimize, causing a merge of all segments to one.
+   * <p>
+   * Note: In most cases it is not required to do explicit optimize
+   *
+   * @param collection the Solr collection to send the optimize to
    * @param waitFlush  block until index changes are flushed to disk
-   * @param waitSearcher  block until a new searcher is opened and registered as the main query searcher, making the changes visible 
+   * @param waitSearcher  block until a new searcher is opened and registered as
+   *                      the main query searcher, making the changes visible
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} containing the response
+   *         from the server
+   *
    * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
    */
-  public UpdateResponse commit(boolean waitFlush, boolean waitSearcher) throws SolrServerException, IOException {
-    return new UpdateRequest().setAction(UpdateRequest.ACTION.COMMIT, waitFlush, waitSearcher).process( this );
+  public UpdateResponse optimize(String collection, boolean waitFlush, boolean waitSearcher) throws SolrServerException, IOException {
+    return optimize(collection, waitFlush, waitSearcher, 1);
   }
 
   /**
-   * Performs an explicit commit, causing pending documents to be committed for indexing
+   * Performs an explicit optimize, causing a merge of all segments to one.
+   * <p>
+   * Note: In most cases it is not required to do explicit optimize
+   *
    * @param waitFlush  block until index changes are flushed to disk
-   * @param waitSearcher  block until a new searcher is opened and registered as the main query searcher, making the changes visible
-   * @param softCommit makes index changes visible while neither fsync-ing index files nor writing a new index descriptor
+   * @param waitSearcher  block until a new searcher is opened and registered as
+   *                      the main query searcher, making the changes visible
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} containing the response
+   *         from the server
+   *
    * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
    */
-  public UpdateResponse commit(boolean waitFlush, boolean waitSearcher, boolean softCommit) throws SolrServerException, IOException {
-    return new UpdateRequest().setAction(UpdateRequest.ACTION.COMMIT, waitFlush, waitSearcher, softCommit).process( this );
+  public UpdateResponse optimize(boolean waitFlush, boolean waitSearcher) throws SolrServerException, IOException {
+    return optimize(null, waitFlush, waitSearcher);
   }
 
   /**
    * Performs an explicit optimize, causing a merge of all segments to one.
-   * <p>
+   *
    * Note: In most cases it is not required to do explicit optimize
+   *
+   * @param collection the Solr collection to send the optimize to
    * @param waitFlush  block until index changes are flushed to disk
-   * @param waitSearcher  block until a new searcher is opened and registered as the main query searcher, making the changes visible 
+   * @param waitSearcher  block until a new searcher is opened and registered as
+   *                      the main query searcher, making the changes visible
+   * @param maxSegments  optimizes down to at most this number of segments
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} containing the response
+   *         from the server
+   *
    * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
    */
-  public UpdateResponse optimize(boolean waitFlush, boolean waitSearcher) throws SolrServerException, IOException {
-    return optimize(waitFlush, waitSearcher, 1);
+  public UpdateResponse optimize(String collection, boolean waitFlush, boolean waitSearcher, int maxSegments)
+      throws SolrServerException, IOException {
+    return new UpdateRequest()
+        .setAction(UpdateRequest.ACTION.OPTIMIZE, waitFlush, waitSearcher, maxSegments)
+        .process(this, collection);
   }
 
   /**
    * Performs an explicit optimize, causing a merge of all segments to one.
-   * <p>
+   *
    * Note: In most cases it is not required to do explicit optimize
+   *
    * @param waitFlush  block until index changes are flushed to disk
-   * @param waitSearcher  block until a new searcher is opened and registered as the main query searcher, making the changes visible 
+   * @param waitSearcher  block until a new searcher is opened and registered as
+   *                      the main query searcher, making the changes visible
    * @param maxSegments  optimizes down to at most this number of segments
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} containing the response
+   *         from the server
+   *
    * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
    */
-  public UpdateResponse optimize(boolean waitFlush, boolean waitSearcher, int maxSegments) throws SolrServerException, IOException {
-    return new UpdateRequest().setAction(UpdateRequest.ACTION.OPTIMIZE, waitFlush, waitSearcher, maxSegments).process( this );
+  public UpdateResponse optimize(boolean waitFlush, boolean waitSearcher, int maxSegments)
+      throws SolrServerException, IOException {
+    return optimize(null, waitFlush, waitSearcher, maxSegments);
   }
 
   /**
    * Performs a rollback of all non-committed documents pending.
-   * <p>
+   *
    * Note that this is not a true rollback as in databases. Content you have previously
    * added may have been committed due to autoCommit, buffer full, other client performing
    * a commit etc.
+   *
+   * @param collection the Solr collection to send the rollback to
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} containing the response
+   *         from the server
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
+   */
+  public UpdateResponse rollback(String collection) throws SolrServerException, IOException {
+    return new UpdateRequest().rollback().process(this, collection);
+  }
+
+  /**
+   * Performs a rollback of all non-committed documents pending.
+   *
+   * Note that this is not a true rollback as in databases. Content you have previously
+   * added may have been committed due to autoCommit, buffer full, other client performing
+   * a commit etc.
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} containing the response
+   *         from the server
+   *
    * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
    */
   public UpdateResponse rollback() throws SolrServerException, IOException {
-    return new UpdateRequest().rollback().process( this );
+    return rollback(null);
+  }
+
+  /**
+   * Deletes a single document by unique ID
+   *
+   * @param collection the Solr collection to delete the document from
+   * @param id  the ID of the document to delete
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} containing the response
+   *         from the server
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
+   */
+  public UpdateResponse deleteById(String collection, String id) throws SolrServerException, IOException {
+    return deleteById(collection, id, -1);
   }
 
   /**
    * Deletes a single document by unique ID
+   *
    * @param id  the ID of the document to delete
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} containing the response
+   *         from the server
+   *
    * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
    */
   public UpdateResponse deleteById(String id) throws SolrServerException, IOException {
-    return deleteById(id, -1);
+    return deleteById(null, id);
   }
 
   /**
    * Deletes a single document by unique ID, specifying max time before commit
+   *
+   * @param collection the Solr collection to delete the document from
    * @param id  the ID of the document to delete
-   * @param commitWithinMs  max time (in ms) before a commit will happen 
+   * @param commitWithinMs  max time (in ms) before a commit will happen
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} containing the response
+   *         from the server
+   *
    * @throws IOException If there is a low-level I/O error.
-   * @since 3.6
+   * @throws SolrServerException if there is an error on the server
+   *
+   * @since 5.1
    */
-  public UpdateResponse deleteById(String id, int commitWithinMs) throws SolrServerException, IOException {
+  public UpdateResponse deleteById(String collection, String id, int commitWithinMs) throws SolrServerException, IOException {
     UpdateRequest req = new UpdateRequest();
     req.deleteById(id);
     req.setCommitWithin(commitWithinMs);
-    return req.process(this);
+    return req.process(this, collection);
+  }
+
+  /**
+   * Deletes a single document by unique ID, specifying max time before commit
+   *
+   * @param id  the ID of the document to delete
+   * @param commitWithinMs  max time (in ms) before a commit will happen
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} containing the response
+   *         from the server
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
+   *
+   * @since 3.6
+   */
+  public UpdateResponse deleteById(String id, int commitWithinMs) throws SolrServerException, IOException {
+    return deleteById(null, id, commitWithinMs);
   }
 
   /**
    * Deletes a list of documents by unique ID
-   * @param ids  the list of document IDs to delete 
+   *
+   * @param collection the Solr collection to delete the documents from
+   * @param ids  the list of document IDs to delete
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} containing the response
+   *         from the server
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
+   */
+  public UpdateResponse deleteById(String collection, List<String> ids) throws SolrServerException, IOException {
+    return deleteById(collection, ids, -1);
+  }
+
+  /**
+   * Deletes a list of documents by unique ID
+   *
+   * @param ids  the list of document IDs to delete
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} containing the response
+   *         from the server
+   *
    * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
    */
   public UpdateResponse deleteById(List<String> ids) throws SolrServerException, IOException {
-    return deleteById(ids, -1);
+    return deleteById(null, ids);
   }
 
   /**
    * Deletes a list of documents by unique ID, specifying max time before commit
+   *
+   * @param collection the Solr collection to delete the documents from
    * @param ids  the list of document IDs to delete 
-   * @param commitWithinMs  max time (in ms) before a commit will happen 
+   * @param commitWithinMs  max time (in ms) before a commit will happen
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} containing the response
+   *         from the server
+   *
    * @throws IOException If there is a low-level I/O error.
-   * @since 3.6
+   * @throws SolrServerException if there is an error on the server
+   *
+   * @since 5.1
    */
-  public UpdateResponse deleteById(List<String> ids, int commitWithinMs) throws SolrServerException, IOException {
+  public UpdateResponse deleteById(String collection, List<String> ids, int commitWithinMs) throws SolrServerException, IOException {
     UpdateRequest req = new UpdateRequest();
     req.deleteById(ids);
     req.setCommitWithin(commitWithinMs);
-    return req.process(this);
+    return req.process(this, collection);
+  }
+
+  /**
+   * Deletes a list of documents by unique ID, specifying max time before commit
+   *
+   * @param ids  the list of document IDs to delete
+   * @param commitWithinMs  max time (in ms) before a commit will happen
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} containing the response
+   *         from the server
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
+   *
+   * @since 3.6
+   */
+  public UpdateResponse deleteById(List<String> ids, int commitWithinMs) throws SolrServerException, IOException {
+    return deleteById(null, ids, commitWithinMs);
+  }
+
+  /**
+   * Deletes documents from the index based on a query
+   *
+   * @param collection the Solr collection to delete the documents from
+   * @param query  the query expressing what documents to delete
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} containing the response
+   *         from the server
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
+   */
+  public UpdateResponse deleteByQuery(String collection, String query) throws SolrServerException, IOException {
+    return deleteByQuery(collection, query, -1);
   }
 
   /**
    * Deletes documents from the index based on a query
+   *
    * @param query  the query expressing what documents to delete
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} containing the response
+   *         from the server
+   *
    * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
    */
   public UpdateResponse deleteByQuery(String query) throws SolrServerException, IOException {
-    return deleteByQuery(query, -1);
+    return deleteByQuery(null, query);
   }
 
   /**
    * Deletes documents from the index based on a query, specifying max time before commit
+   *
+   * @param collection the Solr collection to delete the documents from
    * @param query  the query expressing what documents to delete
-   * @param commitWithinMs  max time (in ms) before a commit will happen 
+   * @param commitWithinMs  max time (in ms) before a commit will happen
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} containing the response
+   *         from the server
+   *
    * @throws IOException If there is a low-level I/O error.
-   * @since 3.6
+   * @throws SolrServerException if there is an error on the server
+   *
+   * @since 5.1
    */
-  public UpdateResponse deleteByQuery(String query, int commitWithinMs) throws SolrServerException, IOException {
+  public UpdateResponse deleteByQuery(String collection, String query, int commitWithinMs) throws SolrServerException, IOException {
     UpdateRequest req = new UpdateRequest();
     req.deleteByQuery(query);
     req.setCommitWithin(commitWithinMs);
-    return req.process(this);
+    return req.process(this, collection);
+  }
+
+  /**
+   * Deletes documents from the index based on a query, specifying max time before commit
+   *
+   * @param query  the query expressing what documents to delete
+   * @param commitWithinMs  max time (in ms) before a commit will happen
+   *
+   * @return an {@link org.apache.solr.client.solrj.response.UpdateResponse} containing the response
+   *         from the server
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
+   *
+   * @since 3.6
+   */
+  public UpdateResponse deleteByQuery(String query, int commitWithinMs) throws SolrServerException, IOException {
+    return deleteByQuery(null, query, commitWithinMs);
   }
 
   /**
    * Issues a ping request to check if the server is alive
+   *
+   * @return a {@link org.apache.solr.client.solrj.response.SolrPingResponse} containing the response
+   *         from the server
+   *
    * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
    */
   public SolrPingResponse ping() throws SolrServerException, IOException {
-    return new SolrPing().process(this);
+    return new SolrPing().process(this, null);
   }
 
   /**
    * Performs a query to the Solr server
+   *
+   * @param collection the Solr collection to query
+   * @param params  an object holding all key/value parameters to send along the request
+   *
+   * @return a {@link org.apache.solr.client.solrj.response.QueryResponse} containing the response
+   *         from the server
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
+   */
+  public QueryResponse query(String collection, SolrParams params) throws SolrServerException, IOException {
+    return new QueryRequest(params).process(this, collection);
+  }
+
+  /**
+   * Performs a query to the Solr server
+   *
    * @param params  an object holding all key/value parameters to send along the request
+   *
+   * @return a {@link org.apache.solr.client.solrj.response.QueryResponse} containing the response
+   *         from the server
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
    */
   public QueryResponse query(SolrParams params) throws SolrServerException, IOException {
-    return new QueryRequest(params).process(this);
+    return query(null, params);
+  }
+
+  /**
+   * Performs a query to the Solr server
+   *
+   * @param collection the Solr collection to query
+   * @param params  an object holding all key/value parameters to send along the request
+   * @param method  specifies the HTTP method to use for the request, such as GET or POST
+   *
+   * @return a {@link org.apache.solr.client.solrj.response.QueryResponse} containing the response
+   *         from the server
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
+   */
+  public QueryResponse query(String collection, SolrParams params, METHOD method) throws SolrServerException, IOException {
+    return new QueryRequest(params, method).process(this, collection);
   }
 
   /**
    * Performs a query to the Solr server
+   *
    * @param params  an object holding all key/value parameters to send along the request
    * @param method  specifies the HTTP method to use for the request, such as GET or POST
+   *
+   * @return a {@link org.apache.solr.client.solrj.response.QueryResponse} containing the response
+   *         from the server
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
    */
   public QueryResponse query(SolrParams params, METHOD method) throws SolrServerException, IOException {
-    return new QueryRequest(params, method).process(this);
+    return query(null, params, method);
   }
 
   /**
@@ -327,34 +1000,95 @@ public abstract class SolrClient implements Serializable, Closeable {
    * future version may pass even more info to the callback and may not return 
    * the results in the QueryResponse.
    *
-   * @since solr 4.0
+   * @param collection the Solr collection to query
+   * @param params  an object holding all key/value parameters to send along the request
+   * @param callback the callback to stream results to
+   *
+   * @return a {@link org.apache.solr.client.solrj.response.QueryResponse} containing the response
+   *         from the server
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
+   *
+   * @since solr 5.1
    */
-  public QueryResponse queryAndStreamResponse(SolrParams params, StreamingResponseCallback callback) throws SolrServerException, IOException
-  {
+  public QueryResponse queryAndStreamResponse(String collection, SolrParams params, StreamingResponseCallback callback)
+      throws SolrServerException, IOException {
     ResponseParser parser = new StreamingBinaryResponseParser(callback);
     QueryRequest req = new QueryRequest(params);
     req.setStreamingResponseCallback(callback);
     req.setResponseParser(parser);
-    return req.process(this);
+    return req.process(this, collection);
+  }
+
+  /**
+   * Query solr, and stream the results.  Unlike the standard query, this will
+   * send events for each Document rather then add them to the QueryResponse.
+   *
+   * Although this function returns a 'QueryResponse' it should be used with care
+   * since it excludes anything that was passed to callback.  Also note that
+   * future version may pass even more info to the callback and may not return
+   * the results in the QueryResponse.
+   *
+   * @param params  an object holding all key/value parameters to send along the request
+   * @param callback the callback to stream results to
+   *
+   * @return a {@link org.apache.solr.client.solrj.response.QueryResponse} containing the response
+   *         from the server
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
+   *
+   * @since solr 4.0
+   */
+  public QueryResponse queryAndStreamResponse(SolrParams params, StreamingResponseCallback callback)
+      throws SolrServerException, IOException {
+    return queryAndStreamResponse(null, params, callback);
   }
 
   /**
    * Retrieves the SolrDocument associated with the given identifier.
    *
-   * @return retrieved SolrDocument, null if no document is found.
+   * @param collection the Solr collection to query
+   * @param id the id
+   *
+   * @return retrieved SolrDocument, or null if no document is found.
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
+   */
+  public SolrDocument getById(String collection, String id) throws SolrServerException, IOException {
+    return getById(collection, id, null);
+  }
+  /**
+   * Retrieves the SolrDocument associated with the given identifier.
+   *
+   * @param id the id
+   *
+   * @return retrieved SolrDocument, or null if no document is found.
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
    */
   public SolrDocument getById(String id) throws SolrServerException, IOException {
-    return getById(id, null);
+    return getById(null, id, null);
   }
 
   /**
    * Retrieves the SolrDocument associated with the given identifier and uses
    * the SolrParams to execute the request.
    *
-   * @return retrieved SolrDocument, null if no document is found.
+   * @param collection the Solr collection to query
+   * @param id the id
+   * @param params additional parameters to add to the query
+   *
+   * @return retrieved SolrDocument, or null if no document is found.
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
    */
-  public SolrDocument getById(String id, SolrParams params) throws SolrServerException, IOException {
-    SolrDocumentList docs = getById(Arrays.asList(id), params);
+  public SolrDocument getById(String collection, String id, SolrParams params) throws SolrServerException, IOException {
+    SolrDocumentList docs = getById(collection, Arrays.asList(id), params);
     if (!docs.isEmpty()) {
       return docs.get(0);
     }
@@ -362,19 +1096,71 @@ public abstract class SolrClient implements Serializable, Closeable {
   }
 
   /**
+   * Retrieves the SolrDocument associated with the given identifier and uses
+   * the SolrParams to execute the request.
+   *
+   * @param id the id
+   * @param params additional parameters to add to the query
+   *
+   * @return retrieved SolrDocument, or null if no document is found.
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
+   */
+  public SolrDocument getById(String id, SolrParams params) throws SolrServerException, IOException {
+    return getById(null, id, params);
+  }
+
+  /**
+   * Retrieves the SolrDocuments associated with the given identifiers.
+   *
+   * If a document was not found, it will not be added to the SolrDocumentList.
+   *
+   * @param collection the Solr collection to query
+   * @param ids the ids
+   *
+   * @return a SolrDocumentList, or null if no documents were found
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
+   */
+  public SolrDocumentList getById(String collection, Collection<String> ids) throws SolrServerException, IOException {
+    return getById(collection, ids, null);
+  }
+
+  /**
    * Retrieves the SolrDocuments associated with the given identifiers.
+   *
    * If a document was not found, it will not be added to the SolrDocumentList.
+   *
+   * @param ids the ids
+   *
+   * @return a SolrDocumentList, or null if no documents were found
+   *
+   *  @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
    */
   public SolrDocumentList getById(Collection<String> ids) throws SolrServerException, IOException {
-    return getById(ids, null);
+    return getById(null, ids);
   }
 
   /**
    * Retrieves the SolrDocuments associated with the given identifiers and uses
    * the SolrParams to execute the request.
+   *
    * If a document was not found, it will not be added to the SolrDocumentList.
+   *
+   * @param collection the Solr collection to query
+   * @param ids the ids
+   * @param params additional parameters to add to the query
+   *
+   * @return a SolrDocumentList, or null if no documents were found
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
    */
-  public SolrDocumentList getById(Collection<String> ids, SolrParams params) throws SolrServerException, IOException {
+  public SolrDocumentList getById(String collection, Collection<String> ids, SolrParams params)
+      throws SolrServerException, IOException {
     if (ids == null || ids.isEmpty()) {
       throw new IllegalArgumentException("Must provide an identifier of a document to retrieve.");
     }
@@ -385,14 +1171,63 @@ public abstract class SolrClient implements Serializable, Closeable {
     }
     reqParams.set("ids", (String[]) ids.toArray());
 
-    return query(reqParams).getResults();
+    return query(collection, reqParams).getResults();
+  }
+
+  /**
+   * Retrieves the SolrDocuments associated with the given identifiers and uses
+   * the SolrParams to execute the request.
+   *
+   * If a document was not found, it will not be added to the SolrDocumentList.
+   *
+   * @param ids the ids
+   * @param params additional parameters to add to the query
+   *
+   * @return a SolrDocumentList, or null if no documents were found
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
+   */
+  public SolrDocumentList getById(Collection<String> ids, SolrParams params) throws SolrServerException, IOException {
+    return getById(null, ids, params);
   }
-  
+
   /**
-   * SolrServer implementations need to implement how a request is actually processed
+   * Execute a request against a Solr server for a given collection
+   *
+   * @param request the request to execute
+   * @param collection the collection to execute the request against
+   *
+   * @return a {@link NamedList} containing the response from the server
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
+   */
+  public abstract NamedList<Object> request(final SolrRequest request, String collection)
+      throws SolrServerException, IOException;
+
+  /**
+   * Execute a request against a Solr server
+   *
+   * @param request the request to execute
+   *
+   * @return a {@link NamedList} containing the response from the server
+   *
+   * @throws IOException If there is a low-level I/O error.
+   * @throws SolrServerException if there is an error on the server
    */
-  public abstract NamedList<Object> request(final SolrRequest request) throws SolrServerException, IOException;
+  public final NamedList<Object> request(final SolrRequest request) throws SolrServerException, IOException {
+    return request(request, null);
+  }
 
+  /**
+   * Get the {@link org.apache.solr.client.solrj.beans.DocumentObjectBinder} for this client.
+   *
+   * @return a DocumentObjectBinder
+   *
+   * @see SolrClient#addBean
+   * @see SolrClient#addBeans
+   */
   public DocumentObjectBinder getBinder() {
     if(binder == null){
       binder = new DocumentObjectBinder();
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/SolrRequest.java b/solr/solrj/src/java/org/apache/solr/client/solrj/SolrRequest.java
index 6d4efb6..daba8ef 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/SolrRequest.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/SolrRequest.java
@@ -120,18 +120,36 @@ public abstract class SolrRequest<T extends SolrResponse> implements Serializabl
 
   /**
    * Send this request to a {@link SolrClient} and return the response
+   *
    * @param client the SolrClient to communicate with
+   * @param collection the collection to execute the request against
+   *
    * @return the response
+   *
    * @throws SolrServerException if there is an error on the Solr server
    * @throws IOException if there is a communication error
    */
-  public final T process(SolrClient client) throws SolrServerException, IOException {
+  public final T process(SolrClient client, String collection) throws SolrServerException, IOException {
     long startTime = TimeUnit.MILLISECONDS.convert(System.nanoTime(), TimeUnit.NANOSECONDS);
     T res = createResponse(client);
-    res.setResponse(client.request(this));
+    res.setResponse(client.request(this, collection));
     long endTime = TimeUnit.MILLISECONDS.convert(System.nanoTime(), TimeUnit.NANOSECONDS);
     res.setElapsedTime(endTime - startTime);
     return res;
   }
 
+  /**
+   * Send this request to a {@link SolrClient} and return the response
+   *
+   * @param client the SolrClient to communicate with
+   *
+   * @return the response
+   *
+   * @throws SolrServerException if there is an error on the Solr server
+   * @throws IOException if there is a communication error
+   */
+  public final T process(SolrClient client) throws SolrServerException, IOException {
+    return process(client, null);
+  }
+
 }
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient.java b/solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient.java
index e238091..0cfbb9a 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient.java
@@ -501,7 +501,7 @@ public class CloudSolrClient extends SolrClient {
     zkStateReader.getConfigManager().downloadConfigDir(configName, downloadPath);
   }
 
-  private NamedList<Object> directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {
+  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {
     UpdateRequest updateRequest = (UpdateRequest) request;
     ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();
     ModifiableSolrParams routableParams = new ModifiableSolrParams();
@@ -515,7 +515,6 @@ public class CloudSolrClient extends SolrClient {
       }
     }
 
-    String collection = nonRoutableParams.get(UpdateParams.COLLECTION, defaultCollection);
     if (collection == null) {
       throw new SolrServerException("No collection param specified on request and no default collection has been set.");
     }
@@ -747,9 +746,11 @@ public class CloudSolrClient extends SolrClient {
   }
 
   @Override
-  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {
+  public NamedList<Object> request(SolrRequest request, String collection) throws SolrServerException, IOException {
     SolrParams reqParams = request.getParams();
-    String collection = (reqParams != null) ? reqParams.get("collection", getDefaultCollection()) : getDefaultCollection();
+
+    if (collection == null)
+      collection = (reqParams != null) ? reqParams.get("collection", getDefaultCollection()) : getDefaultCollection();
     return requestWithRetryOnStaleState(request, 0, collection);
   }
 
@@ -807,7 +808,7 @@ public class CloudSolrClient extends SolrClient {
 
     NamedList<Object> resp = null;
     try {
-      resp = sendRequest(request);
+      resp = sendRequest(request, collection);
       //to avoid an O(n) operation we always add STATE_VERSION to the last and try to read it from there
       Object o = resp.get(STATE_VERSION, resp.size()-1);
       if(o != null && o instanceof Map) {
@@ -905,7 +906,7 @@ public class CloudSolrClient extends SolrClient {
     return resp;
   }
 
-  protected NamedList<Object> sendRequest(SolrRequest request)
+  protected NamedList<Object> sendRequest(SolrRequest request, String collection)
       throws SolrServerException, IOException {
     connect();
     
@@ -916,8 +917,7 @@ public class CloudSolrClient extends SolrClient {
     
     if (request instanceof IsUpdateRequest) {
       if (request instanceof UpdateRequest) {
-        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request,
-            clusterState);
+        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection, clusterState);
         if (response != null) {
           return response;
         }
@@ -938,7 +938,6 @@ public class CloudSolrClient extends SolrClient {
         theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));
       }
     } else {
-      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);
       
       if (collection == null) {
         throw new SolrServerException(
@@ -983,22 +982,18 @@ public class CloudSolrClient extends SolrClient {
           if (!liveNodes.contains(coreNodeProps.getNodeName())
               || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;
           if (nodes.put(node, nodeProps) == null) {
-            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {
+            if (!sendToLeaders || coreNodeProps.isLeader()) {
               String url;
               if (reqParams.get(UpdateParams.COLLECTION) == null) {
-                url = ZkCoreNodeProps.getCoreUrl(
-                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),
-                    defaultCollection);
+                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);
               } else {
                 url = coreNodeProps.getCoreUrl();
               }
               urlList2.add(url);
-            } else if (sendToLeaders) {
+            } else {
               String url;
               if (reqParams.get(UpdateParams.COLLECTION) == null) {
-                url = ZkCoreNodeProps.getCoreUrl(
-                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),
-                    defaultCollection);
+                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);
               } else {
                 url = coreNodeProps.getCoreUrl();
               }
@@ -1039,7 +1034,7 @@ public class CloudSolrClient extends SolrClient {
       }
       
     }
-    
+
     LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);
     LBHttpSolrClient.Rsp rsp = lbClient.request(req);
     return rsp.getResponse();
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.java b/solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.java
index 3e61c9d..cc005fe 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.java
@@ -291,10 +291,10 @@ public class ConcurrentUpdateSolrClient extends SolrClient {
   }
 
   @Override
-  public NamedList<Object> request(final SolrRequest request)
+  public NamedList<Object> request(final SolrRequest request, String collection)
       throws SolrServerException, IOException {
     if (!(request instanceof UpdateRequest)) {
-      return client.request(request);
+      return client.request(request, collection);
     }
     UpdateRequest req = (UpdateRequest) request;
 
@@ -305,13 +305,13 @@ public class ConcurrentUpdateSolrClient extends SolrClient {
           && (req.getDeleteByIdMap() == null || req.getDeleteByIdMap().isEmpty())) {
         if (req.getDeleteQuery() == null) {
           blockUntilFinished();
-          return client.request(request);
+          return client.request(request, collection);
         }
       }
     } else {
       if ((req.getDocuments() == null || req.getDocuments().isEmpty())) {
         blockUntilFinished();
-        return client.request(request);
+        return client.request(request, collection);
       }
     }
 
@@ -322,7 +322,7 @@ public class ConcurrentUpdateSolrClient extends SolrClient {
       if (params.getBool(UpdateParams.WAIT_SEARCHER, false)) {
         log.info("blocking for commit/optimize");
         blockUntilFinished(); // empty the queue
-        return client.request(request);
+        return client.request(request, collection);
       }
     }
 
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrClient.java b/solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrClient.java
index 0499abb..9b6873e 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrClient.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrClient.java
@@ -43,15 +43,12 @@ import org.apache.http.message.BasicHeader;
 import org.apache.http.message.BasicNameValuePair;
 import org.apache.http.util.EntityUtils;
 import org.apache.solr.client.solrj.ResponseParser;
-import org.apache.solr.client.solrj.SolrRequest;
 import org.apache.solr.client.solrj.SolrClient;
+import org.apache.solr.client.solrj.SolrRequest;
 import org.apache.solr.client.solrj.SolrServerException;
 import org.apache.solr.client.solrj.request.RequestWriter;
-import org.apache.solr.client.solrj.request.UpdateRequest;
-import org.apache.solr.client.solrj.response.UpdateResponse;
 import org.apache.solr.client.solrj.util.ClientUtils;
 import org.apache.solr.common.SolrException;
-import org.apache.solr.common.SolrInputDocument;
 import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.ModifiableSolrParams;
 import org.apache.solr.common.params.SolrParams;
@@ -201,7 +198,7 @@ public class HttpSolrClient extends SolrClient {
    *      org.apache.solr.client.solrj.ResponseParser)
    */
   @Override
-  public NamedList<Object> request(final SolrRequest request)
+  public NamedList<Object> request(final SolrRequest request, String collection)
       throws SolrServerException, IOException {
     ResponseParser responseParser = request.getResponseParser();
     if (responseParser == null) {
@@ -701,54 +698,6 @@ public class HttpSolrClient extends SolrClient {
   }
   
   /**
-   * Adds the documents supplied by the given iterator.
-   * 
-   * @param docIterator
-   *          the iterator which returns SolrInputDocument instances
-   * 
-   * @return the response from the SolrServer
-   */
-  public UpdateResponse add(Iterator<SolrInputDocument> docIterator)
-      throws SolrServerException, IOException {
-    UpdateRequest req = new UpdateRequest();
-    req.setDocIterator(docIterator);
-    return req.process(this);
-  }
-  
-  /**
-   * Adds the beans supplied by the given iterator.
-   * 
-   * @param beanIterator
-   *          the iterator which returns Beans
-   * 
-   * @return the response from the SolrServer
-   */
-  public UpdateResponse addBeans(final Iterator<?> beanIterator)
-      throws SolrServerException, IOException {
-    UpdateRequest req = new UpdateRequest();
-    req.setDocIterator(new Iterator<SolrInputDocument>() {
-      
-      @Override
-      public boolean hasNext() {
-        return beanIterator.hasNext();
-      }
-      
-      @Override
-      public SolrInputDocument next() {
-        Object o = beanIterator.next();
-        if (o == null) return null;
-        return getBinder().toSolrInputDocument(o);
-      }
-      
-      @Override
-      public void remove() {
-        beanIterator.remove();
-      }
-    });
-    return req.process(this);
-  }
-  
-  /**
    * Close the {@link ClientConnectionManager} from the internal client.
    */
   @Override
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/impl/LBHttpSolrClient.java b/solr/solrj/src/java/org/apache/solr/client/solrj/impl/LBHttpSolrClient.java
index c6c591d..88dcd0b 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/impl/LBHttpSolrClient.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/impl/LBHttpSolrClient.java
@@ -367,7 +367,7 @@ public class LBHttpSolrClient extends SolrClient {
       boolean isZombie, String zombieKey) throws SolrServerException, IOException {
     Exception ex = null;
     try {
-      rsp.rsp = client.request(req.getRequest());
+      rsp.rsp = client.request(req.getRequest(), (String) null);
       if (isZombie) {
         zombieServers.remove(zombieKey);
       }
@@ -491,7 +491,7 @@ public class LBHttpSolrClient extends SolrClient {
    * @throws IOException If there is a low-level I/O error.
    */
   @Override
-  public NamedList<Object> request(final SolrRequest request)
+  public NamedList<Object> request(final SolrRequest request, String collection)
           throws SolrServerException, IOException {
     Exception ex = null;
     ServerWrapper[] serverList = aliveServerList;
@@ -511,7 +511,7 @@ public class LBHttpSolrClient extends SolrClient {
       wrapper.lastUsed = System.currentTimeMillis();
 
       try {
-        return wrapper.client.request(request);
+        return wrapper.client.request(request, collection);
       } catch (SolrException e) {
         // Server is alive but the request was malformed or invalid
         throw e;
@@ -537,7 +537,7 @@ public class LBHttpSolrClient extends SolrClient {
       
       if (wrapper.standard==false || justFailed!=null && justFailed.containsKey(wrapper.getKey())) continue;
       try {
-        NamedList<Object> rsp = wrapper.client.request(request);
+        NamedList<Object> rsp = wrapper.client.request(request, collection);
         // remove from zombie list *before* adding to alive to avoid a race that could lose a server
         zombieServers.remove(wrapper.getKey());
         addToAlive(wrapper);
diff --git a/solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest.java b/solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest.java
index bc19c6f..82237e6 100644
--- a/solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest.java
+++ b/solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest.java
@@ -17,12 +17,6 @@ package org.apache.solr.client.solrj.impl;
  * limitations under the License.
  */
 
-import static org.apache.solr.cloud.OverseerCollectionProcessor.CREATE_NODE_SET;
-import static org.apache.solr.cloud.OverseerCollectionProcessor.NUM_SLICES;
-import static org.apache.solr.common.cloud.ZkNodeProps.makeMap;
-import static org.apache.solr.common.cloud.ZkStateReader.MAX_SHARDS_PER_NODE;
-import static org.apache.solr.common.cloud.ZkStateReader.REPLICATION_FACTOR;
-
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
@@ -72,6 +66,11 @@ import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.TimeoutException;
 
+import static org.apache.solr.cloud.OverseerCollectionProcessor.NUM_SLICES;
+import static org.apache.solr.common.cloud.ZkNodeProps.makeMap;
+import static org.apache.solr.common.cloud.ZkStateReader.MAX_SHARDS_PER_NODE;
+import static org.apache.solr.common.cloud.ZkStateReader.REPLICATION_FACTOR;
+
 
 /**
  * This test would be faster if we simulated the zk state instead.
@@ -122,6 +121,7 @@ public class CloudSolrClientTest extends AbstractFullDistribZkTestBase {
 
   @Test
   public void test() throws Exception {
+    checkCollectionParameters();
     allTests();
     stateVersionParamTest();
     customHttpClientTest();
@@ -498,6 +498,44 @@ public class CloudSolrClientTest extends AbstractFullDistribZkTestBase {
     indexDoc(doc);
   }
 
+  private void checkCollectionParameters() throws Exception {
+
+    try (CloudSolrClient client = createCloudClient("multicollection1")) {
+
+      createCollection("multicollection1", client, 2, 2);
+      createCollection("multicollection2", client, 2, 2);
+      waitForRecoveriesToFinish("multicollection1", false);
+      waitForRecoveriesToFinish("multicollection2", false);
+
+      List<SolrInputDocument> docs = new ArrayList<>(3);
+      for (int i = 0; i < 3; i++) {
+        SolrInputDocument doc = new SolrInputDocument();
+        doc.addField(id, Integer.toString(i));
+        doc.addField("a_t", "hello");
+        docs.add(doc);
+      }
+
+      client.add(docs);     // default - will add them to multicollection1
+      client.commit();
+
+      ModifiableSolrParams queryParams = new ModifiableSolrParams();
+      queryParams.add("q", "*:*");
+      assertEquals(3, client.query(queryParams).getResults().size());
+      assertEquals(0, client.query("multicollection2", queryParams).getResults().size());
+
+      SolrQuery query = new SolrQuery("*:*");
+      query.set("collection", "multicollection2");
+      assertEquals(0, client.query(query).getResults().size());
+
+      client.add("multicollection2", docs);
+      client.commit("multicollection2");
+
+      assertEquals(3, client.query("multicollection2", queryParams).getResults().size());
+
+    }
+
+  }
+
   private void stateVersionParamTest() throws Exception {
 
     try (CloudSolrClient client = createCloudClient(null)) {

