GitDiffStart: 597912787c3f7171ffbca0f3d6ba9629432ca20e | Wed Apr 9 19:48:14 2014 +0000
diff --git a/solr/CHANGES.txt b/solr/CHANGES.txt
index f7001bc..e2789af 100644
--- a/solr/CHANGES.txt
+++ b/solr/CHANGES.txt
@@ -41,6 +41,13 @@ Upgrading from Solr 4.x
   update your configs to use <arr name="fieldName"> instead. See SOLR-4249 for more 
   details.
 
+* The following legacy numeric and date field types, deprecated in Solr 4.8, are no
+  longer supported: BCDIntField, BCDLongField, BCDStrField, IntField, LongField,
+  FloatField, DoubleField, SortableIntField, SortableLongField, SortableFloatField,
+  SortableDoubleField, and DateField.  Convert these types in your schema to the
+  corresponding Trie-based field type and then re-index.  See SOLR-5936 for more
+  information.
+
 Detailed Change List
 ----------------------
 
@@ -66,6 +73,9 @@ Other Changes
 
 * SOLR-4792: Stop shipping a .war. (Robert Muir)
 
+* SOLR-5936: Removed deprecated non-Trie-based numeric & date field types.
+  (Steve Rowe)
+
 ==================  4.8.0 ==================
 
 Versions of Major Components
@@ -277,6 +287,8 @@ Other Changes
 * SOLR-5914: Cleanup and fix Solr's test cleanup code. 
  (Mark Miller, Uwe Schindler)
 
+* SOLR-5936: Deprecate non-Trie-based numeric & date field types. (Steve Rowe)
+
 * SOLR-5934: LBHttpSolrServer exception handling improvement and small test
   improvements. (Gregory Chanan via Mark Miller)
 
diff --git a/solr/contrib/clustering/src/test-files/clustering/solr/collection1/conf/schema.xml b/solr/contrib/clustering/src/test-files/clustering/solr/collection1/conf/schema.xml
index 27b9655..981577c 100644
--- a/solr/contrib/clustering/src/test-files/clustering/solr/collection1/conf/schema.xml
+++ b/solr/contrib/clustering/src/test-files/clustering/solr/collection1/conf/schema.xml
@@ -67,26 +67,30 @@
        - If sortMissingLast="false" and sortMissingFirst="false" (the default),
          then default lucene sorting will be used which places docs without the
          field first in an ascending sort and last in a descending sort.
-    -->    
-
-
-    <!-- numeric field types that store and index the text
-         value verbatim (and hence don't support range queries, since the
-         lexicographic ordering isn't equal to the numeric ordering) -->
-    <fieldType name="integer" class="solr.IntField" omitNorms="true"/>
-    <fieldType name="long" class="solr.LongField" omitNorms="true"/>
-    <fieldType name="float" class="solr.FloatField" omitNorms="true"/>
-    <fieldType name="double" class="solr.DoubleField" omitNorms="true"/>
+    -->
 
+    <!--
+      Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
+    -->
+    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
+    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
+    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
 
-    <!-- Numeric field types that manipulate the value into
-         a string value that isn't human-readable in its internal form,
-         but with a lexicographic ordering the same as the numeric ordering,
-         so that range queries work correctly. -->
-    <fieldType name="sint" class="solr.SortableIntField" sortMissingLast="true" omitNorms="true"/>
-    <fieldType name="slong" class="solr.SortableLongField" sortMissingLast="true" omitNorms="true"/>
-    <fieldType name="sfloat" class="solr.SortableFloatField" sortMissingLast="true" omitNorms="true"/>
-    <fieldType name="sdouble" class="solr.SortableDoubleField" sortMissingLast="true" omitNorms="true"/>
+    <!--
+     Numeric field types that index each value at various levels of precision
+     to accelerate range queries when the number of values between the range
+     endpoints is large. See the javadoc for NumericRangeQuery for internal
+     implementation details.
+
+     Smaller precisionStep values (specified in bits) will lead to more tokens
+     indexed per value, slightly larger index size, and faster range queries.
+     A precisionStep of 0 disables indexing at different precision levels.
+    -->
+    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
+    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
+    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
+    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
 
 
     <!-- The format for this date field is of the form 1995-12-31T23:59:59Z, and
@@ -107,9 +111,9 @@
                   ... 6 months and 3 days in the future from the start of
                       the current day
                       
-         Consult the DateField javadocs for more information.
+         Consult the TrieDateField javadocs for more information.
       -->
-    <fieldType name="date" class="solr.DateField" sortMissingLast="true" omitNorms="true"/>
+    <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true" omitNorms="true"/>
 
 
     <!-- The "RandomSortField" is not used to store or search any
@@ -290,13 +294,13 @@
         EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
         Longer patterns will be matched first.  if equal size patterns
         both match, the first appearing in the schema will be used.  -->
-   <dynamicField name="*_i"  type="sint"    indexed="true"  stored="true"/>
+   <dynamicField name="*_i"  type="int"    indexed="true"  stored="true"/>
    <dynamicField name="*_s"  type="string"  indexed="true"  stored="true"/>
-   <dynamicField name="*_l"  type="slong"   indexed="true"  stored="true"/>
+   <dynamicField name="*_l"  type="long"   indexed="true"  stored="true"/>
    <dynamicField name="*_t"  type="text"    indexed="true"  stored="true"/>
    <dynamicField name="*_b"  type="boolean" indexed="true"  stored="true"/>
-   <dynamicField name="*_f"  type="sfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_d"  type="sdouble" indexed="true"  stored="true"/>
+   <dynamicField name="*_f"  type="float"  indexed="true"  stored="true"/>
+   <dynamicField name="*_d"  type="double" indexed="true"  stored="true"/>
    <dynamicField name="*_dt" type="date"    indexed="true"  stored="true"/>
 
    <dynamicField name="random*" type="random" />
diff --git a/solr/contrib/dataimporthandler-extras/src/test-files/dihextras/solr/collection1/conf/dataimport-schema-no-unique-key.xml b/solr/contrib/dataimporthandler-extras/src/test-files/dihextras/solr/collection1/conf/dataimport-schema-no-unique-key.xml
index e502f74..b4c4db0 100644
--- a/solr/contrib/dataimporthandler-extras/src/test-files/dihextras/solr/collection1/conf/dataimport-schema-no-unique-key.xml
+++ b/solr/contrib/dataimporthandler-extras/src/test-files/dihextras/solr/collection1/conf/dataimport-schema-no-unique-key.xml
@@ -67,26 +67,31 @@
        - If sortMissingLast="false" and sortMissingFirst="false" (the default),
          then default lucene sorting will be used which places docs without the
          field first in an ascending sort and last in a descending sort.
-    -->    
-
-
-    <!-- numeric field types that store and index the text
-         value verbatim (and hence don't support range queries, since the
-         lexicographic ordering isn't equal to the numeric ordering) -->
-    <fieldType name="integer" class="solr.IntField" omitNorms="true"/>
-    <fieldType name="long" class="solr.LongField" omitNorms="true"/>
-    <fieldType name="float" class="solr.FloatField" omitNorms="true"/>
-    <fieldType name="double" class="solr.DoubleField" omitNorms="true"/>
+    -->
 
 
-    <!-- Numeric field types that manipulate the value into
-         a string value that isn't human-readable in its internal form,
-         but with a lexicographic ordering the same as the numeric ordering,
-         so that range queries work correctly. -->
-    <fieldType name="sint" class="solr.SortableIntField" sortMissingLast="true" omitNorms="true"/>
-    <fieldType name="slong" class="solr.SortableLongField" sortMissingLast="true" omitNorms="true"/>
-    <fieldType name="sfloat" class="solr.SortableFloatField" sortMissingLast="true" omitNorms="true"/>
-    <fieldType name="sdouble" class="solr.SortableDoubleField" sortMissingLast="true" omitNorms="true"/>
+    <!--
+      Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
+    -->
+    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
+    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
+    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
+
+    <!--
+     Numeric field types that index each value at various levels of precision
+     to accelerate range queries when the number of values between the range
+     endpoints is large. See the javadoc for NumericRangeQuery for internal
+     implementation details.
+
+     Smaller precisionStep values (specified in bits) will lead to more tokens
+     indexed per value, slightly larger index size, and faster range queries.
+     A precisionStep of 0 disables indexing at different precision levels.
+    -->
+    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
+    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
+    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
+    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
 
 
     <!-- The format for this date field is of the form 1995-12-31T23:59:59Z, and
@@ -107,9 +112,9 @@
                   ... 6 months and 3 days in the future from the start of
                       the current day
                       
-         Consult the DateField javadocs for more information.
+         Consult the TrieDateField javadocs for more information.
       -->
-    <fieldType name="date" class="solr.DateField" sortMissingLast="true" omitNorms="true"/>
+    <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true" omitNorms="true"/>
 
 
     <!-- The "RandomSortField" is not used to store or search any
diff --git a/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/dataimport-schema.xml b/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/dataimport-schema.xml
index 5c87fb8..5ab14a5 100644
--- a/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/dataimport-schema.xml
+++ b/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/dataimport-schema.xml
@@ -6,7 +6,7 @@
     <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
     <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
     <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>  
-    <fieldType name="date" class="solr.DateField" sortMissingLast="true" omitNorms="true"/>
+    <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true" omitNorms="true"/>
     <fieldType name="text" class="solr.TextField" positionIncrementGap="100">
       <analyzer type="index">
         <tokenizer class="solr.MockTokenizerFactory"/>
diff --git a/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/dataimport-solr_id-schema.xml b/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/dataimport-solr_id-schema.xml
index 7bfd6c2..8eb1bde 100644
--- a/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/dataimport-solr_id-schema.xml
+++ b/solr/contrib/dataimporthandler/src/test-files/dih/solr/collection1/conf/dataimport-solr_id-schema.xml
@@ -67,26 +67,31 @@
        - If sortMissingLast="false" and sortMissingFirst="false" (the default),
          then default lucene sorting will be used which places docs without the
          field first in an ascending sort and last in a descending sort.
-    -->    
-
-
-    <!-- numeric field types that store and index the text
-         value verbatim (and hence don't support range queries, since the
-         lexicographic ordering isn't equal to the numeric ordering) -->
-    <fieldType name="integer" class="solr.IntField" omitNorms="true"/>
-    <fieldType name="long" class="solr.LongField" omitNorms="true"/>
-    <fieldType name="float" class="solr.FloatField" omitNorms="true"/>
-    <fieldType name="double" class="solr.DoubleField" omitNorms="true"/>
+    -->
 
 
-    <!-- Numeric field types that manipulate the value into
-         a string value that isn't human-readable in its internal form,
-         but with a lexicographic ordering the same as the numeric ordering,
-         so that range queries work correctly. -->
-    <fieldType name="sint" class="solr.SortableIntField" sortMissingLast="true" omitNorms="true"/>
-    <fieldType name="slong" class="solr.SortableLongField" sortMissingLast="true" omitNorms="true"/>
-    <fieldType name="sfloat" class="solr.SortableFloatField" sortMissingLast="true" omitNorms="true"/>
-    <fieldType name="sdouble" class="solr.SortableDoubleField" sortMissingLast="true" omitNorms="true"/>
+    <!--
+      Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
+    -->
+    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
+    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
+    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
+
+    <!--
+     Numeric field types that index each value at various levels of precision
+     to accelerate range queries when the number of values between the range
+     endpoints is large. See the javadoc for NumericRangeQuery for internal
+     implementation details.
+
+     Smaller precisionStep values (specified in bits) will lead to more tokens
+     indexed per value, slightly larger index size, and faster range queries.
+     A precisionStep of 0 disables indexing at different precision levels.
+    -->
+    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
+    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
+    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
+    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
 
 
     <!-- The format for this date field is of the form 1995-12-31T23:59:59Z, and
@@ -107,9 +112,9 @@
                   ... 6 months and 3 days in the future from the start of
                       the current day
                       
-         Consult the DateField javadocs for more information.
+         Consult the TrieDateField javadocs for more information.
       -->
-    <fieldType name="date" class="solr.DateField" sortMissingLast="true" omitNorms="true"/>
+    <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true" omitNorms="true"/>
 
 
     <!-- The "RandomSortField" is not used to store or search any
@@ -271,13 +276,13 @@
         EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
         Longer patterns will be matched first.  if equal size patterns
         both match, the first appearing in the schema will be used.  -->
-   <dynamicField name="*_i"  type="sint"    indexed="true"  stored="true"/>
+   <dynamicField name="*_i"  type="int"    indexed="true"  stored="true"/>
    <dynamicField name="*_s"  type="string"  indexed="true"  stored="true"/>
-   <dynamicField name="*_l"  type="slong"   indexed="true"  stored="true"/>
+   <dynamicField name="*_l"  type="long"   indexed="true"  stored="true"/>
    <dynamicField name="*_t"  type="text"    indexed="true"  stored="true"/>
    <dynamicField name="*_b"  type="boolean" indexed="true"  stored="true"/>
-   <dynamicField name="*_f"  type="sfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_d"  type="sdouble" indexed="true"  stored="true"/>
+   <dynamicField name="*_f"  type="float"  indexed="true"  stored="true"/>
+   <dynamicField name="*_d"  type="double" indexed="true"  stored="true"/>
    <dynamicField name="*_dt" type="date"    indexed="true"  stored="true"/>
 
    <dynamicField name="random*" type="random" />
diff --git a/solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/SolrContentHandler.java b/solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/SolrContentHandler.java
index e4bd7e0..4484bc5 100644
--- a/solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/SolrContentHandler.java
+++ b/solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/SolrContentHandler.java
@@ -20,9 +20,9 @@ package org.apache.solr.handler.extraction;
 import org.apache.solr.common.SolrInputDocument;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.DateUtil;
-import org.apache.solr.schema.DateField;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.schema.SchemaField;
+import org.apache.solr.schema.TrieDateField;
 import org.apache.tika.metadata.Metadata;
 import org.apache.tika.metadata.TikaMetadataKeys;
 import org.slf4j.Logger;
@@ -322,7 +322,7 @@ public class SolrContentHandler extends DefaultHandler implements ExtractingPara
    */
   protected String transformValue(String val, SchemaField schFld) {
     String result = val;
-    if (schFld != null && schFld.getType() instanceof DateField) {
+    if (schFld != null && schFld.getType() instanceof TrieDateField) {
       //try to transform the date
       try {
         Date date = DateUtil.parseDate(val, dateFormats);
diff --git a/solr/contrib/extraction/src/test-files/extraction/solr/collection1/conf/schema.xml b/solr/contrib/extraction/src/test-files/extraction/solr/collection1/conf/schema.xml
index 61b2f3f..d751ed0 100644
--- a/solr/contrib/extraction/src/test-files/extraction/solr/collection1/conf/schema.xml
+++ b/solr/contrib/extraction/src/test-files/extraction/solr/collection1/conf/schema.xml
@@ -28,47 +28,28 @@
 <schema name="test" version="1.0">
   <types>
 
-    <!-- field type definitions... note that the "name" attribute is
-         just a label to be used by field definitions.  The "class"
-         attribute and any other attributes determine the real type and
-         behavior of the fieldtype.
-      -->
-
-    <!-- numeric field types that store and index the text
-         value verbatim (and hence don't sort correctly or support range queries.)
-         These are provided more for backward compatability, allowing one
-         to create a schema that matches an existing lucene index.
+    <!--
+      Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
     -->
-    <fieldType name="integer" class="solr.IntField"/>
-    <fieldType name="long" class="solr.LongField"/>
-    <fieldtype name="float" class="solr.FloatField"/>
-    <fieldType name="double" class="solr.DoubleField"/>
-
-    <!-- numeric field types that manipulate the value into
-       a string value that isn't human readable in it's internal form,
-       but sorts correctly and supports range queries.
-
-         If sortMissingLast="true" then a sort on this field will cause documents
-       without the field to come after documents with the field,
-       regardless of the requested sort order.
-         If sortMissingFirst="true" then a sort on this field will cause documents
-       without the field to come before documents with the field,
-       regardless of the requested sort order.
-         If sortMissingLast="false" and sortMissingFirst="false" (the default),
-       then default lucene sorting will be used which places docs without the field
-       first in an ascending sort and last in a descending sort.
-    -->
-    <fieldtype name="sint" class="solr.SortableIntField" sortMissingLast="true"/>
-    <fieldtype name="slong" class="solr.SortableLongField" sortMissingLast="true"/>
-    <fieldtype name="sfloat" class="solr.SortableFloatField" sortMissingLast="true"/>
-    <fieldtype name="sdouble" class="solr.SortableDoubleField" sortMissingLast="true"/>
-
-    <!-- bcd versions of sortable numeric type may provide smaller
-         storage space and support very large numbers.
+    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
+    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
+    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
+
+    <!--
+     Numeric field types that index each value at various levels of precision
+     to accelerate range queries when the number of values between the range
+     endpoints is large. See the javadoc for NumericRangeQuery for internal
+     implementation details.
+
+     Smaller precisionStep values (specified in bits) will lead to more tokens
+     indexed per value, slightly larger index size, and faster range queries.
+     A precisionStep of 0 disables indexing at different precision levels.
     -->
-    <fieldtype name="bcdint" class="solr.BCDIntField" sortMissingLast="true"/>
-    <fieldtype name="bcdlong" class="solr.BCDLongField" sortMissingLast="true"/>
-    <fieldtype name="bcdstr" class="solr.BCDStrField" sortMissingLast="true"/>
+    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
+    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
+    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
+    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
 
     <!-- Field type demonstrating an Analyzer failure -->
     <fieldtype name="failtype1" class="solr.TextField">
@@ -106,7 +87,7 @@
     <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
          seconds part (.999) is optional.
       -->
-    <fieldtype name="date" class="solr.DateField" sortMissingLast="true"/>
+    <fieldtype name="date" class="solr.TrieDateField" sortMissingLast="true" omitNorms="true"/>
 
     <!-- solr.TextField allows the specification of custom
          text analyzers specified as a tokenizer and a list
@@ -339,8 +320,8 @@
    <field name="bind" type="boolean" indexed="true" stored="false"/>
    <field name="bsto" type="boolean" indexed="false" stored="true"/>
    <field name="bindsto" type="boolean" indexed="true" stored="true"/>
-   <field name="isto" type="integer" indexed="false" stored="true"/>
-   <field name="iind" type="integer" indexed="true" stored="false"/>
+   <field name="isto" type="int" indexed="false" stored="true"/>
+   <field name="iind" type="int" indexed="true" stored="false"/>
    <field name="ssto" type="string" indexed="false" stored="true"/>
    <field name="sind" type="string" indexed="true" stored="false"/>
    <field name="sindsto" type="string" indexed="true" stored="true"/>
@@ -392,7 +373,7 @@
    
    <field name="timestamp" type="date" indexed="true" stored="true" default="NOW" multiValued="false"/>
    <field name="multiDefault" type="string" indexed="true" stored="true" default="muLti-Default" multiValued="true"/>
-   <field name="intDefault" type="sint" indexed="true" stored="true" default="42" multiValued="false"/>
+   <field name="intDefault" type="int" indexed="true" stored="true" default="42" multiValued="false"/>
    
    <field name="extractedDate" type="date" indexed="true" stored="true" multiValued="true"/>
    <field name="extractedContent" type="text" indexed="true" stored="true" multiValued="true"/>
@@ -416,16 +397,15 @@
         Longer patterns will be matched first.  if equal size patterns
         both match, the first appearing in the schema will be used.
    -->
-   <dynamicField name="*_i"  type="sint"    indexed="true"  stored="true"/>
+   <dynamicField name="*_i"  type="int"    indexed="true"  stored="true"/>
    <dynamicField name="*_s"  type="string"  indexed="true"  stored="true"/>
    <dynamicField name="*_s1"  type="string"  indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_l"  type="slong"   indexed="true"  stored="true"/>
+   <dynamicField name="*_l"  type="long"   indexed="true"  stored="true"/>
    <dynamicField name="*_t"  type="text"    indexed="true"  stored="true"/>
    <dynamicField name="*_b"  type="boolean" indexed="true"  stored="true"/>
-   <dynamicField name="*_f"  type="sfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_d"  type="sdouble" indexed="true"  stored="true"/>
+   <dynamicField name="*_f"  type="float"  indexed="true"  stored="true"/>
+   <dynamicField name="*_d"  type="double" indexed="true"  stored="true"/>
    <dynamicField name="*_dt" type="date"    indexed="true"  stored="true"/>
-   <dynamicField name="*_bcd" type="bcdstr" indexed="true"  stored="true"/>
 
    <dynamicField name="*_sI" type="string"  indexed="true"  stored="false"/>
    <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
@@ -443,7 +423,7 @@
   
    <!-- for testing to ensure that longer patterns are matched first -->
    <dynamicField name="*aa"  type="string"  indexed="true" stored="true"/>
-   <dynamicField name="*aaa" type="integer" indexed="false" stored="true"/>
+   <dynamicField name="*aaa" type="int" indexed="false" stored="true"/>
 
    <!-- ignored because not stored or indexed -->
    <dynamicField name="ignored_*" type="text" indexed="false" stored="false"/>
diff --git a/solr/contrib/morphlines-core/src/test-files/solr/collection1/conf/schema.xml b/solr/contrib/morphlines-core/src/test-files/solr/collection1/conf/schema.xml
index ae2c56d..a1c6787 100644
--- a/solr/contrib/morphlines-core/src/test-files/solr/collection1/conf/schema.xml
+++ b/solr/contrib/morphlines-core/src/test-files/solr/collection1/conf/schema.xml
@@ -238,7 +238,7 @@
                   ... 6 months and 3 days in the future from the start of
                       the current day
                       
-         Consult the DateField javadocs for more information.
+         Consult the TrieDateField javadocs for more information.
 
          Note: For faster range queries, consider the tdate type
       -->
@@ -251,21 +251,6 @@
     <!--Binary data type. The data should be sent/retrieved in as Base64 encoded Strings -->
     <fieldtype name="binary" class="solr.BinaryField"/>
 
-    <!--
-      Note:
-      These should only be used for compatibility with existing indexes (created with lucene or older Solr versions).
-      Use Trie based fields instead. As of Solr 3.5 and 4.x, Trie based fields support sortMissingFirst/Last
-      
-      Plain numeric field types that store and index the text
-      value verbatim (and hence don't correctly support range queries, since the
-      lexicographic ordering isn't equal to the numeric ordering)
-    -->
-    <fieldType name="pint" class="solr.IntField"/>
-    <fieldType name="plong" class="solr.LongField"/>
-    <fieldType name="pfloat" class="solr.FloatField"/>
-    <fieldType name="pdouble" class="solr.DoubleField"/>
-    <fieldType name="pdate" class="solr.DateField" sortMissingLast="true"/>
-
     <!-- The "RandomSortField" is not used to store or search any
          data.  You can declare fields of this type it in your schema
          to generate pseudo-random orderings of your docs for sorting 
diff --git a/solr/contrib/morphlines-core/src/test-files/solr/minimr/conf/schema.xml b/solr/contrib/morphlines-core/src/test-files/solr/minimr/conf/schema.xml
index 65192ef..c32d13f 100644
--- a/solr/contrib/morphlines-core/src/test-files/solr/minimr/conf/schema.xml
+++ b/solr/contrib/morphlines-core/src/test-files/solr/minimr/conf/schema.xml
@@ -253,7 +253,7 @@
                   ... 6 months and 3 days in the future from the start of
                       the current day
                       
-         Consult the DateField javadocs for more information.
+         Consult the TrieDateField javadocs for more information.
 
          Note: For faster range queries, consider the tdate type
       -->
@@ -266,21 +266,6 @@
     <!--Binary data type. The data should be sent/retrieved in as Base64 encoded Strings -->
     <fieldtype name="binary" class="solr.BinaryField"/>
 
-    <!--
-      Note:
-      These should only be used for compatibility with existing indexes (created with lucene or older Solr versions).
-      Use Trie based fields instead. As of Solr 3.5 and 4.x, Trie based fields support sortMissingFirst/Last
-      
-      Plain numeric field types that store and index the text
-      value verbatim (and hence don't correctly support range queries, since the
-      lexicographic ordering isn't equal to the numeric ordering)
-    -->
-    <fieldType name="pint" class="solr.IntField"/>
-    <fieldType name="plong" class="solr.LongField"/>
-    <fieldType name="pfloat" class="solr.FloatField"/>
-    <fieldType name="pdouble" class="solr.DoubleField"/>
-    <fieldType name="pdate" class="solr.DateField" sortMissingLast="true"/>
-
     <!-- The "RandomSortField" is not used to store or search any
          data.  You can declare fields of this type it in your schema
          to generate pseudo-random orderings of your docs for sorting 
diff --git a/solr/contrib/morphlines-core/src/test-files/solr/mrunit/conf/schema.xml b/solr/contrib/morphlines-core/src/test-files/solr/mrunit/conf/schema.xml
index b133c13..5c04e77 100644
--- a/solr/contrib/morphlines-core/src/test-files/solr/mrunit/conf/schema.xml
+++ b/solr/contrib/morphlines-core/src/test-files/solr/mrunit/conf/schema.xml
@@ -253,7 +253,7 @@
                   ... 6 months and 3 days in the future from the start of
                       the current day
                       
-         Consult the DateField javadocs for more information.
+         Consult the TrieDateField javadocs for more information.
 
          Note: For faster range queries, consider the tdate type
       -->
@@ -266,21 +266,6 @@
     <!--Binary data type. The data should be sent/retrieved in as Base64 encoded Strings -->
     <fieldtype name="binary" class="solr.BinaryField"/>
 
-    <!--
-      Note:
-      These should only be used for compatibility with existing indexes (created with lucene or older Solr versions).
-      Use Trie based fields instead. As of Solr 3.5 and 4.x, Trie based fields support sortMissingFirst/Last
-      
-      Plain numeric field types that store and index the text
-      value verbatim (and hence don't correctly support range queries, since the
-      lexicographic ordering isn't equal to the numeric ordering)
-    -->
-    <fieldType name="pint" class="solr.IntField"/>
-    <fieldType name="plong" class="solr.LongField"/>
-    <fieldType name="pfloat" class="solr.FloatField"/>
-    <fieldType name="pdouble" class="solr.DoubleField"/>
-    <fieldType name="pdate" class="solr.DateField" sortMissingLast="true"/>
-
     <!-- The "RandomSortField" is not used to store or search any
          data.  You can declare fields of this type it in your schema
          to generate pseudo-random orderings of your docs for sorting 
diff --git a/solr/contrib/morphlines-core/src/test-files/solr/solrcelltest/collection1/conf/schema.xml b/solr/contrib/morphlines-core/src/test-files/solr/solrcelltest/collection1/conf/schema.xml
index 83080df..709737a 100644
--- a/solr/contrib/morphlines-core/src/test-files/solr/solrcelltest/collection1/conf/schema.xml
+++ b/solr/contrib/morphlines-core/src/test-files/solr/solrcelltest/collection1/conf/schema.xml
@@ -205,7 +205,7 @@
                   ... 6 months and 3 days in the future from the start of
                       the current day
                       
-         Consult the DateField javadocs for more information.
+         Consult the TrieDateField javadocs for more information.
 
          Note: For faster range queries, consider the tdate type
       -->
@@ -218,21 +218,6 @@
     <!--Binary data type. The data should be sent/retrieved in as Base64 encoded Strings -->
     <fieldtype name="binary" class="solr.BinaryField"/>
 
-    <!--
-      Note:
-      These should only be used for compatibility with existing indexes (created with lucene or older Solr versions).
-      Use Trie based fields instead. As of Solr 3.5 and 4.x, Trie based fields support sortMissingFirst/Last
-      
-      Plain numeric field types that store and index the text
-      value verbatim (and hence don't correctly support range queries, since the
-      lexicographic ordering isn't equal to the numeric ordering)
-    -->
-    <fieldType name="pint" class="solr.IntField"/>
-    <fieldType name="plong" class="solr.LongField"/>
-    <fieldType name="pfloat" class="solr.FloatField"/>
-    <fieldType name="pdouble" class="solr.DoubleField"/>
-    <fieldType name="pdate" class="solr.DateField" sortMissingLast="true"/>
-
     <!-- The "RandomSortField" is not used to store or search any
          data.  You can declare fields of this type it in your schema
          to generate pseudo-random orderings of your docs for sorting 
diff --git a/solr/contrib/uima/src/test-files/uima/solr/collection1/conf/schema.xml b/solr/contrib/uima/src/test-files/uima/solr/collection1/conf/schema.xml
index a9ec834..eb1ba78 100644
--- a/solr/contrib/uima/src/test-files/uima/solr/collection1/conf/schema.xml
+++ b/solr/contrib/uima/src/test-files/uima/solr/collection1/conf/schema.xml
@@ -79,11 +79,7 @@
     <fieldtype name="binary" class="solr.BinaryField" />
 
     <!--
-      The optional sortMissingLast and sortMissingFirst attributes are
-      currently supported on types that are sorted internally as
-      strings. This includes
-      "string","boolean","sint","slong","sfloat","sdouble","pdate" - If
-      sortMissingLast="true", then a sort on this field will cause
+      If sortMissingLast="true", then a sort on this field will cause
       documents without the field to come after documents with the
       field, regardless of the requested sort order (asc or desc). - If
       sortMissingFirst="true", then a sort on this field will cause
@@ -139,7 +135,7 @@
       ie... NOW/HOUR ... Round to the start of the current hour NOW-1DAY
       ... Exactly 1 day prior to now NOW/DAY+6MONTHS+3DAYS ... 6 months
       and 3 days in the future from the start of the current day Consult
-      the DateField javadocs for more information. Note: For faster
+      the TrieDateField javadocs for more information. Note: For faster
       range queries, consider the tdate type
     -->
     <fieldType name="date" class="solr.TrieDateField"
@@ -152,45 +148,6 @@
     <fieldType name="tdate" class="solr.TrieDateField"
       omitNorms="true" precisionStep="6" positionIncrementGap="0" />
 
-
-    <!--
-      Note: These should only be used for compatibility with existing
-      indexes (created with older Solr versions) or if
-      "sortMissingFirst" or "sortMissingLast" functionality is needed.
-      Use Trie based fields instead. Plain numeric field types that
-      store and index the text value verbatim (and hence don't support
-      range queries, since the lexicographic ordering isn't equal to the
-      numeric ordering)
-    -->
-    <fieldType name="pint" class="solr.IntField" omitNorms="true" />
-    <fieldType name="plong" class="solr.LongField" omitNorms="true" />
-    <fieldType name="pfloat" class="solr.FloatField"
-      omitNorms="true" />
-    <fieldType name="pdouble" class="solr.DoubleField"
-      omitNorms="true" />
-    <fieldType name="pdate" class="solr.DateField"
-      sortMissingLast="true" omitNorms="true" />
-
-
-    <!--
-      Note: These should only be used for compatibility with existing
-      indexes (created with older Solr versions) or if
-      "sortMissingFirst" or "sortMissingLast" functionality is needed.
-      Use Trie based fields instead. Numeric field types that manipulate
-      the value into a string value that isn't human-readable in its
-      internal form, but with a lexicographic ordering the same as the
-      numeric ordering, so that range queries work correctly.
-    -->
-    <fieldType name="sint" class="solr.SortableIntField"
-      sortMissingLast="true" omitNorms="true" />
-    <fieldType name="slong" class="solr.SortableLongField"
-      sortMissingLast="true" omitNorms="true" />
-    <fieldType name="sfloat" class="solr.SortableFloatField"
-      sortMissingLast="true" omitNorms="true" />
-    <fieldType name="sdouble" class="solr.SortableDoubleField"
-      sortMissingLast="true" omitNorms="true" />
-
-
     <!--
       The "RandomSortField" is not used to store or search any data. You
       can declare fields of this type it in your schema to generate
@@ -584,8 +541,7 @@
       <dynamicField name="*_tf" type="tfloat" indexed="true"
       stored="true"/> <dynamicField name="*_td" type="tdouble"
       indexed="true" stored="true"/> <dynamicField name="*_tdt"
-      type="tdate" indexed="true" stored="true"/> <dynamicField
-      name="*_pi" type="pint" indexed="true" stored="true"/>
+      type="tdate" indexed="true" stored="true"/>
 
       <dynamicField name="ignored_*" type="ignored" multiValued="true"/>
       <dynamicField name="attr_*" type="textgen" indexed="true"
diff --git a/solr/contrib/uima/src/test-files/uima/uima-tokenizers-schema.xml b/solr/contrib/uima/src/test-files/uima/uima-tokenizers-schema.xml
index af6928d..b361630 100644
--- a/solr/contrib/uima/src/test-files/uima/uima-tokenizers-schema.xml
+++ b/solr/contrib/uima/src/test-files/uima/uima-tokenizers-schema.xml
@@ -79,11 +79,7 @@
     <fieldtype name="binary" class="solr.BinaryField" />
 
     <!--
-      The optional sortMissingLast and sortMissingFirst attributes are
-      currently supported on types that are sorted internally as
-      strings. This includes
-      "string","boolean","sint","slong","sfloat","sdouble","pdate" - If
-      sortMissingLast="true", then a sort on this field will cause
+      If sortMissingLast="true", then a sort on this field will cause
       documents without the field to come after documents with the
       field, regardless of the requested sort order (asc or desc). - If
       sortMissingFirst="true", then a sort on this field will cause
@@ -139,7 +135,7 @@
       ie... NOW/HOUR ... Round to the start of the current hour NOW-1DAY
       ... Exactly 1 day prior to now NOW/DAY+6MONTHS+3DAYS ... 6 months
       and 3 days in the future from the start of the current day Consult
-      the DateField javadocs for more information. Note: For faster
+      the TrieDateField javadocs for more information. Note: For faster
       range queries, consider the tdate type
     -->
     <fieldType name="date" class="solr.TrieDateField"
@@ -152,45 +148,6 @@
     <fieldType name="tdate" class="solr.TrieDateField"
       omitNorms="true" precisionStep="6" positionIncrementGap="0" />
 
-
-    <!--
-      Note: These should only be used for compatibility with existing
-      indexes (created with older Solr versions) or if
-      "sortMissingFirst" or "sortMissingLast" functionality is needed.
-      Use Trie based fields instead. Plain numeric field types that
-      store and index the text value verbatim (and hence don't support
-      range queries, since the lexicographic ordering isn't equal to the
-      numeric ordering)
-    -->
-    <fieldType name="pint" class="solr.IntField" omitNorms="true" />
-    <fieldType name="plong" class="solr.LongField" omitNorms="true" />
-    <fieldType name="pfloat" class="solr.FloatField"
-      omitNorms="true" />
-    <fieldType name="pdouble" class="solr.DoubleField"
-      omitNorms="true" />
-    <fieldType name="pdate" class="solr.DateField"
-      sortMissingLast="true" omitNorms="true" />
-
-
-    <!--
-      Note: These should only be used for compatibility with existing
-      indexes (created with older Solr versions) or if
-      "sortMissingFirst" or "sortMissingLast" functionality is needed.
-      Use Trie based fields instead. Numeric field types that manipulate
-      the value into a string value that isn't human-readable in its
-      internal form, but with a lexicographic ordering the same as the
-      numeric ordering, so that range queries work correctly.
-    -->
-    <fieldType name="sint" class="solr.SortableIntField"
-      sortMissingLast="true" omitNorms="true" />
-    <fieldType name="slong" class="solr.SortableLongField"
-      sortMissingLast="true" omitNorms="true" />
-    <fieldType name="sfloat" class="solr.SortableFloatField"
-      sortMissingLast="true" omitNorms="true" />
-    <fieldType name="sdouble" class="solr.SortableDoubleField"
-      sortMissingLast="true" omitNorms="true" />
-
-
     <!--
       The "RandomSortField" is not used to store or search any data. You
       can declare fields of this type it in your schema to generate
@@ -585,8 +542,7 @@
       <dynamicField name="*_tf" type="tfloat" indexed="true"
       stored="true"/> <dynamicField name="*_td" type="tdouble"
       indexed="true" stored="true"/> <dynamicField name="*_tdt"
-      type="tdate" indexed="true" stored="true"/> <dynamicField
-      name="*_pi" type="pint" indexed="true" stored="true"/>
+      type="tdate" indexed="true" stored="true"/>
 
       <dynamicField name="ignored_*" type="ignored" multiValued="true"/>
       <dynamicField name="attr_*" type="textgen" indexed="true"
diff --git a/solr/core/src/java/org/apache/solr/analytics/util/RangeEndpointCalculator.java b/solr/core/src/java/org/apache/solr/analytics/util/RangeEndpointCalculator.java
index 83c9b7c..749e6f5 100644
--- a/solr/core/src/java/org/apache/solr/analytics/util/RangeEndpointCalculator.java
+++ b/solr/core/src/java/org/apache/solr/analytics/util/RangeEndpointCalculator.java
@@ -27,14 +27,13 @@ import org.apache.solr.analytics.request.RangeFacetRequest;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.params.FacetParams.FacetRangeInclude;
 import org.apache.solr.common.params.FacetParams.FacetRangeOther;
-import org.apache.solr.schema.DateField;
 import org.apache.solr.schema.FieldType;
 import org.apache.solr.schema.SchemaField;
+import org.apache.solr.schema.TrieDateField;
 import org.apache.solr.schema.TrieField;
 import org.apache.solr.util.DateMathParser;
 
 
-@SuppressWarnings("deprecation")
 public abstract class RangeEndpointCalculator<T extends Comparable<T>> {
   protected final SchemaField field;
   protected final RangeFacetRequest request;
@@ -248,7 +247,7 @@ public abstract class RangeEndpointCalculator<T extends Comparable<T>> {
         default:
           throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "Unable to range facet on tried field of unexpected type:" + sf.getName());
       }
-    } else if (ft instanceof DateField) {
+    } else if (ft instanceof TrieDateField) {
       calc = new DateRangeEndpointCalculator(request, null);
     } else {
       throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, "Unable to range facet on field:" + sf);
@@ -325,21 +324,19 @@ public abstract class RangeEndpointCalculator<T extends Comparable<T>> {
     public DateRangeEndpointCalculator(final RangeFacetRequest request, final Date now) { 
       super(request); 
       this.now = now;
-      if (! (field.getType() instanceof DateField) ) {
-        throw new IllegalArgumentException("SchemaField must use filed type extending DateField");
+      if (! (field.getType() instanceof TrieDateField) ) {
+        throw new IllegalArgumentException("SchemaField must use field type extending TrieDateField");
       }
     }
     
     @Override
-    @SuppressWarnings("deprecation")
     public String formatValue(Date val) {
-      return ((DateField)field.getType()).toExternal(val);
+      return ((TrieDateField)field.getType()).toExternal(val);
     }
     
     @Override
-    @SuppressWarnings("deprecation")
     protected Date parseVal(String rawval) {
-      return ((DateField)field.getType()).parseMath(now, rawval);
+      return ((TrieDateField)field.getType()).parseMath(now, rawval);
     }
     
     @Override
diff --git a/solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy.java b/solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy.java
index 20b51f5..bbe810c 100644
--- a/solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy.java
+++ b/solr/core/src/java/org/apache/solr/core/SolrDeletionPolicy.java
@@ -21,7 +21,7 @@ import org.apache.lucene.index.IndexDeletionPolicy;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.FSDirectory;
 import org.apache.solr.common.util.NamedList;
-import org.apache.solr.schema.DateField;
+import org.apache.solr.schema.TrieDateField;
 import org.apache.solr.util.DateMathParser;
 import org.apache.solr.util.plugin.NamedListInitializedPlugin;
 import org.slf4j.Logger;
@@ -174,7 +174,7 @@ public class SolrDeletionPolicy extends IndexDeletionPolicy implements NamedList
         try {
           if (maxCommitAge != null) {
             if (maxCommitAgeTimeStamp==-1) {
-              DateMathParser dmp = new DateMathParser(DateField.UTC, Locale.ROOT);
+              DateMathParser dmp = new DateMathParser(TrieDateField.UTC, Locale.ROOT);
               maxCommitAgeTimeStamp = dmp.parseMath(maxCommitAge).getTime();
             }
             if (IndexDeletionPolicyWrapper.getCommitTimestamp(commit) < maxCommitAgeTimeStamp) {
diff --git a/solr/core/src/java/org/apache/solr/handler/PingRequestHandler.java b/solr/core/src/java/org/apache/solr/handler/PingRequestHandler.java
index b1bc0f2..4c3a10e 100644
--- a/solr/core/src/java/org/apache/solr/handler/PingRequestHandler.java
+++ b/solr/core/src/java/org/apache/solr/handler/PingRequestHandler.java
@@ -28,11 +28,11 @@ import org.apache.solr.common.params.ModifiableSolrParams;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.core.SolrCore;
+import org.apache.solr.schema.TrieDateField;
 import org.apache.solr.util.plugin.SolrCoreAware;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrRequestHandler;
 import org.apache.solr.response.SolrQueryResponse;
-import org.apache.solr.schema.DateField;
 
 import org.apache.commons.io.FileUtils;
 
@@ -274,7 +274,7 @@ public class PingRequestHandler extends RequestHandlerBase implements SolrCoreAw
       try {
         // write out when the file was created
         FileUtils.write(healthcheck, 
-                        DateField.formatExternal(new Date()), "UTF-8");
+                        TrieDateField.formatExternal(new Date()), "UTF-8");
       } catch (IOException e) {
         throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, 
                                 "Unable to write healthcheck flag file", e);
diff --git a/solr/core/src/java/org/apache/solr/handler/component/StatsValuesFactory.java b/solr/core/src/java/org/apache/solr/handler/component/StatsValuesFactory.java
index f5f1b62d..591f23b 100644
--- a/solr/core/src/java/org/apache/solr/handler/component/StatsValuesFactory.java
+++ b/solr/core/src/java/org/apache/solr/handler/component/StatsValuesFactory.java
@@ -44,18 +44,10 @@ public class StatsValuesFactory {
   public static StatsValues createStatsValues(SchemaField sf, boolean calcDistinct) {
     // TODO: allow for custom field types
     FieldType fieldType = sf.getType();
-    if (DoubleField.class.isInstance(fieldType) ||
-        IntField.class.isInstance(fieldType) ||
-        LongField.class.isInstance(fieldType) ||
-        FloatField.class.isInstance(fieldType) ||
-        TrieField.class.isInstance(fieldType) ||
-        SortableDoubleField.class.isInstance(fieldType) ||
-        SortableIntField.class.isInstance(fieldType) ||
-        SortableLongField.class.isInstance(fieldType) ||
-        SortableFloatField.class.isInstance(fieldType)) {
-      return new NumericStatsValues(sf, calcDistinct);
-    } else if (DateField.class.isInstance(fieldType)) {
+    if (TrieDateField.class.isInstance(fieldType)) {
       return new DateStatsValues(sf, calcDistinct);
+    } else if (TrieField.class.isInstance(fieldType)) {
+      return new NumericStatsValues(sf, calcDistinct);
     } else if (StrField.class.isInstance(fieldType)) {
       return new StringStatsValues(sf, calcDistinct);
     } else if (sf.getType().getClass().equals(EnumField.class)) {
diff --git a/solr/core/src/java/org/apache/solr/request/SimpleFacets.java b/solr/core/src/java/org/apache/solr/request/SimpleFacets.java
index e247ff4..38aeb0c 100644
--- a/solr/core/src/java/org/apache/solr/request/SimpleFacets.java
+++ b/solr/core/src/java/org/apache/solr/request/SimpleFacets.java
@@ -73,14 +73,10 @@ import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.common.util.StrUtils;
 import org.apache.solr.handler.component.ResponseBuilder;
 import org.apache.solr.schema.BoolField;
-import org.apache.solr.schema.DateField;
 import org.apache.solr.schema.FieldType;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.schema.SchemaField;
-import org.apache.solr.schema.SortableDoubleField;
-import org.apache.solr.schema.SortableFloatField;
-import org.apache.solr.schema.SortableIntField;
-import org.apache.solr.schema.SortableLongField;
+import org.apache.solr.schema.TrieDateField;
 import org.apache.solr.schema.TrieField;
 import org.apache.solr.search.BitDocSet;
 import org.apache.solr.search.DocIterator;
@@ -980,12 +976,12 @@ public class SimpleFacets {
     final NamedList<Object> resInner = new SimpleOrderedMap<>();
     resOuter.add(key, resInner);
     final SchemaField sf = schema.getField(f);
-    if (! (sf.getType() instanceof DateField)) {
+    if (! (sf.getType() instanceof TrieDateField)) {
       throw new SolrException
           (SolrException.ErrorCode.BAD_REQUEST,
-              "Can not date facet on a field which is not a DateField: " + f);
+              "Can not date facet on a field which is not a TrieDateField: " + f);
     }
-    final DateField ft = (DateField) sf.getType();
+    final TrieDateField ft = (TrieDateField) sf.getType();
     final String startS
         = required.getFieldParam(f,FacetParams.FACET_DATE_START);
     final Date start;
@@ -1179,16 +1175,8 @@ public class SimpleFacets {
               (SolrException.ErrorCode.BAD_REQUEST,
                   "Unable to range facet on tried field of unexpected type:" + f);
       }
-    } else if (ft instanceof DateField) {
+    } else if (ft instanceof TrieDateField) {
       calc = new DateRangeEndpointCalculator(sf, null);
-    } else if (ft instanceof SortableIntField) {
-      calc = new IntegerRangeEndpointCalculator(sf);
-    } else if (ft instanceof SortableLongField) {
-      calc = new LongRangeEndpointCalculator(sf);
-    } else if (ft instanceof SortableFloatField) {
-      calc = new FloatRangeEndpointCalculator(sf);
-    } else if (ft instanceof SortableDoubleField) {
-      calc = new DoubleRangeEndpointCalculator(sf);
     } else {
       throw new SolrException
           (SolrException.ErrorCode.BAD_REQUEST,
@@ -1346,7 +1334,7 @@ public class SimpleFacets {
   @Deprecated
   protected int rangeCount(SchemaField sf, Date low, Date high,
                            boolean iLow, boolean iHigh) throws IOException {
-    Query rangeQ = ((DateField)(sf.getType())).getRangeQuery(null, sf, low, high, iLow, iHigh);
+    Query rangeQ = ((TrieDateField)(sf.getType())).getRangeQuery(null, sf, low, high, iLow, iHigh);
     return searcher.numDocs(rangeQ, docs);
   }
   
@@ -1534,18 +1522,18 @@ public class SimpleFacets {
                                        final Date now) { 
       super(f); 
       this.now = now;
-      if (! (field.getType() instanceof DateField) ) {
+      if (! (field.getType() instanceof TrieDateField) ) {
         throw new IllegalArgumentException
-          ("SchemaField must use filed type extending DateField");
+          ("SchemaField must use field type extending TrieDateField");
       }
     }
     @Override
     public String formatValue(Date val) {
-      return ((DateField)field.getType()).toExternal(val);
+      return ((TrieDateField)field.getType()).toExternal(val);
     }
     @Override
     protected Date parseVal(String rawval) {
-      return ((DateField)field.getType()).parseMath(now, rawval);
+      return ((TrieDateField)field.getType()).parseMath(now, rawval);
     }
     @Override
     protected Object parseGap(final String rawval) {
diff --git a/solr/core/src/java/org/apache/solr/response/BinaryResponseWriter.java b/solr/core/src/java/org/apache/solr/response/BinaryResponseWriter.java
index 3ec8dde..1f91281 100644
--- a/solr/core/src/java/org/apache/solr/response/BinaryResponseWriter.java
+++ b/solr/core/src/java/org/apache/solr/response/BinaryResponseWriter.java
@@ -256,18 +256,6 @@ public class BinaryResponseWriter implements BinaryQueryResponseWriter {
 
   static {
     KNOWN_TYPES.add(BoolField.class);
-    KNOWN_TYPES.add(BCDIntField.class);
-    KNOWN_TYPES.add(BCDLongField.class);
-    KNOWN_TYPES.add(BCDStrField.class);
-    KNOWN_TYPES.add(DateField.class);
-    KNOWN_TYPES.add(DoubleField.class);
-    KNOWN_TYPES.add(FloatField.class);
-    KNOWN_TYPES.add(IntField.class);
-    KNOWN_TYPES.add(LongField.class);
-    KNOWN_TYPES.add(SortableLongField.class);
-    KNOWN_TYPES.add(SortableIntField.class);
-    KNOWN_TYPES.add(SortableFloatField.class);
-    KNOWN_TYPES.add(SortableDoubleField.class);
     KNOWN_TYPES.add(StrField.class);
     KNOWN_TYPES.add(TextField.class);
     KNOWN_TYPES.add(TrieField.class);
diff --git a/solr/core/src/java/org/apache/solr/response/TextResponseWriter.java b/solr/core/src/java/org/apache/solr/response/TextResponseWriter.java
index 513ffd6..7fddd44 100644
--- a/solr/core/src/java/org/apache/solr/response/TextResponseWriter.java
+++ b/solr/core/src/java/org/apache/solr/response/TextResponseWriter.java
@@ -29,6 +29,7 @@ import org.apache.lucene.util.BytesRef;
 import org.apache.solr.common.SolrDocument;
 import org.apache.solr.common.SolrDocumentList;
 import org.apache.solr.common.util.Base64;
+import org.apache.solr.schema.TrieDateField;
 import org.apache.solr.util.FastWriter;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.request.SolrQueryRequest;
@@ -36,7 +37,6 @@ import org.apache.solr.response.transform.DocTransformer;
 import org.apache.solr.response.transform.TransformContext;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.schema.SchemaField;
-import org.apache.solr.schema.DateField;
 import org.apache.solr.search.DocList;
 import org.apache.solr.search.ReturnFields;
 
@@ -346,7 +346,7 @@ public abstract class TextResponseWriter {
 
 
   public void writeDate(String name, Date val) throws IOException {
-    writeDate(name, DateField.formatExternal(val));
+    writeDate(name, TrieDateField.formatExternal(val));
   }
   
 
diff --git a/solr/core/src/java/org/apache/solr/schema/BCDIntField.java b/solr/core/src/java/org/apache/solr/schema/BCDIntField.java
deleted file mode 100644
index 17679b6..0000000
--- a/solr/core/src/java/org/apache/solr/schema/BCDIntField.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.schema;
-
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.search.SortField;
-import org.apache.solr.search.QParser;
-import org.apache.lucene.index.GeneralField;
-import org.apache.lucene.index.StorableField;
-import org.apache.solr.util.BCDUtils;
-import org.apache.solr.response.TextResponseWriter;
-
-import java.io.IOException;
-/**
- *
- */
-public class BCDIntField extends PrimitiveFieldType {
-  @Override
-  public SortField getSortField(SchemaField field,boolean reverse) {
-    return getStringSort(field,reverse);
-  }
-
-  @Override
-  public ValueSource getValueSource(SchemaField field, QParser qparser) {
-    throw new UnsupportedOperationException("ValueSource not implemented");
-  }
-
-  @Override
-  public String toInternal(String val) {
-    // TODO? make sure each character is a digit?
-    return BCDUtils.base10toBase10kSortableInt(val);
-  }
-
-  @Override
-  public String toExternal(StorableField f) {
-    return indexedToReadable(f.stringValue());
-  }
-  
-  // Note, this can't return type 'Integer' because BCDStrField and BCDLong extend it
-  @Override
-  public Object toObject(StorableField f) {
-    return Integer.valueOf( toExternal(f) );
-  }
-
-  @Override
-  public String indexedToReadable(String indexedForm) {
-    return BCDUtils.base10kSortableIntToBase10(indexedForm);
-  }
-
-  @Override
-  public void write(TextResponseWriter writer, String name, StorableField f) throws IOException {
-    writer.writeInt(name,toExternal(f));
-  }
-
-  @Override
-  public Object marshalSortValue(Object value) {
-    return marshalStringSortValue(value);
-  }
-
-  @Override
-  public Object unmarshalSortValue(Object value) {
-    return unmarshalStringSortValue(value);
-  }
-}
-
-
-
-
-
diff --git a/solr/core/src/java/org/apache/solr/schema/BCDLongField.java b/solr/core/src/java/org/apache/solr/schema/BCDLongField.java
deleted file mode 100644
index 4945be2..0000000
--- a/solr/core/src/java/org/apache/solr/schema/BCDLongField.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.schema;
-
-import org.apache.lucene.index.StorableField;
-/**
- *
- */
-public class BCDLongField extends BCDIntField {
-  @Override
-  public Long toObject(StorableField f) {
-    return Long.valueOf( toExternal(f) );
-  }
-}
diff --git a/solr/core/src/java/org/apache/solr/schema/BCDStrField.java b/solr/core/src/java/org/apache/solr/schema/BCDStrField.java
deleted file mode 100644
index ab5afd2..0000000
--- a/solr/core/src/java/org/apache/solr/schema/BCDStrField.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.schema;
-
-import org.apache.lucene.index.StorableField;
-/**
- *
- */
-public class BCDStrField extends BCDIntField {
-  /**
-   * This only works for strings that represent an interger.  If the string
-   * is not an integer, it will not survive the base10k conversion!
-   */
-  @Override
-  public String toObject(StorableField f) {
-    return toExternal(f);
-  }
-}
diff --git a/solr/core/src/java/org/apache/solr/schema/DateField.java b/solr/core/src/java/org/apache/solr/schema/DateField.java
deleted file mode 100644
index 52eac81..0000000
--- a/solr/core/src/java/org/apache/solr/schema/DateField.java
+++ /dev/null
@@ -1,564 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.schema;
-
-import org.apache.lucene.index.AtomicReaderContext;
-import org.apache.lucene.index.GeneralField;
-import org.apache.lucene.index.IndexableField;
-import org.apache.lucene.index.StorableField;
-import org.apache.lucene.queries.function.docvalues.DocTermsIndexDocValues;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.SortField;
-import org.apache.lucene.search.TermRangeQuery;
-import org.apache.lucene.queries.function.FunctionValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.queries.function.valuesource.FieldCacheSource;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CharsRef;
-import org.apache.lucene.util.UnicodeUtil;
-import org.apache.solr.common.SolrException;
-import org.apache.solr.common.util.DateUtil;
-import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.response.TextResponseWriter;
-import org.apache.solr.search.QParser;
-import org.apache.solr.util.DateMathParser;
-import org.apache.solr.update.processor.TimestampUpdateProcessorFactory; //jdoc
-
-import java.io.IOException;
-import java.text.*;
-import java.util.*;
-
-// TODO: make a FlexibleDateField that can accept dates in multiple
-// formats, better for human entered dates.
-
-// TODO: make a DayField that only stores the day?
-
-
-/**
- * FieldType that can represent any Date/Time with millisecond precision.
- * <p>
- * Date Format for the XML, incoming and outgoing:
- * </p>
- * <blockquote>
- * A date field shall be of the form 1995-12-31T23:59:59Z
- * The trailing "Z" designates UTC time and is mandatory
- * (See below for an explanation of UTC).
- * Optional fractional seconds are allowed, as long as they do not end
- * in a trailing 0 (but any precision beyond milliseconds will be ignored).
- * All other parts are mandatory.
- * </blockquote>
- * <p>
- * This format was derived to be standards compliant (ISO 8601) and is a more
- * restricted form of the
- * <a href="http://www.w3.org/TR/xmlschema-2/#dateTime-canonical-representation">canonical
- * representation of dateTime</a> from XML schema part 2.  Examples...
- * </p>
- * <ul>
- *   <li>1995-12-31T23:59:59Z</li>
- *   <li>1995-12-31T23:59:59.9Z</li>
- *   <li>1995-12-31T23:59:59.99Z</li>
- *   <li>1995-12-31T23:59:59.999Z</li>
- * </ul>
- * <p>
- * Note that DateField is lenient with regards to parsing fractional
- * seconds that end in trailing zeros and will ensure that those values
- * are indexed in the correct canonical format.
- * </p>
- * <p>
- * This FieldType also supports incoming "Date Math" strings for computing
- * values by adding/rounding internals of time relative either an explicit
- * datetime (in the format specified above) or the literal string "NOW",
- * ie: "NOW+1YEAR", "NOW/DAY", "1995-12-31T23:59:59.999Z+5MINUTES", etc...
- * -- see {@link DateMathParser} for more examples.
- * </p>
- * <p>
- * <b>NOTE:</b> Allthough it is possible to configure a <code>DateField</code> 
- * instance with a default value of "<code>NOW</code>" to compute a timestamp 
- * of when the document was indexed, this is not advisable when using SolrCloud 
- * since each replica of the document may compute a slightly different value. 
- * {@link TimestampUpdateProcessorFactory} is recomended instead.
- * </p>
- *
- * <p>
- * Explanation of "UTC"...
- * </p>
- * <blockquote>
- * "In 1970 the Coordinated Universal Time system was devised by an
- * international advisory group of technical experts within the International
- * Telecommunication Union (ITU).  The ITU felt it was best to designate a
- * single abbreviation for use in all languages in order to minimize
- * confusion.  Since unanimous agreement could not be achieved on using
- * either the English word order, CUT, or the French word order, TUC, the
- * acronym UTC was chosen as a compromise."
- * </blockquote>
- *
- *
- * @see <a href="http://www.w3.org/TR/xmlschema-2/#dateTime">XML schema part 2</a>
- * @deprecated {@link TrieDateField} is recomended for all new schemas
- */
-public class DateField extends PrimitiveFieldType implements DateValueFieldType {
-
-  public static TimeZone UTC = TimeZone.getTimeZone("UTC");
-
-  /** 
-   * No longer used
-   * @deprecated use DateMathParser.DEFAULT_MATH_TZ
-   * @see DateMathParser#DEFAULT_MATH_TZ
-   */
-  protected static final TimeZone MATH_TZ = DateMathParser.DEFAULT_MATH_TZ;
-  /** 
-   * No longer used
-   * @deprecated use DateMathParser.DEFAULT_MATH_LOCALE
-   * @see DateMathParser#DEFAULT_MATH_LOCALE
-   */
-  protected static final Locale MATH_LOCALE = DateMathParser.DEFAULT_MATH_LOCALE;
-
-  /** 
-   * Fixed TimeZone (UTC) needed for parsing/formating Dates in the 
-   * canonical representation.
-   */
-  protected static final TimeZone CANONICAL_TZ = UTC;
-  /** 
-   * Fixed Locale needed for parsing/formating Milliseconds in the 
-   * canonical representation.
-   */
-  protected static final Locale CANONICAL_LOCALE = Locale.ROOT;
-  
-  // The XML (external) date format will sort correctly, except if
-  // fractions of seconds are present (because '.' is lower than 'Z').
-  // The easiest fix is to simply remove the 'Z' for the internal
-  // format.
-  
-  protected static String NOW = "NOW";
-  protected static char Z = 'Z';
-  private static char[] Z_ARRAY = new char[] {Z};
-  
-  
-  @Override
-  public String toInternal(String val) {
-    return toInternal(parseMath(null, val));
-  }
-
-  /**
-   * Parses a String which may be a date (in the standard format)
-   * followed by an optional math expression.
-   * @param now an optional fixed date to use as "NOW" in the DateMathParser
-   * @param val the string to parse
-   */
-  public Date parseMath(Date now, String val) {
-    String math = null;
-    final DateMathParser p = new DateMathParser();
-    
-    if (null != now) p.setNow(now);
-    
-    if (val.startsWith(NOW)) {
-      math = val.substring(NOW.length());
-    } else {
-      final int zz = val.indexOf(Z);
-      if (0 < zz) {
-        math = val.substring(zz+1);
-        try {
-          // p.setNow(toObject(val.substring(0,zz)));
-          p.setNow(parseDate(val.substring(0,zz+1)));
-        } catch (ParseException e) {
-          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,
-                                   "Invalid Date in Date Math String:'"
-                                   +val+'\'',e);
-        }
-      } else {
-        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,
-                                 "Invalid Date String:'" +val+'\'');
-      }
-    }
-
-    if (null == math || math.equals("")) {
-      return p.getNow();
-    }
-    
-    try {
-      return p.parseMath(math);
-    } catch (ParseException e) {
-      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,
-                               "Invalid Date Math String:'" +val+'\'',e);
-    }
-  }
-
-  @Override
-  public StorableField createField(SchemaField field, Object value, float boost) {
-    // Convert to a string before indexing
-    if(value instanceof Date) {
-      value = toInternal( (Date)value ) + Z;
-    }
-    return super.createField(field, value, boost);
-  }
-  
-  public String toInternal(Date val) {
-    return formatDate(val);
-  }
-
-  @Override
-  public String indexedToReadable(String indexedForm) {
-    return indexedForm + Z;
-  }
-
-  @Override
-  public CharsRef indexedToReadable(BytesRef input, CharsRef charsRef) {
-    UnicodeUtil.UTF8toUTF16(input, charsRef);
-    charsRef.append(Z_ARRAY, 0, 1);
-    return charsRef;
-  }
-
-  @Override
-  public String toExternal(StorableField f) {
-    return indexedToReadable(f.stringValue());
-  }
-
-  public Date toObject(String indexedForm) throws java.text.ParseException {
-    return parseDate(indexedToReadable(indexedForm));
-  }
-
-  @Override
-  public Date toObject(StorableField f) {
-    try {
-      return parseDate( toExternal(f) );
-    }
-    catch( ParseException ex ) {
-      throw new RuntimeException( ex );
-    }
-  }
-
-  @Override
-  public SortField getSortField(SchemaField field,boolean reverse) {
-    return getStringSort(field,reverse);
-  }
-
-  @Override
-  public Object marshalSortValue(Object value) {
-    return marshalStringSortValue(value);
-  }
-
-  @Override
-  public Object unmarshalSortValue(Object value) {
-    return unmarshalStringSortValue(value);
-  }
-
-  @Override
-  public void write(TextResponseWriter writer, String name, StorableField f) throws IOException {
-    writer.writeDate(name, toExternal(f));
-  }
-
-  /**
-   * Returns a formatter that can be use by the current thread if needed to
-   * convert Date objects to the Internal representation.
-   *
-   * Only the <tt>format(Date)</tt> can be used safely.
-   * 
-   * @deprecated - use formatDate(Date) instead
-   */
-  @Deprecated
-  protected DateFormat getThreadLocalDateFormat() {
-    return fmtThreadLocal.get();
-  }
-
-  /**
-   * Thread safe method that can be used by subclasses to format a Date
-   * using the Internal representation.
-   */
-  protected String formatDate(Date d) {
-    return fmtThreadLocal.get().format(d);
-  }
-
-  /**
-   * Return the standard human readable form of the date
-   */
-  public static String formatExternal(Date d) {
-    return fmtThreadLocal.get().format(d) + 'Z';
-  }
-
-  /**
-   * @see #formatExternal
-   */
-  public String toExternal(Date d) {
-    return formatExternal(d);
-  }
-
-  /**
-   * Thread safe method that can be used by subclasses to parse a Date
-   * that is already in the internal representation
-   */
-   public static Date parseDate(String s) throws ParseException {
-     return fmtThreadLocal.get().parse(s);
-   }
-
-  /** Parse a date string in the standard format, or any supported by DateUtil.parseDate */
-   public Date parseDateLenient(String s, SolrQueryRequest req) throws ParseException {
-     // request could define timezone in the future
-     try {
-       return fmtThreadLocal.get().parse(s);
-     } catch (Exception e) {
-       return DateUtil.parseDate(s);
-     }
-   }
-
-  /**
-   * Parses a String which may be a date
-   * followed by an optional math expression.
-   * @param now an optional fixed date to use as "NOW" in the DateMathParser
-   * @param val the string to parse
-   */
-  public Date parseMathLenient(Date now, String val, SolrQueryRequest req) {
-    String math = null;
-    final DateMathParser p = new DateMathParser();
-
-    if (null != now) p.setNow(now);
-
-    if (val.startsWith(NOW)) {
-      math = val.substring(NOW.length());
-    } else {
-      final int zz = val.indexOf(Z);
-      if (0 < zz) {
-        math = val.substring(zz+1);
-        try {
-          // p.setNow(toObject(val.substring(0,zz)));
-          p.setNow(parseDateLenient(val.substring(0,zz+1), req));
-        } catch (ParseException e) {
-          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,
-                                   "Invalid Date in Date Math String:'"
-                                   +val+'\'',e);
-        }
-      } else {
-        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,
-                                 "Invalid Date String:'" +val+'\'');
-      }
-    }
-
-    if (null == math || math.equals("")) {
-      return p.getNow();
-    }
-
-    try {
-      return p.parseMath(math);
-    } catch (ParseException e) {
-      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,
-                               "Invalid Date Math String:'" +val+'\'',e);
-    }
-  }
-
-
-  
-  /**
-   * Thread safe DateFormat that can <b>format</b> in the canonical
-   * ISO8601 date format, not including the trailing "Z" (since it is
-   * left off in the internal indexed values)
-   */
-  private final static ThreadLocalDateFormat fmtThreadLocal
-    = new ThreadLocalDateFormat(new ISO8601CanonicalDateFormat());
-  
-  private static class ISO8601CanonicalDateFormat extends SimpleDateFormat {
-    
-    protected NumberFormat millisParser
-      = NumberFormat.getIntegerInstance(CANONICAL_LOCALE);
-
-    protected NumberFormat millisFormat = new DecimalFormat(".###", 
-      new DecimalFormatSymbols(CANONICAL_LOCALE));
-
-    public ISO8601CanonicalDateFormat() {
-      super("yyyy-MM-dd'T'HH:mm:ss", CANONICAL_LOCALE);
-      this.setTimeZone(CANONICAL_TZ);
-    }
-
-    @Override
-    public Date parse(String i, ParsePosition p) {
-      /* delegate to SimpleDateFormat for easy stuff */
-      Date d = super.parse(i, p);
-      int milliIndex = p.getIndex();
-      /* worry about the milliseconds ourselves */
-      if (null != d &&
-          -1 == p.getErrorIndex() &&
-          milliIndex + 1 < i.length() &&
-          '.' == i.charAt(milliIndex)) {
-        p.setIndex( ++milliIndex ); // NOTE: ++ to chomp '.'
-        Number millis = millisParser.parse(i, p);
-        if (-1 == p.getErrorIndex()) {
-          int endIndex = p.getIndex();
-            d = new Date(d.getTime()
-                         + (long)(millis.doubleValue() *
-                                  Math.pow(10, (3-endIndex+milliIndex))));
-        }
-      }
-      return d;
-    }
-
-    @Override
-    public StringBuffer format(Date d, StringBuffer toAppendTo,
-                               FieldPosition pos) {
-      /* delegate to SimpleDateFormat for easy stuff */
-      super.format(d, toAppendTo, pos);
-      /* worry aboutthe milliseconds ourselves */
-      long millis = d.getTime() % 1000l;
-      if (0L == millis) {
-        return toAppendTo;
-      }
-      if (millis < 0L) {
-        // original date was prior to epoch
-        millis += 1000L;
-      }
-      int posBegin = toAppendTo.length();
-      toAppendTo.append(millisFormat.format(millis / 1000d));
-      if (DateFormat.MILLISECOND_FIELD == pos.getField()) {
-        pos.setBeginIndex(posBegin);
-        pos.setEndIndex(toAppendTo.length());
-      }
-      return toAppendTo;
-    }
-
-    @Override
-    public DateFormat clone() {
-      ISO8601CanonicalDateFormat c
-        = (ISO8601CanonicalDateFormat) super.clone();
-      c.millisParser = NumberFormat.getIntegerInstance(CANONICAL_LOCALE);
-      c.millisFormat = new DecimalFormat(".###", 
-        new DecimalFormatSymbols(CANONICAL_LOCALE));
-      return c;
-    }
-  }
-  
-  private static class ThreadLocalDateFormat extends ThreadLocal<DateFormat> {
-    DateFormat proto;
-    public ThreadLocalDateFormat(DateFormat d) {
-      super();
-      proto = d;
-    }
-    @Override
-    protected DateFormat initialValue() {
-      return (DateFormat) proto.clone();
-    }
-  }
-
-  @Override
-  public ValueSource getValueSource(SchemaField field, QParser parser) {
-    field.checkFieldCacheSource(parser);
-    return new DateFieldSource(field.getName(), field);
-  }
-
-  /** DateField specific range query */
-  public Query getRangeQuery(QParser parser, SchemaField sf, Date part1, Date part2, boolean minInclusive, boolean maxInclusive) {
-    return TermRangeQuery.newStringRange(
-            sf.getName(),
-            part1 == null ? null : toInternal(part1),
-            part2 == null ? null : toInternal(part2),
-            minInclusive, maxInclusive);
-  }
-
-}
-
-
-
-class DateFieldSource extends FieldCacheSource {
-  // NOTE: this is bad for serialization... but we currently need the fieldType for toInternal()
-  SchemaField sf;
-  FieldType ft;
-
-  public DateFieldSource(String name, SchemaField sf) {
-    super(name);
-    this.sf = sf;
-    this.ft = sf.getType();
-  }
-
-  @Override
-  public String description() {
-    return "date(" + field + ')';
-  }
-
-  @Override
-  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    return new DocTermsIndexDocValues(this, readerContext, field) {
-      @Override
-      protected String toTerm(String readableValue) {
-        // needed for frange queries to work properly
-        return ft.toInternal(readableValue);
-      }
-
-      @Override
-      public boolean exists(int doc) {
-        return termsIndex.getOrd(doc) >= 0;
-      }
-
-      @Override
-      public float floatVal(int doc) {
-        return (float)intVal(doc);
-      }
-
-      @Override
-      public int intVal(int doc) {
-        int ord=termsIndex.getOrd(doc);
-        return ord;
-      }
-
-      @Override
-      public long longVal(int doc) {
-        return (long)intVal(doc);
-      }
-
-      @Override
-      public double doubleVal(int doc) {
-        return (double)intVal(doc);
-      }
-
-      @Override
-      public String strVal(int doc) {
-        int ord=termsIndex.getOrd(doc);
-        if (ord == -1) {
-          return null;
-        } else {
-          termsIndex.lookupOrd(ord, spare);
-          return ft.indexedToReadable(spare, spareChars).toString();
-        }
-      }
-
-      @Override
-      public Object objectVal(int doc) {
-        int ord=termsIndex.getOrd(doc);
-        if (ord == -1) {
-          return null;
-        } else {
-          final BytesRef br = new BytesRef();
-          termsIndex.lookupOrd(ord, br);
-          return ft.toObject(sf, br);
-        }
-      }
-
-      @Override
-      public String toString(int doc) {
-        return description() + '=' + intVal(doc);
-      }
-    };
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    return o instanceof DateFieldSource
-            && super.equals(o);
-  }
-
-  private static int hcode = DateFieldSource.class.hashCode();
-  @Override
-  public int hashCode() {
-    return hcode + super.hashCode();
-  };
-}
diff --git a/solr/core/src/java/org/apache/solr/schema/DoubleField.java b/solr/core/src/java/org/apache/solr/schema/DoubleField.java
deleted file mode 100644
index 550adae..0000000
--- a/solr/core/src/java/org/apache/solr/schema/DoubleField.java
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.schema;
-
-import java.io.IOException;
-import java.util.Map;
-
-import org.apache.lucene.index.StorableField;
-import org.apache.lucene.index.Terms;
-import org.apache.lucene.index.TermsEnum;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.queries.function.valuesource.DoubleFieldSource;
-import org.apache.lucene.search.FieldCache;
-import org.apache.lucene.search.SortField;
-import org.apache.lucene.util.BytesRef;
-import org.apache.solr.response.TextResponseWriter;
-import org.apache.solr.search.QParser;
-
-/**
- * A legacy numeric field type that encodes "Double" values as simple Strings.
- * This class should not be used except by people with existing indexes that
- * contain numeric values indexed as Strings.  
- * New schemas should use {@link TrieDoubleField}.
- *
- * <p>
- * Field values will sort numerically, but Range Queries (and other features 
- * that rely on numeric ranges) will not work as expected: values will be 
- * evaluated in unicode String order, not numeric order.
- * </p>
- * 
- * @see TrieDoubleField
- */
-public class DoubleField extends PrimitiveFieldType implements DoubleValueFieldType {
-
-  private static final FieldCache.DoubleParser PARSER = new FieldCache.DoubleParser() {
-    
-    @Override
-    public TermsEnum termsEnum(Terms terms) throws IOException {
-      return terms.iterator(null);
-    }
-
-    @Override
-    public double parseDouble(BytesRef term) {
-      return Double.parseDouble(term.utf8ToString());
-    }
-  };
-
-  @Override
-  protected void init(IndexSchema schema, Map<String, String> args) {
-    super.init(schema, args);
-    restrictProps(SORT_MISSING_FIRST | SORT_MISSING_LAST);
-  }
-
-  /////////////////////////////////////////////////////////////
-  @Override
-  public SortField getSortField(SchemaField field, boolean reverse) {
-    field.checkSortability();
-    return new SortField(field.name, PARSER, reverse);
-  }
-
-  @Override
-  public ValueSource getValueSource(SchemaField field, QParser qparser) {
-    field.checkFieldCacheSource(qparser);
-    return new DoubleFieldSource(field.name, PARSER);
-  }
-
-  @Override
-  public void write(TextResponseWriter writer, String name, StorableField f) throws IOException {
-    String s = f.stringValue();
-
-    // these values may be from a legacy lucene index, which may
-    // not be properly formatted in some output formats, or may
-    // incorrectly have a zero length.
-
-    if (s.length()==0) {
-      // zero length value means someone mistakenly indexed the value
-      // instead of simply leaving it out.  Write a null value instead of a numeric.
-      writer.writeNull(name);
-      return;
-    }
-
-    try {
-      double val = Double.parseDouble(s);
-      writer.writeDouble(name, val);
-    } catch (NumberFormatException e){
-      // can't parse - write out the contents as a string so nothing is lost and
-      // clients don't get a parse error.
-      writer.writeStr(name, s, true);
-    }
-  }
-
-
-  @Override
-  public Double toObject(StorableField f) {
-    return Double.valueOf(toExternal(f));
-  }
-}
diff --git a/solr/core/src/java/org/apache/solr/schema/ExternalFileField.java b/solr/core/src/java/org/apache/solr/schema/ExternalFileField.java
index be855c7..e445c60 100644
--- a/solr/core/src/java/org/apache/solr/schema/ExternalFileField.java
+++ b/solr/core/src/java/org/apache/solr/schema/ExternalFileField.java
@@ -69,9 +69,9 @@ public class ExternalFileField extends FieldType implements SchemaAware {
     String ftypeS = args.remove("valType");
     if (ftypeS != null) {
       ftype = schema.getFieldTypes().get(ftypeS);
-      if (ftype != null && !(ftype instanceof FloatField) && !(ftype instanceof TrieFloatField)) {
+      if (ftype != null && !(ftype instanceof TrieFloatField)) {
         throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,
-            "Only float and pfloat (Trie|Float)Field are currently supported as external field type.  Got " + ftypeS);
+            "Only float (TrieFloatField) is currently supported as external field type.  Got " + ftypeS);
       }
     }
     keyFieldName = args.remove("keyField");
diff --git a/solr/core/src/java/org/apache/solr/schema/FloatField.java b/solr/core/src/java/org/apache/solr/schema/FloatField.java
deleted file mode 100644
index 6d80535..0000000
--- a/solr/core/src/java/org/apache/solr/schema/FloatField.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.schema;
-
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.queries.function.valuesource.FloatFieldSource;
-import org.apache.lucene.search.FieldCache;
-import org.apache.lucene.search.SortField;
-import org.apache.lucene.util.BytesRef;
-import org.apache.solr.search.QParser;
-import org.apache.lucene.index.GeneralField;
-import org.apache.lucene.index.IndexableField;
-import org.apache.lucene.index.StorableField;
-import org.apache.lucene.index.Terms;
-import org.apache.lucene.index.TermsEnum;
-import org.apache.solr.response.TextResponseWriter;
-
-import java.util.Map;
-import java.io.IOException;
-/**
- * A legacy numeric field type that encodes "Float" values as simple Strings.
- * This class should not be used except by people with existing indexes that
- * contain numeric values indexed as Strings.  
- * New schemas should use {@link TrieFloatField}.
- *
- * <p>
- * Field values will sort numerically, but Range Queries (and other features 
- * that rely on numeric ranges) will not work as expected: values will be 
- * evaluated in unicode String order, not numeric order.
- * </p>
- * 
- * @see TrieFloatField
- */
-public class FloatField extends PrimitiveFieldType implements FloatValueFieldType {
-
-  private static final FieldCache.FloatParser PARSER = new FieldCache.FloatParser() {
-    
-    @Override
-    public TermsEnum termsEnum(Terms terms) throws IOException {
-      return terms.iterator(null);
-    }
-
-    @Override
-    public float parseFloat(BytesRef term) {
-      return Float.parseFloat(term.utf8ToString());
-    }
-  };
-
-  @Override
-  protected void init(IndexSchema schema, Map<String,String> args) {
-    super.init(schema, args);
-    restrictProps(SORT_MISSING_FIRST | SORT_MISSING_LAST);
-  }
-
-  @Override
-  public SortField getSortField(SchemaField field,boolean reverse) {
-    field.checkSortability();
-    return new SortField(field.name, PARSER, reverse);
-  }
-
-  @Override
-  public ValueSource getValueSource(SchemaField field, QParser qparser) {
-    field.checkFieldCacheSource(qparser);
-    return new FloatFieldSource(field.name, PARSER);
-  }
-
-  @Override
-  public void write(TextResponseWriter writer, String name, StorableField f) throws IOException {
-    String s = f.stringValue();
-
-    // these values may be from a legacy lucene index, which may
-    // not be properly formatted in some output formats, or may
-    // incorrectly have a zero length.
-
-    if (s.length()==0) {
-      // zero length value means someone mistakenly indexed the value
-      // instead of simply leaving it out.  Write a null value instead of a numeric.
-      writer.writeNull(name);
-      return;
-    }
-
-    try {
-      float fval = Float.parseFloat(s);
-      writer.writeFloat(name, fval);
-    } catch (NumberFormatException e){
-      // can't parse - write out the contents as a string so nothing is lost and
-      // clients don't get a parse error.
-      writer.writeStr(name, s, true);
-    }
-  }
-
-  @Override
-  public Float toObject(StorableField f) {
-    return Float.valueOf( toExternal(f) );
-  }
-}
diff --git a/solr/core/src/java/org/apache/solr/schema/IntField.java b/solr/core/src/java/org/apache/solr/schema/IntField.java
deleted file mode 100644
index 2b14867..0000000
--- a/solr/core/src/java/org/apache/solr/schema/IntField.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.schema;
-
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.queries.function.valuesource.IntFieldSource;
-import org.apache.lucene.search.FieldCache;
-import org.apache.lucene.search.SortField;
-import org.apache.lucene.util.BytesRef;
-import org.apache.solr.search.QParser;
-import org.apache.lucene.index.GeneralField;
-import org.apache.lucene.index.IndexableField;
-import org.apache.lucene.index.StorableField;
-import org.apache.lucene.index.Terms;
-import org.apache.lucene.index.TermsEnum;
-import org.apache.solr.response.TextResponseWriter;
-
-import java.util.Map;
-import java.io.IOException;
-/**
- * A legacy numeric field type that encodes "Integer" values as simple Strings.
- * This class should not be used except by people with existing indexes that
- * contain numeric values indexed as Strings.  
- * New schemas should use {@link TrieIntField}.
- *
- * <p>
- * Field values will sort numerically, but Range Queries (and other features 
- * that rely on numeric ranges) will not work as expected: values will be 
- * evaluated in unicode String order, not numeric order.
- * </p>
- * 
- * @see TrieIntField
- */
-public class IntField extends PrimitiveFieldType implements IntValueFieldType {
-
-  private static final FieldCache.IntParser PARSER = new FieldCache.IntParser() {
-    
-    @Override
-    public TermsEnum termsEnum(Terms terms) throws IOException {
-      return terms.iterator(null);
-    }
-
-    @Override
-    public int parseInt(BytesRef term) {
-      return Integer.parseInt(term.utf8ToString());
-    }
-  };
-
-  @Override
-  protected void init(IndexSchema schema, Map<String,String> args) {
-    super.init(schema, args);
-    restrictProps(SORT_MISSING_FIRST | SORT_MISSING_LAST);
-  }
-
-  @Override
-  public SortField getSortField(SchemaField field,boolean reverse) {
-    field.checkSortability();
-    return new SortField(field.name, PARSER, reverse);
-  }
-
-  @Override
-  public ValueSource getValueSource(SchemaField field, QParser qparser) {
-    field.checkFieldCacheSource(qparser);
-    return new IntFieldSource(field.name, PARSER);
-  }
-
-  @Override
-  public void write(TextResponseWriter writer, String name, StorableField f) throws IOException {
-    String s = f.stringValue();
-
-    // these values may be from a legacy lucene index, which may
-    // not be properly formatted in some output formats, or may
-    // incorrectly have a zero length.
-
-    if (s.length()==0) {
-      // zero length value means someone mistakenly indexed the value
-      // instead of simply leaving it out.  Write a null value instead of a numeric.
-      writer.writeNull(name);
-      return;
-    }
-
-    try {
-      int val = Integer.parseInt(s);
-      writer.writeInt(name, val);
-    } catch (NumberFormatException e){
-      // can't parse - write out the contents as a string so nothing is lost and
-      // clients don't get a parse error.
-      writer.writeStr(name, s, true);
-    }
-  }
-
-  @Override
-  public Integer toObject(StorableField f) {
-    return Integer.valueOf( toExternal(f) );
-  }
-}
diff --git a/solr/core/src/java/org/apache/solr/schema/LongField.java b/solr/core/src/java/org/apache/solr/schema/LongField.java
deleted file mode 100644
index 5b18db8..0000000
--- a/solr/core/src/java/org/apache/solr/schema/LongField.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.schema;
-
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.queries.function.valuesource.LongFieldSource;
-import org.apache.lucene.index.GeneralField;
-import org.apache.lucene.index.IndexableField;
-import org.apache.lucene.index.StorableField;
-import org.apache.lucene.index.Terms;
-import org.apache.lucene.index.TermsEnum;
-import org.apache.lucene.search.FieldCache;
-import org.apache.lucene.search.SortField;
-import org.apache.lucene.util.BytesRef;
-import org.apache.solr.response.TextResponseWriter;
-import org.apache.solr.search.QParser;
-
-import java.io.IOException;
-import java.util.Map;
-/**
- * A legacy numeric field type that encodes "Long" values as simple Strings.
- * This class should not be used except by people with existing indexes that
- * contain numeric values indexed as Strings.  
- * New schemas should use {@link TrieLongField}.
- *
- * <p>
- * Field values will sort numerically, but Range Queries (and other features 
- * that rely on numeric ranges) will not work as expected: values will be 
- * evaluated in unicode String order, not numeric order.
- * </p>
- * 
- * @see TrieLongField
- */
-public class LongField extends PrimitiveFieldType implements LongValueFieldType {
-
-  private static final FieldCache.LongParser PARSER = new FieldCache.LongParser() {
-    
-    @Override
-    public TermsEnum termsEnum(Terms terms) throws IOException {
-      return terms.iterator(null);
-    }
-
-    @Override
-    public long parseLong(BytesRef term) {
-      return Long.parseLong(term.utf8ToString());
-    }
-  };
-
-  @Override
-  protected void init(IndexSchema schema, Map<String,String> args) {
-    super.init(schema, args);
-    restrictProps(SORT_MISSING_FIRST | SORT_MISSING_LAST);
-  }
-
-  /////////////////////////////////////////////////////////////
-
-  @Override
-  public SortField getSortField(SchemaField field,boolean reverse) {
-    field.checkSortability();
-    return new SortField(field.name, PARSER, reverse);
-  }
-
-  @Override
-  public ValueSource getValueSource(SchemaField field, QParser qparser) {
-    field.checkFieldCacheSource(qparser);
-    return new LongFieldSource(field.name, PARSER);
-  }
-
-  @Override
-  public void write(TextResponseWriter writer, String name, StorableField f) throws IOException {
-    String s = f.stringValue();
-
-    // these values may be from a legacy lucene index, which may
-    // not be properly formatted in some output formats, or may
-    // incorrectly have a zero length.
-
-    if (s.length()==0) {
-      // zero length value means someone mistakenly indexed the value
-      // instead of simply leaving it out.  Write a null value instead of a numeric.
-      writer.writeNull(name);
-      return;
-    }
-
-    try {
-      long val = Long.parseLong(s);
-      writer.writeLong(name, val);
-    } catch (NumberFormatException e){
-      // can't parse - write out the contents as a string so nothing is lost and
-      // clients don't get a parse error.
-      writer.writeStr(name, s, true);
-    }
-  }
-
-  @Override
-  public Long toObject(StorableField f) {
-    return Long.valueOf( toExternal(f) );
-  }
-}
diff --git a/solr/core/src/java/org/apache/solr/schema/SortableDoubleField.java b/solr/core/src/java/org/apache/solr/schema/SortableDoubleField.java
deleted file mode 100644
index 382dfd4..0000000
--- a/solr/core/src/java/org/apache/solr/schema/SortableDoubleField.java
+++ /dev/null
@@ -1,247 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.schema;
-
-import org.apache.lucene.queries.function.FunctionValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.queries.function.docvalues.DocTermsIndexDocValues;
-import org.apache.lucene.queries.function.valuesource.FieldCacheSource;
-import org.apache.lucene.search.SortField;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CharsRef;
-import org.apache.lucene.util.UnicodeUtil;
-import org.apache.lucene.util.mutable.MutableValue;
-import org.apache.lucene.util.mutable.MutableValueDouble;
-import org.apache.solr.search.QParser;
-import org.apache.lucene.index.AtomicReaderContext;
-import org.apache.lucene.index.GeneralField;
-import org.apache.lucene.index.IndexableField;
-import org.apache.lucene.index.StorableField;
-import org.apache.solr.util.NumberUtils;
-import org.apache.solr.response.TextResponseWriter;
-
-import java.util.Map;
-import java.io.IOException;
-/**
- * A legacy numeric field type that encodes "Double" values as Strings such 
- * that Term enumeration order matches the natural numeric order.  This class 
- * should not be used except by people with existing indexes that already 
- * contain fields of this type.  New schemas should use {@link TrieDoubleField}.
- *
- * <p>
- * The naming convention "Sortable" comes from the fact that both the numeric 
- * values and encoded String representations Sort identically (as opposed to 
- * a direct String representation where values such as "11" sort before values 
- * such as "2").
- * </p>
- * 
- * @see TrieDoubleField
- * @deprecated use {@link DoubleField} or {@link TrieDoubleField} - will be removed in 5.x
- */
-@Deprecated
-public class SortableDoubleField extends PrimitiveFieldType implements DoubleValueFieldType {
-  @Override
-  public SortField getSortField(SchemaField field,boolean reverse) {
-    return getStringSort(field,reverse);
-  }
-
-  @Override
-  public ValueSource getValueSource(SchemaField field, QParser qparser) {
-    field.checkFieldCacheSource(qparser);
-    return new SortableDoubleFieldSource(field.name);
-  }
-
-  @Override
-  public String toInternal(String val) {
-    return NumberUtils.double2sortableStr(val);
-  }
-
-  @Override
-  public String toExternal(StorableField f) {
-    return indexedToReadable(f.stringValue());
-  }
-
-  @Override
-  public Double toObject(StorableField f) {
-    return NumberUtils.SortableStr2double(f.stringValue());
-  }
-  
-  @Override
-  public String indexedToReadable(String indexedForm) {
-    return NumberUtils.SortableStr2doubleStr(indexedForm);
-  }
-
-  @Override
-  public CharsRef indexedToReadable(BytesRef input, CharsRef charsRef) {
-    // TODO: this could be more efficient, but the sortable types should be deprecated instead
-    UnicodeUtil.UTF8toUTF16(input, charsRef);
-    final char[] indexedToReadable = indexedToReadable(charsRef.toString()).toCharArray();
-    charsRef.copyChars(indexedToReadable, 0, indexedToReadable.length);
-    return charsRef;
-  }
-
-  @Override
-  public void write(TextResponseWriter writer, String name, StorableField f) throws IOException {
-    String sval = f.stringValue();
-    writer.writeDouble(name, NumberUtils.SortableStr2double(sval));
-  }
-
-  @Override
-  public Object marshalSortValue(Object value) {
-    if (null == value) {
-      return null;
-    }
-    CharsRef chars = new CharsRef();
-    UnicodeUtil.UTF8toUTF16((BytesRef)value, chars);
-    return NumberUtils.SortableStr2double(chars.toString());
-  }
-
-  @Override
-  public Object unmarshalSortValue(Object value) {
-    if (null == value) {
-      return null;
-    }
-    String sortableString = NumberUtils.double2sortableStr(value.toString());
-    BytesRef bytes = new BytesRef();
-    UnicodeUtil.UTF16toUTF8(sortableString, 0, sortableString.length(), bytes);
-    return bytes;
-  }
-}
-
-class SortableDoubleFieldSource extends FieldCacheSource {
-  protected double defVal;
-
-  public SortableDoubleFieldSource(String field) {
-    this(field, 0.0);
-  }
-
-  public SortableDoubleFieldSource(String field, double defVal) {
-    super(field);
-    this.defVal = defVal;
-  }
-
-  @Override
-  public String description() {
-    return "sdouble(" + field + ')';
-  }
-
-  @Override
-  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    final double def = defVal;
-
-    return new DocTermsIndexDocValues(this, readerContext, field) {
-      private final BytesRef spare = new BytesRef();
-
-      @Override
-      protected String toTerm(String readableValue) {
-        return NumberUtils.double2sortableStr(readableValue);
-      }
-
-      @Override
-      public boolean exists(int doc) {
-        return termsIndex.getOrd(doc) >= 0;
-      }
-
-      @Override
-      public float floatVal(int doc) {
-        return (float)doubleVal(doc);
-      }
-
-      @Override
-      public int intVal(int doc) {
-        return (int)doubleVal(doc);
-      }
-
-      @Override
-      public long longVal(int doc) {
-        return (long)doubleVal(doc);
-      }
-
-      @Override
-      public double doubleVal(int doc) {
-        int ord=termsIndex.getOrd(doc);
-        if (ord == -1) {
-          return def;
-        } else {
-          termsIndex.lookupOrd(ord, spare);
-          return NumberUtils.SortableStr2double(spare);
-        }
-      }
-
-      @Override
-      public String strVal(int doc) {
-        return Double.toString(doubleVal(doc));
-      }
-
-      @Override
-      public Object objectVal(int doc) {
-        return exists(doc) ? doubleVal(doc) : null;
-      }
-
-      @Override
-      public String toString(int doc) {
-        return description() + '=' + doubleVal(doc);
-      }
-
-      @Override
-      public ValueFiller getValueFiller() {
-        return new ValueFiller() {
-          private final MutableValueDouble mval = new MutableValueDouble();
-
-          @Override
-          public MutableValue getValue() {
-            return mval;
-          }
-
-          @Override
-          public void fillValue(int doc) {
-            int ord=termsIndex.getOrd(doc);
-            if (ord == -1) {
-              mval.value = def;
-              mval.exists = false;
-            } else {
-              termsIndex.lookupOrd(ord, spare);
-              mval.value = NumberUtils.SortableStr2double(spare);
-              mval.exists = true;
-            }
-          }
-        };
-      }
-    };
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    return o instanceof SortableDoubleFieldSource
-            && super.equals(o)
-            && defVal == ((SortableDoubleFieldSource)o).defVal;
-  }
-
-  private static int hcode = SortableDoubleFieldSource.class.hashCode();
-  @Override
-  public int hashCode() {
-    long bits = Double.doubleToLongBits(defVal);
-    int ibits = (int)(bits ^ (bits>>>32));  // mix upper bits into lower.
-    return hcode + super.hashCode() + ibits;
-  };
-}
-
-
-
-
-
diff --git a/solr/core/src/java/org/apache/solr/schema/SortableFloatField.java b/solr/core/src/java/org/apache/solr/schema/SortableFloatField.java
deleted file mode 100644
index aa7a075..0000000
--- a/solr/core/src/java/org/apache/solr/schema/SortableFloatField.java
+++ /dev/null
@@ -1,248 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.schema;
-
-import org.apache.lucene.queries.function.FunctionValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.queries.function.docvalues.DocTermsIndexDocValues;
-import org.apache.lucene.queries.function.valuesource.FieldCacheSource;
-import org.apache.lucene.search.SortField;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CharsRef;
-import org.apache.lucene.util.UnicodeUtil;
-import org.apache.lucene.util.mutable.MutableValue;
-import org.apache.lucene.util.mutable.MutableValueFloat;
-import org.apache.solr.search.QParser;
-import org.apache.lucene.index.AtomicReaderContext;
-import org.apache.lucene.index.GeneralField;
-import org.apache.lucene.index.IndexableField;
-import org.apache.lucene.index.StorableField;
-import org.apache.solr.util.NumberUtils;
-import org.apache.solr.response.TextResponseWriter;
-
-import java.util.Map;
-import java.io.IOException;
-
-/**
- * A legacy numeric field type that encodes "Float" values as Strings such 
- * that Term enumeration order matches the natural numeric order.  This class 
- * should not be used except by people with existing indexes that already 
- * contain fields of this type.  New schemas should use {@link TrieFloatField}.
- *
- * <p>
- * The naming convention "Sortable" comes from the fact that both the numeric 
- * values and encoded String representations Sort identically (as opposed to 
- * a direct String representation where values such as "11" sort before values 
- * such as "2").
- * </p>
- *
- * @see TrieFloatField
- * @deprecated use {@link FloatField} or {@link TrieFloatField} - will be removed in 5.x
- */
-@Deprecated
-public class SortableFloatField extends PrimitiveFieldType implements FloatValueFieldType {
-  @Override
-  public SortField getSortField(SchemaField field,boolean reverse) {
-    return getStringSort(field,reverse);
-  }
-
-  @Override
-  public ValueSource getValueSource(SchemaField field, QParser qparser) {
-    field.checkFieldCacheSource(qparser);
-    return new SortableFloatFieldSource(field.name);
-  }
-
-  @Override
-  public String toInternal(String val) {
-    return NumberUtils.float2sortableStr(val);
-  }
-
-  @Override
-  public String toExternal(StorableField f) {
-    return indexedToReadable(f.stringValue());
-  }
-
-  @Override
-  public Float toObject(StorableField f) {
-    return NumberUtils.SortableStr2float(f.stringValue());
-  }
-  
-  @Override
-  public String indexedToReadable(String indexedForm) {
-    return NumberUtils.SortableStr2floatStr(indexedForm);
-  }
-
-  @Override
-  public CharsRef indexedToReadable(BytesRef input, CharsRef charsRef) {
-    // TODO: this could be more efficient, but the sortable types should be deprecated instead
-    UnicodeUtil.UTF8toUTF16(input, charsRef);
-    final char[] indexedToReadable = indexedToReadable(charsRef.toString()).toCharArray();
-    charsRef.copyChars(indexedToReadable, 0, indexedToReadable.length);
-    return charsRef;
-  }
-
-  @Override
-  public void write(TextResponseWriter writer, String name, StorableField f) throws IOException {
-    String sval = f.stringValue();
-    writer.writeFloat(name, NumberUtils.SortableStr2float(sval));
-  }
-
-  @Override
-  public Object marshalSortValue(Object value) {
-    if (null == value) {
-      return null;
-    }
-    CharsRef chars = new CharsRef();
-    UnicodeUtil.UTF8toUTF16((BytesRef)value, chars);
-    return NumberUtils.SortableStr2float(chars.toString());
-  }
-
-  @Override
-  public Object unmarshalSortValue(Object value) {
-    if (null == value) {
-      return null;
-    }
-    String sortableString = NumberUtils.float2sortableStr(value.toString());
-    BytesRef bytes = new BytesRef();
-    UnicodeUtil.UTF16toUTF8(sortableString, 0, sortableString.length(), bytes);
-    return bytes;
-  }
-}
-
-
-
-
-class SortableFloatFieldSource extends FieldCacheSource {
-  protected float defVal;
-
-  public SortableFloatFieldSource(String field) {
-    this(field, 0.0f);
-  }
-
-  public SortableFloatFieldSource(String field, float defVal) {
-    super(field);
-    this.defVal = defVal;
-  }
-
-    @Override
-    public String description() {
-    return "sfloat(" + field + ')';
-  }
-
-  @Override
-  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    final float def = defVal;
-
-    return new DocTermsIndexDocValues(this, readerContext, field) {
-      private final BytesRef spare = new BytesRef();
-
-      @Override
-      protected String toTerm(String readableValue) {
-        return NumberUtils.float2sortableStr(readableValue);
-      }
-
-      @Override
-      public boolean exists(int doc) {
-        return termsIndex.getOrd(doc) >= 0;
-      }
-
-      @Override
-      public float floatVal(int doc) {
-        int ord=termsIndex.getOrd(doc);
-        if (ord==-1) {
-          return def;
-        } else {
-          termsIndex.lookupOrd(ord, spare);
-          return NumberUtils.SortableStr2float(spare);
-        }
-      }
-
-      @Override
-      public int intVal(int doc) {
-        return (int)floatVal(doc);
-      }
-
-      @Override
-      public long longVal(int doc) {
-        return (long)floatVal(doc);
-      }
-
-      @Override
-      public double doubleVal(int doc) {
-        return (double)floatVal(doc);
-      }
-
-      @Override
-      public String strVal(int doc) {
-        return Float.toString(floatVal(doc));
-      }
-
-      @Override
-      public String toString(int doc) {
-        return description() + '=' + floatVal(doc);
-      }
-
-      @Override
-      public Object objectVal(int doc) {
-        return exists(doc) ? floatVal(doc) : null;
-      }
-
-      @Override
-      public ValueFiller getValueFiller() {
-        return new ValueFiller() {
-          private final MutableValueFloat mval = new MutableValueFloat();
-
-          @Override
-          public MutableValue getValue() {
-            return mval;
-          }
-
-          @Override
-          public void fillValue(int doc) {
-            int ord=termsIndex.getOrd(doc);
-            if (ord == -1) {
-              mval.value = def;
-              mval.exists = false;
-            } else {
-              termsIndex.lookupOrd(ord, spare);
-              mval.value = NumberUtils.SortableStr2float(spare);
-              mval.exists = true;
-            }
-          }
-        };
-      }
-    };
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    return o instanceof SortableFloatFieldSource
-            && super.equals(o)
-            && defVal == ((SortableFloatFieldSource)o).defVal;
-  }
-
-  private static int hcode = SortableFloatFieldSource.class.hashCode();
-  @Override
-  public int hashCode() {
-    return hcode + super.hashCode() + Float.floatToIntBits(defVal);
-  };
-}
-
-
-
-
diff --git a/solr/core/src/java/org/apache/solr/schema/SortableIntField.java b/solr/core/src/java/org/apache/solr/schema/SortableIntField.java
deleted file mode 100644
index 97cbfe2..0000000
--- a/solr/core/src/java/org/apache/solr/schema/SortableIntField.java
+++ /dev/null
@@ -1,247 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.schema;
-
-import org.apache.lucene.queries.function.FunctionValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.queries.function.docvalues.DocTermsIndexDocValues;
-import org.apache.lucene.queries.function.valuesource.FieldCacheSource;
-import org.apache.lucene.search.SortField;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CharsRef;
-import org.apache.lucene.util.UnicodeUtil;
-import org.apache.lucene.util.mutable.MutableValue;
-import org.apache.lucene.util.mutable.MutableValueInt;
-import org.apache.solr.search.QParser;
-import org.apache.lucene.index.AtomicReaderContext;
-import org.apache.lucene.index.GeneralField;
-import org.apache.lucene.index.IndexableField;
-import org.apache.lucene.index.StorableField;
-import org.apache.solr.util.NumberUtils;
-import org.apache.solr.response.TextResponseWriter;
-
-import java.util.Map;
-import java.io.IOException;
-
-/**
- * A legacy numeric field type that encodes "Integer" values as Strings such 
- * that Term enumeration order matches the natural numeric order.  This class 
- * should not be used except by people with existing indexes that already 
- * contain fields of this type.  New schemas should use {@link TrieIntField}.
- *
- * <p>
- * The naming convention "Sortable" comes from the fact that both the numeric 
- * values and encoded String representations Sort identically (as opposed to 
- * a direct String representation where values such as "11" sort before values 
- * such as "2").
- * </p>
- * 
- * @see TrieIntField
- * @deprecated use {@link IntField} or {@link TrieIntField} - will be removed in 5.x
- */
-@Deprecated
-public class SortableIntField extends PrimitiveFieldType implements IntValueFieldType {
-  @Override
-  public SortField getSortField(SchemaField field,boolean reverse) {
-    return getStringSort(field,reverse);
-  }
-
-  @Override
-  public ValueSource getValueSource(SchemaField field, QParser qparser) {
-    field.checkFieldCacheSource(qparser);
-    return new SortableIntFieldSource(field.name);
-  }
-
-  @Override
-  public String toInternal(String val) {
-    // special case single digits?  years?, etc
-    // stringCache?  general stringCache on a
-    // global field level?
-    return NumberUtils.int2sortableStr(val);
-  }
-
-  @Override
-  public String toExternal(StorableField f) {
-    return indexedToReadable(f.stringValue());
-  }
-
-  @Override
-  public String indexedToReadable(String indexedForm) {
-    return NumberUtils.SortableStr2int(indexedForm);
-  }
-
-  @Override
-  public CharsRef indexedToReadable(BytesRef input, CharsRef charsRef) {
-    // TODO: this could be more efficient, but the sortable types should be deprecated instead
-    UnicodeUtil.UTF8toUTF16(input, charsRef);
-    final char[] indexedToReadable = indexedToReadable(charsRef.toString()).toCharArray();
-    charsRef.copyChars(indexedToReadable, 0, indexedToReadable.length);
-    return charsRef;
-  }
-
-  @Override
-  public Integer toObject(StorableField f) {
-    return NumberUtils.SortableStr2int(f.stringValue(), 0, 3);    
-  }
-
-  @Override
-  public void write(TextResponseWriter writer, String name, StorableField f) throws IOException {
-    String sval = f.stringValue();
-    writer.writeInt(name, NumberUtils.SortableStr2int(sval,0,sval.length()));
-  }
-
-  @Override
-  public Object marshalSortValue(Object value) {
-    if (null == value) { 
-      return null;
-    }
-    CharsRef chars = new CharsRef();
-    UnicodeUtil.UTF8toUTF16((BytesRef)value, chars);
-    return NumberUtils.SortableStr2int(chars.toString());
-  }
-
-  @Override
-  public Object unmarshalSortValue(Object value) {
-    if (null == value) {
-      return null;
-    }
-    String sortableString = NumberUtils.int2sortableStr(value.toString());
-    BytesRef bytes = new BytesRef();
-    UnicodeUtil.UTF16toUTF8(sortableString, 0, sortableString.length(), bytes);
-    return bytes;
-  }
-}
-
-
-
-class SortableIntFieldSource extends FieldCacheSource {
-  protected int defVal;
-
-  public SortableIntFieldSource(String field) {
-    this(field, 0);
-  }
-
-  public SortableIntFieldSource(String field, int defVal) {
-    super(field);
-    this.defVal = defVal;
-  }
-
-  @Override
-  public String description() {
-    return "sint(" + field + ')';
-  }
-
-  @Override
-  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    final int def = defVal;
-
-    return new DocTermsIndexDocValues(this, readerContext, field) {
-      private final BytesRef spare = new BytesRef();
-
-      @Override
-      protected String toTerm(String readableValue) {
-        return NumberUtils.int2sortableStr(readableValue);
-      }
-
-      @Override
-      public float floatVal(int doc) {
-        return (float)intVal(doc);
-      }
-
-      @Override
-      public boolean exists(int doc) {
-        return termsIndex.getOrd(doc) >= 0;
-      }
-
-      @Override
-      public int intVal(int doc) {
-        int ord=termsIndex.getOrd(doc);
-        if (ord==-1) {
-          return def;
-        } else {
-          termsIndex.lookupOrd(ord, spare);
-          return NumberUtils.SortableStr2int(spare,0,3);
-        }
-      }
-
-      @Override
-      public long longVal(int doc) {
-        return (long)intVal(doc);
-      }
-
-      @Override
-      public double doubleVal(int doc) {
-        return (double)intVal(doc);
-      }
-
-      @Override
-      public String strVal(int doc) {
-        return Integer.toString(intVal(doc));
-      }
-
-      @Override
-      public String toString(int doc) {
-        return description() + '=' + intVal(doc);
-      }
-
-      @Override
-      public Object objectVal(int doc) {
-        return exists(doc) ? intVal(doc) : null;
-      }
-
-      @Override
-      public ValueFiller getValueFiller() {
-        return new ValueFiller() {
-          private final MutableValueInt mval = new MutableValueInt();
-
-          @Override
-          public MutableValue getValue() {
-            return mval;
-          }
-
-          @Override
-          public void fillValue(int doc) {
-            int ord=termsIndex.getOrd(doc);
-            if (ord == -1) {
-              mval.value = def;
-              mval.exists = false;
-            } else {
-              termsIndex.lookupOrd(ord, spare);
-              mval.value = NumberUtils.SortableStr2int(spare,0,3);
-              mval.exists = true;
-            }
-          }
-        };
-      }
-
-    };
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    return o instanceof SortableIntFieldSource
-            && super.equals(o)
-            && defVal == ((SortableIntFieldSource)o).defVal;
-  }
-
-  private static int hcode = SortableIntFieldSource.class.hashCode();
-  @Override
-  public int hashCode() {
-    return hcode + super.hashCode() + defVal;
-  };
-}
diff --git a/solr/core/src/java/org/apache/solr/schema/SortableLongField.java b/solr/core/src/java/org/apache/solr/schema/SortableLongField.java
deleted file mode 100644
index 3c48af1..0000000
--- a/solr/core/src/java/org/apache/solr/schema/SortableLongField.java
+++ /dev/null
@@ -1,244 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.schema;
-
-import org.apache.lucene.queries.function.FunctionValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.queries.function.docvalues.DocTermsIndexDocValues;
-import org.apache.lucene.queries.function.valuesource.FieldCacheSource;
-import org.apache.lucene.search.SortField;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CharsRef;
-import org.apache.lucene.util.UnicodeUtil;
-import org.apache.lucene.util.mutable.MutableValue;
-import org.apache.lucene.util.mutable.MutableValueLong;
-import org.apache.solr.search.QParser;
-import org.apache.lucene.index.AtomicReaderContext;
-import org.apache.lucene.index.GeneralField;
-import org.apache.lucene.index.IndexableField;
-import org.apache.lucene.index.StorableField;
-import org.apache.solr.util.NumberUtils;
-import org.apache.solr.response.TextResponseWriter;
-
-import java.util.Map;
-import java.io.IOException;
-/**
- * A legacy numeric field type that encodes "Long" values as Strings such 
- * that Term enumeration order matches the natural numeric order.  This class 
- * should not be used except by people with existing indexes that already 
- * contain fields of this type.  New schemas should use {@link TrieLongField}.
- *
- * <p>
- * The naming convention "Sortable" comes from the fact that both the numeric 
- * values and encoded String representations Sort identically (as opposed to 
- * a direct String representation where values such as "11" sort before values 
- * such as "2").
- * </p>
- * 
- * @see TrieLongField
- * @deprecated use {@link LongField} or {@link TrieLongField} - will be removed in 5.x
- */
-@Deprecated
-public class SortableLongField extends PrimitiveFieldType {
-  @Override
-  public SortField getSortField(SchemaField field,boolean reverse) {
-    return getStringSort(field,reverse);
-  }
-
-  @Override
-  public ValueSource getValueSource(SchemaField field, QParser qparser) {
-    field.checkFieldCacheSource(qparser);
-    return new SortableLongFieldSource(field.name);
-  }
-
-  @Override
-  public String toInternal(String val) {
-    return NumberUtils.long2sortableStr(val);
-  }
-
-  @Override
-  public String indexedToReadable(String indexedForm) {
-    return NumberUtils.SortableStr2long(indexedForm);
-  }
-
-  @Override
-  public CharsRef indexedToReadable(BytesRef input, CharsRef charsRef) {
-    // TODO: this could be more efficient, but the sortable types should be deprecated instead
-    UnicodeUtil.UTF8toUTF16(input, charsRef);
-    final char[] indexedToReadable = indexedToReadable(charsRef.toString()).toCharArray();
-    charsRef.copyChars(indexedToReadable, 0, indexedToReadable.length);
-    return charsRef;
-  }
-
-  @Override
-  public String toExternal(StorableField f) {
-    return indexedToReadable(f.stringValue());
-  }
-
-  @Override
-  public Long toObject(StorableField f) {
-    return NumberUtils.SortableStr2long(f.stringValue(),0,5);
-  }
-
-  @Override
-  public void write(TextResponseWriter writer, String name, StorableField f) throws IOException {
-    String sval = f.stringValue();
-    writer.writeLong(name, NumberUtils.SortableStr2long(sval,0,sval.length()));
-  }
-
-  @Override
-  public Object marshalSortValue(Object value) {
-    if (null == value) {
-      return null;
-    }
-    CharsRef chars = new CharsRef();
-    UnicodeUtil.UTF8toUTF16((BytesRef)value, chars);
-    return NumberUtils.SortableStr2long(chars.toString());
-  }
-
-  @Override
-  public Object unmarshalSortValue(Object value) {
-    if (null == value) {
-      return null;
-    }
-    String sortableString = NumberUtils.long2sortableStr(value.toString());
-    BytesRef bytes = new BytesRef();
-    UnicodeUtil.UTF16toUTF8(sortableString, 0, sortableString.length(), bytes);
-    return bytes;
-  }
-}
-
-
-
-
-
-class SortableLongFieldSource extends FieldCacheSource {
-  protected long defVal;
-
-  public SortableLongFieldSource(String field) {
-    this(field, 0);
-  }
-
-  public SortableLongFieldSource(String field, long defVal) {
-    super(field);
-    this.defVal = defVal;
-  }
-
-  @Override
-  public String description() {
-    return "slong(" + field + ')';
-  }
-
-  @Override
-  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    final long def = defVal;
-
-    return new DocTermsIndexDocValues(this, readerContext, field) {
-      private final BytesRef spare = new BytesRef();
-
-      @Override
-      protected String toTerm(String readableValue) {
-        return NumberUtils.long2sortableStr(readableValue);
-      }
-
-      @Override
-      public boolean exists(int doc) {
-        return termsIndex.getOrd(doc) >= 0;
-      }
-
-      @Override
-      public float floatVal(int doc) {
-        return (float)longVal(doc);
-      }
-
-      @Override
-      public int intVal(int doc) {
-        return (int)longVal(doc);
-      }
-
-      @Override
-      public long longVal(int doc) {
-        int ord=termsIndex.getOrd(doc);
-        if (ord==-1) {
-          return def;
-        } else {
-          termsIndex.lookupOrd(ord, spare);
-          return NumberUtils.SortableStr2long(spare,0,5);
-        }
-      }
-
-      @Override
-      public double doubleVal(int doc) {
-        return (double)longVal(doc);
-      }
-
-      @Override
-      public String strVal(int doc) {
-        return Long.toString(longVal(doc));
-      }
-
-      @Override
-      public Object objectVal(int doc) {
-        return exists(doc) ? longVal(doc) : null;
-      }
-
-      @Override
-      public String toString(int doc) {
-        return description() + '=' + longVal(doc);
-      }
-
-      @Override
-      public ValueFiller getValueFiller() {
-        return new ValueFiller() {
-          private final MutableValueLong mval = new MutableValueLong();
-
-          @Override
-          public MutableValue getValue() {
-            return mval;
-          }
-
-          @Override
-          public void fillValue(int doc) {
-            int ord=termsIndex.getOrd(doc);
-            if (ord == -1) {
-              mval.value = def;
-              mval.exists = false;
-            } else {
-              termsIndex.lookupOrd(ord, spare);
-              mval.value = NumberUtils.SortableStr2long(spare,0,5);
-              mval.exists = true;
-            }
-          }
-        };
-      }
-    };
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    return o instanceof SortableLongFieldSource
-            && super.equals(o)
-            && defVal == ((SortableLongFieldSource)o).defVal;
-  }
-
-  private static int hcode = SortableLongFieldSource.class.hashCode();
-  @Override
-  public int hashCode() {
-    return hcode + super.hashCode() + (int)defVal;
-  };
-}
diff --git a/solr/core/src/java/org/apache/solr/schema/StrFieldSource.java b/solr/core/src/java/org/apache/solr/schema/StrFieldSource.java
index 7cf4784..46629f0 100644
--- a/solr/core/src/java/org/apache/solr/schema/StrFieldSource.java
+++ b/solr/core/src/java/org/apache/solr/schema/StrFieldSource.java
@@ -73,7 +73,7 @@ public class StrFieldSource extends FieldCacheSource {
             && super.equals(o);
   }
 
-  private static int hcode = SortableFloatFieldSource.class.hashCode();
+  private static int hcode = StrFieldSource.class.hashCode();
   @Override
   public int hashCode() {
     return hcode + super.hashCode();
diff --git a/solr/core/src/java/org/apache/solr/schema/TrieDateField.java b/solr/core/src/java/org/apache/solr/schema/TrieDateField.java
index e92d601..79ff9f1 100644
--- a/solr/core/src/java/org/apache/solr/schema/TrieDateField.java
+++ b/solr/core/src/java/org/apache/solr/schema/TrieDateField.java
@@ -17,14 +17,15 @@
 
 package org.apache.solr.schema;
 
-import org.apache.solr.search.QParser;
 import org.apache.solr.common.SolrException;
+import org.apache.solr.common.util.DateUtil;
+import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.search.QParser;
 import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.update.processor.TimestampUpdateProcessorFactory; //jdoc
+import org.apache.solr.util.DateMathParser;
 import org.apache.lucene.document.FieldType.NumericType;
-import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.StorableField;
-import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.Query;
@@ -32,30 +33,312 @@ import org.apache.lucene.search.NumericRangeQuery;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.CharsRef;
 
+import java.text.DateFormat;
+import java.text.DecimalFormat;
+import java.text.DecimalFormatSymbols;
+import java.text.FieldPosition;
+import java.text.NumberFormat;
+import java.text.ParseException;
+import java.text.ParsePosition;
+import java.text.SimpleDateFormat;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Date;
 import java.io.IOException;
+import java.util.TimeZone;
 
 /**
+ * FieldType that can represent any Date/Time with millisecond precision.
+ * <p>
+ * Date Format for the XML, incoming and outgoing:
+ * </p>
+ * <blockquote>
+ * A date field shall be of the form 1995-12-31T23:59:59Z
+ * The trailing "Z" designates UTC time and is mandatory
+ * (See below for an explanation of UTC).
+ * Optional fractional seconds are allowed, as long as they do not end
+ * in a trailing 0 (but any precision beyond milliseconds will be ignored).
+ * All other parts are mandatory.
+ * </blockquote>
+ * <p>
+ * This format was derived to be standards compliant (ISO 8601) and is a more
+ * restricted form of the
+ * <a href="http://www.w3.org/TR/xmlschema-2/#dateTime-canonical-representation">canonical
+ * representation of dateTime</a> from XML schema part 2.  Examples...
+ * </p>
+ * <ul>
+ *   <li>1995-12-31T23:59:59Z</li>
+ *   <li>1995-12-31T23:59:59.9Z</li>
+ *   <li>1995-12-31T23:59:59.99Z</li>
+ *   <li>1995-12-31T23:59:59.999Z</li>
+ * </ul>
+ * <p>
+ * Note that TrieDateField is lenient with regards to parsing fractional
+ * seconds that end in trailing zeros and will ensure that those values
+ * are indexed in the correct canonical format.
+ * </p>
+ * <p>
+ * This FieldType also supports incoming "Date Math" strings for computing
+ * values by adding/rounding internals of time relative either an explicit
+ * datetime (in the format specified above) or the literal string "NOW",
+ * ie: "NOW+1YEAR", "NOW/DAY", "1995-12-31T23:59:59.999Z+5MINUTES", etc...
+ * -- see {@link DateMathParser} for more examples.
+ * </p>
  * <p>
- * An extension of {@link DateField} that supports the same values and 
- * syntax, but indexes the value more efficiently using a numeric 
- * {@link TrieField} under the covers.  See the description of 
- * {@link DateField} for more details of the supported usage.
+ * <b>NOTE:</b> Although it is possible to configure a <code>TrieDateField</code>
+ * instance with a default value of "<code>NOW</code>" to compute a timestamp
+ * of when the document was indexed, this is not advisable when using SolrCloud
+ * since each replica of the document may compute a slightly different value.
+ * {@link TimestampUpdateProcessorFactory} is recommended instead.
  * </p>
+ *
  * <p>
- * <b>NOTE:</b> Allthough it is possible to configure a <code>TrieDateField</code> 
- * instance with a default value of "<code>NOW</code>" to compute a timestamp 
- * of when the document was indexed, this is not advisable when using SolrCloud 
- * since each replica of the document may compute a slightly different value. 
- * {@link TimestampUpdateProcessorFactory} is recomended instead.
+ * Explanation of "UTC"...
  * </p>
+ * <blockquote>
+ * "In 1970 the Coordinated Universal Time system was devised by an
+ * international advisory group of technical experts within the International
+ * Telecommunication Union (ITU).  The ITU felt it was best to designate a
+ * single abbreviation for use in all languages in order to minimize
+ * confusion.  Since unanimous agreement could not be achieved on using
+ * either the English word order, CUT, or the French word order, TUC, the
+ * acronym UTC was chosen as a compromise."
+ * </blockquote>
  *
- * @see DateField
  * @see TrieField
  */
-public class TrieDateField extends DateField implements DateValueFieldType {
+public class TrieDateField extends PrimitiveFieldType implements DateValueFieldType {
+
+  public static final TimeZone UTC = TimeZone.getTimeZone("UTC");
+
+  /**
+   * Fixed TimeZone (UTC) needed for parsing/formatting Dates in the
+   * canonical representation.
+   */
+  protected static final TimeZone CANONICAL_TZ = UTC;
+  /**
+   * Fixed Locale needed for parsing/formatting Milliseconds in the
+   * canonical representation.
+   */
+  protected static final Locale CANONICAL_LOCALE = Locale.ROOT;
+
+  protected static final String NOW = "NOW";
+  protected static final char Z = 'Z';
+
+
+  /**
+   * Parses a String which may be a date (in the standard format)
+   * followed by an optional math expression.
+   * @param now an optional fixed date to use as "NOW" in the DateMathParser
+   * @param val the string to parse
+   */
+  public Date parseMath(Date now, String val) {
+    String math = null;
+    final DateMathParser p = new DateMathParser();
+
+    if (null != now) p.setNow(now);
+
+    if (val.startsWith(NOW)) {
+      math = val.substring(NOW.length());
+    } else {
+      final int zz = val.indexOf(Z);
+      if (0 < zz) {
+        math = val.substring(zz+1);
+        try {
+          // p.setNow(toObject(val.substring(0,zz)));
+          p.setNow(parseDate(val.substring(0,zz+1)));
+        } catch (ParseException e) {
+          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,
+                                  "Invalid Date in Date Math String:'" + val + '\'', e);
+        }
+      } else {
+        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,
+                                "Invalid Date String:'" +val+'\'');
+      }
+    }
+
+    if (null == math || math.equals("")) {
+      return p.getNow();
+    }
+
+    try {
+      return p.parseMath(math);
+    } catch (ParseException e) {
+      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,
+                              "Invalid Date Math String:'" +val+'\'',e);
+    }
+  }
+
+  /**
+   * Thread safe method that can be used by subclasses to format a Date
+   * without the trailing 'Z'.
+   */
+  protected String formatDate(Date d) {
+    return fmtThreadLocal.get().format(d);
+  }
+
+  /**
+   * Return the standard human readable form of the date
+   */
+  public static String formatExternal(Date d) {
+    return fmtThreadLocal.get().format(d) + Z;
+  }
+
+  /**
+   * @see #formatExternal
+   */
+  public String toExternal(Date d) {
+    return formatExternal(d);
+  }
+
+  /**
+   * Thread safe method that can be used by subclasses to parse a Date
+   * without the trailing 'Z'
+   */
+  public static Date parseDate(String s) throws ParseException {
+    return fmtThreadLocal.get().parse(s);
+  }
+
+  /** Parse a date string in the standard format, or any supported by DateUtil.parseDate */
+  public Date parseDateLenient(String s, SolrQueryRequest req) throws ParseException {
+    // request could define timezone in the future
+    try {
+      return fmtThreadLocal.get().parse(s);
+    } catch (Exception e) {
+      return DateUtil.parseDate(s);
+    }
+  }
+
+  /**
+   * Parses a String which may be a date
+   * followed by an optional math expression.
+   * @param now an optional fixed date to use as "NOW" in the DateMathParser
+   * @param val the string to parse
+   */
+  public Date parseMathLenient(Date now, String val, SolrQueryRequest req) {
+    String math = null;
+    final DateMathParser p = new DateMathParser();
+
+    if (null != now) p.setNow(now);
+
+    if (val.startsWith(NOW)) {
+      math = val.substring(NOW.length());
+    } else {
+      final int zz = val.indexOf(Z);
+      if (0 < zz) {
+        math = val.substring(zz+1);
+        try {
+          // p.setNow(toObject(val.substring(0,zz)));
+          p.setNow(parseDateLenient(val.substring(0,zz+1), req));
+        } catch (ParseException e) {
+          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,
+                                  "Invalid Date in Date Math String: '" + val + '\'', e);
+        }
+      } else {
+        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,
+                                "Invalid Date String: '" +val+'\'');
+      }
+    }
+
+    if (null == math || math.equals("")) {
+      return p.getNow();
+    }
+
+    try {
+      return p.parseMath(math);
+    } catch (ParseException e) {
+      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,
+                              "Invalid Date Math String: '" +val+'\'',e);
+    }
+  }
+
+
+
+  /**
+   * Thread safe DateFormat that can <b>format</b> in the canonical
+   * ISO8601 date format, not including the trailing "Z" (since it is
+   * left off in the internal indexed values)
+   */
+  private final static ThreadLocalDateFormat fmtThreadLocal
+      = new ThreadLocalDateFormat(new ISO8601CanonicalDateFormat());
+
+  private static class ISO8601CanonicalDateFormat extends SimpleDateFormat {
+
+    protected NumberFormat millisParser
+        = NumberFormat.getIntegerInstance(CANONICAL_LOCALE);
+
+    protected NumberFormat millisFormat = new DecimalFormat
+        (".###", new DecimalFormatSymbols(CANONICAL_LOCALE));
+
+    public ISO8601CanonicalDateFormat() {
+      super("yyyy-MM-dd'T'HH:mm:ss", CANONICAL_LOCALE);
+      this.setTimeZone(CANONICAL_TZ);
+    }
+
+    @Override
+    public Date parse(String i, ParsePosition p) {
+      /* delegate to SimpleDateFormat for easy stuff */
+      Date d = super.parse(i, p);
+      int milliIndex = p.getIndex();
+      /* worry about the milliseconds ourselves */
+      if (null != d &&
+          -1 == p.getErrorIndex() &&
+          milliIndex + 1 < i.length() &&
+          '.' == i.charAt(milliIndex)) {
+        p.setIndex(++milliIndex); // NOTE: ++ to chomp '.'
+        Number millis = millisParser.parse(i, p);
+        if (-1 == p.getErrorIndex()) {
+          int endIndex = p.getIndex();
+          d = new Date(d.getTime()
+              + (long)(millis.doubleValue() * Math.pow(10, (3 - endIndex + milliIndex))));
+        }
+      }
+      return d;
+    }
+
+    @Override
+    public StringBuffer format(Date d, StringBuffer toAppendTo, FieldPosition pos) {
+      /* delegate to SimpleDateFormat for easy stuff */
+      super.format(d, toAppendTo, pos);
+      /* worry about the milliseconds ourselves */
+      long millis = d.getTime() % 1000l;
+      if (0L == millis) {
+        return toAppendTo;
+      }
+      if (millis < 0L) {
+        // original date was prior to epoch
+        millis += 1000L;
+      }
+      int posBegin = toAppendTo.length();
+      toAppendTo.append(millisFormat.format(millis / 1000d));
+      if (DateFormat.MILLISECOND_FIELD == pos.getField()) {
+        pos.setBeginIndex(posBegin);
+        pos.setEndIndex(toAppendTo.length());
+      }
+      return toAppendTo;
+    }
+
+    @Override
+    public DateFormat clone() {
+      ISO8601CanonicalDateFormat c = (ISO8601CanonicalDateFormat)super.clone();
+      c.millisParser = NumberFormat.getIntegerInstance(CANONICAL_LOCALE);
+      c.millisFormat = new DecimalFormat(".###", new DecimalFormatSymbols(CANONICAL_LOCALE));
+      return c;
+    }
+  }
+
+  private static class ThreadLocalDateFormat extends ThreadLocal<DateFormat> {
+    DateFormat proto;
+    public ThreadLocalDateFormat(DateFormat d) {
+      super();
+      proto = d;
+    }
+    @Override
+    protected DateFormat initialValue() {
+      return (DateFormat)proto.clone();
+    }
+  }
 
   final TrieField wrappedField = new TrieField() {{
     type = TrieTypes.DATE;
@@ -174,8 +457,14 @@ public class TrieDateField extends DateField implements DateValueFieldType {
   public Query getRangeQuery(QParser parser, SchemaField field, String min, String max, boolean minInclusive, boolean maxInclusive) {
     return wrappedField.getRangeQuery(parser, field, min, max, minInclusive, maxInclusive);
   }
-  
+
   @Override
+  protected boolean hasProperty(int p) {
+    return wrappedField.hasProperty(p);
+  }
+
+
+  /** TrieDateField specific range query */
   public Query getRangeQuery(QParser parser, SchemaField sf, Date min, Date max, boolean minInclusive, boolean maxInclusive) {
     return NumericRangeQuery.newLongRange(sf.getName(), wrappedField.precisionStep,
               min == null ? null : min.getTime(),
diff --git a/solr/core/src/java/org/apache/solr/schema/TrieField.java b/solr/core/src/java/org/apache/solr/schema/TrieField.java
index a0aca98..ea4a558 100644
--- a/solr/core/src/java/org/apache/solr/schema/TrieField.java
+++ b/solr/core/src/java/org/apache/solr/schema/TrieField.java
@@ -83,9 +83,9 @@ public class TrieField extends PrimitiveFieldType {
 
   
   /**
-   * Used for handling date types following the same semantics as DateField
+   * Used for handling date types
    */
-  static final DateField dateField = new DateField();
+  static final TrieDateField dateField = new TrieDateField();
 
   @Override
   protected void init(IndexSchema schema, Map<String, String> args) {
@@ -421,7 +421,7 @@ public class TrieField extends PrimitiveFieldType {
   @Override
   public String toExternal(StorableField f) {
     return (type == TrieTypes.DATE)
-      ? dateField.toExternal((Date) toObject(f)) 
+      ? dateField.toExternal((Date) toObject(f))
       : toObject(f).toString();
   }
 
diff --git a/solr/core/src/java/org/apache/solr/search/ValueSourceParser.java b/solr/core/src/java/org/apache/solr/search/ValueSourceParser.java
index a2b567e..8637974 100644
--- a/solr/core/src/java/org/apache/solr/search/ValueSourceParser.java
+++ b/solr/core/src/java/org/apache/solr/search/ValueSourceParser.java
@@ -876,7 +876,7 @@ public abstract class ValueSourceParser implements NamedListInitializedPlugin {
 
 
 class DateValueSourceParser extends ValueSourceParser {
-  DateField df = new TrieDateField();
+  TrieDateField df = new TrieDateField();
 
   @Override
   public void init(NamedList args) {
@@ -893,9 +893,6 @@ class DateValueSourceParser extends ValueSourceParser {
   public ValueSource getValueSource(FunctionQParser fp, String arg) {
     if (arg == null) return null;
     SchemaField f = fp.req.getSchema().getField(arg);
-    if (f.getType().getClass() == DateField.class) {
-      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "Can't use ms() function on non-numeric legacy date field " + arg);
-    }
     return f.getType().getValueSource(f, fp);
   }
 
diff --git a/solr/core/src/java/org/apache/solr/spelling/suggest/DocumentExpressionDictionaryFactory.java b/solr/core/src/java/org/apache/solr/spelling/suggest/DocumentExpressionDictionaryFactory.java
index cb44d63..d5f9ced 100644
--- a/solr/core/src/java/org/apache/solr/spelling/suggest/DocumentExpressionDictionaryFactory.java
+++ b/solr/core/src/java/org/apache/solr/spelling/suggest/DocumentExpressionDictionaryFactory.java
@@ -29,11 +29,7 @@ import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.spell.Dictionary;
 import org.apache.lucene.search.suggest.DocumentValueSourceDictionary;
 import org.apache.solr.core.SolrCore;
-import org.apache.solr.schema.DoubleField;
 import org.apache.solr.schema.FieldType;
-import org.apache.solr.schema.FloatField;
-import org.apache.solr.schema.IntField;
-import org.apache.solr.schema.LongField;
 import org.apache.solr.schema.TrieDoubleField;
 import org.apache.solr.schema.TrieFloatField;
 import org.apache.solr.schema.TrieIntField;
@@ -116,13 +112,13 @@ public class DocumentExpressionDictionaryFactory extends DictionaryFactory {
     SortField.Type type = null;
     String fieldTypeName = core.getLatestSchema().getField(sortFieldName).getType().getTypeName();
     FieldType ft = core.getLatestSchema().getFieldTypes().get(fieldTypeName);
-    if (ft instanceof FloatField || ft instanceof TrieFloatField) {
+    if (ft instanceof TrieFloatField) {
       type = SortField.Type.FLOAT;
-    } else if (ft instanceof IntField || ft instanceof TrieIntField) {
+    } else if (ft instanceof TrieIntField) {
       type = SortField.Type.INT;
-    } else if (ft instanceof LongField || ft instanceof TrieLongField) {
+    } else if (ft instanceof TrieLongField) {
       type = SortField.Type.LONG;
-    } else if (ft instanceof DoubleField || ft instanceof TrieDoubleField) {
+    } else if (ft instanceof TrieDoubleField) {
       type = SortField.Type.DOUBLE;
     }
     return type;
diff --git a/solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.java b/solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.java
index a006ebb..d2a3a21 100644
--- a/solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.java
+++ b/solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.java
@@ -35,7 +35,7 @@ import org.apache.solr.request.SolrRequestInfo;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.LocalSolrQueryRequest;
 import org.apache.solr.response.SolrQueryResponse;
-import org.apache.solr.schema.DateField;
+import org.apache.solr.schema.TrieDateField;
 import org.apache.solr.update.AddUpdateCommand;
 import org.apache.solr.update.CommitUpdateCommand;
 import org.apache.solr.update.DeleteUpdateCommand;
@@ -402,7 +402,7 @@ public final class DocExpirationUpdateProcessorFactory
           try {
             DeleteUpdateCommand del = new DeleteUpdateCommand(req);
             del.setQuery("{!cache=false}" + expireField + ":[* TO " +
-                         DateField.formatExternal(SolrRequestInfo.getRequestInfo().getNOW())
+                         TrieDateField.formatExternal(SolrRequestInfo.getRequestInfo().getNOW())
                          + "]");
             proc.processDelete(del);
             
diff --git a/solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessorFactory.java b/solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessorFactory.java
index 5df67ba..9803bec 100644
--- a/solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessorFactory.java
+++ b/solr/core/src/java/org/apache/solr/update/processor/FieldMutatingUpdateProcessorFactory.java
@@ -91,7 +91,7 @@ import org.apache.solr.util.plugin.SolrCoreAware;
  *     &lt;str name="fieldRegex"&gt;.*SKIP.*&lt;/str&gt;
  *   &lt;/lst&gt;
  *   &lt;lst name="exclude"&gt;
- *     &lt;str name="typeClass"&gt;solr.DateField&lt;/str&gt;
+ *     &lt;str name="typeClass"&gt;solr.TrieDateField&lt;/str&gt;
  *   &lt;/lst&gt;
  * &lt;/processor&gt;</pre>
  * 
diff --git a/solr/core/src/java/org/apache/solr/update/processor/ParseDateFieldUpdateProcessorFactory.java b/solr/core/src/java/org/apache/solr/update/processor/ParseDateFieldUpdateProcessorFactory.java
index 2314952..967c3dd 100644
--- a/solr/core/src/java/org/apache/solr/update/processor/ParseDateFieldUpdateProcessorFactory.java
+++ b/solr/core/src/java/org/apache/solr/update/processor/ParseDateFieldUpdateProcessorFactory.java
@@ -50,7 +50,7 @@ import java.util.Map;
  * <p>
  * The default selection behavior is to mutate both those fields that don't match
  * a schema field, as well as those fields that match a schema field with a field 
- * type that uses class solr.DateField or a sub-class, including solr.TrieDateField.
+ * type that uses class solr.TrieDateField.
  * </p>
  * <p>
  * If all values are parseable as dates (or are already Date), then the field will
diff --git a/solr/core/src/java/org/apache/solr/update/processor/ParseDoubleFieldUpdateProcessorFactory.java b/solr/core/src/java/org/apache/solr/update/processor/ParseDoubleFieldUpdateProcessorFactory.java
index 07c984c..27c0458 100644
--- a/solr/core/src/java/org/apache/solr/update/processor/ParseDoubleFieldUpdateProcessorFactory.java
+++ b/solr/core/src/java/org/apache/solr/update/processor/ParseDoubleFieldUpdateProcessorFactory.java
@@ -39,8 +39,7 @@ import java.util.Locale;
  * <p>
  * The default selection behavior is to mutate both those fields that don't match
  * a schema field, as well as those fields that match a schema field with a field 
- * type that uses class solr.DoubleField, solr.TrieDoubleField, or 
- * solr.SortableDoubleField.
+ * type that uses class solr.TrieDoubleField.
  * </p>
  * <p>
  * If all values are parseable as double (or are already Double), then the field
diff --git a/solr/core/src/java/org/apache/solr/update/processor/ParseFloatFieldUpdateProcessorFactory.java b/solr/core/src/java/org/apache/solr/update/processor/ParseFloatFieldUpdateProcessorFactory.java
index b085b80..2eebaf7 100644
--- a/solr/core/src/java/org/apache/solr/update/processor/ParseFloatFieldUpdateProcessorFactory.java
+++ b/solr/core/src/java/org/apache/solr/update/processor/ParseFloatFieldUpdateProcessorFactory.java
@@ -39,8 +39,7 @@ import java.util.Locale;
  * <p>
  * The default selection behavior is to mutate both those fields that don't match
  * a schema field, as well as those fields that match a schema field with a field 
- * type that uses class solr.FloatField, solr.TrieFloatField, or 
- * solr.SortableFloatField.
+ * type that uses class solr.TrieFloatField.
  * </p>
  * <p>
  * If all values are parseable as float (or are already Float), then the field
diff --git a/solr/core/src/java/org/apache/solr/update/processor/ParseIntFieldUpdateProcessorFactory.java b/solr/core/src/java/org/apache/solr/update/processor/ParseIntFieldUpdateProcessorFactory.java
index 51faad7..cc51d96 100644
--- a/solr/core/src/java/org/apache/solr/update/processor/ParseIntFieldUpdateProcessorFactory.java
+++ b/solr/core/src/java/org/apache/solr/update/processor/ParseIntFieldUpdateProcessorFactory.java
@@ -36,8 +36,7 @@ import java.util.Locale;
  * <p>
  * The default selection behavior is to mutate both those fields that don't match
  * a schema field, as well as those fields that match a schema field with a field 
- * type that uses class solr.IntField, solr.TrieIntField, or
- * solr.SortableIntField.
+ * type that uses class solr.TrieIntField.
  * </p>
  * <p>
  * If all values are parseable as int (or are already Integer), then the field
diff --git a/solr/core/src/java/org/apache/solr/update/processor/ParseLongFieldUpdateProcessorFactory.java b/solr/core/src/java/org/apache/solr/update/processor/ParseLongFieldUpdateProcessorFactory.java
index 1b0ceb5..b787678 100644
--- a/solr/core/src/java/org/apache/solr/update/processor/ParseLongFieldUpdateProcessorFactory.java
+++ b/solr/core/src/java/org/apache/solr/update/processor/ParseLongFieldUpdateProcessorFactory.java
@@ -36,8 +36,7 @@ import java.util.Locale;
  * <p>
  * The default selection behavior is to mutate both those fields that don't match
  * a schema field, as well as those fields that match a schema field with a field 
- * type that uses class solr.LongField, solr.TrieLongField, or 
- * solr.SortableLongField.
+ * type that uses class solr.TrieLongField.
  * </p>
  * <p>
  * If all values are parseable as long (or are already Long), then the field
diff --git a/solr/core/src/java/org/apache/solr/util/BCDUtils.java b/solr/core/src/java/org/apache/solr/util/BCDUtils.java
deleted file mode 100644
index c5c252d..0000000
--- a/solr/core/src/java/org/apache/solr/util/BCDUtils.java
+++ /dev/null
@@ -1,532 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.util;
-
-
-/**
- *
- */
-public class BCDUtils {
-  // idiv is expensive...
-  // use fixed point math to multiply by 1/10
-  // http://www.cs.uiowa.edu/~jones/bcd/divide.html
-  private static int div10(int a) { return (a * 0xcccd) >>> 19; }
-  private static int mul10(int a) { return (a*10); }
-  // private static int mul10(int a) { return ((a<<3)+(a<<1)); }
-  // private static int mul10(int a) { return (a+(a<<2))<<1; } // attempt to use LEA instr
-  // (imul32 on AMD64 only has a 3 cycle latency in any case)
-
-
-  // something that won't clash with other base100int
-// chars (something >= 100)
-  private static final char NEG_CHAR=(char)126;
-  // The zero exponent.
-// NOTE: for smaller integer representations, this current implementation
-// combines sign and exponent into the first char.  sign is negative if
-// exponent is less than the zero point (no negative exponents themselves)
-  private static final int ZERO_EXPONENT='a';  // 97
-
-  // WARNING: assumption is that this is a legal int...
-// no validation is done.  [+-]?digit*
-//
-// Normalization of zeros *is* done...
-//  0004, 004, 04, 4 will all end up being equal
-//  0,-0 are normalized to '' (zero length)
-//
-// The value is written to the output buffer
-// from the end to the start.  The return value
-// is the start of the Base100 int in the output buffer.
-//
-// As the output will be smaller than the input, arr and
-// out may refer to the same array if desired.
-//
-  public static int base10toBase100(char[] arr, int start, int end,
-                                    char[] out, int outend
-                                    )
-  {
-    int wpos=outend;  // write position
-    boolean neg=false;
-
-    while (--end >= start) {
-      int val = arr[end];
-      if (val=='+') { break; }
-      else if (val=='-') { neg=!neg; break; }
-      else {
-        val = val - '0';
-        if (end > start) {
-          int val2 = arr[end-1];
-          if (val2=='+') { out[--wpos]=(char)val; break; }
-          if (val2=='-') { out[--wpos]=(char)val; neg=!neg; break; }
-          end--;
-          val = val + (val2 - '0')*10;
-        }
-        out[--wpos] = (char)val;
-      }
-    }
-
-    // remove leading base100 zeros
-    while (wpos<outend && out[wpos]==0) wpos++;
-
-    // check for a zero value
-    if (wpos==outend) {
-      // if zero, don't add negative sign
-    } else if (neg) {
-      out[--wpos]=NEG_CHAR;
-    }
-
-    return wpos;  // the start of the base100 int
-  }
-
-  // Converts a base100 number to base10 character form
-// returns number of chars written.
-// At least 1 char is always written.
-  public static int base100toBase10(char[] arr, int start, int end,
-                                    char[] out, int offset)
-  {
-    int wpos=offset;  // write position
-    boolean firstDigit=true;
-    for (int i=start; i<end; i++) {
-      int val = arr[i];
-      if (val== NEG_CHAR) { out[wpos++]='-'; continue; }
-      char tens = (char)(val / 10 + '0');
-      if (!firstDigit || tens!='0') {  // skip leading 0
-        out[wpos++] = (char)(val / 10 + '0');    // tens position
-      }
-      out[wpos++] = (char)(val % 10 + '0');    // ones position
-      firstDigit=false;
-    }
-    if (firstDigit) out[wpos++]='0';
-    return wpos-offset;
-  }
-
-  public static String base10toBase100SortableInt(String val) {
-    char[] arr = new char[val.length()+1];
-    val.getChars(0,val.length(),arr,0);
-    int len = base10toBase100SortableInt(arr,0,val.length(),arr,arr.length);
-    return new String(arr,arr.length-len,len);
-  }
-
-  public static String base100SortableIntToBase10(String val) {
-    int slen = val.length();
-    char[] arr = new char[slen<<2];
-    val.getChars(0,slen,arr,0);
-    int len = base100SortableIntToBase10(arr,0,slen,arr,slen);
-    return new String(arr,slen,len);
-  }
-
-  public static String base10toBase10kSortableInt(String val) {
-    char[] arr = new char[val.length()+1];
-    val.getChars(0,val.length(),arr,0);
-    int len = base10toBase10kSortableInt(arr,0,val.length(),arr,arr.length);
-    return new String(arr,arr.length-len,len);
-  }
-
-  public static String base10kSortableIntToBase10(String val) {
-    int slen = val.length();
-    char[] arr = new char[slen*5]; // +1 time for orig, +4 for new
-    val.getChars(0,slen,arr,0);
-    int len = base10kSortableIntToBase10(arr,0,slen,arr,slen);
-    return new String(arr,slen,len);
-  }
-
-  /********* FUTURE
-    // the zero exponent... exponents above this point are positive
-    // and below are negative.
-    // It is desirable to make ordinary numbers have a single byte
-    // exponent when converted to UTF-8
-    // For integers, the exponent will always be >=0, but this format
-    // is meant to be valid for floating point numbers as well...
-    private static final int ZERO_EXPONENT='a';  // 97
-
-    // if exponent is larger than what can be represented
-    // in a single byte (char), then this is the multibyte
-    // escape char.
-    // UCS-2 surrogates start at 0xD800
-    private static final int POSITIVE_EXPONENT_ESCAPE=0x3fff;
-
-    // if exponent is smaller than what can be represented in
-    // a single byte, then this is the multibyte escape
-    private static final int NEGATIVE_EXPONENT_ESCAPE=1;
-
-    // if number is negative, it starts with this optional value
-    // this should not overlap with any exponent values
-    private static final int NEGATIVE_SIGN=0;
-  **********/
-
-    // WARNING: assumption is that this is a legal int...
-    // no validation is done.  [+-]?digit*
-    //
-    // Normalization of zeros *is* done...
-    //  0004, 004, 04, 4 will all end up being equal
-    //  0,-0 are normalized to '' (zero length)
-    //
-    // The value is written to the output buffer
-    // from the end to the start.  The return value
-    // is the start of the Base100 int in the output buffer.
-    //
-    // As the output will be smaller than the input, arr and
-    // out may refer to the same array if desired.
-    //
-    public static int base10toBase100SortableInt(char[] arr, int start, int end,
-                                                 char[] out, int outend
-                                      )
-    {
-      int wpos=outend;  // write position
-      boolean neg=false;
-      --end;  // position end pointer *on* the last char
-
-      // read signs and leading zeros
-      while (start <= end) {
-        char val = arr[start];
-        if (val=='-') neg=!neg;
-        else if (val>='1' && val<='9') break;
-        start++;
-      }
-
-      // eat whitespace on RHS?
-      outer: while (start <= end) {
-        switch(arr[end]) {
-          case ' ':
-          case '\t':
-          case '\n':
-          case '\r': end--; break;
-          default: break outer;
-        }
-      }
-
-      int hundreds=0;
-      /******************************************************
-       * remove RHS zero normalization since it only helps 1 in 100
-       * numbers and complicates both encoding and decoding.
-
-      // remove pairs of zeros on the RHS and keep track of
-      // the count.
-      while (start <= end) {
-        char val = arr[end];
-
-        if (val=='0' && start <= end) {
-          val=arr[end-1];
-          if (val=='0') {
-            hundreds++;
-            end-=2;
-            continue;
-          }
-        }
-
-        break;
-      }
-      *************************************************************/
-
-
-      // now start at the end and work our way forward
-      // encoding two base 10 digits into 1 base 100 digit
-      while (start <= end) {
-        int val = arr[end--];
-        val = val - '0';
-        if (start <= end) {
-          int val2 = arr[end--];
-          val = val + (val2 - '0')*10;
-        }
-        out[--wpos] = neg ? (char)(99-val) : (char)val;
-      }
-
-      /****** FUTURE: not needed for this implementation of exponent combined with sign
-      // normalize all zeros to positive values
-      if (wpos==outend) neg=false;
-      ******/
-
-      // adjust exponent by the number of base 100 chars written
-      hundreds += outend - wpos;
-
-      // write the exponent and sign combined
-      out[--wpos] = neg ? (char)(ZERO_EXPONENT - hundreds) : (char)(ZERO_EXPONENT + hundreds);
-
-      return outend-wpos;  // the length of the base100 int
-    }
-
-  // Converts a base100 sortable number to base10 character form
-// returns number of chars written.
-// At least 1 char is always written.
-  public static int base100SortableIntToBase10(char[] arr, int start, int end,
-                                               char[] out, int offset)
-  {
-    // Take care of "0" case first.  It's the only number that is represented
-    // in one char.
-    if (end-start == 1) {
-      out[offset]='0';
-      return 1;
-    }
-
-    int wpos = offset;  // write position
-    boolean neg = false;
-    int exp = arr[start++];
-    if (exp < ZERO_EXPONENT) {
-      neg=true;
-      exp = ZERO_EXPONENT - exp;
-      out[wpos++]='-';
-    }
-
-    boolean firstDigit=true;
-    while (start < end) {
-      int val = arr[start++];
-      if (neg) val = 99 - val;
-      // opt - if we ever want a faster version we can avoid one integer
-      // divide by using fixed point math to multiply by 1/10
-      // http://www.cs.uiowa.edu/~jones/bcd/divide.html
-      // TIP: write a small function in gcc or cl and see what
-      // the optimized assemply output looks like (and which is fastest).
-      // In C you can specify "unsigned" which gives the compiler more
-      // info than the Java compiler has.
-      char tens = (char)(val / 10 + '0');
-      if (!firstDigit || tens!='0') {  // skip leading 0
-        out[wpos++] = tens;      // write tens position
-      }
-      out[wpos++] = (char)(val % 10 + '0');    // write ones position
-      firstDigit=false;
-    }
-
-    // OPTIONAL: if trailing zeros were truncated, then this is where
-    // we would restore them (compare number of chars read vs exponent)
-
-    return wpos-offset;
-  }
-
-  public static int base10toBase10kSortableInt(char[] arr, int start, int end,
-                                               char[] out, int outend
-                                    )
-  {
-    int wpos=outend;  // write position
-    boolean neg=false;
-    --end;  // position end pointer *on* the last char
-
-    // read signs and leading zeros
-    while (start <= end) {
-      char val = arr[start];
-      if (val=='-') neg=!neg;
-      else if (val>='1' && val<='9') break;
-      start++;
-    }
-
-    // eat whitespace on RHS?
-    outer: while (start <= end) {
-      switch(arr[end]) {
-        case ' ': // fallthrough
-        case '\t': // fallthrough
-        case '\n': // fallthrough
-        case '\r': end--; break;
-        default: break outer;
-      }
-    }
-
-    int exp=0;
-
-    /******************************************************
-     * remove RHS zero normalization since it only helps 1 in 100
-     * numbers and complicates both encoding and decoding.
-
-    // remove pairs of zeros on the RHS and keep track of
-    // the count.
-    while (start <= end) {
-      char val = arr[end];
-
-      if (val=='0' && start <= end) {
-        val=arr[end-1];
-        if (val=='0') {
-          hundreds++;
-          end-=2;
-          continue;
-        }
-      }
-
-      break;
-    }
-    *************************************************************/
-
-
-    // now start at the end and work our way forward
-    // encoding two base 10 digits into 1 base 100 digit
-    while (start <= end) {
-      int val = arr[end--] - '0';          // ones
-      if (start <= end) {
-        val += (arr[end--] - '0')*10;      // tens
-        if (start <= end) {
-          val += (arr[end--] - '0')*100;    // hundreds
-          if (start <= end) {
-            val += (arr[end--] - '0')*1000;  // thousands
-          }
-        }
-      }
-      out[--wpos] = neg ? (char)(9999-val) : (char)val;
-    }
-
-
-    /****** FUTURE: not needed for this implementation of exponent combined with sign
-    // normalize all zeros to positive values
-    if (wpos==outend) neg=false;
-    ******/
-
-    // adjust exponent by the number of base 100 chars written
-    exp += outend - wpos;
-
-    // write the exponent and sign combined
-    out[--wpos] = neg ? (char)(ZERO_EXPONENT - exp) : (char)(ZERO_EXPONENT + exp);
-
-    return outend-wpos;  // the length of the base100 int
-  }
-
-  // Converts a base100 sortable number to base10 character form
-// returns number of chars written.
-// At least 1 char is always written.
-  public static int base10kSortableIntToBase10(char[] arr, int start, int end,
-                                               char[] out, int offset)
-  {
-    // Take care of "0" case first.  It's the only number that is represented
-    // in one char since we don't chop trailing zeros.
-    if (end-start == 1) {
-      out[offset]='0';
-      return 1;
-    }
-
-    int wpos = offset;  // write position
-    boolean neg;
-    int exp = arr[start++];
-    if (exp < ZERO_EXPONENT) {
-      neg=true;
-      // We don't currently use exp on decoding...
-      // exp = ZERO_EXPONENT - exp;
-      out[wpos++]='-';
-    } else {
-      neg=false;
-    }
-
-    // since so many values will fall in one char, pull it
-    // out of the loop (esp since the first value must
-    // be special-cased to not print leading zeros.
-    // integer division is still expensive, so it's best to check
-    // if you actually need to do it.
-    //
-    // TIP: write a small function in gcc or cl and see what
-    // the optimized assemply output looks like (and which is fastest).
-    // In C you can specify "unsigned" which gives the compiler more
-    // info than the Java compiler has.
-    int val = arr[start++];
-    if (neg) val = 9999 - val;
-
-    /***
-    if (val < 10) {
-      out[wpos++] = (char)(val + '0');
-    } else if (val < 100) {
-      out[wpos++] = (char)(val/10 + '0');
-      out[wpos++] = (char)(val%10 + '0');
-    } else if (val < 1000) {
-      out[wpos++] = (char)(val/100 + '0');
-      out[wpos++] = (char)((val/10)%10 + '0');
-      out[wpos++] = (char)(val%10 + '0');
-    } else {
-      out[wpos++] = (char)(val/1000 + '0');
-      out[wpos++] = (char)((val/100)%10 + '0');
-      out[wpos++] = (char)((val/10)%10 + '0');
-      out[wpos++] = (char)(val % 10 + '0');
-    }
-    ***/
-
-    if (val < 10) {
-      out[wpos++] = (char)(val + '0');
-    } else if (val < 100) {
-      int div = div10(val);
-      int ones = val - mul10(div); // mod 10
-      out[wpos++] = (char)(div + '0');
-      out[wpos++] = (char)(ones + '0');
-    } else if (val < 1000) {
-      int div = div10(val);
-      int ones = val - mul10(div); // mod 10
-      val=div;
-      div = div10(val);
-      int tens = val - mul10(div); // mod 10
-      out[wpos++] = (char)(div + '0');
-      out[wpos++] = (char)(tens + '0');
-      out[wpos++] = (char)(ones + '0');
-    } else {
-      int div = div10(val);
-      int ones = val - mul10(div); // mod 10
-      val=div;
-      div = div10(val);
-      int tens = val - mul10(div); // mod 10
-      val=div;
-      div = div10(val);
-      int hundreds = val - mul10(div); // mod 10
-
-      out[wpos++] = (char)(div + '0');
-      out[wpos++] = (char)(hundreds + '0');
-      out[wpos++] = (char)(tens + '0');
-      out[wpos++] = (char)(ones + '0');
-    }
-
-
-    while (start < end) {
-      val = arr[start++];
-      if (neg) val = 9999 - val;
-
-      int div = div10(val);
-      int ones = val - mul10(div); // mod 10
-      val=div;
-      div = div10(val);
-      int tens = val - mul10(div); // mod 10
-      val=div;
-      div = div10(val);
-      int hundreds = val - mul10(div); // mod 10
-
-      /***
-      int ones = val % 10;
-      val /= 10;
-      int tens = val!=0 ? val % 10 : 0;
-      val /= 10;
-      int hundreds = val!=0 ? val % 10 : 0;
-      val /= 10;
-      int thousands = val!=0 ? val % 10 : 0;
-      ***/
-
-      /***
-      int thousands = val>=1000 ? val/1000 : 0;
-      int hundreds  = val>=100 ? (val/100)%10 : 0;
-      int tens      = val>=10 ? (val/10)%10 : 0;
-      int ones      = val % 10;
-      ***/
-
-      /***
-      int thousands =  val/1000;
-      int hundreds  = (val/100)%10;
-      int tens      = (val/10)%10;
-      int ones      = val % 10;
-      ***/
-
-      out[wpos++] = (char)(div + '0');
-      out[wpos++] = (char)(hundreds + '0');
-      out[wpos++] = (char)(tens + '0');
-      out[wpos++] = (char)(ones + '0');
-    }
-
-    // OPTIONAL: if trailing zeros were truncated, then this is where
-    // we would restore them (compare number of chars read vs exponent)
-
-    return wpos-offset;
-  }
-
-
-
-}
diff --git a/solr/core/src/test-files/solr/analysisconfs/analysis-err-schema.xml b/solr/core/src/test-files/solr/analysisconfs/analysis-err-schema.xml
index 9072b8d..2ebe16c 100644
--- a/solr/core/src/test-files/solr/analysisconfs/analysis-err-schema.xml
+++ b/solr/core/src/test-files/solr/analysisconfs/analysis-err-schema.xml
@@ -23,7 +23,7 @@
 <schema name="test" version="1.5">
   <types>
     <fieldtype name="long" class="solr.TrieLongField" stored="true" indexed="true" />
-    <fieldtype name="sint" class="solr.SortableIntField" />
+    <fieldtype name="int" class="solr.TrieIntField" precisionStep="0"/>
     <fieldtype name="text" class="solr.TextField">
       <analyzer>
         <tokenizer class="solr.StandardTokenizerFactory"/>
@@ -34,7 +34,7 @@
 
 
  <fields>
-   <field name="id" type="sint" indexed="true" stored="true" multiValued="false"/>
+   <field name="id" type="int" indexed="true" stored="true" multiValued="false"/>
    <field name="text" type="text" indexed="true" stored="true"/>
    <field name="_version_" type="long" />
  </fields>
diff --git a/solr/core/src/test-files/solr/collection1/conf/bad-schema-dup-fieldType.xml b/solr/core/src/test-files/solr/collection1/conf/bad-schema-dup-fieldType.xml
index 34ef44b..98e23be3 100644
--- a/solr/core/src/test-files/solr/collection1/conf/bad-schema-dup-fieldType.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/bad-schema-dup-fieldType.xml
@@ -23,8 +23,8 @@
     <fieldType name="string" class="solr.StrField"/>
     
     <!-- BEGIN BAD STUFF -->
-    <fieldType name="ftAgain" class="solr.IntField"/>
-    <fieldType name="ftAgain" class="solr.IntField"/>
+    <fieldType name="ftAgain" class="solr.TrieIntField"/>
+    <fieldType name="ftAgain" class="solr.TrieIntField"/>
     <!-- END BAD STUFF -->
     
  </types>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-binaryfield.xml b/solr/core/src/test-files/solr/collection1/conf/schema-binaryfield.xml
index 1f9312e..63db983 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-binaryfield.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-binaryfield.xml
@@ -34,59 +34,45 @@
          behavior of the fieldtype.
       -->
 
-    <!-- numeric field types that store and index the text
-         value verbatim (and hence don't sort correctly or support range queries.)
-         These are provided more for backward compatability, allowing one
-         to create a schema that matches an existing lucene index.
+    <!--
+      Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
     -->
-    <fieldType name="integer" class="solr.IntField"/>
-    <fieldType name="long" class="solr.LongField"/>
-    <fieldtype name="float" class="solr.FloatField"/>
-    <fieldType name="double" class="solr.DoubleField"/>
-
-    <!-- numeric field types that manipulate the value into
-       a string value that isn't human readable in it's internal form,
-       but sorts correctly and supports range queries.
-
-         If sortMissingLast="true" then a sort on this field will cause documents
-       without the field to come after documents with the field,
-       regardless of the requested sort order.
-         If sortMissingFirst="true" then a sort on this field will cause documents
-       without the field to come before documents with the field,
-       regardless of the requested sort order.
-         If sortMissingLast="false" and sortMissingFirst="false" (the default),
-       then default lucene sorting will be used which places docs without the field
-       first in an ascending sort and last in a descending sort.
+    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
+    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
+    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
+
+    <!--
+     Numeric field types that index each value at various levels of precision
+     to accelerate range queries when the number of values between the range
+     endpoints is large. See the javadoc for NumericRangeQuery for internal
+     implementation details.
+
+     Smaller precisionStep values (specified in bits) will lead to more tokens
+     indexed per value, slightly larger index size, and faster range queries.
+     A precisionStep of 0 disables indexing at different precision levels.
     -->
-    <fieldtype name="sint" class="solr.SortableIntField" sortMissingLast="true"/>
-    <fieldtype name="slong" class="solr.SortableLongField" sortMissingLast="true"/>
-    <fieldtype name="sfloat" class="solr.SortableFloatField" sortMissingLast="true"/>
-    <fieldtype name="sdouble" class="solr.SortableDoubleField" sortMissingLast="true"/>
-    <fieldtype name="binary" class="solr.BinaryField"/>
-
-    <!-- bcd versions of sortable numeric type may provide smaller
-         storage space and support very large numbers.
-    -->
-    <fieldtype name="bcdint" class="solr.BCDIntField" sortMissingLast="true"/>
-    <fieldtype name="bcdlong" class="solr.BCDLongField" sortMissingLast="true"/>
-    <fieldtype name="bcdstr" class="solr.BCDStrField" sortMissingLast="true"/>
-
+    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
+    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
+    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
+    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
 
 
+    <fieldtype name="binary" class="solr.BinaryField"/>
     <fieldtype name="boolean" class="solr.BoolField" sortMissingLast="true"/>
     <fieldtype name="string" class="solr.StrField" sortMissingLast="true"/>
 
     <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
          seconds part (.999) is optional.
       -->
-    <fieldtype name="date" class="solr.DateField" sortMissingLast="true"/>
+    <fieldtype name="date" class="solr.TrieDateField" sortMissingLast="true"/>
 
 
 
  </types>
 
  <fields>
-   <field name="id" type="integer" indexed="true" stored="true" multiValued="false" required="true"/>
+   <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="true"/>
    <field name="data" type="binary" stored="true"/>
 
  </fields>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-copyfield-test.xml b/solr/core/src/test-files/solr/collection1/conf/schema-copyfield-test.xml
index 3ab7837..25e0d29 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-copyfield-test.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-copyfield-test.xml
@@ -34,41 +34,28 @@
          behavior of the fieldtype.
       -->
 
-    <!-- numeric field types that store and index the text
-         value verbatim (and hence don't sort correctly or support range queries.)
-         These are provided more for backward compatability, allowing one
-         to create a schema that matches an existing lucene index.
+    <!--
+      Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
     -->
-    <fieldType name="integer" class="solr.IntField"/>
-    <fieldType name="long" class="solr.LongField"/>
-    <fieldtype name="float" class="solr.FloatField"/>
-    <fieldType name="double" class="solr.DoubleField"/>
-
-    <!-- numeric field types that manipulate the value into
-       a string value that isn't human readable in it's internal form,
-       but sorts correctly and supports range queries.
-
-         If sortMissingLast="true" then a sort on this field will cause documents
-       without the field to come after documents with the field,
-       regardless of the requested sort order.
-         If sortMissingFirst="true" then a sort on this field will cause documents
-       without the field to come before documents with the field,
-       regardless of the requested sort order.
-         If sortMissingLast="false" and sortMissingFirst="false" (the default),
-       then default lucene sorting will be used which places docs without the field
-       first in an ascending sort and last in a descending sort.
+    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
+    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
+    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
+
+    <!--
+     Numeric field types that index each value at various levels of precision
+     to accelerate range queries when the number of values between the range
+     endpoints is large. See the javadoc for NumericRangeQuery for internal
+     implementation details.
+
+     Smaller precisionStep values (specified in bits) will lead to more tokens
+     indexed per value, slightly larger index size, and faster range queries.
+     A precisionStep of 0 disables indexing at different precision levels.
     -->
-    <fieldtype name="sint" class="solr.SortableIntField" sortMissingLast="true"/>
-    <fieldtype name="slong" class="solr.SortableLongField" sortMissingLast="true"/>
-    <fieldtype name="sfloat" class="solr.SortableFloatField" sortMissingLast="true"/>
-    <fieldtype name="sdouble" class="solr.SortableDoubleField" sortMissingLast="true"/>
-
-    <!-- bcd versions of sortable numeric type may provide smaller
-         storage space and support very large numbers.
-    -->
-    <fieldtype name="bcdint" class="solr.BCDIntField" sortMissingLast="true"/>
-    <fieldtype name="bcdlong" class="solr.BCDLongField" sortMissingLast="true"/>
-    <fieldtype name="bcdstr" class="solr.BCDStrField" sortMissingLast="true"/>
+    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
+    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
+    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
+    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
 
     <!-- Field type demonstrating an Analyzer failure -->
     <fieldtype name="failtype1" class="solr.TextField">
@@ -98,7 +85,7 @@
     <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
          seconds part (.999) is optional.
       -->
-    <fieldtype name="date" class="solr.DateField" sortMissingLast="true"/>
+    <fieldtype name="date" class="solr.TrieDateField" sortMissingLast="true"/>
 
     <!-- solr.TextField allows the specification of custom
          text analyzers specified as a tokenizer and a list
@@ -308,7 +295,7 @@
 
 
  <fields>
-   <field name="id" type="integer" indexed="true" stored="true" multiValued="false" required="false"/>
+   <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="false"/>
    <field name="name" type="nametext" indexed="true" stored="true"/>
    <field name="text" type="text" indexed="true" stored="false"/>
    <field name="subject" type="text" indexed="true" stored="true"/>
@@ -331,8 +318,8 @@
    <field name="bind" type="boolean" indexed="true" stored="false"/>
    <field name="bsto" type="boolean" indexed="false" stored="true"/>
    <field name="bindsto" type="boolean" indexed="true" stored="true"/>
-   <field name="isto" type="integer" indexed="false" stored="true"/>
-   <field name="iind" type="integer" indexed="true" stored="false"/>
+   <field name="isto" type="int" indexed="false" stored="true"/>
+   <field name="iind" type="int" indexed="true" stored="false"/>
    <field name="ssto" type="string" indexed="false" stored="true"/>
    <field name="sind" type="string" indexed="true" stored="false"/>
    <field name="sindsto" type="string" indexed="true" stored="true"/>
@@ -383,7 +370,7 @@
    
    <field name="timestamp" type="date" indexed="true" stored="true" default="NOW" multiValued="false"/>
    <field name="multiDefault" type="string" indexed="true" stored="true" default="muLti-Default" multiValued="true"/>
-   <field name="intDefault" type="sint" indexed="true" stored="true" default="42" multiValued="false"/>
+   <field name="intDefault" type="int" indexed="true" stored="true" default="42" multiValued="false"/>
    
    <!-- test maxChars copyField attribute -->
    <field name="text_fr"  type="text" indexed="true"  stored="true" 
@@ -405,16 +392,15 @@
         Longer patterns will be matched first.  if equal size patterns
         both match, the first appearing in the schema will be used.
    -->
-   <dynamicField name="*_i"  type="sint"    indexed="true"  stored="true"/>
+   <dynamicField name="*_i"  type="int"    indexed="true"  stored="true"/>
    <dynamicField name="*_s"  type="string"  indexed="true"  stored="true"/>
    <dynamicField name="*_s1"  type="string"  indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_l"  type="slong"   indexed="true"  stored="true"/>
+   <dynamicField name="*_l"  type="long"   indexed="true"  stored="true"/>
    <dynamicField name="*_t"  type="text"    indexed="true"  stored="true"/>
    <dynamicField name="*_b"  type="boolean" indexed="true"  stored="true"/>
-   <dynamicField name="*_f"  type="sfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_d"  type="sdouble" indexed="true"  stored="true"/>
+   <dynamicField name="*_f"  type="float"  indexed="true"  stored="true"/>
+   <dynamicField name="*_d"  type="double" indexed="true"  stored="true"/>
    <dynamicField name="*_dt" type="date"    indexed="true"  stored="true"/>
-   <dynamicField name="*_bcd" type="bcdstr" indexed="true"  stored="true"/>
 
    <dynamicField name="*_sI" type="string"  indexed="true"  stored="false"/>
    <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
@@ -428,7 +414,7 @@
   
    <!-- for testing to ensure that longer patterns are matched first -->
    <dynamicField name="*aa"  type="string"  indexed="true" stored="true"/>
-   <dynamicField name="*aaa" type="integer" indexed="false" stored="true"/>
+   <dynamicField name="*aaa" type="int" indexed="false" stored="true"/>
 
    <!-- ignored becuase not stored or indexed -->
    <dynamicField name="*_ignored" type="text" indexed="false" stored="false"/>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-customfield.xml b/solr/core/src/test-files/solr/collection1/conf/schema-customfield.xml
index fb05920..0660af0 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-customfield.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-customfield.xml
@@ -34,15 +34,29 @@
          behavior of the fieldtype.
       -->
 
-    <!-- numeric field types that store and index the text
-         value verbatim (and hence don't sort correctly or support range queries.)
-         These are provided more for backward compatability, allowing one
-         to create a schema that matches an existing lucene index.
+    <!--
+      Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
     -->
-    <fieldType name="integer" class="solr.IntField"/>
-    <fieldType name="long" class="solr.LongField"/>
-    <fieldtype name="float" class="solr.FloatField"/>
-    <fieldType name="double" class="solr.DoubleField"/>
+    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
+    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
+    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
+
+    <!--
+     Numeric field types that index each value at various levels of precision
+     to accelerate range queries when the number of values between the range
+     endpoints is large. See the javadoc for NumericRangeQuery for internal
+     implementation details.
+
+     Smaller precisionStep values (specified in bits) will lead to more tokens
+     indexed per value, slightly larger index size, and faster range queries.
+     A precisionStep of 0 disables indexing at different precision levels.
+    -->
+    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
+    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
+    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
+    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
+
     <fieldType name="customfield" class="org.apache.solr.schema.MyCrazyCustomField" multiValued="true" positionIncrementGap="100">
     <analyzer>
       <tokenizer class="solr.StandardTokenizerFactory"/>
@@ -54,8 +68,8 @@
  </types>
 
  <fields>
-   <field name="id" type="integer" indexed="true" stored="true" multiValued="false" required="true"/>
-   <field name="intfield" type="integer" indexed="true" stored="true"/>
+   <field name="id" type="int" indexed="true" stored="true" multiValued="false" required="true"/>
+   <field name="intfield" type="int" indexed="true" stored="true"/>
    <field name="swap_foo_bar_in_prefix_query" type="customfield" indexed="true" stored="true" multiValued="true"/>
    <field name="int_prefix_as_range" type="customtrieintfield" indexed="true" stored="true"/>
 
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-distributed-missing-sort.xml b/solr/core/src/test-files/solr/collection1/conf/schema-distributed-missing-sort.xml
index c78c11c..c97cd99 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-distributed-missing-sort.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-distributed-missing-sort.xml
@@ -35,8 +35,8 @@
 
     <fieldtype name="boolean"   class="solr.BoolField"        sortMissingLast="true"/>
 
-    <fieldtype name="sint_ml"   class="solr.SortableIntField" sortMissingLast="true"/>
-    <fieldtype name="sint_mf"   class="solr.SortableIntField" sortMissingFirst="true"/>
+    <fieldtype name="int_ml"   class="solr.TrieIntField" precisionStep="0" sortMissingLast="true"/>
+    <fieldtype name="int_mf"   class="solr.TrieIntField" precisionStep="0" sortMissingFirst="true"/>
 
     <fieldType name="long_ml"   class="solr.TrieLongField"    precisionStep="0" omitNorms="true" positionIncrementGap="0" sortMissingLast="true"/>
     <fieldType name="long_mf"   class="solr.TrieLongField"    precisionStep="0" omitNorms="true" positionIncrementGap="0" sortMissingFirst="true"/>
@@ -51,8 +51,8 @@
     <field name="signatureField"  type="string_ml" indexed="true"  stored="false"/>
 
     <dynamicField name="*_ti1"    type="tint"      indexed="true"  stored="true"  multiValued="false"/>
-    <dynamicField name="*_si_ml"  type="sint_ml"   indexed="true"  stored="true"  multiValued="false"/>
-    <dynamicField name="*_si_mf"  type="sint_mf"   indexed="true"  stored="true"  multiValued="false"/>
+    <dynamicField name="*_i1_ml"  type="int_ml"    indexed="true"  stored="true"  multiValued="false"/>
+    <dynamicField name="*_i1_mf"  type="int_mf"    indexed="true"  stored="true"  multiValued="false"/>
 
     <dynamicField name="*_l1_ml"  type="long_ml"   indexed="true"  stored="true"  multiValued="false"/>
     <dynamicField name="*_l1_mf"  type="long_mf"   indexed="true"  stored="true"  multiValued="false"/>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-not-required-unique-key.xml b/solr/core/src/test-files/solr/collection1/conf/schema-not-required-unique-key.xml
index b386981..1b62877 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-not-required-unique-key.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-not-required-unique-key.xml
@@ -24,7 +24,7 @@
 <schema name="test" version="1.0">
   <types>
     <fieldType name="string" class="solr.StrField"/>
-    <fieldtype name="sint" class="solr.SortableIntField" />
+    <fieldtype name="int" class="solr.TrieIntField" precisionStep="0"/>
     <fieldtype name="text" class="solr.TextField">
       <analyzer>
         <tokenizer class="solr.StandardTokenizerFactory"/>
@@ -35,7 +35,7 @@
 
 
  <fields>
-   <field name="id" type="sint" multiValued="false" indexed="true" stored="true" required="false"/>
+   <field name="id" type="int" multiValued="false" indexed="true" stored="true" required="false"/>
    <field name="subject" type="text" indexed="true" stored="true"/>
    <field name="signatureField" type="string" indexed="true" stored="false"/>
    <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-replication1.xml b/solr/core/src/test-files/solr/collection1/conf/schema-replication1.xml
index fe123df..681fd4a 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-replication1.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-replication1.xml
@@ -28,7 +28,7 @@
 <schema name="test" version="1.2">
   <types>
 
-    <fieldType name="integer" class="solr.IntField"/>
+    <fieldType name="integer" class="solr.TrieIntField" precisionStep="0"/>
     <fieldtype name="string" class="solr.StrField" sortMissingLast="true"/>
 
 
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-replication2.xml b/solr/core/src/test-files/solr/collection1/conf/schema-replication2.xml
index a240945..47a565e 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-replication2.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-replication2.xml
@@ -28,7 +28,7 @@
 <schema name="test" version="1.2">
   <types>
 
-    <fieldType name="integer" class="solr.IntField"/>
+    <fieldType name="integer" class="solr.TrieIntField" precisionStep="0"/>
     <fieldtype name="string" class="solr.StrField" sortMissingLast="true"/>
 
   </types>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-required-fields.xml b/solr/core/src/test-files/solr/collection1/conf/schema-required-fields.xml
index 8dea791..f4baf51 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-required-fields.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-required-fields.xml
@@ -34,41 +34,28 @@
          behavior of the fieldtype.
       -->
 
-    <!-- numeric field types that store and index the text
-         value verbatim (and hence don't sort correctly or support range queries.)
-         These are provided more for backward compatability, allowing one
-         to create a schema that matches an existing lucene index.
+    <!--
+      Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
     -->
-    <fieldtype name="integer" class="solr.IntField"/>
-    <fieldtype name="long" class="solr.LongField"/>
-    <fieldtype name="float" class="solr.FloatField"/>
-    <fieldtype name="double" class="solr.DoubleField"/>
-
-    <!-- numeric field types that manipulate the value into
-       a string value that isn't human readable in it's internal form,
-       but sorts correctly and supports range queries.
-
-         If sortMissingLast="true" then a sort on this field will cause documents
-       without the field to come after documents with the field,
-       regardless of the requested sort order.
-         If sortMissingFirst="true" then a sort on this field will cause documents
-       without the field to come before documents with the field,
-       regardless of the requested sort order.
-         If sortMissingLast="false" and sortMissingFirst="false" (the default),
-       then default lucene sorting will be used which places docs without the field
-       first in an ascending sort and last in a descending sort.
+    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
+    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
+    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
+
+    <!--
+     Numeric field types that index each value at various levels of precision
+     to accelerate range queries when the number of values between the range
+     endpoints is large. See the javadoc for NumericRangeQuery for internal
+     implementation details.
+
+     Smaller precisionStep values (specified in bits) will lead to more tokens
+     indexed per value, slightly larger index size, and faster range queries.
+     A precisionStep of 0 disables indexing at different precision levels.
     -->
-    <fieldtype name="sint" class="solr.SortableIntField" sortMissingLast="true"/>
-    <fieldtype name="slong" class="solr.SortableLongField" sortMissingLast="true"/>
-    <fieldtype name="sfloat" class="solr.SortableFloatField" sortMissingLast="true"/>
-    <fieldtype name="sdouble" class="solr.SortableDoubleField" sortMissingLast="true"/>
-
-    <!-- bcd versions of sortable numeric type may provide smaller
-         storage space and support very large numbers.
-    -->
-    <fieldtype name="bcdint" class="solr.BCDIntField" sortMissingLast="true"/>
-    <fieldtype name="bcdlong" class="solr.BCDLongField" sortMissingLast="true"/>
-    <fieldtype name="bcdstr" class="solr.BCDStrField" sortMissingLast="true"/>
+    <fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
+    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
+    <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
+    <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
 
     <!-- Field type demonstrating an Analyzer failure -->
     <fieldtype name="failtype1" class="solr.TextField">
@@ -89,7 +76,7 @@
     <!-- format for date is 1995-12-31T23:59:59.999Z and only the fractional
          seconds part (.999) is optional.
       -->
-    <fieldtype name="date" class="solr.DateField" sortMissingLast="true"/>
+    <fieldtype name="date" class="solr.TrieDateField" sortMissingLast="true"/>
 
     <!-- solr.TextField allows the specification of custom
          text analyzers specified as a tokenizer and a list
@@ -299,7 +286,7 @@
 
 
  <fields>
-   <field name="id" type="integer" multiValued="false" indexed="true" stored="true"/> <!-- the uniqueKey is required by default -->
+   <field name="id" type="int" multiValued="false" indexed="true" stored="true"/> <!-- the uniqueKey is required by default -->
    <field name="name" type="nametext" indexed="true" stored="true" required="true"/>
    <field name="text" type="text" indexed="true" stored="false"/>
    <field name="subject" type="text" indexed="true" stored="true" required="true" default="Stuff"/>
@@ -322,8 +309,8 @@
    <field name="bind" type="boolean" indexed="true" stored="false"/>
    <field name="bsto" type="boolean" indexed="false" stored="true"/>
    <field name="bindsto" type="boolean" indexed="true" stored="true"/>
-   <field name="isto" type="integer" indexed="false" stored="true"/>
-   <field name="iind" type="integer" indexed="true" stored="false"/>
+   <field name="isto" type="int" indexed="false" stored="true"/>
+   <field name="iind" type="int" indexed="true" stored="false"/>
    <field name="ssto" type="string" indexed="false" stored="true"/>
    <field name="sind" type="string" indexed="true" stored="false"/>
    <field name="sindsto" type="string" indexed="true" stored="true"/>
@@ -373,7 +360,7 @@
    
    <field name="timestamp" type="date" indexed="true" stored="true" default="NOW" multiValued="false"/>
    <field name="multiDefault" type="string" indexed="true" stored="true" default="muLti-Default" multiValued="true"/>
-   <field name="intDefault" type="sint" indexed="true" stored="true" default="42" multiValued="false"/>
+   <field name="intDefault" type="int" indexed="true" stored="true" default="42" multiValued="false"/>
    <field name="signatureField" type="string" indexed="true" stored="false"/>
    
    <field name="_version_" type="long" indexed="true" stored="true" multiValued="false" />
@@ -386,16 +373,15 @@
         Longer patterns will be matched first.  if equal size patterns
         both match, the first appearing in the schema will be used.
    -->
-   <dynamicField name="*_i"  type="sint"    indexed="true"  stored="true"/>
+   <dynamicField name="*_i"  type="int"    indexed="true"  stored="true"/>
    <dynamicField name="*_s"  type="string"  indexed="true"  stored="true"/>
    <dynamicField name="*_s1"  type="string"  indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_l"  type="slong"   indexed="true"  stored="true"/>
+   <dynamicField name="*_l"  type="long"   indexed="true"  stored="true"/>
    <dynamicField name="*_t"  type="text"    indexed="true"  stored="true"/>
    <dynamicField name="*_b"  type="boolean" indexed="true"  stored="true"/>
-   <dynamicField name="*_f"  type="sfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_d"  type="sdouble" indexed="true"  stored="true"/>
+   <dynamicField name="*_f"  type="float"  indexed="true"  stored="true"/>
+   <dynamicField name="*_d"  type="double" indexed="true"  stored="true"/>
    <dynamicField name="*_dt" type="date"    indexed="true"  stored="true"/>
-   <dynamicField name="*_bcd" type="bcdstr" indexed="true"  stored="true"/>
 
    <dynamicField name="*_sI" type="string"  indexed="true"  stored="false"/>
    <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
@@ -406,7 +392,7 @@
 
    <!-- for testing to ensure that longer patterns are matched first -->
    <dynamicField name="*aa"  type="string"  indexed="true" stored="true"/>
-   <dynamicField name="*aaa" type="integer" indexed="false" stored="true"/>
+   <dynamicField name="*aaa" type="int" indexed="false" stored="true"/>
 
 
 
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-rest.xml b/solr/core/src/test-files/solr/collection1/conf/schema-rest.xml
index ece1a8e..b3612b5 100755
--- a/solr/core/src/test-files/solr/collection1/conf/schema-rest.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-rest.xml
@@ -31,11 +31,6 @@
        1.5: omitNorms defaults to true for primitive field types (int, float, boolean, string...)
      -->
   <types>
-    <fieldType name="pint" class="solr.IntField"/>
-    <fieldType name="plong" class="solr.LongField"/>
-    <fieldtype name="pfloat" class="solr.FloatField"/>
-    <fieldType name="pdouble" class="solr.DoubleField"/>
-
     <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
     <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
     <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
@@ -46,25 +41,6 @@
     <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
     <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
 
-    <!-- numeric field types that manipulate the value into
-       a string value that isn't human readable in it's internal form,
-       but sorts correctly and supports range queries.
-
-         If sortMissingLast="true" then a sort on this field will cause documents
-       without the field to come after documents with the field,
-       regardless of the requested sort order.
-         If sortMissingFirst="true" then a sort on this field will cause documents
-       without the field to come before documents with the field,
-       regardless of the requested sort order.
-         If sortMissingLast="false" and sortMissingFirst="false" (the default),
-       then default lucene sorting will be used which places docs without the field
-       first in an ascending sort and last in a descending sort.
-    -->
-    <fieldtype name="sint" class="solr.SortableIntField" sortMissingLast="true" />
-    <fieldtype name="slong" class="solr.SortableLongField" sortMissingLast="true"/>
-    <fieldtype name="sfloat" class="solr.SortableFloatField" sortMissingLast="true"/>
-    <fieldtype name="sdouble" class="solr.SortableDoubleField" sortMissingLast="true"/>
-
     <!-- Field type demonstrating an Analyzer failure -->
     <fieldtype name="failtype1" class="solr.TextField">
       <analyzer type="index">
@@ -103,7 +79,6 @@
       -->
     <fieldtype name="date" class="solr.TrieDateField" sortMissingLast="true"/>
     <fieldtype name="tdate" class="solr.TrieDateField" sortMissingLast="true" precisionStep="6"/>
-    <fieldtype name="pdate" class="solr.DateField" sortMissingLast="true"/>
 
   <fieldType name="text" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true" >
       <analyzer type="index">
@@ -573,12 +548,6 @@
 
    <dynamicField name="*_coordinate"  type="tdouble" indexed="true"  stored="false"/>
 
-
-   <dynamicField name="*_si"  type="sint"  indexed="true"  stored="true"/>
-   <dynamicField name="*_sl"  type="slong"  indexed="true"  stored="true"/>
-   <dynamicField name="*_sf"  type="sfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_sd"  type="sdouble"  indexed="true"  stored="true"/>
-
    <dynamicField name="*_sI" type="string"  indexed="true"  stored="false"/>
    <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
    <dynamicField name="t_*"  type="text"    indexed="true"  stored="true"/>
@@ -612,13 +581,6 @@
    <dynamicField name="*_td" type="tdouble" indexed="true"  stored="true"/>
    <dynamicField name="*_tdt" type="tdate"  indexed="true"  stored="true"/>
 
-   <dynamicField name="*_pi"  type="pint"    indexed="true"  stored="true"/>
-   <dynamicField name="*_pf"  type="pfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_pl"  type="plong"   indexed="true"  stored="true"/>
-   <dynamicField name="*_pd"  type="pdouble" indexed="true"  stored="true"/>
-   <dynamicField name="*_pdt"  type="pdate" indexed="true"  stored="true"/>
-
-
    <dynamicField name="ignored_*" type="ignored" multiValued="true"/>
    <dynamicField name="attr_*" type="text" indexed="true" stored="true" multiValued="true"/>
 
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-reversed.xml b/solr/core/src/test-files/solr/collection1/conf/schema-reversed.xml
index 40fc0e8..51fedf5 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-reversed.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-reversed.xml
@@ -26,7 +26,7 @@
 
 
     <fieldtype name="long" class="solr.TrieLongField" />
-    <fieldtype name="integer" class="solr.IntField" />
+    <fieldType name="integer" class="solr.TrieIntField" precisionStep="0"/>
     <fieldtype name="string" class="solr.StrField" />
 
     <fieldtype name="text" class="solr.TextField">
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-sorts.xml b/solr/core/src/test-files/solr/collection1/conf/schema-sorts.xml
index 53433b0..48f325d 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-sorts.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-sorts.xml
@@ -115,50 +115,6 @@ NOTE: Tests expect every field in this schema to be sortable.
     <!-- <field name="enum_dv_last" type="enum_dv_last" />         -->
     <!-- <field name="enum_dv_first" type="enum_dv_first" />       -->
 
-    <field name="bcd_int" type="bcd_int" />
-    <field name="bcd_int_last" type="bcd_int_last" />
-    <field name="bcd_int_first" type="bcd_int_first" />
-
-    <field name="bcd_long" type="bcd_long" />
-    <field name="bcd_long_last" type="bcd_long_last" />
-    <field name="bcd_long_first" type="bcd_long_first" />
-
-    <field name="bcd_str" type="bcd_str" />
-    <field name="bcd_str_last" type="bcd_str_last" />
-    <field name="bcd_str_first" type="bcd_str_first" />
-
-    <!-- IntField doesn't support sortMissingFirst or sortMissingLast variants -->
-    <field name="legacy_int" type="legacy_int" />
-
-    <field name="legacy_sortable_int" type="legacy_sortable_int" />
-    <field name="legacy_sortable_int_last" type="legacy_sortable_int_last" />
-    <field name="legacy_sortable_int_first" type="legacy_sortable_int_first" />
-
-    <!-- LongField doesn't support sortMissingFirst or sortMissingLast variants -->
-    <field name="legacy_long" type="legacy_long" />
-
-    <field name="legacy_sortable_long" type="legacy_sortable_long" />
-    <field name="legacy_sortable_long_last" type="legacy_sortable_long_last" />
-    <field name="legacy_sortable_long_first" type="legacy_sortable_long_first" />
-
-    <!-- FloatField doesn't support sortMissingFirst or sortMissingLast variants -->
-    <field name="legacy_float" type="legacy_float" />
-
-    <field name="legacy_sortable_float" type="legacy_sortable_float" />
-    <field name="legacy_sortable_float_last" type="legacy_sortable_float_last" />
-    <field name="legacy_sortable_float_first" type="legacy_sortable_float_first" />
-
-    <!-- DoubleField doesn't support sortMissingFirst or sortMissingLast variants -->
-    <field name="legacy_double" type="legacy_double" />
-
-    <field name="legacy_sortable_double" type="legacy_sortable_double" />
-    <field name="legacy_sortable_double_last" type="legacy_sortable_double_last" />
-    <field name="legacy_sortable_double_first" type="legacy_sortable_double_first" />
-
-    <field name="legacy_date" type="legacy_date" />
-    <field name="legacy_date_last" type="legacy_date_last" />
-    <field name="legacy_date_first" type="legacy_date_first" />
-
     <!-- ensure function sorts don't mistakenly get interpreted as field sorts
          https://issues.apache.org/jira/browse/SOLR-5354?focusedCommentId=13835891&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13835891
     -->
@@ -192,57 +148,30 @@ NOTE: Tests expect every field in this schema to be sortable.
   <copyField source="int" dest="int_dv" />
   <copyField source="int" dest="int_dv_last" />
   <copyField source="int" dest="int_dv_first" />
-  <copyField source="int" dest="bcd_int" />
-  <copyField source="int" dest="bcd_int_last" />
-  <copyField source="int" dest="bcd_int_first" />
-  <copyField source="int" dest="bcd_str" />
-  <copyField source="int" dest="bcd_str_last" />
-  <copyField source="int" dest="bcd_str_first" />
-  <copyField source="int" dest="legacy_int" />
-  <copyField source="int" dest="legacy_sortable_int" />
-  <copyField source="int" dest="legacy_sortable_int_last" />
-  <copyField source="int" dest="legacy_sortable_int_first" />
 
   <copyField source="long" dest="long_last" />
   <copyField source="long" dest="long_first" />
   <copyField source="long" dest="long_dv" />
   <copyField source="long" dest="long_dv_last" />
   <copyField source="long" dest="long_dv_first" />
-  <copyField source="long" dest="bcd_long" />
-  <copyField source="long" dest="bcd_long_last" />
-  <copyField source="long" dest="bcd_long_first" />
-  <copyField source="long" dest="legacy_long" />
-  <copyField source="long" dest="legacy_sortable_long" />
-  <copyField source="long" dest="legacy_sortable_long_last" />
-  <copyField source="long" dest="legacy_sortable_long_first" />
 
   <copyField source="float" dest="float_last" />
   <copyField source="float" dest="float_first" />
   <copyField source="float" dest="float_dv" />
   <copyField source="float" dest="float_dv_last" />
   <copyField source="float" dest="float_dv_first" />
-  <copyField source="float" dest="legacy_float" />
-  <copyField source="float" dest="legacy_sortable_float" />
-  <copyField source="float" dest="legacy_sortable_float_last" />
-  <copyField source="float" dest="legacy_sortable_float_first" />
 
   <copyField source="double" dest="double_last" />
   <copyField source="double" dest="double_first" />
   <copyField source="double" dest="double_dv" />
   <copyField source="double" dest="double_dv_last" />
   <copyField source="double" dest="double_dv_first" />
-  <copyField source="double" dest="legacy_double" />
-  <copyField source="double" dest="legacy_sortable_double" />
-  <copyField source="double" dest="legacy_sortable_double_last" />
-  <copyField source="double" dest="legacy_sortable_double_first" />
 
   <copyField source="date" dest="date_last" />
   <copyField source="date" dest="date_first" />
   <copyField source="date" dest="date_dv" />
   <copyField source="date" dest="date_dv_last" />
   <copyField source="date" dest="date_dv_first" />
-  <copyField source="date" dest="legacy_date_last" />
-  <copyField source="date" dest="legacy_date_first" />
 
   <copyField source="uuid" dest="uuid_last" />
   <copyField source="uuid" dest="uuid_first" />
@@ -351,50 +280,6 @@ NOTE: Tests expect every field in this schema to be sortable.
     <!-- <fieldType name="enum_dv" class="solr.EnumField" enumsConfig="enumsConfig.xml" enumName="severity" docValues="true"/> -->
     <!-- <fieldType name="enum_dv_last" class="solr.EnumField" enumsConfig="enumsConfig.xml" enumName="severity" docValues="true" sortMissingLast="true"/> -->
     <!-- <fieldType name="enum_dv_first" class="solr.EnumField" enumsConfig="enumsConfig.xml" enumName="severity" docValues="true" sortMissingFirst="true"/> -->
-
-    <fieldtype name="bcd_int" class="solr.BCDIntField" stored="true" indexed="true" />
-    <fieldtype name="bcd_int_last" class="solr.BCDIntField" stored="true" indexed="true" sortMissingLast="true"/>
-    <fieldtype name="bcd_int_first" class="solr.BCDIntField" stored="true" indexed="true" sortMissingFirst="true"/>
-
-    <fieldtype name="bcd_long" class="solr.BCDLongField" stored="true" indexed="true" />
-    <fieldtype name="bcd_long_last" class="solr.BCDLongField" stored="true" indexed="true" sortMissingLast="true"/>
-    <fieldtype name="bcd_long_first" class="solr.BCDLongField" stored="true" indexed="true" sortMissingFirst="true"/>
-
-    <fieldtype name="bcd_str" class="solr.BCDStrField" stored="true" indexed="true" />
-    <fieldtype name="bcd_str_last" class="solr.BCDStrField" stored="true" indexed="true" sortMissingLast="true"/>
-    <fieldtype name="bcd_str_first" class="solr.BCDStrField" stored="true" indexed="true" sortMissingFirst="true"/>
-
-    <!-- IntField doesn't support sortMissingFirst or sortMissingLast variants -->
-    <fieldtype name="legacy_int" class="solr.IntField" stored="true" indexed="true" />
-
-    <fieldtype name="legacy_sortable_int" class="solr.SortableIntField" stored="true" indexed="true" />
-    <fieldtype name="legacy_sortable_int_last" class="solr.SortableIntField" stored="true" indexed="true" sortMissingLast="true"/>
-    <fieldtype name="legacy_sortable_int_first" class="solr.SortableIntField" stored="true" indexed="true" sortMissingFirst="true"/>
-
-    <!-- LongField doesn't support sortMissingFirst or sortMissingLast variants -->
-    <fieldtype name="legacy_long" class="solr.LongField" stored="true" indexed="true" />
-
-    <fieldtype name="legacy_sortable_long" class="solr.SortableLongField" stored="true" indexed="true" />
-    <fieldtype name="legacy_sortable_long_last" class="solr.SortableLongField" stored="true" indexed="true" sortMissingLast="true"/>
-    <fieldtype name="legacy_sortable_long_first" class="solr.SortableLongField" stored="true" indexed="true" sortMissingFirst="true"/>
-
-    <!-- FloatField doesn't support sortMissingFirst or sortMissingLast variants -->
-    <fieldtype name="legacy_float" class="solr.FloatField" stored="true" indexed="true" />
-
-    <fieldtype name="legacy_sortable_float" class="solr.SortableFloatField" stored="true" indexed="true" />
-    <fieldtype name="legacy_sortable_float_last" class="solr.SortableFloatField" stored="true" indexed="true" sortMissingLast="true"/>
-    <fieldtype name="legacy_sortable_float_first" class="solr.SortableFloatField" stored="true" indexed="true" sortMissingFirst="true"/>
-
-    <!-- DoubleField doesn't support sortMissingFirst or sortMissingLast variants -->
-    <fieldtype name="legacy_double" class="solr.DoubleField" stored="true" indexed="true" />
-
-    <fieldtype name="legacy_sortable_double" class="solr.SortableDoubleField" stored="true" indexed="true" />
-    <fieldtype name="legacy_sortable_double_last" class="solr.SortableDoubleField" stored="true" indexed="true" sortMissingLast="true"/>
-    <fieldtype name="legacy_sortable_double_first" class="solr.SortableDoubleField" stored="true" indexed="true" sortMissingFirst="true"/>
-
-    <fieldtype name="legacy_date" class="solr.DateField" stored="true" indexed="true" />
-    <fieldtype name="legacy_date_last" class="solr.DateField" stored="true" indexed="true" sortMissingLast="true"/>
-    <fieldtype name="legacy_date_first" class="solr.DateField" stored="true" indexed="true" sortMissingFirst="true"/>
   </types>
 
 </schema>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-stop-keep.xml b/solr/core/src/test-files/solr/collection1/conf/schema-stop-keep.xml
index 831539e..edcab1a 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-stop-keep.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-stop-keep.xml
@@ -26,7 +26,7 @@
   <types>
 
 
-    <fieldtype name="integer" class="solr.IntField" />
+    <fieldtype name="integer" class="solr.TrieIntField" precisionStep="0"/>
 
     <fieldtype name="string" class="solr.StrField" sortMissingLast="true"/>
     <fieldtype name="stop-one" class="solr.TextField">
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-trie.xml b/solr/core/src/test-files/solr/collection1/conf/schema-trie.xml
index 1819bfa..0f879b0 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-trie.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-trie.xml
@@ -69,24 +69,10 @@
          field first in an ascending sort and last in a descending sort.
     -->
 
-
-    <!-- numeric field types that store and index the text
-         value verbatim (and hence don't support range queries, since the
-         lexicographic ordering isn't equal to the numeric ordering) -->
-    <fieldType name="integer" class="solr.IntField" omitNorms="true"/>
-    <fieldType name="long" class="solr.LongField" omitNorms="true"/>
-    <fieldType name="float" class="solr.FloatField" omitNorms="true"/>
-    <fieldType name="double" class="solr.DoubleField" omitNorms="true"/>
-
-
-    <!-- Numeric field types that manipulate the value into
-         a string value that isn't human-readable in its internal form,
-         but with a lexicographic ordering the same as the numeric ordering,
-         so that range queries work correctly. -->
-    <fieldType name="sint" class="solr.SortableIntField" sortMissingLast="true" omitNorms="true"/>
-    <fieldType name="slong" class="solr.SortableLongField" sortMissingLast="true" omitNorms="true"/>
-    <fieldType name="sfloat" class="solr.SortableFloatField" sortMissingLast="true" omitNorms="true"/>
-    <fieldType name="sdouble" class="solr.SortableDoubleField" sortMissingLast="true" omitNorms="true"/>
+    <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+    <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+    <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
+    <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
 
     <fieldType name="tint" class="solr.TrieIntField" omitNorms="true" positionIncrementGap="0" indexed="true" stored="false" />
     <fieldType name="tfloat" class="solr.TrieFloatField" omitNorms="true" positionIncrementGap="0" indexed="true" stored="false" />
@@ -116,9 +102,9 @@
                   ... 6 months and 3 days in the future from the start of
                       the current day
 
-         Consult the DateField javadocs for more information.
+         Consult the TrieDateField javadocs for more information.
       -->
-    <fieldType name="date" class="solr.DateField" sortMissingLast="true" omitNorms="true"/>
+    <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true" omitNorms="true"/>
 
 
     <!-- The "RandomSortField" is not used to store or search any
@@ -269,7 +255,7 @@
    -->
 
    <!-- for testing, a type that does a transform to see if it's correctly done everywhere -->
-   <field name="id" type="sfloat" indexed="true" stored="true" required="true" />
+   <field name="id" type="tfloat" indexed="true" stored="true" required="true" />
    <field name="text" type="text" indexed="true" stored="false" />
    <field name="signatureField" type="string" indexed="true" stored="false"/>
 
@@ -294,15 +280,10 @@
    <dynamicField name="*_s"  type="string"  indexed="true"  stored="true"/>
    <dynamicField name="*_ss"  type="string"  indexed="true"  stored="true" multiValued="true"/>
    <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
-   <dynamicField name="*_i"  type="sint"    indexed="true"  stored="true"/>
-   <dynamicField name="*_l"  type="slong"   indexed="true"  stored="true"/>
-   <dynamicField name="*_f"  type="sfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_d"  type="sdouble" indexed="true"  stored="true"/>
-
-   <dynamicField name="*_pi"  type="integer" indexed="true"  stored="true"/>
-   <dynamicField name="*_pl"  type="long"   indexed="true"  stored="true"/>
-   <dynamicField name="*_pf"  type="float"  indexed="true"  stored="true"/>
-   <dynamicField name="*_pd"  type="double" indexed="true"  stored="true"/>
+   <dynamicField name="*_i"  type="tint"    indexed="true"  stored="true"/>
+   <dynamicField name="*_l"  type="tlong"   indexed="true"  stored="true"/>
+   <dynamicField name="*_f"  type="tfloat"  indexed="true"  stored="true"/>
+   <dynamicField name="*_d"  type="tdouble" indexed="true"  stored="true"/>
 
    <dynamicField name="*_t"  type="text"    indexed="true"  stored="true"/>
    <dynamicField name="*_b"  type="boolean" indexed="true"  stored="true"/>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema.xml b/solr/core/src/test-files/solr/collection1/conf/schema.xml
index a22844d..219361c 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema.xml
@@ -34,16 +34,6 @@
          behavior of the fieldtype.
       -->
 
-    <!-- numeric field types that store and index the text
-         value verbatim (and hence don't sort correctly or support range queries.)
-         These are provided more for backward compatability, allowing one
-         to create a schema that matches an existing lucene index.
-    -->
-    <fieldType name="pint" class="solr.IntField"/>
-    <fieldType name="plong" class="solr.LongField"/>
-    <fieldtype name="pfloat" class="solr.FloatField"/>
-    <fieldType name="pdouble" class="solr.DoubleField"/>
-
     <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
     <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
     <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
@@ -55,32 +45,6 @@
     <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
     <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
 
-    <!-- numeric field types that manipulate the value into
-       a string value that isn't human readable in it's internal form,
-       but sorts correctly and supports range queries.
-
-         If sortMissingLast="true" then a sort on this field will cause documents
-       without the field to come after documents with the field,
-       regardless of the requested sort order.
-         If sortMissingFirst="true" then a sort on this field will cause documents
-       without the field to come before documents with the field,
-       regardless of the requested sort order.
-         If sortMissingLast="false" and sortMissingFirst="false" (the default),
-       then default lucene sorting will be used which places docs without the field
-       first in an ascending sort and last in a descending sort.
-    -->
-    <fieldtype name="sint" class="solr.SortableIntField" sortMissingLast="true"/>
-    <fieldtype name="slong" class="solr.SortableLongField" sortMissingLast="true"/>
-    <fieldtype name="sfloat" class="solr.SortableFloatField" sortMissingLast="true"/>
-    <fieldtype name="sdouble" class="solr.SortableDoubleField" sortMissingLast="true"/>
-
-    <!-- bcd versions of sortable numeric type may provide smaller
-         storage space and support very large numbers.
-    -->
-    <fieldtype name="bcdint" class="solr.BCDIntField" sortMissingLast="true"/>
-    <fieldtype name="bcdlong" class="solr.BCDLongField" sortMissingLast="true"/>
-    <fieldtype name="bcdstr" class="solr.BCDStrField" sortMissingLast="true"/>
-
     <!-- Field type demonstrating an Analyzer failure -->
     <fieldtype name="failtype1" class="solr.TextField">
       <analyzer type="index">
@@ -119,7 +83,6 @@
       -->
     <fieldtype name="date" class="solr.TrieDateField" precisionStep="0"/>
     <fieldtype name="tdate" class="solr.TrieDateField" precisionStep="6"/>
-    <fieldtype name="pdate" class="solr.DateField" sortMissingLast="true"/>
 
 
     <!-- solr.TextField allows the specification of custom
@@ -501,24 +464,6 @@
    <field name="test_posofftv" type="text" termVectors="true"
      termPositions="true" termOffsets="true"/>
 
-   <!-- test valid combinations of indexed settings, 
-        see also BadIndexSchemaTest -->
-   <!-- indexed=false should not prevent omit___=true -->
-   <field name="pint_i_norm" type="pint" omitNorms="true"
-          indexed="false" />
-   <field name="pint_i_tf"   type="pint" omitTermFreqAndPositions="true"
-          indexed="false" />
-   <field name="pint_i_pos"  type="pint" omitPositions="true"
-          indexed="false" />
-   <field name="pint_i_all"  type="pint" 
-          indexed="false" 
-          omitNorms="true"
-          omitTermFreqAndPositions="true"
-          omitPositions="true" />
-   <!-- omitTermFreqAndPositions=false and omitPositions=true are ok -->
-   <field name="pint_tf_pos" type="pint" indexed="true" 
-          omitTermFreqAndPositions="false" omitPositions="true" />
-
    <!-- test highlit field settings -->
    <field name="test_hlt" type="highlittext" indexed="true"/>
    <field name="test_hlt_off" type="highlittext" indexed="true"/>
@@ -594,7 +539,7 @@
         both match, the first appearing in the schema will be used.
    -->
    <dynamicField name="*_i"  type="int"    indexed="true"  stored="true"/>
-   <dynamicField name="*_i1"  type="int"    indexed="true" stored="true" multiValued="false"/>
+   <dynamicField name="*_i1"  type="int"    indexed="true" stored="true" multiValued="false" sortMissingLast="true"/>
                  
    <dynamicField name="*_s"  type="string"  indexed="true"  stored="true"/>
    <dynamicField name="*_s1"  type="string"  indexed="true"  stored="true" multiValued="false"/>
@@ -609,7 +554,6 @@
    <dynamicField name="*_d1"  type="double" indexed="true"  stored="true" multiValued="false"/>
    <dynamicField name="*_dt" type="date"    indexed="true"  stored="true"/>
    <dynamicField name="*_dt1" type="date"    indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_bcd" type="bcdstr" indexed="true"  stored="true"/>
 
 
       <!-- some trie-coded dynamic fields for faster range queries -->
@@ -625,20 +569,6 @@
    <dynamicField name="*_tdt" type="tdate"  indexed="true"  stored="true"/>
    <dynamicField name="*_tdt1" type="tdate"  indexed="true"  stored="true" multiValued="false"/>
 
-   <dynamicField name="*_si"  type="sint"  indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_sl"  type="slong"  indexed="true"  stored="true"/>
-   <dynamicField name="*_sf"  type="sfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_sf1"  type="sfloat"  indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_sd"  type="sdouble"  indexed="true"  stored="true"/>
-   <dynamicField name="*_sd1"  type="sdouble"  indexed="true"  stored="true" multiValued="false"/>
-
-   <dynamicField name="*_pi"  type="pint"    indexed="true"  stored="true"/>
-   <dynamicField name="*_pf"  type="pfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_pl"  type="plong"   indexed="true"  stored="true"/>
-   <dynamicField name="*_pd"  type="pdouble" indexed="true"  stored="true"/>
-   <dynamicField name="*_pdt"  type="pdate" indexed="true"  stored="true"/>
-
-
    <dynamicField name="*_sI" type="string"  indexed="true"  stored="false"/>
    <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
    <dynamicField name="t_*"  type="text"    indexed="true"  stored="true"/>
@@ -657,7 +587,7 @@
 
    <!-- for testing to ensure that longer patterns are matched first -->
    <dynamicField name="*aa"  type="string"  indexed="true" stored="true"/>
-   <dynamicField name="*aaa" type="pint" indexed="false" stored="true"/>
+   <dynamicField name="*aaa" type="int" indexed="false" stored="true"/>
 
    <!-- ignored becuase not stored or indexed -->
    <dynamicField name="*_ignored" type="text" indexed="false" stored="false"/>
@@ -691,15 +621,8 @@
 
 	 <copyField source="*_t" dest="text"/>
 
-	 <copyField source="id"            dest="range_facet_si"/>
 	 <copyField source="id"            dest="range_facet_l"/>
-	 <copyField source="id"            dest="range_facet_sl"/>
-	 <copyField source="range_facet_f" dest="range_facet_sf"/>
 	 <copyField source="range_facet_f" dest="range_facet_d"/>
-	 <copyField source="range_facet_f" dest="range_facet_sd"/>
-
-	 <copyField source="bday" dest="bday_pdt"/>
-	 <copyField source="a_tdt" dest="a_pdt"/>
 
    <!-- dynamic destination -->
    <copyField source="*_dynamic" dest="dynamic_*"/>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema11.xml b/solr/core/src/test-files/solr/collection1/conf/schema11.xml
index 69723c6..19271a4 100755
--- a/solr/core/src/test-files/solr/collection1/conf/schema11.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema11.xml
@@ -67,26 +67,16 @@
        - If sortMissingLast="false" and sortMissingFirst="false" (the default),
          then default lucene sorting will be used which places docs without the
          field first in an ascending sort and last in a descending sort.
-    -->    
-
-
-    <!-- numeric field types that store and index the text
-         value verbatim (and hence don't support range queries, since the
-         lexicographic ordering isn't equal to the numeric ordering) -->
-    <fieldType name="integer" class="solr.IntField" omitNorms="true"/>
-    <fieldType name="long" class="solr.LongField" omitNorms="true"/>
-    <fieldType name="float" class="solr.FloatField" omitNorms="true"/>
-    <fieldType name="double" class="solr.DoubleField" omitNorms="true"/>
+    -->
 
 
-    <!-- Numeric field types that manipulate the value into
-         a string value that isn't human-readable in its internal form,
-         but with a lexicographic ordering the same as the numeric ordering,
-         so that range queries work correctly. -->
-    <fieldType name="sint" class="solr.SortableIntField" sortMissingLast="true" omitNorms="true"/>
-    <fieldType name="slong" class="solr.SortableLongField" sortMissingLast="true" omitNorms="true"/>
-    <fieldType name="sfloat" class="solr.SortableFloatField" sortMissingLast="true" omitNorms="true"/>
-    <fieldType name="sdouble" class="solr.SortableDoubleField" sortMissingLast="true" omitNorms="true"/>
+  <!--
+    Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.
+  -->
+  <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
+  <fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
 
 
     <!-- The format for this date field is of the form 1995-12-31T23:59:59Z, and
@@ -107,9 +97,9 @@
                   ... 6 months and 3 days in the future from the start of
                       the current day
                       
-         Consult the DateField javadocs for more information.
+         Consult the TrieDateField javadocs for more information.
       -->
-    <fieldType name="date" class="solr.DateField" sortMissingLast="true" omitNorms="true"/>
+    <fieldType name="date" class="solr.TrieDateField" sortMissingLast="true" omitNorms="true"/>
 
 
     <!-- The "RandomSortField" is not used to store or search any
@@ -268,7 +258,6 @@ valued. -->
     <fieldType name="location" class="solr.LatLonType" subFieldSuffix="_coordinate"/>
 
      <!-- These should pass right through and insure that we can declare external field types -->
-    <fieldType name="pfloat" class="solr.FloatField" omitNorms="true"/>
     <fieldType name="eff_float" keyField="id" defVal="0"
                stored="false" indexed="true"
                class="solr.ExternalFileField" valType="float"/>
@@ -277,10 +266,6 @@ valued. -->
                stored="false" indexed="true"
                class="solr.ExternalFileField" valType="tfloat"/>
 
-    <fieldType name="eff_pfloat" keyField="id" defVal="0"
-               stored="false" indexed="true"
-               class="solr.ExternalFileField" valType="pfloat"/>
-
     <!-- Be sure that the valType can be optional Since valType has done nothing up until now, this is preferred -->
     <fieldType name="eff_none" keyField="id" defVal="0"
                stored="false" indexed="true"
@@ -314,7 +299,7 @@ valued. -->
    -->
 
    <!-- for testing, a type that does a transform to see if it's correctly done everywhere -->
-   <field name="id" type="sfloat" indexed="true" stored="true" required="true" /> 
+   <field name="id" type="float" indexed="true" stored="true" required="true" />
    <field name="text" type="text" indexed="true" stored="false" />
 
    <!-- Test a point field for distances -->
@@ -344,17 +329,11 @@ valued. -->
    <dynamicField name="*_s"  type="string"  indexed="true"  stored="true"/>
    <dynamicField name="*_ss"  type="string"  indexed="true"  stored="true" multiValued="true"/>
    <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
-   <dynamicField name="*_ii"  type="integer"    indexed="true"  stored="true" multiValued="true"/>
-   <dynamicField name="*_i"  type="sint"    indexed="true"  stored="true"/>
-   <dynamicField name="*_is"  type="sint"    indexed="true"  stored="true" multiValued="true"/>
-   <dynamicField name="*_l"  type="slong"   indexed="true"  stored="true"/>
-   <dynamicField name="*_f"  type="sfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_d"  type="sdouble" indexed="true"  stored="true"/>
-
-   <dynamicField name="*_pi"  type="integer" indexed="true"  stored="true"/>
-   <dynamicField name="*_pl"  type="long"   indexed="true"  stored="true"/>
-   <dynamicField name="*_pf"  type="float"  indexed="true"  stored="true"/>
-   <dynamicField name="*_pd"  type="double" indexed="true"  stored="true"/>
+   <dynamicField name="*_i"  type="int"    indexed="true"  stored="true"/>
+   <dynamicField name="*_ii" type="int"    indexed="true"  stored="true" multiValued="true"/>
+   <dynamicField name="*_l"  type="long"   indexed="true"  stored="true"/>
+   <dynamicField name="*_f"  type="float"  indexed="true"  stored="true"/>
+   <dynamicField name="*_d"  type="double" indexed="true"  stored="true"/>
 
    <dynamicField name="*_ti"  type="tint"    indexed="true"  stored="true"/>
    <dynamicField name="*_tl"  type="tlong"   indexed="true"  stored="true"/>
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema12.xml b/solr/core/src/test-files/solr/collection1/conf/schema12.xml
index 506e08d..904097b 100755
--- a/solr/core/src/test-files/solr/collection1/conf/schema12.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema12.xml
@@ -34,16 +34,6 @@
          behavior of the fieldtype.
       -->
 
-    <!-- numeric field types that store and index the text
-         value verbatim (and hence don't sort correctly or support range queries.)
-         These are provided more for backward compatability, allowing one
-         to create a schema that matches an existing lucene index.
-    -->
-    <fieldType name="pint" class="solr.IntField"/>
-    <fieldType name="plong" class="solr.LongField"/>
-    <fieldtype name="pfloat" class="solr.FloatField"/>
-    <fieldType name="pdouble" class="solr.DoubleField"/>
-
     <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
     <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
     <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
@@ -54,25 +44,6 @@
     <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
     <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
 
-    <!-- numeric field types that manipulate the value into
-       a string value that isn't human readable in it's internal form,
-       but sorts correctly and supports range queries.
-
-         If sortMissingLast="true" then a sort on this field will cause documents
-       without the field to come after documents with the field,
-       regardless of the requested sort order.
-         If sortMissingFirst="true" then a sort on this field will cause documents
-       without the field to come before documents with the field,
-       regardless of the requested sort order.
-         If sortMissingLast="false" and sortMissingFirst="false" (the default),
-       then default lucene sorting will be used which places docs without the field
-       first in an ascending sort and last in a descending sort.
-    -->
-    <fieldtype name="sint" class="solr.SortableIntField" sortMissingLast="true" omitNorms="true" />
-    <fieldtype name="slong" class="solr.SortableLongField" sortMissingLast="true" omitNorms="true"/>
-    <fieldtype name="sfloat" class="solr.SortableFloatField" sortMissingLast="true" omitNorms="true"/>
-    <fieldtype name="sdouble" class="solr.SortableDoubleField" sortMissingLast="true" omitNorms="true"/>
-
     <!-- Field type demonstrating an Analyzer failure -->
     <fieldtype name="failtype1" class="solr.TextField">
       <analyzer type="index">
@@ -111,7 +82,6 @@
       -->
     <fieldtype name="date" class="solr.TrieDateField" sortMissingLast="true"/>
     <fieldtype name="tdate" class="solr.TrieDateField" sortMissingLast="true" precisionStep="6"/>
-    <fieldtype name="pdate" class="solr.DateField" sortMissingLast="true"/>
 
   <fieldType name="text" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true" >
       <analyzer type="index">
@@ -540,12 +510,6 @@
 
    <dynamicField name="*_coordinate"  type="tdouble" indexed="true"  stored="false"/>
 
-
-   <dynamicField name="*_si"  type="sint"  indexed="true"  stored="true"/>
-   <dynamicField name="*_sl"  type="slong"  indexed="true"  stored="true"/>
-   <dynamicField name="*_sf"  type="sfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_sd"  type="sdouble"  indexed="true"  stored="true"/>
-
    <dynamicField name="*_sI" type="string"  indexed="true"  stored="false"/>
    <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
    <dynamicField name="t_*"  type="text"    indexed="true"  stored="true"/>
@@ -579,13 +543,6 @@
    <dynamicField name="*_td" type="tdouble" indexed="true"  stored="true"/>
    <dynamicField name="*_tdt" type="tdate"  indexed="true"  stored="true"/>
 
-   <dynamicField name="*_pi"  type="pint"    indexed="true"  stored="true"/>
-   <dynamicField name="*_pf"  type="pfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_pl"  type="plong"   indexed="true"  stored="true"/>
-   <dynamicField name="*_pd"  type="pdouble" indexed="true"  stored="true"/>
-   <dynamicField name="*_pdt"  type="pdate" indexed="true"  stored="true"/>
-
-
    <dynamicField name="ignored_*" type="ignored" multiValued="true"/>
    <dynamicField name="attr_*" type="text" indexed="true" stored="true" multiValued="true"/>
 
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema15.xml b/solr/core/src/test-files/solr/collection1/conf/schema15.xml
index b05e1a7..cef30b1 100755
--- a/solr/core/src/test-files/solr/collection1/conf/schema15.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema15.xml
@@ -31,11 +31,6 @@
        1.5: omitNorms defaults to true for primitive field types (int, float, boolean, string...)
      -->
   <types>
-    <fieldType name="pint" class="solr.IntField"/>
-    <fieldType name="plong" class="solr.LongField"/>
-    <fieldtype name="pfloat" class="solr.FloatField"/>
-    <fieldType name="pdouble" class="solr.DoubleField"/>
-
     <fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
     <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
     <fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
@@ -47,25 +42,6 @@
     <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
     <fieldType name="currency" class="solr.CurrencyField" currencyConfig="currency.xml" multiValued="false" />
 
-    <!-- numeric field types that manipulate the value into
-       a string value that isn't human readable in it's internal form,
-       but sorts correctly and supports range queries.
-
-         If sortMissingLast="true" then a sort on this field will cause documents
-       without the field to come after documents with the field,
-       regardless of the requested sort order.
-         If sortMissingFirst="true" then a sort on this field will cause documents
-       without the field to come before documents with the field,
-       regardless of the requested sort order.
-         If sortMissingLast="false" and sortMissingFirst="false" (the default),
-       then default lucene sorting will be used which places docs without the field
-       first in an ascending sort and last in a descending sort.
-    -->
-    <fieldtype name="sint" class="solr.SortableIntField" sortMissingLast="true" />
-    <fieldtype name="slong" class="solr.SortableLongField" sortMissingLast="true"/>
-    <fieldtype name="sfloat" class="solr.SortableFloatField" sortMissingLast="true"/>
-    <fieldtype name="sdouble" class="solr.SortableDoubleField" sortMissingLast="true"/>
-
     <!-- Field type demonstrating an Analyzer failure -->
     <fieldtype name="failtype1" class="solr.TextField">
       <analyzer type="index">
@@ -104,7 +80,6 @@
       -->
     <fieldtype name="date" class="solr.TrieDateField" sortMissingLast="true"/>
     <fieldtype name="tdate" class="solr.TrieDateField" sortMissingLast="true" precisionStep="6"/>
-    <fieldtype name="pdate" class="solr.DateField" sortMissingLast="true"/>
 
   <fieldType name="text" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true" >
       <analyzer type="index">
@@ -535,12 +510,6 @@
 
    <dynamicField name="*_coordinate"  type="tdouble" indexed="true"  stored="false"/>
 
-
-   <dynamicField name="*_si"  type="sint"  indexed="true"  stored="true"/>
-   <dynamicField name="*_sl"  type="slong"  indexed="true"  stored="true"/>
-   <dynamicField name="*_sf"  type="sfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_sd"  type="sdouble"  indexed="true"  stored="true"/>
-
    <dynamicField name="*_sI" type="string"  indexed="true"  stored="false"/>
    <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
    <dynamicField name="t_*"  type="text"    indexed="true"  stored="true"/>
@@ -575,13 +544,6 @@
    <dynamicField name="*_td" type="tdouble" indexed="true"  stored="true"/>
    <dynamicField name="*_tdt" type="tdate"  indexed="true"  stored="true"/>
 
-   <dynamicField name="*_pi"  type="pint"    indexed="true"  stored="true"/>
-   <dynamicField name="*_pf"  type="pfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_pl"  type="plong"   indexed="true"  stored="true"/>
-   <dynamicField name="*_pd"  type="pdouble" indexed="true"  stored="true"/>
-   <dynamicField name="*_pdt"  type="pdate" indexed="true"  stored="true"/>
-
-
    <dynamicField name="ignored_*" type="ignored" multiValued="true"/>
    <dynamicField name="attr_*" type="text" indexed="true" stored="true" multiValued="true"/>
 
diff --git a/solr/core/src/test-files/solr/collection1/conf/schemasurround.xml b/solr/core/src/test-files/solr/collection1/conf/schemasurround.xml
index 04e90e3..7939431 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schemasurround.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schemasurround.xml
@@ -34,16 +34,6 @@
          behavior of the fieldtype.
       -->
 
-    <!-- numeric field types that store and index the text
-         value verbatim (and hence don't sort correctly or support range queries.)
-         These are provided more for backward compatability, allowing one
-         to create a schema that matches an existing lucene index.
-    -->
-    <fieldType name="pint" class="solr.IntField"/>
-    <fieldType name="plong" class="solr.LongField"/>
-    <fieldtype name="pfloat" class="solr.FloatField"/>
-    <fieldType name="pdouble" class="solr.DoubleField"/>
-
     <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
     <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
     <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
@@ -54,25 +44,6 @@
     <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
     <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
 
-    <!-- numeric field types that manipulate the value into
-       a string value that isn't human readable in it's internal form,
-       but sorts correctly and supports range queries.
-
-         If sortMissingLast="true" then a sort on this field will cause documents
-       without the field to come after documents with the field,
-       regardless of the requested sort order.
-         If sortMissingFirst="true" then a sort on this field will cause documents
-       without the field to come before documents with the field,
-       regardless of the requested sort order.
-         If sortMissingLast="false" and sortMissingFirst="false" (the default),
-       then default lucene sorting will be used which places docs without the field
-       first in an ascending sort and last in a descending sort.
-    -->
-    <fieldtype name="sint" class="solr.SortableIntField" sortMissingLast="true" omitNorms="true" />
-    <fieldtype name="slong" class="solr.SortableLongField" sortMissingLast="true" omitNorms="true"/>
-    <fieldtype name="sfloat" class="solr.SortableFloatField" sortMissingLast="true" omitNorms="true"/>
-    <fieldtype name="sdouble" class="solr.SortableDoubleField" sortMissingLast="true" omitNorms="true"/>
-
     <!-- Field type demonstrating an Analyzer failure -->
     <fieldtype name="failtype1" class="solr.TextField">
       <analyzer type="index">
@@ -111,7 +82,6 @@
       -->
     <fieldtype name="date" class="solr.TrieDateField" sortMissingLast="true"/>
     <fieldtype name="tdate" class="solr.TrieDateField" sortMissingLast="true" precisionStep="6"/>
-    <fieldtype name="pdate" class="solr.DateField" sortMissingLast="true"/>
 
   <fieldType name="text" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true" >
       <analyzer type="index">
@@ -543,12 +513,6 @@
 
    <dynamicField name="*_coordinate"  type="tdouble" indexed="true"  stored="false"/>
 
-
-   <dynamicField name="*_si"  type="sint"  indexed="true"  stored="true"/>
-   <dynamicField name="*_sl"  type="slong"  indexed="true"  stored="true"/>
-   <dynamicField name="*_sf"  type="sfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_sd"  type="sdouble"  indexed="true"  stored="true"/>
-
    <dynamicField name="*_sI" type="string"  indexed="true"  stored="false"/>
    <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
    <dynamicField name="t_*"  type="text"    indexed="true"  stored="true"/>
@@ -582,13 +546,6 @@
    <dynamicField name="*_td" type="tdouble" indexed="true"  stored="true"/>
    <dynamicField name="*_tdt" type="tdate"  indexed="true"  stored="true"/>
 
-   <dynamicField name="*_pi"  type="pint"    indexed="true"  stored="true"/>
-   <dynamicField name="*_pf"  type="pfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_pl"  type="plong"   indexed="true"  stored="true"/>
-   <dynamicField name="*_pd"  type="pdouble" indexed="true"  stored="true"/>
-   <dynamicField name="*_pdt"  type="pdate" indexed="true"  stored="true"/>
-
-
    <dynamicField name="ignored_*" type="ignored" multiValued="true"/>
    <dynamicField name="attr_*" type="text" indexed="true" stored="true" multiValued="true"/>
 
diff --git a/solr/core/src/test-files/solr/collection1/conf/solrconfig-parsing-update-processor-chains.xml b/solr/core/src/test-files/solr/collection1/conf/solrconfig-parsing-update-processor-chains.xml
index 3c41f50..aeedb82 100644
--- a/solr/core/src/test-files/solr/collection1/conf/solrconfig-parsing-update-processor-chains.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/solrconfig-parsing-update-processor-chains.xml
@@ -48,7 +48,6 @@
 
   <updateRequestProcessorChain name="parse-date-explicit-typeclass-selector-no-run-processor">
     <processor class="solr.ParseDateFieldUpdateProcessorFactory">
-      <str name="typeClass">solr.DateField</str>
       <str name="typeClass">solr.TrieDateField</str>
       <str name="format">yyyy-MM-dd'T'HH:mm:ss.SSSZ</str>
     </processor>
diff --git a/solr/core/src/test-files/solr/collection1/conf/solrconfig-update-processor-chains.xml b/solr/core/src/test-files/solr/collection1/conf/solrconfig-update-processor-chains.xml
index a5ffdd4..cd80c29 100644
--- a/solr/core/src/test-files/solr/collection1/conf/solrconfig-update-processor-chains.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/solrconfig-update-processor-chains.xml
@@ -89,7 +89,7 @@
       <str name="fieldRegex">bar.*</str>
       <!-- each set of exclusions is checked independently -->
       <lst name="exclude">
-        <str name="typeClass">solr.DateField</str>
+        <str name="typeClass">solr.TrieDateField</str>
       </lst>
       <lst name="exclude">
         <str name="fieldRegex">.*HOSS.*</str>
@@ -102,7 +102,7 @@
       <str name="fieldRegex">bar.*</str>
       <!-- only excluded if it matches all in set -->
       <lst name="exclude">
-        <str name="typeClass">solr.DateField</str>
+        <str name="typeClass">solr.TrieDateField</str>
         <str name="fieldRegex">.*HOSS.*</str>
       </lst>
     </processor>
@@ -139,14 +139,14 @@
 
   <updateRequestProcessorChain name="trim-classes">
     <processor class="solr.TrimFieldUpdateProcessorFactory">
-      <str name="typeClass">solr.DateField</str>
+      <str name="typeClass">solr.TrieDateField</str>
       <str name="typeClass">solr.StrField</str>
     </processor>
   </updateRequestProcessorChain>
 
   <updateRequestProcessorChain name="trim-multi">
     <processor class="solr.TrimFieldUpdateProcessorFactory">
-      <str name="typeClass">solr.DateField</str>
+      <str name="typeClass">solr.TrieDateField</str>
       <str name="typeClass">solr.StrField</str>
       <arr name="fieldRegex">
         <str>foo.*</str>
diff --git a/solr/core/src/test-files/solr/crazy-path-to-schema.xml b/solr/core/src/test-files/solr/crazy-path-to-schema.xml
index a2216dd..7723aba 100644
--- a/solr/core/src/test-files/solr/crazy-path-to-schema.xml
+++ b/solr/core/src/test-files/solr/crazy-path-to-schema.xml
@@ -23,7 +23,7 @@
 
 <schema name="test" version="1.0">
   <types>
-    <fieldtype name="sint" class="solr.SortableIntField" />
+    <fieldtype name="int" class="solr.TrieIntField" precisionStep="0"/>
     <fieldtype name="text" class="solr.TextField">
       <analyzer>
         <tokenizer class="solr.StandardTokenizerFactory"/>
@@ -37,7 +37,7 @@
 
 
  <fields>
-   <field name="id" type="sint" indexed="true" stored="true" multiValued="false"/>
+   <field name="id" type="int" indexed="true" stored="true" multiValued="false"/>
    <field name="subject" type="text" indexed="true" stored="true"/>
  </fields>
 
diff --git a/solr/core/src/test/org/apache/solr/BasicFunctionalityTest.java b/solr/core/src/test/org/apache/solr/BasicFunctionalityTest.java
index 34383c6..86ae23b 100644
--- a/solr/core/src/test/org/apache/solr/BasicFunctionalityTest.java
+++ b/solr/core/src/test/org/apache/solr/BasicFunctionalityTest.java
@@ -795,7 +795,7 @@ public class BasicFunctionalityTest extends SolrTestCaseJ4 {
 
     // testing everything from query level is hard because
     // time marches on ... and there is no easy way to reach into the
-    // bowels of DateField and muck with the definition of "now"
+    // bowels of TrieDateField and muck with the definition of "now"
     //    ...
     // BUT: we can test that crazy combinations of "NOW" all work correctly,
     // assuming the test doesn't take too long to run...
diff --git a/solr/core/src/test/org/apache/solr/ConvertedLegacyTest.java b/solr/core/src/test/org/apache/solr/ConvertedLegacyTest.java
index 508631b..e948212 100644
--- a/solr/core/src/test/org/apache/solr/ConvertedLegacyTest.java
+++ b/solr/core/src/test/org/apache/solr/ConvertedLegacyTest.java
@@ -583,47 +583,47 @@ public class ConvertedLegacyTest extends SolrTestCaseJ4 {
     // test binary float ranges and sorting
 
     assertU("<delete><id>44</id></delete>");
-    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_sf1\">1.4142135</field></doc></add>");
-    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_sf1\">Infinity</field></doc></add>");
-    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_sf1\">-Infinity</field></doc></add>");
-    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_sf1\">NaN</field></doc></add>");
-    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_sf1\">2</field></doc></add>");
-    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_sf1\">-1</field></doc></add>");
-    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_sf1\">-987654321</field></doc></add>");
-    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_sf1\">-999999.99</field></doc></add>");
-    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_sf1\">-1e20</field></doc></add>");
-    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_sf1\">0</field></doc></add>");
+    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_f1\">1.4142135</field></doc></add>");
+    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_f1\">Infinity</field></doc></add>");
+    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_f1\">-Infinity</field></doc></add>");
+    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_f1\">NaN</field></doc></add>");
+    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_f1\">2</field></doc></add>");
+    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_f1\">-1</field></doc></add>");
+    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_f1\">-987654321</field></doc></add>");
+    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_f1\">-999999.99</field></doc></add>");
+    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_f1\">-1e20</field></doc></add>");
+    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_f1\">0</field></doc></add>");
     assertU("<commit/>");
     assertQ(req("id:44")
             ,"*[count(//doc)=10]"
             );
-    assertQ(req("num_sf1:Infinity")
+    assertQ(req("num_f1:Infinity")
             ,"//@numFound[.='1']  "
             ,"//float[.='Infinity']"
             );
-    assertQ(req("num_sf1:\"-Infinity\"")
+    assertQ(req("num_f1:\"-Infinity\"")
             ,"//@numFound[.='1']  "
             ,"//float[.='-Infinity']"
             );
-    assertQ(req("num_sf1:\"NaN\"")
+    assertQ(req("num_f1:\"NaN\"")
             ,"//@numFound[.='1']  "
             ,"//float[.='NaN']"
             );
-    assertQ(req("num_sf1:\"-1e20\"")
+    assertQ(req("num_f1:\"-1e20\"")
             ,"//@numFound[.='1']"
             );
-    assertQ(req("id:44;num_sf1 asc;")
+    assertQ(req("id:44;num_f1 asc;")
             ,"//doc[1]/float[.='-Infinity'] "
             ,"//doc[last()]/float[.='NaN']"
             );
-    assertQ(req("id:44;num_sf1 desc;")
+    assertQ(req("id:44;num_f1 desc;")
             ,"//doc[1]/float[.='NaN'] "
             ,"//doc[last()]/float[.='-Infinity']"
             );
-    assertQ(req("num_sf1:[-1 TO 2]")
+    assertQ(req("num_f1:[-1 TO 2]")
             ,"*[count(//doc)=4]"
             );
-    assertQ(req("num_sf1:[-Infinity TO Infinity]")
+    assertQ(req("num_f1:[-Infinity TO Infinity]")
             ,"*[count(//doc)=9]"
             );
 
@@ -632,50 +632,50 @@ public class ConvertedLegacyTest extends SolrTestCaseJ4 {
     // test binary double ranges and sorting
 
     assertU("<delete><id>44</id></delete>");
-    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_sd1\">1.4142135</field></doc></add>");
-    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_sd1\">Infinity</field></doc></add>");
-    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_sd1\">-Infinity</field></doc></add>");
-    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_sd1\">NaN</field></doc></add>");
-    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_sd1\">2</field></doc></add>");
-    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_sd1\">-1</field></doc></add>");
-    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_sd1\">1e-100</field></doc></add>");
-    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_sd1\">-999999.99</field></doc></add>");
-    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_sd1\">-1e100</field></doc></add>");
-    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_sd1\">0</field></doc></add>");
+    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_d1\">1.4142135</field></doc></add>");
+    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_d1\">Infinity</field></doc></add>");
+    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_d1\">-Infinity</field></doc></add>");
+    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_d1\">NaN</field></doc></add>");
+    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_d1\">2</field></doc></add>");
+    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_d1\">-1</field></doc></add>");
+    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_d1\">1e-100</field></doc></add>");
+    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_d1\">-999999.99</field></doc></add>");
+    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_d1\">-1e100</field></doc></add>");
+    assertU("<add overwrite=\"false\"><doc><field name=\"id\">44</field><field name=\"num_d1\">0</field></doc></add>");
     assertU("<commit/>");
     assertQ(req("id:44")
             ,"*[count(//doc)=10]"
             );
-    assertQ(req("num_sd1:Infinity")
+    assertQ(req("num_d1:Infinity")
             ,"//@numFound[.='1']  "
             ,"//double[.='Infinity']"
             );
-    assertQ(req("num_sd1:\"-Infinity\"")
+    assertQ(req("num_d1:\"-Infinity\"")
             ,"//@numFound[.='1']  "
             ,"//double[.='-Infinity']"
             );
-    assertQ(req("num_sd1:\"NaN\"")
+    assertQ(req("num_d1:\"NaN\"")
             ,"//@numFound[.='1']  "
             ,"//double[.='NaN']"
             );
-    assertQ(req("num_sd1:\"-1e100\"")
+    assertQ(req("num_d1:\"-1e100\"")
             ,"//@numFound[.='1']"
             );
-    assertQ(req("num_sd1:\"1e-100\"")
+    assertQ(req("num_d1:\"1e-100\"")
             ,"//@numFound[.='1']"
             );
-    assertQ(req("id:44;num_sd1 asc;")
+    assertQ(req("id:44;num_d1 asc;")
             ,"//doc[1]/double[.='-Infinity'] "
             ,"//doc[last()]/double[.='NaN']"
             );
-    assertQ(req("id:44;num_sd1 desc;")
+    assertQ(req("id:44;num_d1 desc;")
             ,"//doc[1]/double[.='NaN'] "
             ,"//doc[last()]/double[.='-Infinity']"
             );
-    assertQ(req("num_sd1:[-1 TO 2]")
+    assertQ(req("num_d1:[-1 TO 2]")
             ,"*[count(//doc)=5]"
             );
-    assertQ(req("num_sd1:[-Infinity TO Infinity]")
+    assertQ(req("num_d1:[-Infinity TO Infinity]")
             ,"*[count(//doc)=9]"
             );
 
@@ -728,35 +728,35 @@ public class ConvertedLegacyTest extends SolrTestCaseJ4 {
     assertU("<delete><query>id_i:[1000 TO 1010]</query></delete>");
     assertU("<add overwrite=\"false\"><doc><field name=\"id_i\">1000</field><field name=\"a_i1\">1</field><field name=\"nullfirst\">Z</field></doc></add>");
     assertU("<add overwrite=\"false\"><doc><field name=\"id_i\">1001</field><field name=\"a_i1\">10</field><field name=\"nullfirst\">A</field></doc></add>");
-    assertU("<add overwrite=\"false\"><doc><field name=\"id_i\">1002</field><field name=\"a_i1\">1</field><field name=\"b_si\">100</field></doc></add>");
+    assertU("<add overwrite=\"false\"><doc><field name=\"id_i\">1002</field><field name=\"a_i1\">1</field><field name=\"b_i1\">100</field></doc></add>");
     assertU("<add overwrite=\"false\"><doc><field name=\"id_i\">1003</field><field name=\"a_i1\">-1</field></doc></add>");
     assertU("<add overwrite=\"false\"><doc><field name=\"id_i\">1004</field><field name=\"a_i1\">15</field></doc></add>");
-    assertU("<add overwrite=\"false\"><doc><field name=\"id_i\">1005</field><field name=\"a_i1\">1</field><field name=\"b_si\">50</field></doc></add>");
+    assertU("<add overwrite=\"false\"><doc><field name=\"id_i\">1005</field><field name=\"a_i1\">1</field><field name=\"b_i1\">50</field></doc></add>");
     assertU("<add overwrite=\"false\"><doc><field name=\"id_i\">1006</field><field name=\"a_i1\">0</field></doc></add>");
     assertU("<commit/>");
     assertQ(req("id_i:[1000 TO 1010]")
             ,"*[count(//doc)=7]"
             );
-    assertQ(req("id_i:[1000 TO 1010]; b_si asc")
+    assertQ(req("id_i:[1000 TO 1010]; b_i1 asc")
             ,"*[count(//doc)=7] "
             ,"//doc[1]/int[.='50'] "
             ,"//doc[2]/int[.='100']"
             );
-    assertQ(req("id_i:[1000 TO 1010]; b_si desc")
+    assertQ(req("id_i:[1000 TO 1010]; b_i1 desc")
             ,"*[count(//doc)=7] "
             ,"//doc[1]/int[.='100'] "
             ,"//doc[2]/int[.='50']"
             );
-    assertQ(req("id_i:[1000 TO 1010]; a_i1 asc,b_si desc")
+    assertQ(req("id_i:[1000 TO 1010]; a_i1 asc,b_i1 desc")
             ,"*[count(//doc)=7] "
-            ,"//doc[3]/int[@name='b_si' and .='100'] "
-            ,"//doc[4]/int[@name='b_si' and .='50']  "
+            ,"//doc[3]/int[@name='b_i1' and .='100'] "
+            ,"//doc[4]/int[@name='b_i1' and .='50']  "
             ,"//doc[5]/arr[@name='id_i' and .='1000']"
             );
-    assertQ(req("id_i:[1000 TO 1010]; a_i1 asc,b_si asc")
+    assertQ(req("id_i:[1000 TO 1010]; a_i1 asc,b_i1 asc")
             ,"*[count(//doc)=7] "
-            ,"//doc[3]/int[@name='b_si' and .='50'] "
-            ,"//doc[4]/int[@name='b_si' and .='100']  "
+            ,"//doc[3]/int[@name='b_i1' and .='50'] "
+            ,"//doc[4]/int[@name='b_i1' and .='100']  "
             ,"//doc[5]/arr[@name='id_i' and .='1000']"
             );
     // nullfirst tests
diff --git a/solr/core/src/test/org/apache/solr/CursorPagingTest.java b/solr/core/src/test/org/apache/solr/CursorPagingTest.java
index 6552da7..a9563f8 100644
--- a/solr/core/src/test/org/apache/solr/CursorPagingTest.java
+++ b/solr/core/src/test/org/apache/solr/CursorPagingTest.java
@@ -31,7 +31,7 @@ import static org.apache.solr.common.params.CursorMarkParams.CURSOR_MARK_START;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.SolrException.ErrorCode;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.schema.DateField;
+import org.apache.solr.schema.TrieDateField;
 import org.apache.solr.search.CursorMark; //jdoc
 
 import org.noggit.ObjectBuilder;
@@ -963,7 +963,7 @@ public class CursorPagingTest extends SolrTestCaseJ4 {
   }
 
   private static String randomDate() {
-    return DateField.formatExternal(new Date(random().nextLong()));
+    return TrieDateField.formatExternal(new Date(random().nextLong()));
   }
 
   private static String dateWithRandomSecondOn2010_10_31_at_10_31() {
@@ -998,9 +998,7 @@ public class CursorPagingTest extends SolrTestCaseJ4 {
       String field = shuffledNames.get(i);
 
       // wrap in a function sometimes
-      if ( (!"score".equals(field) && !field.contains("bcd"))
-           && 
-           (0 == TestUtil.nextInt(random(), 0, 7)) ) {
+      if ( ! "score".equals(field) && 0 == TestUtil.nextInt(random(), 0, 7)) {
         // specific function doesn't matter, just proving that we can handle the concept.
         // but we do have to be careful with non numeric fields
         if (field.contains("float") || field.contains("double")
diff --git a/solr/core/src/test/org/apache/solr/TestDistributedGrouping.java b/solr/core/src/test/org/apache/solr/TestDistributedGrouping.java
index 3eccde1..b4cae09 100644
--- a/solr/core/src/test/org/apache/solr/TestDistributedGrouping.java
+++ b/solr/core/src/test/org/apache/solr/TestDistributedGrouping.java
@@ -36,7 +36,7 @@ import org.apache.solr.common.util.NamedList;
 public class TestDistributedGrouping extends BaseDistributedSearchTestCase {
 
   String t1="a_t";
-  String i1="a_si";
+  String i1="a_i1";
   String s1="a_s";
   String tlong = "other_tl1";
   String tdate_a = "a_n_tdt";
diff --git a/solr/core/src/test/org/apache/solr/TestDistributedMissingSort.java b/solr/core/src/test/org/apache/solr/TestDistributedMissingSort.java
index 6f7956d..97673f2 100644
--- a/solr/core/src/test/org/apache/solr/TestDistributedMissingSort.java
+++ b/solr/core/src/test/org/apache/solr/TestDistributedMissingSort.java
@@ -30,8 +30,8 @@ public class TestDistributedMissingSort extends BaseDistributedSearchTestCase {
     schemaString = "schema-distributed-missing-sort.xml";
   }
   
-  String sint1_ml = "one_si_ml";    // SortableIntField, sortMissingLast=true, multiValued=false
-  String sint1_mf = "two_si_mf";    // SortableIntField, sortMissingFirst=true, multiValued=false
+  String sint1_ml = "one_i1_ml";    // TrieIntField, sortMissingLast=true, multiValued=false
+  String sint1_mf = "two_i1_mf";    // TrieIntField, sortMissingFirst=true, multiValued=false
   String long1_ml = "three_l1_ml";  // TrieLongField, sortMissingLast=true, multiValued=false
   String long1_mf = "four_l1_mf";   // TrieLongField, sortMissingFirst=true, multiValued=false
   String string1_ml = "five_s1_ml"; // StringField, sortMissingLast=true, multiValued=false
@@ -113,7 +113,6 @@ public class TestDistributedMissingSort extends BaseDistributedSearchTestCase {
     rsp = query("q","*:*", "sort", sint1_ml + " desc," + id + " asc", "rows", "200");
     assertFieldValues(rsp.getResults(), id,
         10, 8, 5, 12, 13, 7, 1, 2, 9, 3, 4, 6, 11,
-        // missing field sint1_ml="a_si", ascending id sort
         14, 15, 16, 17,
         100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
         110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
@@ -124,7 +123,6 @@ public class TestDistributedMissingSort extends BaseDistributedSearchTestCase {
     rsp = query("q","*:*", "sort", sint1_ml + " asc," + id + " desc", "rows", "200");
     assertFieldValues(rsp.getResults(), id,
         11, 6, 4, 3, 9, 2, 1, 7, 13, 12, 5, 8, 10,
-        // missing field sint1_ml="a_si", descending id sort
         149, 148, 147, 146, 145, 144, 143, 142, 141, 140,
         139, 138, 137, 136, 135, 134, 133, 132, 131, 130,
         129, 128, 127, 126, 125, 124, 123, 122, 121, 120,
@@ -146,7 +144,6 @@ public class TestDistributedMissingSort extends BaseDistributedSearchTestCase {
     rsp = query("q","*:*", "sort", long1_ml + " desc," + id + " asc", "rows", "200");
     assertFieldValues(rsp.getResults(), id,
         10, 8, 5, 12, 13, 7, 1, 2, 9, 3, 4, 6, 11,
-        // missing field sint1_ml="a_si", ascending id sort
         14, 15, 16, 17,
         100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
         110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
@@ -157,7 +154,6 @@ public class TestDistributedMissingSort extends BaseDistributedSearchTestCase {
     rsp = query("q","*:*", "sort", long1_ml + " asc," + id + " desc", "rows", "200");
     assertFieldValues(rsp.getResults(), id,
         11, 6, 4, 3, 9, 2, 1, 7, 13, 12, 5, 8, 10,
-        // missing field sint1_ml="a_si", descending id sort
         149, 148, 147, 146, 145, 144, 143, 142, 141, 140,
         139, 138, 137, 136, 135, 134, 133, 132, 131, 130,
         129, 128, 127, 126, 125, 124, 123, 122, 121, 120,
@@ -208,7 +204,6 @@ public class TestDistributedMissingSort extends BaseDistributedSearchTestCase {
 
     QueryResponse rsp = query("q","*:*", "sort", sint1_mf + " desc," + id + " asc", "rows", "200");
     assertFieldValues(rsp.getResults(), id,
-        // missing field sint1_mf="a_si_mf", ascending id sort
         14, 15, 16, 17,
         100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
         110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
@@ -219,7 +214,6 @@ public class TestDistributedMissingSort extends BaseDistributedSearchTestCase {
 
     rsp = query("q","*:*", "sort", sint1_mf + " asc," + id + " desc", "rows", "200");
     assertFieldValues(rsp.getResults(), id,
-        // missing field sint1_mf="a_si_mf", descending id sort
         149, 148, 147, 146, 145, 144, 143, 142, 141, 140,
         139, 138, 137, 136, 135, 134, 133, 132, 131, 130,
         129, 128, 127, 126, 125, 124, 123, 122, 121, 120,
@@ -236,7 +230,6 @@ public class TestDistributedMissingSort extends BaseDistributedSearchTestCase {
 
     rsp = query("q","*:*", "sort", long1_mf + " desc," + id + " asc", "rows", "200");
     assertFieldValues(rsp.getResults(), id,
-        // missing field sint1_mf="a_si_mf", ascending id sort
         14, 15, 16, 17,
         100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
         110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
@@ -247,7 +240,6 @@ public class TestDistributedMissingSort extends BaseDistributedSearchTestCase {
 
     rsp = query("q","*:*", "sort", long1_mf + " asc," + id + " desc", "rows", "200");
     assertFieldValues(rsp.getResults(), id,
-        // missing field sint1_mf="a_si_mf", descending id sort
         149, 148, 147, 146, 145, 144, 143, 142, 141, 140,
         139, 138, 137, 136, 135, 134, 133, 132, 131, 130,
         129, 128, 127, 126, 125, 124, 123, 122, 121, 120,
diff --git a/solr/core/src/test/org/apache/solr/TestDistributedSearch.java b/solr/core/src/test/org/apache/solr/TestDistributedSearch.java
index c583102..d268c13 100644
--- a/solr/core/src/test/org/apache/solr/TestDistributedSearch.java
+++ b/solr/core/src/test/org/apache/solr/TestDistributedSearch.java
@@ -48,16 +48,10 @@ import org.apache.solr.common.util.NamedList;
 public class TestDistributedSearch extends BaseDistributedSearchTestCase {
 
   String t1="a_t";
-  String i1="a_si";
+  String i1="a_i1";
   String nint = "n_i";
   String tint = "n_ti";
-  String nfloat = "n_f";
-  String tfloat = "n_tf";
-  String ndouble = "n_d";
-  String tdouble = "n_td";
-  String nlong = "n_l";
   String tlong = "other_tl1";
-  String ndate = "n_dt";
   String tdate_a = "a_n_tdt";
   String tdate_b = "b_n_tdt";
   
diff --git a/solr/core/src/test/org/apache/solr/TestGroupingSearch.java b/solr/core/src/test/org/apache/solr/TestGroupingSearch.java
index e45259e..af34844 100644
--- a/solr/core/src/test/org/apache/solr/TestGroupingSearch.java
+++ b/solr/core/src/test/org/apache/solr/TestGroupingSearch.java
@@ -72,11 +72,11 @@ public class TestGroupingSearch extends SolrTestCaseJ4 {
 
   @Test
   public void testGroupingGroupSortingScore_basic() {
-    assertU(add(doc("id", "1","name", "author1", "title", "a book title", "group_si", "1")));
-    assertU(add(doc("id", "2","name", "author1", "title", "the title", "group_si", "2")));
-    assertU(add(doc("id", "3","name", "author2", "title", "a book title", "group_si", "1")));
-    assertU(add(doc("id", "4","name", "author2", "title", "title", "group_si", "2")));
-    assertU(add(doc("id", "5","name", "author3", "title", "the title of a title", "group_si", "1")));
+    assertU(add(doc("id", "1","name", "author1", "title", "a book title", "group_i", "1")));
+    assertU(add(doc("id", "2","name", "author1", "title", "the title", "group_i", "2")));
+    assertU(add(doc("id", "3","name", "author2", "title", "a book title", "group_i", "1")));
+    assertU(add(doc("id", "4","name", "author2", "title", "title", "group_i", "2")));
+    assertU(add(doc("id", "5","name", "author3", "title", "the title of a title", "group_i", "1")));
     assertU(commit());
     
     assertQ(req("q","title:title", "group", "true", "group.field","name")
@@ -99,8 +99,8 @@ public class TestGroupingSearch extends SolrTestCaseJ4 {
             ,"//arr[@name='groups']/lst[3]/result/doc/*[@name='id'][.='5']"
             );
 
-    assertQ(req("q", "title:title", "group", "true", "group.field", "group_si")
-        , "//lst[@name='grouped']/lst[@name='group_si']"
+    assertQ(req("q", "title:title", "group", "true", "group.field", "group_i")
+        , "//lst[@name='grouped']/lst[@name='group_i']"
         , "*[count(//arr[@name='groups']/lst) = 2]"
 
         , "//arr[@name='groups']/lst[1]/int[@name='groupValue'][.='2']"
@@ -115,11 +115,11 @@ public class TestGroupingSearch extends SolrTestCaseJ4 {
 
   @Test
   public void testGroupingGroupSortingScore_withTotalGroupCount() {
-    assertU(add(doc("id", "1","name", "author1", "title", "a book title", "group_si", "1")));
-    assertU(add(doc("id", "2","name", "author1", "title", "the title", "group_si", "2")));
-    assertU(add(doc("id", "3","name", "author2", "title", "a book title", "group_si", "1")));
-    assertU(add(doc("id", "4","name", "author2", "title", "title", "group_si", "2")));
-    assertU(add(doc("id", "5","name", "author3", "title", "the title of a title", "group_si", "1")));
+    assertU(add(doc("id", "1","name", "author1", "title", "a book title", "group_i", "1")));
+    assertU(add(doc("id", "2","name", "author1", "title", "the title", "group_i", "2")));
+    assertU(add(doc("id", "3","name", "author2", "title", "a book title", "group_i", "1")));
+    assertU(add(doc("id", "4","name", "author2", "title", "title", "group_i", "2")));
+    assertU(add(doc("id", "5","name", "author3", "title", "the title of a title", "group_i", "1")));
     assertU(commit());
 
     assertQ(req("q","title:title", "group", "true", "group.field","name", "group.ngroups", "true")
@@ -141,9 +141,9 @@ public class TestGroupingSearch extends SolrTestCaseJ4 {
             ,"//arr[@name='groups']/lst[3]/result/doc/*[@name='id'][.='5']"
             );
 
-    assertQ(req("q", "title:title", "group", "true", "group.field", "group_si", "group.ngroups", "true")
-        , "//lst[@name='grouped']/lst[@name='group_si']/int[@name='matches'][.='5']"
-        , "//lst[@name='grouped']/lst[@name='group_si']/int[@name='ngroups'][.='2']"
+    assertQ(req("q", "title:title", "group", "true", "group.field", "group_i", "group.ngroups", "true")
+        , "//lst[@name='grouped']/lst[@name='group_i']/int[@name='matches'][.='5']"
+        , "//lst[@name='grouped']/lst[@name='group_i']/int[@name='ngroups'][.='2']"
         , "*[count(//arr[@name='groups']/lst) = 2]"
 
         , "//arr[@name='groups']/lst[1]/int[@name='groupValue'][.='2']"
diff --git a/solr/core/src/test/org/apache/solr/TestTrie.java b/solr/core/src/test/org/apache/solr/TestTrie.java
index 6aba33b..e9da8bc 100644
--- a/solr/core/src/test/org/apache/solr/TestTrie.java
+++ b/solr/core/src/test/org/apache/solr/TestTrie.java
@@ -17,8 +17,8 @@
 package org.apache.solr;
 
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.schema.DateField;
 import org.apache.solr.schema.FieldType;
+import org.apache.solr.schema.TrieDateField;
 import org.apache.solr.schema.TrieField;
 import org.apache.solr.util.DateMathParser;
 import org.junit.After;
@@ -173,7 +173,7 @@ public class TestTrie extends SolrTestCaseJ4 {
     format.setTimeZone(TimeZone.getTimeZone("UTC"));
 
     assertU(delQ("*:*"));
-    DateMathParser dmp = new DateMathParser(DateField.UTC, Locale.ROOT);
+    DateMathParser dmp = new DateMathParser(TrieDateField.UTC, Locale.ROOT);
     String largestDate = "";
     for (int i = 0; i < 10; i++) {
       // index 10 days starting with today
@@ -222,7 +222,7 @@ public class TestTrie extends SolrTestCaseJ4 {
     // For tdate tests
     SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.ROOT);
     format.setTimeZone(TimeZone.getTimeZone("UTC"));
-    DateMathParser dmp = new DateMathParser(DateField.UTC, Locale.ROOT);
+    DateMathParser dmp = new DateMathParser(TrieDateField.UTC, Locale.ROOT);
 
     for (int i = 0; i < 10; i++) {
       long l = Integer.MAX_VALUE + i*1L;
diff --git a/solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest.java b/solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest.java
index 3a14fe0..4169c48 100644
--- a/solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest.java
@@ -83,22 +83,12 @@ public class BasicDistributedZkTest extends AbstractFullDistribZkTestBase {
   private static final String DEFAULT_COLLECTION = "collection1";
   protected static final boolean DEBUG = false;
   String t1="a_t";
-  String i1="a_si";
-  String nint = "n_i";
-  String tint = "n_ti";
-  String nfloat = "n_f";
-  String tfloat = "n_tf";
-  String ndouble = "n_d";
-  String tdouble = "n_td";
-  String nlong = "n_l";
+  String i1="a_i1";
   String tlong = "other_tl1";
-  String ndate = "n_dt";
-  String tdate = "n_tdt";
-  
+
   String oddField="oddField_s";
   String missingField="ignore_exception__missing_but_valid_field_t";
-  String invalidField="ignore_exception__invalid_field_not_in_schema";
-  
+
   private Map<String,List<SolrServer>> otherCollectionClients = new HashMap<>();
 
   private String oneInstanceCollection = "oneInstanceCollection";
diff --git a/solr/core/src/test/org/apache/solr/handler/admin/LukeRequestHandlerTest.java b/solr/core/src/test/org/apache/solr/handler/admin/LukeRequestHandlerTest.java
index 12f6e11..7467e2c 100644
--- a/solr/core/src/test/org/apache/solr/handler/admin/LukeRequestHandlerTest.java
+++ b/solr/core/src/test/org/apache/solr/handler/admin/LukeRequestHandlerTest.java
@@ -43,10 +43,6 @@ public class LukeRequestHandlerTest extends AbstractSolrTestCase {
   @Before
   public void before() {
     assertU(adoc("id","SOLR1000", "name","Apache Solr",
-        "solr_si", "10",
-        "solr_sl", "10",
-        "solr_sf", "10",
-        "solr_sd", "10",
         "solr_s", "10",
         "solr_sI", "10",
         "solr_sS", "10",
@@ -61,13 +57,8 @@ public class LukeRequestHandlerTest extends AbstractSolrTestCase {
         "solr_tl", "10",
         "solr_tf", "10",
         "solr_td", "10",
-        "solr_pi", "10",
-        "solr_pl", "10",
-        "solr_pf", "10",
-        "solr_pd", "10",
         "solr_dt", "2000-01-01T01:01:01Z",
-        "solr_tdt", "2000-01-01T01:01:01Z",
-        "solr_pdt", "2000-01-01T01:01:01Z"
+        "solr_tdt", "2000-01-01T01:01:01Z"
     ));
     assertU(commit());
 
@@ -112,7 +103,7 @@ public class LukeRequestHandlerTest extends AbstractSolrTestCase {
 
     // code should be the same for all fields, but just in case do several
     for (String f : Arrays.asList("solr_t","solr_s","solr_ti",
-        "solr_td","solr_pl","solr_dt","solr_b",
+        "solr_td","solr_dt","solr_b",
         "solr_sS","solr_sI")) {
 
       final String xp = getFieldXPathPrefix(f);
@@ -125,7 +116,7 @@ public class LukeRequestHandlerTest extends AbstractSolrTestCase {
     // diff loop for checking 'index' flags,
     // only valid for fields that are indexed & stored
     for (String f : Arrays.asList("solr_t","solr_s","solr_ti",
-        "solr_td","solr_pl","solr_dt","solr_b")) {
+        "solr_td","solr_dt","solr_b")) {
 
       final String xp = getFieldXPathPrefix(f);
       assertQ("Not as many index flags as expected ("+numFlags+") for " + f,
@@ -164,7 +155,7 @@ public class LukeRequestHandlerTest extends AbstractSolrTestCase {
 
       // Now test that the other fields are NOT there
       for (String f : Arrays.asList("solr_ti",
-          "solr_td", "solr_pl", "solr_dt", "solr_b")) {
+          "solr_td", "solr_dt", "solr_b")) {
 
         assertNotNull(TestHarness.validateXPath(response,
             getFieldXPathPrefix(f) + "[@name='index']"));
@@ -174,7 +165,7 @@ public class LukeRequestHandlerTest extends AbstractSolrTestCase {
       req = req("qt", "/admin/luke", "fl", "*");
       response = h.query(req);
       for (String f : Arrays.asList("solr_t", "solr_s", "solr_ti",
-          "solr_td", "solr_pl", "solr_dt", "solr_b")) {
+          "solr_td", "solr_dt", "solr_b")) {
 
         assertNull(TestHarness.validateXPath(response,
             getFieldXPathPrefix(f) + "[@name='index']"));
diff --git a/solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest.java b/solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest.java
index 3a016c1..a5bf0ac 100644
--- a/solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest.java
+++ b/solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest.java
@@ -63,8 +63,7 @@ public class StatsComponentTest extends AbstractSolrTestCase {
       doTestFacetStatisticsMissingResult(f);
     }
 
-    for (String f : new String[] {"stats_ii", // plain int
-            "stats_is",    // sortable int
+    for (String f : new String[] {"stats_ii",
             "stats_tis","stats_tfs","stats_tls","stats_tds"  // trie fields
                                   }) {
       doTestMVFieldStatisticsResult(f);
diff --git a/solr/core/src/test/org/apache/solr/request/SimpleFacetsTest.java b/solr/core/src/test/org/apache/solr/request/SimpleFacetsTest.java
index a49adbc..dd81ce2 100644
--- a/solr/core/src/test/org/apache/solr/request/SimpleFacetsTest.java
+++ b/solr/core/src/test/org/apache/solr/request/SimpleFacetsTest.java
@@ -657,19 +657,11 @@ public class SimpleFacetsTest extends SolrTestCaseJ4 {
   public void testTrieDateFacets() {
     helpTestDateFacets("bday", false);
   }
-  @Test
-  public void testDateFacets() {
-    helpTestDateFacets("bday_pdt", false);
-  }
 
   @Test
   public void testTrieDateRangeFacets() {
     helpTestDateFacets("bday", true);
   }
-  @Test
-  public void testDateRangeFacets() {
-    helpTestDateFacets("bday_pdt", true);
-  }
 
   private void helpTestDateFacets(final String fieldName, 
                                   final boolean rangeMode) {
@@ -862,19 +854,11 @@ public class SimpleFacetsTest extends SolrTestCaseJ4 {
   public void testTrieDateFacetsWithIncludeOption() {
     helpTestDateFacetsWithIncludeOption("a_tdt", false);
   }
-  @Test
-  public void testDateFacetsWithIncludeOption() {
-    helpTestDateFacetsWithIncludeOption("a_pdt", false);
-  }
 
   @Test
   public void testTrieDateRangeFacetsWithIncludeOption() {
     helpTestDateFacetsWithIncludeOption("a_tdt", true);
   }
-  @Test
-  public void testDateRangeFacetsWithIncludeOption() {
-    helpTestDateFacetsWithIncludeOption("a_pdt", true);
-  }
 
   /** similar to helpTestDateFacets, but for differnet fields with test data 
       exactly on on boundary marks */
@@ -1188,10 +1172,8 @@ public class SimpleFacetsTest extends SolrTestCaseJ4 {
 
   @Test
   public void testDateFacetsWithTz() {
-    for (String field : new String[] { "a_tdt", "a_pdt"}) {
-      for (boolean rangeType : new boolean[] { true, false }) {
-        helpTestDateFacetsWithTz(field, rangeType);
-      }
+    for (boolean rangeType : new boolean[] { true, false }) {
+      helpTestDateFacetsWithTz("a_tdt", rangeType);
     }
   }
 
@@ -1288,23 +1270,11 @@ public class SimpleFacetsTest extends SolrTestCaseJ4 {
   public void testNumericRangeFacetsTrieDouble() {
     helpTestFractionalNumberRangeFacets("range_facet_d");
   }
-  @Test
-  public void testNumericRangeFacetsSortableFloat() {
-    helpTestFractionalNumberRangeFacets("range_facet_sf");
-  }
-  @Test
-  public void testNumericRangeFacetsSortableDouble() {
-    helpTestFractionalNumberRangeFacets("range_facet_sd");
-  }
 
   @Test
   public void testNumericRangeFacetsOverflowTrieDouble() {
     helpTestNumericRangeFacetsDoubleOverflow("range_facet_d");
   }
-  @Test
-  public void testNumericRangeFacetsOverflowSortableDouble() {
-    helpTestNumericRangeFacetsDoubleOverflow("range_facet_sd");
-  }
 
   private void helpTestNumericRangeFacetsDoubleOverflow(final String fieldName) {
     final String f = fieldName;
@@ -1548,24 +1518,11 @@ public class SimpleFacetsTest extends SolrTestCaseJ4 {
   public void testNumericRangeFacetsTrieLong() {
     helpTestWholeNumberRangeFacets("range_facet_l");
   }
-  @Test
-  public void testNumericRangeFacetsSortableInt() {
-    helpTestWholeNumberRangeFacets("range_facet_si");
-  }
-  @Test
-  public void testNumericRangeFacetsSortableLong() {
-    helpTestWholeNumberRangeFacets("range_facet_sl");
-  }
-
 
   @Test
   public void testNumericRangeFacetsOverflowTrieLong() {
     helpTestNumericRangeFacetsLongOverflow("range_facet_l");
   }
-  @Test
-  public void testNumericRangeFacetsOverflowSortableLong() {
-    helpTestNumericRangeFacetsLongOverflow("range_facet_sl");
-  }
 
   private void helpTestNumericRangeFacetsLongOverflow(final String fieldName) {
     final String f = fieldName;
@@ -2132,9 +2089,7 @@ public class SimpleFacetsTest extends SolrTestCaseJ4 {
    */
   public void testRangeFacetInfiniteLoopDetection() {
 
-    for (String field : new String[] {"foo_f", "foo_sf", 
-                                      "foo_d", "foo_sd",
-                                      "foo_i", "foo_si"}) {
+    for (String field : new String[] {"foo_f", "foo_d", "foo_i"}) {
       assertQEx("no zero gap error: " + field,
                 req("q", "*:*",
                     "facet", "true",
@@ -2144,8 +2099,8 @@ public class SimpleFacetsTest extends SolrTestCaseJ4 {
                     "facet.range.end", "100"),
                 400);
     }
-    for (String field : new String[] {"foo_pdt", "foo_dt"}) {
-      for (String type : new String[] {"date", "range"}) {
+    String field = "foo_dt";
+    for (String type : new String[]{"date", "range"}) {
       assertQEx("no zero gap error for facet." + type + ": " + field,
                 req("q", "*:*",
                     "facet", "true",
@@ -2154,31 +2109,26 @@ public class SimpleFacetsTest extends SolrTestCaseJ4 {
                     "facet."+type+".gap", "+0DAYS",
                     "facet."+type+".end", "NOW+10DAY"),
                 400);
-      }
-    }
-    
-    for (String field : new String[] {"foo_f", "foo_sf"}) {
-      assertQEx("no float underflow error: " + field,
-                req("q", "*:*",
-                    "facet", "true",
-                    "facet.range", field,
-                    "facet.range.start", "100000000000",
-                    "facet.range.end", "100000086200",
-                    "facet.range.gap", "2160"),
-                400);
     }
-
-    for (String field : new String[] {"foo_d", "foo_sd"}) {
-      assertQEx("no double underflow error: " + field,
-                req("q", "*:*",
-                    "facet", "true",
-                    "facet.range", field,
-                    "facet.range.start", "9900000000000",
-                    "facet.range.end", "9900000086200",
-                    "facet.range.gap", "0.0003"),
-                400);
-    }
-    
+    field = "foo_f";
+    assertQEx("no float underflow error: " + field,
+              req("q", "*:*",
+                  "facet", "true",
+                  "facet.range", field,
+                  "facet.range.start", "100000000000",
+                  "facet.range.end", "100000086200",
+                  "facet.range.gap", "2160"),
+              400);
+
+    field = "foo_d";
+    assertQEx("no double underflow error: " + field,
+              req("q", "*:*",
+                  "facet", "true",
+                  "facet.range", field,
+                  "facet.range.start", "9900000000000",
+                  "facet.range.end", "9900000086200",
+                  "facet.range.gap", "0.0003"),
+              400);
   }
 
 }
diff --git a/solr/core/src/test/org/apache/solr/schema/BadIndexSchemaTest.java b/solr/core/src/test/org/apache/solr/schema/BadIndexSchemaTest.java
index d5d67e6..7c782b1 100644
--- a/solr/core/src/test/org/apache/solr/schema/BadIndexSchemaTest.java
+++ b/solr/core/src/test/org/apache/solr/schema/BadIndexSchemaTest.java
@@ -56,7 +56,7 @@ public class BadIndexSchemaTest extends AbstractBadConfigTestBase {
 
   public void testBadExternalFileField() throws Exception {
     doTest("bad-schema-external-filefield.xml",
-           "Only float and pfloat");
+           "Only float (TrieFloatField) is currently supported as external field type.");
   }
 
   public void testUniqueKeyRules() throws Exception {
diff --git a/solr/core/src/test/org/apache/solr/schema/CopyFieldTest.java b/solr/core/src/test/org/apache/solr/schema/CopyFieldTest.java
index 3b09d82..780cd64 100644
--- a/solr/core/src/test/org/apache/solr/schema/CopyFieldTest.java
+++ b/solr/core/src/test/org/apache/solr/schema/CopyFieldTest.java
@@ -186,7 +186,7 @@ public class CopyFieldTest extends SolrTestCaseJ4 {
     assertTrue("'" + dest_sub_no_ast_s + "' should match dynamic field '*_s', but instead matches '" + dynamicPattern2 + "'",
                dynamicPattern2.equals("*_s"));
     
-    assertU(adoc("id", "A5", "sku1", "10-1839ACX-93", "sku2", "AAM46"));
+    assertU(adoc("id", "5", "sku1", "10-1839ACX-93", "sku2", "AAM46"));
     assertU(commit());
 
     Map<String,String> args = new HashMap<>();
@@ -195,7 +195,7 @@ public class CopyFieldTest extends SolrTestCaseJ4 {
     SolrQueryRequest req = new LocalSolrQueryRequest( core, new MapSolrParams( args) );
     assertQ("sku2 copied to text", req
         ,"//*[@numFound='1']"
-        ,"//result/doc[1]/str[@name='id'][.='A5']"
+        ,"//result/doc[1]/int[@name='id'][.='5']"
     );
 
     args = new HashMap<>();
@@ -204,7 +204,7 @@ public class CopyFieldTest extends SolrTestCaseJ4 {
     req = new LocalSolrQueryRequest( core, new MapSolrParams( args) );
     assertQ("sku1 copied to dynamic dest *_s", req
         ,"//*[@numFound='1']"
-        ,"//result/doc[1]/str[@name='id'][.='A5']"
+        ,"//result/doc[1]/int[@name='id'][.='5']"
         ,"//result/doc[1]/arr[@name='sku1']/str[.='10-1839ACX-93']"
     );
 
@@ -234,7 +234,7 @@ public class CopyFieldTest extends SolrTestCaseJ4 {
 
     assertTrue("schema should contain dynamic field '*_s'", schema.getDynamicPattern("*_s").equals("*_s"));
 
-    assertU(adoc("id", "A5", "sku1", "10-1839ACX-93", "testing123_s", "AAM46"));
+    assertU(adoc("id", "5", "sku1", "10-1839ACX-93", "testing123_s", "AAM46"));
     assertU(commit());
 
     Map<String,String> args = new HashMap<>();
@@ -243,7 +243,7 @@ public class CopyFieldTest extends SolrTestCaseJ4 {
     SolrQueryRequest req = new LocalSolrQueryRequest( core, new MapSolrParams( args) );
     assertQ("sku2 copied to text", req
         ,"//*[@numFound='1']"
-        ,"//result/doc[1]/str[@name='id'][.='A5']"
+        ,"//result/doc[1]/int[@name='id'][.='5']"
     );
   }
 
@@ -253,12 +253,12 @@ public class CopyFieldTest extends SolrTestCaseJ4 {
     assertNull("'*' should not be (or match) a dynamic field", 
                schema.getDynamicPattern("*"));
     
-    assertU(adoc("id", "A5", "sku1", "10-1839ACX-93", "testing123_s", "AAM46"));
+    assertU(adoc("id", "5", "sku1", "10-1839ACX-93", "testing123_s", "AAM46"));
     assertU(commit());
-    for (String q : new String[] {"A5", "10-1839ACX-93", "AAM46" }) {
+    for (String q : new String[] {"5", "10-1839ACX-93", "AAM46" }) {
       assertQ(req("q","catchall_t:" + q)
               ,"//*[@numFound='1']"
-              ,"//result/doc[1]/str[@name='id'][.='A5']");
+              ,"//result/doc[1]/int[@name='id'][.='5']");
     }
   }
 }
diff --git a/solr/core/src/test/org/apache/solr/schema/DateFieldTest.java b/solr/core/src/test/org/apache/solr/schema/DateFieldTest.java
index 4f8a534..a5da2b4 100644
--- a/solr/core/src/test/org/apache/solr/schema/DateFieldTest.java
+++ b/solr/core/src/test/org/apache/solr/schema/DateFieldTest.java
@@ -17,66 +17,79 @@
 
 package org.apache.solr.schema;
 
-import org.apache.lucene.document.Field;
-import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.index.StorableField;
-import org.apache.lucene.util.LuceneTestCase;
+import org.apache.solr.SolrTestCaseJ4;
+import org.apache.solr.core.SolrConfig;
+import org.apache.solr.core.SolrResourceLoader;
 import org.apache.solr.util.DateMathParser;
 
+import org.junit.BeforeClass;
 import org.junit.Ignore;
 
+import java.io.File;
+import java.text.ParseException;
+import java.util.Collections;
 import java.util.Date;
 import java.util.TimeZone;
 import java.util.Locale;
 
-public class DateFieldTest extends LuceneTestCase {
+public class DateFieldTest extends SolrTestCaseJ4 {
   public static TimeZone UTC = TimeZone.getTimeZone("UTC");
-  protected DateField f = null;
-  protected DateMathParser p = new DateMathParser(UTC, Locale.ROOT);
+  private final String testInstanceDir = TEST_HOME() + File.separator + "collection1";
+  private final String testConfHome = testInstanceDir + File.separator + "conf"+ File.separator;
+  private TrieDateField f = null;
+  private DateMathParser p = new DateMathParser(UTC, Locale.ROOT);
 
   @Override
   public void setUp()  throws Exception {
     super.setUp();
-    f = new DateField();
+    // set some system properties for use by tests
+    System.setProperty("solr.test.sys.prop1", "propone");
+    System.setProperty("solr.test.sys.prop2", "proptwo");
+    SolrConfig config = new SolrConfig
+        (new SolrResourceLoader(testInstanceDir), testConfHome + "solrconfig.xml", null);
+    IndexSchema schema = IndexSchemaFactory.buildIndexSchema(testConfHome + "schema.xml", config);
+    f = new TrieDateField();
+    f.init(schema, Collections.<String,String>emptyMap());
   }
 
-  public void assertToI(String expected, String input) {
-    assertEquals("Input: " + input, expected, f.toInternal(input));
+  public void assertFormatParsed(String expected, String input) throws ParseException {
+    assertEquals("Input: " + input, expected, f.formatDate(f.parseMath(new Date(), input)));
   }
   
-  public void assertToI(String expected, long input) {
-    assertEquals("Input: " + input, expected, f.toInternal(new Date(input)));
+  public void assertFormatDate(String expected, long input) {
+    assertEquals("Input: " + input, expected, f.formatDate(new Date(input)));
   }
 
   public void testToInternal() throws Exception {
-    assertToI("1995-12-31T23:59:59.999", "1995-12-31T23:59:59.999666Z");
-    assertToI("1995-12-31T23:59:59.999", "1995-12-31T23:59:59.999Z");
-    assertToI("1995-12-31T23:59:59.99",  "1995-12-31T23:59:59.99Z");
-    assertToI("1995-12-31T23:59:59.9",   "1995-12-31T23:59:59.9Z");
-    assertToI("1995-12-31T23:59:59",     "1995-12-31T23:59:59Z");
+    assertFormatParsed("1995-12-31T23:59:59.999", "1995-12-31T23:59:59.999666Z");
+    assertFormatParsed("1995-12-31T23:59:59.999", "1995-12-31T23:59:59.999Z");
+    assertFormatParsed("1995-12-31T23:59:59.99", "1995-12-31T23:59:59.99Z");
+    assertFormatParsed("1995-12-31T23:59:59.9", "1995-12-31T23:59:59.9Z");
+    assertFormatParsed("1995-12-31T23:59:59", "1995-12-31T23:59:59Z");
 
     // here the input isn't in the canonical form, but we should be forgiving
-    assertToI("1995-12-31T23:59:59.99",  "1995-12-31T23:59:59.990Z");
-    assertToI("1995-12-31T23:59:59.9",   "1995-12-31T23:59:59.900Z");
-    assertToI("1995-12-31T23:59:59.9",   "1995-12-31T23:59:59.90Z");
-    assertToI("1995-12-31T23:59:59",     "1995-12-31T23:59:59.000Z");
-    assertToI("1995-12-31T23:59:59",     "1995-12-31T23:59:59.00Z");
-    assertToI("1995-12-31T23:59:59",     "1995-12-31T23:59:59.0Z");
+    assertFormatParsed("1995-12-31T23:59:59.99", "1995-12-31T23:59:59.990Z");
+    assertFormatParsed("1995-12-31T23:59:59.9", "1995-12-31T23:59:59.900Z");
+    assertFormatParsed("1995-12-31T23:59:59.9", "1995-12-31T23:59:59.90Z");
+    assertFormatParsed("1995-12-31T23:59:59", "1995-12-31T23:59:59.000Z");
+    assertFormatParsed("1995-12-31T23:59:59", "1995-12-31T23:59:59.00Z");
+    assertFormatParsed("1995-12-31T23:59:59", "1995-12-31T23:59:59.0Z");
 
     // kind of kludgy, but we have other tests for the actual date math
-    assertToI(f.toInternal(p.parseMath("/DAY")), "NOW/DAY");
+    assertFormatParsed(f.formatDate(p.parseMath("/DAY")), "NOW/DAY");
 
     // as of Solr 1.3
-    assertToI("1995-12-31T00:00:00", "1995-12-31T23:59:59Z/DAY");
-    assertToI("1995-12-31T00:00:00", "1995-12-31T23:59:59.123Z/DAY");
-    assertToI("1995-12-31T00:00:00", "1995-12-31T23:59:59.123999Z/DAY");
+    assertFormatParsed("1995-12-31T00:00:00", "1995-12-31T23:59:59Z/DAY");
+    assertFormatParsed("1995-12-31T00:00:00", "1995-12-31T23:59:59.123Z/DAY");
+    assertFormatParsed("1995-12-31T00:00:00", "1995-12-31T23:59:59.123999Z/DAY");
   }
   
   public void testToInternalObj() throws Exception {
-    assertToI("1995-12-31T23:59:59.999", 820454399999l);
-    assertToI("1995-12-31T23:59:59.99",  820454399990l);
-    assertToI("1995-12-31T23:59:59.9",   820454399900l);
-    assertToI("1995-12-31T23:59:59",     820454399000l);
+    assertFormatDate("1995-12-31T23:59:59.999", 820454399999l);
+    assertFormatDate("1995-12-31T23:59:59.99", 820454399990l);
+    assertFormatDate("1995-12-31T23:59:59.9", 820454399900l);
+    assertFormatDate("1995-12-31T23:59:59", 820454399000l);
   }
     
   public void assertParseMath(long expected, String input) {
@@ -98,42 +111,6 @@ public class DateFieldTest extends LuceneTestCase {
     assertParseMath(194918400000l, "1976-03-06T03:06:00.000Z/DAY");
   }
 
-  public void assertToObject(long expected, String input) throws Exception {
-    assertEquals("Input: "+input, expected, f.toObject(input).getTime());
-  }
-  
-  // as of Solr1.3
-  public void testToObject() throws Exception {
-
-    // just after epoch
-    assertToObject(  5L, "1970-01-01T00:00:00.005Z");
-    assertToObject(  0L, "1970-01-01T00:00:00Z");
-    assertToObject(370L, "1970-01-01T00:00:00.37Z");
-    assertToObject(900L, "1970-01-01T00:00:00.9Z");
-
-    // well after epoch
-    assertToObject(820454399987l, "1995-12-31T23:59:59.987666Z");
-    assertToObject(820454399987l, "1995-12-31T23:59:59.987Z");
-    assertToObject(820454399980l, "1995-12-31T23:59:59.98Z");
-    assertToObject(820454399900l, "1995-12-31T23:59:59.9Z");
-    assertToObject(820454399000l, "1995-12-31T23:59:59Z");
-
-    // waaaay after epoch
-    assertToObject(327434918399005L, "12345-12-31T23:59:59.005Z");
-    assertToObject(327434918399000L, "12345-12-31T23:59:59Z");
-    assertToObject(327434918399370L, "12345-12-31T23:59:59.37Z");
-    assertToObject(327434918399900L, "12345-12-31T23:59:59.9Z");
-
-    // well before epoch
-    assertToObject(-52700112001000L, "0299-12-31T23:59:59Z");
-    assertToObject(-52700112000877L, "0299-12-31T23:59:59.123Z");
-    assertToObject(-52700112000910L, "0299-12-31T23:59:59.09Z");
-
-    // flexible in parsing years less then 4 digits
-    assertToObject(-52700112001000L,  "299-12-31T23:59:59Z");
-
-  }
-  
   public void testFormatter() {
     // just after epoch
     assertFormat("1970-01-01T00:00:00.005", 5L);
@@ -198,8 +175,8 @@ public class DateFieldTest extends LuceneTestCase {
   }
 
   protected void assertRoundTrip(String canonicalDate) throws Exception {
-    Date d = DateField.parseDate(canonicalDate);
-    String result = DateField.formatExternal(d);
+    Date d = TrieDateField.parseDate(canonicalDate);
+    String result = TrieDateField.formatExternal(d);
     assertEquals("d:" + d.getTime(), canonicalDate, result);
 
   }
diff --git a/solr/core/src/test/org/apache/solr/schema/PrimitiveFieldTypeTest.java b/solr/core/src/test/org/apache/solr/schema/PrimitiveFieldTypeTest.java
index 6581e4f..5c8aadd 100644
--- a/solr/core/src/test/org/apache/solr/schema/PrimitiveFieldTypeTest.java
+++ b/solr/core/src/test/org/apache/solr/schema/PrimitiveFieldTypeTest.java
@@ -60,14 +60,9 @@ public class PrimitiveFieldTypeTest extends SolrTestCaseJ4 {
   public void testDefaultOmitNorms() throws Exception {
     BinaryField bin;
     TextField t;
-    DateField dt;
+    TrieDateField dt;
     StrField s;
-    IntField i;
     TrieIntField ti;
-    SortableIntField si;
-    LongField l;
-    FloatField f;
-    DoubleField d;
     BoolField b;
     
     
@@ -76,7 +71,7 @@ public class PrimitiveFieldTypeTest extends SolrTestCaseJ4 {
     // ***********************
     schema = IndexSchemaFactory.buildIndexSchema(testConfHome + "schema12.xml", config);
     
-    dt = new DateField();
+    dt = new TrieDateField();
     dt.init(schema, initMap);
     assertFalse(dt.hasProperty(FieldType.OMIT_NORMS));
 
@@ -84,34 +79,10 @@ public class PrimitiveFieldTypeTest extends SolrTestCaseJ4 {
     s.init(schema, initMap);
     assertFalse(s.hasProperty(FieldType.OMIT_NORMS));
 
-    i = new IntField();
-    i.init(schema, initMap);
-    assertFalse(i.hasProperty(FieldType.OMIT_NORMS));
-
     ti = new TrieIntField();
     ti.init(schema, initMap);
     assertFalse(ti.hasProperty(FieldType.OMIT_NORMS));
 
-    si = new SortableIntField();
-    si.init(schema, initMap);
-    assertFalse(si.hasProperty(FieldType.OMIT_NORMS));
-
-    l = new LongField();
-    l.init(schema, initMap);
-    assertFalse(l.hasProperty(FieldType.OMIT_NORMS));
-
-    f = new FloatField();
-    f.init(schema, initMap);
-    assertFalse(f.hasProperty(FieldType.OMIT_NORMS));
-
-    d = new DoubleField();
-    d.init(schema, initMap);
-    assertFalse(d.hasProperty(FieldType.OMIT_NORMS));
-
-    dt = new DateField();
-    dt.init(schema, initMap);
-    assertFalse(dt.hasProperty(FieldType.OMIT_NORMS));
-
     b = new BoolField();
     b.init(schema, initMap);
     assertFalse(b.hasProperty(FieldType.OMIT_NORMS));
@@ -130,7 +101,7 @@ public class PrimitiveFieldTypeTest extends SolrTestCaseJ4 {
     // ***********************
     schema = IndexSchemaFactory.buildIndexSchema(testConfHome + "schema15.xml", config);
 
-    dt = new DateField();
+    dt = new TrieDateField();
     dt.init(schema, initMap);
     assertTrue(dt.hasProperty(FieldType.OMIT_NORMS));
 
@@ -138,34 +109,10 @@ public class PrimitiveFieldTypeTest extends SolrTestCaseJ4 {
     s.init(schema, initMap);
     assertTrue(s.hasProperty(FieldType.OMIT_NORMS));
 
-    i = new IntField();
-    i.init(schema, initMap);
-    assertTrue(i.hasProperty(FieldType.OMIT_NORMS));
-
     ti = new TrieIntField();
     ti.init(schema, initMap);
     assertTrue(ti.hasProperty(FieldType.OMIT_NORMS));
 
-    si = new SortableIntField();
-    si.init(schema, initMap);
-    assertTrue(si.hasProperty(FieldType.OMIT_NORMS));
-
-    l = new LongField();
-    l.init(schema, initMap);
-    assertTrue(l.hasProperty(FieldType.OMIT_NORMS));
-
-    f = new FloatField();
-    f.init(schema, initMap);
-    assertTrue(f.hasProperty(FieldType.OMIT_NORMS));
-
-    d = new DoubleField();
-    d.init(schema, initMap);
-    assertTrue(d.hasProperty(FieldType.OMIT_NORMS));
-
-    dt = new DateField();
-    dt.init(schema, initMap);
-    assertTrue(dt.hasProperty(FieldType.OMIT_NORMS));
-
     b = new BoolField();
     b.init(schema, initMap);
     assertTrue(b.hasProperty(FieldType.OMIT_NORMS));
diff --git a/solr/core/src/test/org/apache/solr/search/CursorMarkTest.java b/solr/core/src/test/org/apache/solr/search/CursorMarkTest.java
index 61799eb..7818140 100644
--- a/solr/core/src/test/org/apache/solr/search/CursorMarkTest.java
+++ b/solr/core/src/test/org/apache/solr/search/CursorMarkTest.java
@@ -24,9 +24,9 @@ import org.apache.lucene.util.TestUtil;
 import org.apache.lucene.util.BytesRef;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.SolrException.ErrorCode;
-import org.apache.solr.schema.DateField;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.schema.SchemaField;
+import org.apache.solr.schema.TrieDateField;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.CursorPagingTest;
@@ -232,54 +232,16 @@ public class CursorMarkTest extends SolrTestCaseJ4 {
           byte[] randBytes = new byte[TestUtil.nextInt(random(), 1, 50)];
           random().nextBytes(randBytes);
           val = new BytesRef(randBytes);
-        } else if (fieldName.startsWith("bcd")) {
-          if (fieldName.startsWith("bcd_long")) {           // BCDLongField
-            val = Long.toString(random().nextLong());
-            val = sf.getType().toInternal((String)val);
-            val = sf.getType().unmarshalSortValue(val);
-          } else {                                          // BCDIntField & BCDStrField
-            val = Integer.toString(random().nextInt());
-            val = sf.getType().toInternal((String)val);
-            val = sf.getType().unmarshalSortValue(val);
-          }
         } else if (fieldName.contains("int")) {
           val = random().nextInt();                         // TrieIntField
-          if (fieldName.startsWith("legacy")) {             // IntField
-            val = Integer.toString((Integer)val);
-            if (fieldName.startsWith("legacy_sortable")) {  // SortableIntField
-              val = sf.getType().unmarshalSortValue(val);
-            }
-          }
         } else if (fieldName.contains("long")) {
           val = random().nextLong();                        // TrieLongField
-          if (fieldName.startsWith("legacy")) {             // LongField
-            val = Long.toString((Long)val);
-            if (fieldName.startsWith("legacy_sortable")) {  // SortableLongField
-              val = sf.getType().unmarshalSortValue(val);
-            }
-          }
         } else if (fieldName.contains("float")) {
           val = random().nextFloat() * random().nextInt();  // TrieFloatField
-          if (fieldName.startsWith("legacy")) {             // FloatField
-            val = Float.toString((Float)val);
-            if (fieldName.startsWith("legacy_sortable")) {  // SortableFloatField
-              val = sf.getType().unmarshalSortValue(val);
-            }
-          }
         } else if (fieldName.contains("double")) {
           val = random().nextDouble() * random().nextInt(); // TrieDoubleField
-          if (fieldName.startsWith("legacy")) {             // DoubleField
-            val = Double.toString((Double)val);
-            if (fieldName.startsWith("legacy_sortable")) {  // SortableDoubleField
-              val = sf.getType().unmarshalSortValue(val);
-            }
-          }
         } else if (fieldName.contains("date")) {
           val = random().nextLong();                        // TrieDateField
-          if (fieldName.startsWith("legacy_date")) {        // DateField
-            val = ((DateField)sf.getType()).toInternal(new Date((Long)val));
-            val = sf.getType().unmarshalSortValue(val);
-          }
         } else if (fieldName.startsWith("currency")) {
           val = random().nextDouble();
         } else if (fieldName.startsWith("uuid")) {
diff --git a/solr/core/src/test/org/apache/solr/search/TestOverriddenPrefixQueryForCustomFieldType.java b/solr/core/src/test/org/apache/solr/search/TestOverriddenPrefixQueryForCustomFieldType.java
index 68249ac..3952c4f 100644
--- a/solr/core/src/test/org/apache/solr/search/TestOverriddenPrefixQueryForCustomFieldType.java
+++ b/solr/core/src/test/org/apache/solr/search/TestOverriddenPrefixQueryForCustomFieldType.java
@@ -90,8 +90,6 @@ public class TestOverriddenPrefixQueryForCustomFieldType extends SolrTestCaseJ4
     assertQ(req("q", "swap_foo_bar_in_prefix_query:bar*"), "//*[@numFound='" + counts[0] + "']");
     assertQ(req("q", "swap_foo_bar_in_prefix_query:spam*"), "//*[@numFound='" + otherCounts + "']");
 
-    assertQ(req("q", "intfield:2*"), "//*[@numFound='11']"); //2 and the 10 in twenties
-
     //Custom field should query for the range [2,MAX_INT)
     assertQ(req("q", "int_prefix_as_range:2*"),"//*[@numFound='98']");
 
diff --git a/solr/core/src/test/org/apache/solr/search/TestRangeQuery.java b/solr/core/src/test/org/apache/solr/search/TestRangeQuery.java
index ad2dcad..8d70f03 100644
--- a/solr/core/src/test/org/apache/solr/search/TestRangeQuery.java
+++ b/solr/core/src/test/org/apache/solr/search/TestRangeQuery.java
@@ -113,10 +113,6 @@ public class TestRangeQuery extends SolrTestCaseJ4 {
     frange_fields.put("foo_td", doubles);
     frange_fields.put("foo_tdt", dates);
 
-    frange_fields.put("foo_pi", ints);
-    frange_fields.put("foo_pl", longs);
-    frange_fields.put("foo_pd", doubles);
-
     frange_fields.put("foo_s", strings);
     frange_fields.put("foo_dt", dates);
 
@@ -202,9 +198,8 @@ public class TestRangeQuery extends SolrTestCaseJ4 {
   @Test
   public void testRandomRangeQueries() throws Exception {
     String handler="";
-    final String[] fields = {"foo_s","foo_i","foo_l","foo_f","foo_d"  // SortableIntField, etc
-            ,"foo_pi","foo_pl","foo_pf","foo_pd"                      // plain int  IntField, etc
-            ,"foo_ti","foo_tl","foo_tf","foo_td"                      // trie numer fields
+    final String[] fields = {"foo_s","foo_i","foo_l","foo_f","foo_d"
+            ,"foo_ti","foo_tl","foo_tf","foo_td"
     };
     final int l=5;
     final int u=25;
@@ -226,8 +221,7 @@ public class TestRangeQuery extends SolrTestCaseJ4 {
     };
     
     // fields that a value source range query should work on
-    String[] frange_fields = {"foo_i","foo_l","foo_f","foo_d",
-            "foo_pi","foo_pl","foo_pf","foo_pd"};
+    String[] frange_fields = {"foo_i","foo_l","foo_f","foo_d"};
 
     for (int i=0; i<1000; i++) {
       int lower = l + r.nextInt(u-l+10)-5;
diff --git a/solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery.java b/solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery.java
index 3952fb0..d5fe2bb 100644
--- a/solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery.java
+++ b/solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery.java
@@ -120,7 +120,7 @@ public class TestFunctionQuery extends SolrTestCaseJ4 {
     List<String> tests = new ArrayList<>();
 
     // Construct xpaths like the following:
-    // "//doc[./float[@name='foo_pf']='10.0' and ./float[@name='score']='10.0']"
+    // "//doc[./float[@name='foo_f']='10.0' and ./float[@name='score']='10.0']"
 
     for (int i=0; i<results.length; i+=2) {
       String xpath = "//doc[./float[@name='" + "id" + "']='"
@@ -208,7 +208,6 @@ public class TestFunctionQuery extends SolrTestCaseJ4 {
 
   @Test
   public void testFunctions() {
-    doTest("foo_pf");  // a plain float field
     doTest("foo_f");  // a sortable float field
     doTest("foo_tf");  // a trie float field
   }
@@ -742,7 +741,6 @@ public class TestFunctionQuery extends SolrTestCaseJ4 {
     
     for (String suffix : new String[] {"s", "b", "dt", "tdt",
                                        "i", "l", "f", "d", 
-                                       "pi", "pl", "pf", "pd",
                                        "ti", "tl", "tf", "td"    }) {
       final String field = "no__vals____" + suffix;
       assertQ(req("q","id:1",
diff --git a/solr/core/src/test/org/apache/solr/update/processor/FieldMutatingUpdateProcessorTest.java b/solr/core/src/test/org/apache/solr/update/processor/FieldMutatingUpdateProcessorTest.java
index d731dc9..5ac91e4 100644
--- a/solr/core/src/test/org/apache/solr/update/processor/FieldMutatingUpdateProcessorTest.java
+++ b/solr/core/src/test/org/apache/solr/update/processor/FieldMutatingUpdateProcessorTest.java
@@ -196,16 +196,13 @@ public class FieldMutatingUpdateProcessorTest extends UpdateProcessorTestBase {
                    doc(f("id", "1111"),
                        f("foo_t", " string1 "),
                        f("foo_s", " string2 "),
-                       f("bar_dt", " string3 "),
-                       f("bar_pdt", " string4 ")));
+                       f("bar_dt", " string3 ")));
 
     assertNotNull(d);
 
     assertEquals(" string1 ", d.getFieldValue("foo_t"));
     assertEquals("string2", d.getFieldValue("foo_s"));
     assertEquals("string3", d.getFieldValue("bar_dt"));
-    assertEquals("string4", d.getFieldValue("bar_pdt"));
-
   }
 
   public void testTrimMultipleRules() throws Exception {
@@ -214,16 +211,13 @@ public class FieldMutatingUpdateProcessorTest extends UpdateProcessorTestBase {
                    doc(f("id", "1111"),
                        f("foo_t", " string1 "),
                        f("foo_s", " string2 "),
-                       f("bar_dt", " string3 "),
-                       f("foo_pdt", " string4 ")));
+                       f("bar_dt", " string3 ")));
 
     assertNotNull(d);
 
     assertEquals(" string1 ", d.getFieldValue("foo_t"));
     assertEquals("string2", d.getFieldValue("foo_s"));
     assertEquals(" string3 ", d.getFieldValue("bar_dt"));
-    assertEquals("string4", d.getFieldValue("foo_pdt"));
-
   }
 
   public void testTrimExclusions() throws Exception {
@@ -232,24 +226,20 @@ public class FieldMutatingUpdateProcessorTest extends UpdateProcessorTestBase {
                    doc(f("id", "1111"),
                        f("foo_t", " string1 "),
                        f("foo_s", " string2 "),
-                       f("bar_dt", " string3 "),
-                       f("foo_pdt", " string4 ")));
+                       f("bar_dt", " string3 ")));
 
     assertNotNull(d);
 
     assertEquals(" string1 ", d.getFieldValue("foo_t"));
     assertEquals("string2", d.getFieldValue("foo_s"));
     assertEquals("string3", d.getFieldValue("bar_dt"));
-    assertEquals("string4", d.getFieldValue("foo_pdt"));
 
     d = processAdd("trim-many", 
                    doc(f("id", "1111"),
                        f("foo_t", " string1 "),
                        f("foo_s", " string2 "),
                        f("bar_dt", " string3 "),
-                       f("bar_HOSS_s", " string4 "),
-                       f("foo_pdt", " string5 "),
-                       f("foo_HOSS_pdt", " string6 ")));
+                       f("bar_HOSS_s", " string4 ")));
 
     assertNotNull(d);
 
@@ -257,17 +247,13 @@ public class FieldMutatingUpdateProcessorTest extends UpdateProcessorTestBase {
     assertEquals("string2", d.getFieldValue("foo_s"));
     assertEquals("string3", d.getFieldValue("bar_dt"));
     assertEquals(" string4 ", d.getFieldValue("bar_HOSS_s"));
-    assertEquals("string5", d.getFieldValue("foo_pdt"));
-    assertEquals(" string6 ", d.getFieldValue("foo_HOSS_pdt"));
 
     d = processAdd("trim-few", 
                    doc(f("id", "1111"),
                        f("foo_t", " string1 "),
                        f("foo_s", " string2 "),
                        f("bar_dt", " string3 "),
-                       f("bar_HOSS_s", " string4 "),
-                       f("foo_pdt", " string5 "),
-                       f("foo_HOSS_pdt", " string6 ")));
+                       f("bar_HOSS_s", " string4 ")));
 
     assertNotNull(d);
 
@@ -275,17 +261,13 @@ public class FieldMutatingUpdateProcessorTest extends UpdateProcessorTestBase {
     assertEquals("string2", d.getFieldValue("foo_s"));
     assertEquals(" string3 ", d.getFieldValue("bar_dt"));
     assertEquals(" string4 ", d.getFieldValue("bar_HOSS_s"));
-    assertEquals(" string5 ", d.getFieldValue("foo_pdt"));
-    assertEquals(" string6 ", d.getFieldValue("foo_HOSS_pdt"));
 
     d = processAdd("trim-some", 
                    doc(f("id", "1111"),
                        f("foo_t", " string1 "),
                        f("foo_s", " string2 "),
                        f("bar_dt", " string3 "),
-                       f("bar_HOSS_s", " string4 "),
-                       f("foo_pdt", " string5 "),
-                       f("foo_HOSS_pdt", " string6 ")));
+                       f("bar_HOSS_s", " string4 ")));
 
     assertNotNull(d);
 
@@ -293,8 +275,6 @@ public class FieldMutatingUpdateProcessorTest extends UpdateProcessorTestBase {
     assertEquals("string2", d.getFieldValue("foo_s"));
     assertEquals("string3", d.getFieldValue("bar_dt"));
     assertEquals("string4", d.getFieldValue("bar_HOSS_s"));
-    assertEquals("string5", d.getFieldValue("foo_pdt"));
-    assertEquals(" string6 ", d.getFieldValue("foo_HOSS_pdt"));
   }
 
   public void testRemoveBlanks() throws Exception {
diff --git a/solr/core/src/test/org/apache/solr/util/TestNumberUtils.java b/solr/core/src/test/org/apache/solr/util/TestNumberUtils.java
deleted file mode 100644
index 8e5f3f3..0000000
--- a/solr/core/src/test/org/apache/solr/util/TestNumberUtils.java
+++ /dev/null
@@ -1,266 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.util;
-
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.solr.util.NumberUtils;
-import org.apache.solr.util.BCDUtils;
-import org.junit.AfterClass;
-import org.junit.Assert;
-import org.junit.BeforeClass;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Random;
-
-public class TestNumberUtils extends LuceneTestCase {
-
-  static Random rng;
-
-  @BeforeClass
-  public static void beforeClass() {
-    rng = random();
-  }
-
-  @AfterClass
-  public static void cleanup() {
-    rng = null;
-  }
-
-  static int[] special = {0,10,100,1000,10000,Integer.MAX_VALUE, Integer.MIN_VALUE};
-  static int getSpecial() {
-    int i = rng.nextInt();
-    int j = rng.nextInt();
-    if ((i & 0x10) != 0) return j;
-    return special[(j&0x7fffffff) % special.length]* ((i & 0x20)==0?1:-1) + ((i&0x03)-1);
-  }
-
-  static long[] lspecial = {0,10,100,1000,10000,2,4,8,256,16384,32768,65536,
-                            Integer.MAX_VALUE, Integer.MIN_VALUE,
-                            Long.MAX_VALUE, Long.MIN_VALUE};
-  static long getLongSpecial() {
-    int i = rng.nextInt();
-    long j = rng.nextLong();
-    if ((i & 0x10) != 0) return j;
-    return lspecial[((int)j&0x7fffffff) % special.length]* ((i & 0x20)==0?1:-1) + ((i&0x03)-1);
-  }
-
-  static float[] fspecial = {0,1,2,4,8,256,16384,32768,65536,.1f,.25f
-     ,Float.NEGATIVE_INFINITY,Float.POSITIVE_INFINITY,Float.MIN_VALUE, Float.MAX_VALUE};
-  static float getFloatSpecial() {
-    int i = rng.nextInt();
-    int j = rng.nextInt();
-    float f = Float.intBitsToFloat(j);
-    if (f!=f) f=0; // get rid of NaN for comparison purposes
-    if ((i & 0x10) != 0) return f;
-    return fspecial[(j&0x7fffffff) % fspecial.length]* ((i & 0x20)==0?1:-1) + ((i&0x03)-1);
-  }
-
-  static double[] dspecial = {0,1,2,4,8,256,16384,32768,65536,.1,.25
-     ,Float.NEGATIVE_INFINITY,Float.POSITIVE_INFINITY,Float.MIN_VALUE, Float.MAX_VALUE
-     ,Double.NEGATIVE_INFINITY,Double.POSITIVE_INFINITY,Double.MIN_VALUE, Double.MAX_VALUE
-      };
-  static double getDoubleSpecial() {
-    int i = rng.nextInt();
-    long j = rng.nextLong();
-    double f = Double.longBitsToDouble(j);
-    if (f!=f) f=0; // get rid of NaN for comparison purposes
-    if ((i & 0x10) != 0) return f;
-    return dspecial[((int)j&0x7fffffff) % dspecial.length]* ((i & 0x20)==0?1:-1) + ((i&0x03)-1);
-  }
-
-  public static <T extends Comparable<T>> void test(T n1, T n2, Converter conv) {
-    String s1=n1.toString();
-    String s2=n2.toString();
-    String v1 = conv.toInternal(s1);
-    String v2 = conv.toInternal(s2);
-    String out1=conv.toExternal(v1);
-    String out2=conv.toExternal(v2);
-
-    Assert.assertEquals(conv + " :: n1 :: input!=output", s1, out1);
-    Assert.assertEquals(conv + " :: n2 :: input!=output", s2, out2);
-    
-    int c1 = n1.compareTo(n2);
-    int c2 = v1.compareTo(v2);
-
-    Assert.assertFalse( (c1==0 && !(c2==0)) );
-//    Assert.assertFalse( c1 < 0 && !(c2<0) );
-//    Assert.assertFalse( c1 > 0 && !(c2>0) );
-//    
-    //    if (c1==0 && !(c2==0) 
-//    || c1 < 0 && !(c2<0) 
-//    || c1 > 0 && !(c2>0)
-//    || !out1.equals(s1) || !out2.equals(s2))
-//    {
-//      Assert.fail("Comparison error:"+s1+","+s2 + " :: " + conv);
-//      System.out.print("v1=");
-//      for (int ii=0; ii<v1.length(); ii++) {
-//        System.out.print(" " + (int)v1.charAt(ii));
-//      }
-//      System.out.print("\nv2=");
-//      for (int ii=0; ii<v2.length(); ii++) {
-//        System.out.print(" " + (int)v2.charAt(ii));
-//      }
-//      System.out.println("\nout1='"+out1+"', out2='" + out2 + "'");
-//    }
-  }
-  
-  
-  public void testConverters()
-  {
-    int iter=1000;
-
-    // INTEGERS
-    List<Converter> converters = new ArrayList<>();
-    converters.add( new Int2Int() );
-    converters.add( new SortInt() );
-    converters.add( new Base10kS() );
-    converters.add( new Base100S() );
-    
-    for( Converter c : converters ) {
-      for (int i=0; i<iter; i++) {
-        test(getSpecial(), getSpecial(), c );
-      }
-    }
-
-    // LONG
-    converters.clear();
-    converters.add( new SortLong() );
-    converters.add( new Base10kS() );
-    converters.add( new Base100S() );
-    for( Converter c : converters ) {
-      for (int i=0; i<iter; i++) {
-        test(getLongSpecial(), getLongSpecial(), c );
-      }
-    }
-
-    // FLOAT
-    converters.clear();
-    converters.add( new Float2Float() );
-    converters.add( new SortFloat() );
-    for( Converter c : converters ) {
-      for (int i=0; i<iter; i++) {
-        test(getFloatSpecial(), getFloatSpecial(), c );
-      }
-    }
-
-    // DOUBLE
-    converters.clear();
-    converters.add( new SortDouble() );
-    for( Converter c : converters ) {
-      for (int i=0; i<iter; i++) {
-        test(getDoubleSpecial(), getDoubleSpecial(), c );
-      }
-    }
-  }
-}
-
-
-abstract class Converter {
-  abstract String toInternal(String val);
-  abstract String toExternal(String val);
-}
-
-class Int2Int extends Converter {
-  @Override
-  public String toInternal(String val) {
-    return Integer.toString(Integer.parseInt(val));
-  }
-  @Override
-  public String toExternal(String val) {
-    return Integer.toString(Integer.parseInt(val));
-  }
-}
-
-class SortInt extends Converter {
-  @Override
-  public String toInternal(String val) {
-    return NumberUtils.int2sortableStr(val);
-  }
-  @Override
-  public String toExternal(String val) {
-    return NumberUtils.SortableStr2int(val);
-  }
-}
-
-class SortLong extends Converter {
-  @Override
-  public String toInternal(String val) {
-    return NumberUtils.long2sortableStr(val);
-  }
-  @Override
-  public String toExternal(String val) {
-    return NumberUtils.SortableStr2long(val);
-  }
-}
-
-class Float2Float extends Converter {
-  @Override
-  public String toInternal(String val) {
-    return Float.toString(Float.parseFloat(val));
-  }
-  @Override
-  public String toExternal(String val) {
-    return Float.toString(Float.parseFloat(val));
-  }
-}
-
-class SortFloat extends Converter {
-  @Override
-  public String toInternal(String val) {
-    return NumberUtils.float2sortableStr(val);
-  }
-  @Override
-  public String toExternal(String val) {
-    return NumberUtils.SortableStr2floatStr(val);
-  }
-}
-
-class SortDouble extends Converter {
-  @Override
-  public String toInternal(String val) {
-    return NumberUtils.double2sortableStr(val);
-  }
-  @Override
-  public String toExternal(String val) {
-    return NumberUtils.SortableStr2doubleStr(val);
-  }
-}
-
-class Base100S extends Converter {
-  @Override
-  public String toInternal(String val) {
-    return BCDUtils.base10toBase100SortableInt(val);
-  }
-  @Override
-  public String toExternal(String val) {
-    return BCDUtils.base100SortableIntToBase10(val);
-  }
-}
-
-class Base10kS extends Converter {
-  @Override
-  public String toInternal(String val) {
-    return BCDUtils.base10toBase10kSortableInt(val);
-  }
-  @Override
-  public String toExternal(String val) {
-    return BCDUtils.base10kSortableIntToBase10(val);
-  }
-}
-
diff --git a/solr/example/example-schemaless/solr/collection1/conf/schema.xml b/solr/example/example-schemaless/solr/collection1/conf/schema.xml
index ecf5492..86b599c 100755
--- a/solr/example/example-schemaless/solr/collection1/conf/schema.xml
+++ b/solr/example/example-schemaless/solr/collection1/conf/schema.xml
@@ -150,7 +150,6 @@
     <dynamicField name="*_td" type="tdouble" indexed="true"  stored="true"/>
     <dynamicField name="*_tdt" type="tdate"  indexed="true"  stored="true"/>
 
-    <dynamicField name="*_pi"  type="pint"    indexed="true"  stored="true"/>
     <dynamicField name="*_c"   type="currency" indexed="true"  stored="true"/>
 
     <dynamicField name="ignored_*" type="ignored" multiValued="true"/>
@@ -315,7 +314,7 @@
                   ... 6 months and 3 days in the future from the start of
                       the current day
                       
-         Consult the DateField javadocs for more information.
+         Consult the TrieDateField javadocs for more information.
 
          Note: For faster range queries, consider the tdate type
       -->
@@ -330,21 +329,6 @@
     <!--Binary data type. The data should be sent/retrieved in as Base64 encoded Strings -->
     <fieldtype name="binary" class="solr.BinaryField"/>
 
-    <!--
-      Note:
-      These should only be used for compatibility with existing indexes (created with lucene or older Solr versions).
-      Use Trie based fields instead. As of Solr 3.5 and 4.x, Trie based fields support sortMissingFirst/Last
-      
-      Plain numeric field types that store and index the text
-      value verbatim (and hence don't correctly support range queries, since the
-      lexicographic ordering isn't equal to the numeric ordering)
-    -->
-    <fieldType name="pint" class="solr.IntField"/>
-    <fieldType name="plong" class="solr.LongField"/>
-    <fieldType name="pfloat" class="solr.FloatField"/>
-    <fieldType name="pdouble" class="solr.DoubleField"/>
-    <fieldType name="pdate" class="solr.DateField" sortMissingLast="true"/>
-
     <!-- The "RandomSortField" is not used to store or search any
          data.  You can declare fields of this type it in your schema
          to generate pseudo-random orderings of your docs for sorting 
diff --git a/solr/example/solr/collection1/conf/schema.xml b/solr/example/solr/collection1/conf/schema.xml
index 5504a0f..009eb40 100755
--- a/solr/example/solr/collection1/conf/schema.xml
+++ b/solr/example/solr/collection1/conf/schema.xml
@@ -228,7 +228,6 @@
    <dynamicField name="*_td" type="tdouble" indexed="true"  stored="true"/>
    <dynamicField name="*_tdt" type="tdate"  indexed="true"  stored="true"/>
 
-   <dynamicField name="*_pi"  type="pint"    indexed="true"  stored="true"/>
    <dynamicField name="*_c"   type="currency" indexed="true"  stored="true"/>
 
    <dynamicField name="ignored_*" type="ignored" multiValued="true"/>
@@ -380,7 +379,7 @@
                   ... 6 months and 3 days in the future from the start of
                       the current day
                       
-         Consult the DateField javadocs for more information.
+         Consult the TrieDateField javadocs for more information.
 
          Note: For faster range queries, consider the tdate type
       -->
@@ -393,21 +392,6 @@
     <!--Binary data type. The data should be sent/retrieved in as Base64 encoded Strings -->
     <fieldtype name="binary" class="solr.BinaryField"/>
 
-    <!--
-      Note:
-      These should only be used for compatibility with existing indexes (created with lucene or older Solr versions).
-      Use Trie based fields instead. As of Solr 3.5 and 4.x, Trie based fields support sortMissingFirst/Last
-      
-      Plain numeric field types that store and index the text
-      value verbatim (and hence don't correctly support range queries, since the
-      lexicographic ordering isn't equal to the numeric ordering)
-    -->
-    <fieldType name="pint" class="solr.IntField"/>
-    <fieldType name="plong" class="solr.LongField"/>
-    <fieldType name="pfloat" class="solr.FloatField"/>
-    <fieldType name="pdouble" class="solr.DoubleField"/>
-    <fieldType name="pdate" class="solr.DateField" sortMissingLast="true"/>
-
     <!-- The "RandomSortField" is not used to store or search any
          data.  You can declare fields of this type it in your schema
          to generate pseudo-random orderings of your docs for sorting 
diff --git a/solr/solrj/src/test-files/solrj/solr/collection1/conf/schema-replication1.xml b/solr/solrj/src/test-files/solrj/solr/collection1/conf/schema-replication1.xml
index fe123df..681fd4a 100644
--- a/solr/solrj/src/test-files/solrj/solr/collection1/conf/schema-replication1.xml
+++ b/solr/solrj/src/test-files/solrj/solr/collection1/conf/schema-replication1.xml
@@ -28,7 +28,7 @@
 <schema name="test" version="1.2">
   <types>
 
-    <fieldType name="integer" class="solr.IntField"/>
+    <fieldType name="integer" class="solr.TrieIntField" precisionStep="0"/>
     <fieldtype name="string" class="solr.StrField" sortMissingLast="true"/>
 
 
diff --git a/solr/solrj/src/test-files/solrj/solr/collection1/conf/schema.xml b/solr/solrj/src/test-files/solrj/solr/collection1/conf/schema.xml
index a2cc6c8..434f65e 100644
--- a/solr/solrj/src/test-files/solrj/solr/collection1/conf/schema.xml
+++ b/solr/solrj/src/test-files/solrj/solr/collection1/conf/schema.xml
@@ -34,16 +34,6 @@
          behavior of the fieldtype.
       -->
 
-    <!-- numeric field types that store and index the text
-         value verbatim (and hence don't sort correctly or support range queries.)
-         These are provided more for backward compatability, allowing one
-         to create a schema that matches an existing lucene index.
-    -->
-    <fieldType name="pint" class="solr.IntField"/>
-    <fieldType name="plong" class="solr.LongField"/>
-    <fieldtype name="pfloat" class="solr.FloatField"/>
-    <fieldType name="pdouble" class="solr.DoubleField"/>
-
     <fieldType name="int" class="solr.TrieIntField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
     <fieldType name="float" class="solr.TrieFloatField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
     <fieldType name="long" class="solr.TrieLongField" precisionStep="0" omitNorms="true" positionIncrementGap="0"/>
@@ -54,32 +44,6 @@
     <fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
     <fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" omitNorms="true" positionIncrementGap="0"/>
 
-    <!-- numeric field types that manipulate the value into
-       a string value that isn't human readable in it's internal form,
-       but sorts correctly and supports range queries.
-
-         If sortMissingLast="true" then a sort on this field will cause documents
-       without the field to come after documents with the field,
-       regardless of the requested sort order.
-         If sortMissingFirst="true" then a sort on this field will cause documents
-       without the field to come before documents with the field,
-       regardless of the requested sort order.
-         If sortMissingLast="false" and sortMissingFirst="false" (the default),
-       then default lucene sorting will be used which places docs without the field
-       first in an ascending sort and last in a descending sort.
-    -->
-    <fieldtype name="sint" class="solr.SortableIntField" sortMissingLast="true"/>
-    <fieldtype name="slong" class="solr.SortableLongField" sortMissingLast="true"/>
-    <fieldtype name="sfloat" class="solr.SortableFloatField" sortMissingLast="true"/>
-    <fieldtype name="sdouble" class="solr.SortableDoubleField" sortMissingLast="true"/>
-
-    <!-- bcd versions of sortable numeric type may provide smaller
-         storage space and support very large numbers.
-    -->
-    <fieldtype name="bcdint" class="solr.BCDIntField" sortMissingLast="true"/>
-    <fieldtype name="bcdlong" class="solr.BCDLongField" sortMissingLast="true"/>
-    <fieldtype name="bcdstr" class="solr.BCDStrField" sortMissingLast="true"/>
-
     <!-- Field type demonstrating an Analyzer failure -->
     <fieldtype name="failtype1" class="solr.TextField">
       <analyzer type="index">
@@ -115,7 +79,6 @@
       -->
     <fieldtype name="date" class="solr.TrieDateField" precisionStep="0"/>
     <fieldtype name="tdate" class="solr.TrieDateField" precisionStep="6"/>
-    <fieldtype name="pdate" class="solr.DateField" sortMissingLast="true"/>
 
 
     <!-- solr.TextField allows the specification of custom
@@ -530,7 +493,6 @@
    <dynamicField name="*_d1"  type="double" indexed="true"  stored="true" multiValued="false"/>
    <dynamicField name="*_dt" type="date"    indexed="true"  stored="true"/>
    <dynamicField name="*_dt1" type="date"    indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_bcd" type="bcdstr" indexed="true"  stored="true"/>
 
       <!-- some trie-coded dynamic fields for faster range queries -->
    <dynamicField name="*_ti" type="tint"    indexed="true"  stored="true"/>
@@ -545,20 +507,6 @@
    <dynamicField name="*_tdt" type="tdate"  indexed="true"  stored="true"/>
    <dynamicField name="*_tdt1" type="tdate"  indexed="true"  stored="true" multiValued="false"/>
 
-   <dynamicField name="*_si"  type="sint"  indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_sl"  type="slong"  indexed="true"  stored="true"/>
-   <dynamicField name="*_sf"  type="sfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_sf1"  type="sfloat"  indexed="true"  stored="true" multiValued="false"/>
-   <dynamicField name="*_sd"  type="sdouble"  indexed="true"  stored="true"/>
-   <dynamicField name="*_sd1"  type="sdouble"  indexed="true"  stored="true" multiValued="false"/>
-
-   <dynamicField name="*_pi"  type="pint"    indexed="true"  stored="true"/>
-   <dynamicField name="*_pf"  type="pfloat"  indexed="true"  stored="true"/>
-   <dynamicField name="*_pl"  type="plong"   indexed="true"  stored="true"/>
-   <dynamicField name="*_pd"  type="pdouble" indexed="true"  stored="true"/>
-   <dynamicField name="*_pdt"  type="pdate" indexed="true"  stored="true"/>
-
-
    <dynamicField name="*_sI" type="string"  indexed="true"  stored="false"/>
    <dynamicField name="*_sS" type="string"  indexed="false" stored="true"/>
    <dynamicField name="t_*"  type="text"    indexed="true"  stored="true"/>
@@ -575,7 +523,7 @@
 
    <!-- for testing to ensure that longer patterns are matched first -->
    <dynamicField name="*aa"  type="string"  indexed="true" stored="true"/>
-   <dynamicField name="*aaa" type="pint" indexed="false" stored="true"/>
+   <dynamicField name="*aaa" type="int" indexed="false" stored="true"/>
 
    <!-- ignored becuase not stored or indexed -->
    <dynamicField name="*_ignored" type="text" indexed="false" stored="false"/>
@@ -608,15 +556,8 @@
 
 	 <copyField source="*_t" dest="text"/>
 
-	 <copyField source="id"            dest="range_facet_si"/>
 	 <copyField source="id"            dest="range_facet_l"/>
-	 <copyField source="id"            dest="range_facet_sl"/>
-	 <copyField source="range_facet_f" dest="range_facet_sf"/>
 	 <copyField source="range_facet_f" dest="range_facet_d"/>
-	 <copyField source="range_facet_f" dest="range_facet_sd"/>
-
-	 <copyField source="bday" dest="bday_pdt"/>
-	 <copyField source="a_tdt" dest="a_pdt"/>
 
    <!-- dynamic destination -->
    <copyField source="*_dynamic" dest="dynamic_*"/>
diff --git a/solr/solrj/src/test-files/solrj/solr/crazy-path-to-schema.xml b/solr/solrj/src/test-files/solrj/solr/crazy-path-to-schema.xml
index a2216dd..7723aba 100644
--- a/solr/solrj/src/test-files/solrj/solr/crazy-path-to-schema.xml
+++ b/solr/solrj/src/test-files/solrj/solr/crazy-path-to-schema.xml
@@ -23,7 +23,7 @@
 
 <schema name="test" version="1.0">
   <types>
-    <fieldtype name="sint" class="solr.SortableIntField" />
+    <fieldtype name="int" class="solr.TrieIntField" precisionStep="0"/>
     <fieldtype name="text" class="solr.TextField">
       <analyzer>
         <tokenizer class="solr.StandardTokenizerFactory"/>
@@ -37,7 +37,7 @@
 
 
  <fields>
-   <field name="id" type="sint" indexed="true" stored="true" multiValued="false"/>
+   <field name="id" type="int" indexed="true" stored="true" multiValued="false"/>
    <field name="subject" type="text" indexed="true" stored="true"/>
  </fields>
 
diff --git a/solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests.java b/solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests.java
index d5fb2b1..b4945f6 100644
--- a/solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests.java
+++ b/solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests.java
@@ -626,7 +626,7 @@ abstract public class SolrExampleTests extends SolrExampleTestsBase
     server.commit();
     assertNumFound( "*:*", 0 ); // make sure it got in
 
-    String f = "val_pi";
+    String f = "val_i";
     
     int i=0;               // 0   1   2   3   4   5   6   7   8   9 
     int[] nums = new int[] { 23, 26, 38, 46, 55, 63, 77, 84, 92, 94 };
diff --git a/solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase.java b/solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase.java
index aa7e8d1..8cbbe33 100644
--- a/solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase.java
+++ b/solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase.java
@@ -100,21 +100,11 @@ public abstract class AbstractFullDistribZkTestBase extends AbstractDistribZkTes
   protected boolean printLayoutOnTearDown = false;
   
   String t1 = "a_t";
-  String i1 = "a_si";
-  String nint = "n_i";
-  String tint = "n_ti";
-  String nfloat = "n_f";
-  String tfloat = "n_tf";
-  String ndouble = "n_d";
-  String tdouble = "n_td";
-  String nlong = "n_l";
+  String i1 = "a_i1";
   String tlong = "other_tl1";
-  String ndate = "n_dt";
-  String tdate = "n_tdt";
-  
+
   String oddField = "oddField_s";
   String missingField = "ignore_exception__missing_but_valid_field_t";
-  String invalidField = "ignore_exception__invalid_field_not_in_schema";
   protected int sliceCount;
 
   protected CloudSolrServer controlClientCloud;  // cloud version of the control client
diff --git a/solr/test-framework/src/java/org/apache/solr/cloud/StopableIndexingThread.java b/solr/test-framework/src/java/org/apache/solr/cloud/StopableIndexingThread.java
index 1b0e97f..8104b69 100644
--- a/solr/test-framework/src/java/org/apache/solr/cloud/StopableIndexingThread.java
+++ b/solr/test-framework/src/java/org/apache/solr/cloud/StopableIndexingThread.java
@@ -30,7 +30,7 @@ import org.apache.solr.common.SolrInputDocument;
 
 public class StopableIndexingThread extends AbstractFullDistribZkTestBase.StopableThread {
   private static String t1 = "a_t";
-  private static String i1 = "a_si";
+  private static String i1 = "a_i";
   private volatile boolean stop = false;
   protected final String id;
   protected final List<String> deletes = new ArrayList<>();

