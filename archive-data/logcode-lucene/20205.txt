GitDiffStart: 4b6474f60c3996c755c5737f6ca14480648c74a7 | Mon May 25 20:07:24 2009 +0000
diff --git a/CHANGES.txt b/CHANGES.txt
index 5bebede..8d7d343 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -107,10 +107,10 @@ API Changes
    that's visited.  All core collectors now use this API.  (Mark
    Miller, Mike McCandless)
 
-8. LUCENE-1546: Add IndexReader.flush(String commitUserData), allowing
-   you to record an opaque commitUserData into the commit written by
-   IndexReader.  This matches IndexWriter's commit methods.  (Jason
-   Rutherglen via Mike McCandless)
+8. LUCENE-1546: Add IndexReader.flush(Map commitUserData), allowing
+   you to record an opaque commitUserData (maps String -> String) into
+   the commit written by IndexReader.  This matches IndexWriter's
+   commit methods.  (Jason Rutherglen via Mike McCandless)
 
 9. LUCENE-652: Added org.apache.lucene.document.CompressionTools, to
    enable compressing & decompressing binary content, external to
@@ -192,10 +192,11 @@ Bug fixes
     when building transactional support on top of Lucene.  (Mike
     McCandless)
 
- 2. LUCENE-1382: Add an optional arbitrary String "commitUserData" to
-    IndexWriter.commit(), which is stored in the segments file and is
-    then retrievable via IndexReader.getCommitUserData instance and
-    static methods.  (Shalin Shekhar Mangar via Mike McCandless)
+ 2. LUCENE-1382: Add an optional arbitrary Map (String -> String)
+    "commitUserData" to IndexWriter.commit(), which is stored in the
+    segments file and is then retrievable via
+    IndexReader.getCommitUserData instance and static methods.
+    (Shalin Shekhar Mangar via Mike McCandless)
 
  3. LUCENE-1406: Added Arabic analyzer.  (Robert Muir via Grant Ingersoll)
 
diff --git a/common-build.xml b/common-build.xml
index 157e29a..c4e335f 100644
--- a/common-build.xml
+++ b/common-build.xml
@@ -41,7 +41,7 @@
   <property name="name" value="${ant.project.name}"/>
   <property name="Name" value="Lucene"/>
   <property name="version" value="2.9-dev"/>
-  <property name="compatibility.tag" value="lucene_2_4_back_compat_tests_20090509"/>
+  <property name="compatibility.tag" value="lucene_2_4_back_compat_tests_20090525"/>
   <property name="spec.version" value="${version}"/>	
   <property name="year" value="2000-${current.year}"/>
   <property name="final.name" value="lucene-${name}-${version}"/>
@@ -395,6 +395,7 @@
 	      <sysproperty key="dataDir" file="@{dataDir}"/>
 	      <sysproperty key="tempDir" file="@{tempDir}"/>
 	      <sysproperty key="java.io.tmpdir" file="@{tempDir}"/>
+	      <sysproperty key="lucene.version" value="${version}"/>
 	
 		  <contrib-settings />
 	    	
diff --git a/docs/fileformats.html b/docs/fileformats.html
index 0953304..d688991 100644
--- a/docs/fileformats.html
+++ b/docs/fileformats.html
@@ -290,6 +290,14 @@ document.write("Last Published: " + document.lastModified);
 </ul>
 </li>
 <li>
+<a href="#Compound Types">Compound Types</a>
+<ul class="minitoc">
+<li>
+<a href="#String">Map&lt;String,String&gt;</a>
+</li>
+</ul>
+</li>
+<li>
 <a href="#Per-Index Files">Per-Index Files</a>
 <ul class="minitoc">
 <li>
@@ -1263,13 +1271,29 @@ document.write("Last Published: " + document.lastModified);
 </div>
 
         
-<a name="N1043C"></a><a name="Per-Index Files"></a>
+<a name="N1043C"></a><a name="Compound Types"></a>
+<h2 class="boxed">Compound Types</h2>
+<div class="section">
+<a name="N10441"></a><a name="String"></a>
+<h3 class="boxed">Map&lt;String,String&gt;</h3>
+<p>
+		    In a couple places Lucene stores a Map
+                    String-&gt;String.
+                </p>
+<p>
+  		    Map&lt;String,String&gt; --&gt; Count&lt;String,String&gt;<sup>Count</sup>
+                
+</p>
+</div>
+
+        
+<a name="N10451"></a><a name="Per-Index Files"></a>
 <h2 class="boxed">Per-Index Files</h2>
 <div class="section">
 <p>
                 The files in this section exist one-per-index.
             </p>
-<a name="N10444"></a><a name="Segments File"></a>
+<a name="N10459"></a><a name="Segments File"></a>
 <h3 class="boxed">Segments File</h3>
 <p>
                     The active segments in the index are stored in the
@@ -1343,7 +1367,7 @@ document.write("Last Published: " + document.lastModified);
 <b>2.9 and above:</b>
                     Segments --&gt; Format, Version, NameCounter, SegCount, &lt;SegName, SegSize, DelGen, DocStoreOffset, [DocStoreSegment, DocStoreIsCompoundFile], HasSingleNormFile, NumField,
                     NormGen<sup>NumField</sup>,
-                    IsCompoundFile, DeletionCount, HasProx&gt;<sup>SegCount</sup>, HasUserData, CommitUserData?, Checksum
+                    IsCompoundFile, DeletionCount, HasProx, Diagnostics&gt;<sup>SegCount</sup>, CommitUserData, Checksum
                 </p>
 <p>
                     Format, NameCounter, SegCount, SegSize, NumField,
@@ -1353,14 +1377,20 @@ document.write("Last Published: " + document.lastModified);
                     Version, DelGen, NormGen, Checksum --&gt; Int64
                 </p>
 <p>
-                    SegName, DocStoreSegment, CommitUserData --&gt; String
+                   SegName, DocStoreSegment --&gt; String
                 </p>
 <p>
+		   Diagnostics --&gt; Map&lt;String,String&gt;
+		</p>
+<p>
                     IsCompoundFile, HasSingleNormFile,
-                    DocStoreIsCompoundFile, HasProx, HasUserData --&gt; Int8
+                    DocStoreIsCompoundFile, HasProx --&gt; Int8
+                </p>
+<p>
+		    CommitUserData --&gt; Map&lt;String,String&gt;
                 </p>
 <p>
-                    Format is -1 as of Lucene 1.4, -3 (SegmentInfos.FORMAT_SINGLE_NORM_FILE) as of Lucene 2.1 and 2.2, -4 (SegmentInfos.FORMAT_SHARED_DOC_STORE) as of Lucene 2.3, -7 (SegmentInfos.FORMAT_HAS_PROX) as of Lucene 2.4, and -8 (SegmentInfos.FORMAT_USER_DATA) as of Lucene 2.9.
+                    Format is -1 as of Lucene 1.4, -3 (SegmentInfos.FORMAT_SINGLE_NORM_FILE) as of Lucene 2.1 and 2.2, -4 (SegmentInfos.FORMAT_SHARED_DOC_STORE) as of Lucene 2.3, -7 (SegmentInfos.FORMAT_HAS_PROX) as of Lucene 2.4, and -9 (SegmentInfos.FORMAT_DIAGNOSTICS) as of Lucene 2.9.
                 </p>
 <p>
                     Version counts how often the index has been
@@ -1448,12 +1478,19 @@ document.write("Last Published: " + document.lastModified);
 		    omitTf set to false; else, it's 0.
 		</p>
 <p>
-		    If HasUserData is 1, then the string
-		    CommitUserData is non-null and is stored.  This is
-		    a string previously passed to IndexWriter's commit
-		    or prepareCommit method.
+		    CommitUserData stores an optional user-supplied
+		    opaque Map&lt;String,String&gt; that was passed to
+		    IndexWriter's commit or prepareCommit, or
+		    IndexReader's flush methods.
+                </p>
+<p>
+		    The Diagnostics Map is privately written by
+		    IndexWriter, as a debugging aid, for each segment
+		    it creates.  It includes metadata like the current
+		    Lucene version, OS, Java version, why the segment
+		    was created (merge, flush, addIndexes), etc.
                 </p>
-<a name="N104ED"></a><a name="Lock File"></a>
+<a name="N1050B"></a><a name="Lock File"></a>
 <h3 class="boxed">Lock File</h3>
 <p>
                     The write lock, which is stored in the index
@@ -1471,7 +1508,7 @@ document.write("Last Published: " + document.lastModified);
                     Note that prior to version 2.1, Lucene also used a
                     commit lock. This was removed in 2.1.
                 </p>
-<a name="N104F9"></a><a name="Deletable File"></a>
+<a name="N10517"></a><a name="Deletable File"></a>
 <h3 class="boxed">Deletable File</h3>
 <p>
                     Prior to Lucene 2.1 there was a file "deletable"
@@ -1480,7 +1517,7 @@ document.write("Last Published: " + document.lastModified);
                     the files that are deletable, instead, so no file
                     is written.
                 </p>
-<a name="N10502"></a><a name="Compound Files"></a>
+<a name="N10520"></a><a name="Compound Files"></a>
 <h3 class="boxed">Compound Files</h3>
 <p>Starting with Lucene 1.4 the compound file format became default. This
                     is simply a container for all files described in the next section
@@ -1507,14 +1544,14 @@ document.write("Last Published: " + document.lastModified);
 </div>
 
         
-<a name="N1052A"></a><a name="Per-Segment Files"></a>
+<a name="N10548"></a><a name="Per-Segment Files"></a>
 <h2 class="boxed">Per-Segment Files</h2>
 <div class="section">
 <p>
                 The remaining files are all per-segment, and are
                 thus defined by suffix.
             </p>
-<a name="N10532"></a><a name="Fields"></a>
+<a name="N10550"></a><a name="Fields"></a>
 <h3 class="boxed">Fields</h3>
 <p>
                     
@@ -1736,7 +1773,7 @@ document.write("Last Published: " + document.lastModified);
 </li>
                 
 </ol>
-<a name="N105F0"></a><a name="Term Dictionary"></a>
+<a name="N1060E"></a><a name="Term Dictionary"></a>
 <h3 class="boxed">Term Dictionary</h3>
 <p>
                     The term dictionary is represented as two files:
@@ -1926,7 +1963,7 @@ document.write("Last Published: " + document.lastModified);
 </li>
                 
 </ol>
-<a name="N10670"></a><a name="Frequencies"></a>
+<a name="N1068E"></a><a name="Frequencies"></a>
 <h3 class="boxed">Frequencies</h3>
 <p>
                     The .frq file contains the lists of documents
@@ -2054,7 +2091,7 @@ document.write("Last Published: " + document.lastModified);
                    entry in level-1. In the example has entry 15 on level 1 a pointer to entry 15 on level 0 and entry 31 on level 1 a pointer
                    to entry 31 on level 0.                   
                 </p>
-<a name="N106F8"></a><a name="Positions"></a>
+<a name="N10716"></a><a name="Positions"></a>
 <h3 class="boxed">Positions</h3>
 <p>
                     The .prx file contains the lists of positions that
@@ -2124,7 +2161,7 @@ document.write("Last Published: " + document.lastModified);
                     Payload. If PayloadLength is not stored, then this Payload has the same
                     length as the Payload at the previous position.
                 </p>
-<a name="N10734"></a><a name="Normalization Factors"></a>
+<a name="N10752"></a><a name="Normalization Factors"></a>
 <h3 class="boxed">Normalization Factors</h3>
 <p>
                     
@@ -2228,7 +2265,7 @@ document.write("Last Published: " + document.lastModified);
 <b>2.1 and above:</b>
                     Separate norm files are created (when adequate) for both compound and non compound segments.
                 </p>
-<a name="N1079D"></a><a name="Term Vectors"></a>
+<a name="N107BB"></a><a name="Term Vectors"></a>
 <h3 class="boxed">Term Vectors</h3>
 <p>
 		  Term Vector support is an optional on a field by
@@ -2361,7 +2398,7 @@ document.write("Last Published: " + document.lastModified);
 </li>
                 
 </ol>
-<a name="N10833"></a><a name="Deleted Documents"></a>
+<a name="N10851"></a><a name="Deleted Documents"></a>
 <h3 class="boxed">Deleted Documents</h3>
 <p>The .del file is
                     optional, and only exists when a segment contains deletions.
@@ -2433,7 +2470,7 @@ document.write("Last Published: " + document.lastModified);
 </div>
 
         
-<a name="N10876"></a><a name="Limitations"></a>
+<a name="N10894"></a><a name="Limitations"></a>
 <h2 class="boxed">Limitations</h2>
 <div class="section">
 <p>
diff --git a/docs/fileformats.pdf b/docs/fileformats.pdf
index 0670f59..566da20 100644
--- a/docs/fileformats.pdf
+++ b/docs/fileformats.pdf
@@ -23,20 +23,20 @@ Table of contents
     6.1 Segments File................................................................................................................ 8
     6.2 Lock File......................................................................................................................10
     6.3 Deletable File...............................................................................................................10
-    6.4 Compound Files...........................................................................................................10
+    6.4 Compound Files...........................................................................................................11
    7 Per-Segment Files............................................................................................................ 11
     7.1 Fields........................................................................................................................... 11
 
                    Copyright © 2006 The Apache Software Foundation. All rights reserved.
                                                                                                             Apache Lucene - Index File Formats
 
- 7.2 Term Dictionary.......................................................................................................... 12
+ 7.2 Term Dictionary.......................................................................................................... 13
  7.3 Frequencies..................................................................................................................15
  7.4 Positions...................................................................................................................... 16
  7.5 Normalization Factors................................................................................................. 17
  7.6 Term Vectors............................................................................................................... 18
  7.7 Deleted Documents..................................................................................................... 20
-8 Limitations....................................................................................................................... 20
+8 Limitations....................................................................................................................... 21
 
                                                                        Page 2
 
@@ -321,22 +321,23 @@ Copyright © 2006 The Apache Software Foundation. All rights reserved.
 Apache Lucene - Index File Formats
 
 HasSingleNormFile, NumField, NormGenNumField, IsCompoundFile, DeletionCount,
-HasProx>SegCount, HasUserData, CommitUserData?, Checksum
+HasProx>SegCount, HasUserData, CommitUserData?, DiagnosticsCount, <DiagnosticKey,
+DiagnosticValue>DiagnosticsCountChecksum
 
-Format, NameCounter, SegCount, SegSize, NumField, DocStoreOffset, DeletionCount -->
-Int32
+Format, NameCounter, SegCount, SegSize, NumField, DocStoreOffset, DeletionCount,
+DiagnosticsCount --> Int32
 
 Version, DelGen, NormGen, Checksum --> Int64
 
-SegName, DocStoreSegment, CommitUserData --> String
+SegName, DocStoreSegment, CommitUserData, DiagnosticKey, DiagnosticValue --> String
 
 IsCompoundFile, HasSingleNormFile, DocStoreIsCompoundFile, HasProx, HasUserData -->
 Int8
 
 Format is -1 as of Lucene 1.4, -3 (SegmentInfos.FORMAT_SINGLE_NORM_FILE) as of
 Lucene 2.1 and 2.2, -4 (SegmentInfos.FORMAT_SHARED_DOC_STORE) as of Lucene
-2.3, -7 (SegmentInfos.FORMAT_HAS_PROX) as of Lucene 2.4, and -8
-(SegmentInfos.FORMAT_USER_DATA) as of Lucene 2.9.
+2.3, -7 (SegmentInfos.FORMAT_HAS_PROX) as of Lucene 2.4, and -9
+(SegmentInfos.FORMAT_DIAGNOSTICS) as of Lucene 2.9.
 
 Version counts how often the index has been changed by adding or deleting documents.
 
@@ -369,7 +370,7 @@ extension .nrm); if it is 0 then each field's norms are stored as separate .fN f
 Page 9
 
         Copyright © 2006 The Apache Software Foundation. All rights reserved.
-Apache Lucene - Index File Formats
+                                                                                                                Apache Lucene - Index File Formats
 
 DocStoreOffset, DocStoreSegment, DocStoreIsCompoundFile: If DocStoreOffset is -1, this
 segment has its own doc store (stored fields values and term vectors) files and
@@ -391,6 +392,11 @@ HasProx is 1 if any fields in this segment have omitTf set to false; else, it's
 If HasUserData is 1, then the string CommitUserData is non-null and is stored. This is a
 string previously passed to IndexWriter's commit or prepareCommit method.
 
+If DiagnosticsCount is non-zero, then that number of String -> String (key/value map)
+diagnostics is stored. Currently these diagnostics are privately written by IndexWriter, as a
+debugging aid, for each segment it creates. It includes things like the current Lucene version,
+OS, Java version, why the segment was created (merge, flush, addIndexes), etc.
+
 6.2. Lock File
 
 The write lock, which is stored in the index directory by default, is named "write.lock". If the
@@ -408,18 +414,15 @@ Prior to Lucene 2.1 there was a file "deletable" that contained details about fi
 be deleted. As of 2.1, a writer dynamically computes the files that are deletable, instead, so
 no file is written.
 
-6.4. Compound Files
-
-Starting with Lucene 1.4 the compound file format became default. This is simply a container
-for all files described in the next section (except for the .del file).
-
-Compound (.cfs) --> FileCount, <DataOffset, FileName> FileCount , FileData FileCount
-
                                                                        Page 10
 
 Copyright © 2006 The Apache Software Foundation. All rights reserved.
 Apache Lucene - Index File Formats
 
+6.4. Compound Files
+Starting with Lucene 1.4 the compound file format became default. This is simply a container
+for all files described in the next section (except for the .del file).
+Compound (.cfs) --> FileCount, <DataOffset, FileName> FileCount , FileData FileCount
 FileCount --> VInt
 DataOffset --> Long
 FileName --> String
@@ -446,35 +449,50 @@ FNMVersion (added in 2.9) is always -2.
 Fields are numbered by their order in this file. Thus field zero is the first field in the file, field
 one the next, and so on. Note that, like document numbers, field numbers are segment
 relative.
-Stored Fields
-Stored fields are represented by two files:
-1. The field index, or .fdx file.
-
-    This contains, for each document, a pointer to its field data, as follows:
 
 Page 11
 
          Copyright © 2006 The Apache Software Foundation. All rights reserved.
 Apache Lucene - Index File Formats
 
+Stored Fields
+
+Stored fields are represented by two files:
+1. The field index, or .fdx file.
+
+    This contains, for each document, a pointer to its field data, as follows:
+
     FieldIndex (.fdx) --> <FieldValuesPosition> SegSize
+
     FieldValuesPosition --> Uint64
+
     This is used to find the location within the field data file of the fields of a particular
     document. Because it contains fixed-length data, this file may be easily randomly
     accessed. The position of document n 's field data is the Uint64 at n*8 in this file.
 2. The field data, or .fdt file.
     This contains the stored fields of each document, as follows:
+
     FieldData (.fdt) --> <DocFieldData> SegSize
+
     DocFieldData --> FieldCount, <FieldNum, Bits, Value> FieldCount
+
     FieldCount --> VInt
+
     FieldNum --> VInt
+
     Lucene <= 1.4:
+
     Bits --> Byte
+
     Value --> String
+
     Only the low-order bit of Bits is used. It is one for tokenized fields, and zero for
     non-tokenized fields.
+
     Lucene >= 1.9:
+
     Bits --> Byte
+
     ?? low order bit is one for tokenized fields
     ?? second bit is one for fields containing binary data
     ?? third bit is one for fields with compression option enabled (if compression is enabled,
@@ -482,17 +500,19 @@ Page 11
          the algorithm used is ZLIB)
 
     Value --> String | BinaryValue (depending on Bits)
-    BinaryValue --> ValueSize, <Byte>^ValueSize
-    ValueSize --> VInt
-
-7.2. Term Dictionary
-The term dictionary is represented as two files:
 
                                                                        Page 12
 
 Copyright © 2006 The Apache Software Foundation. All rights reserved.
 Apache Lucene - Index File Formats
 
+    BinaryValue --> ValueSize, <Byte>^ValueSize
+
+    ValueSize --> VInt
+
+7.2. Term Dictionary
+
+The term dictionary is represented as two files:
 1. The term infos, or tis file.
 
     TermInfoFile (.tis)--> TIVersion, TermCount, IndexInterval, SkipInterval,
@@ -534,18 +554,17 @@ Copyright © 2006 The Apache Software Foundation. All rights reserved.
 
     DocFreq is the count of documents which contain the term.
 
+Page 13
+
+         Copyright © 2006 The Apache Software Foundation. All rights reserved.
+Apache Lucene - Index File Formats
+
     FreqDelta determines the position of this term's TermFreqs within the .frq file. In
     particular, it is the difference between the position of this term's data in that file and the
     position of the previous term's data (or zero, for the first term in the file).
 
     ProxDelta determines the position of this term's TermPositions within the .prx file. In
     particular, it is the difference between the position of this term's data in that file and the
-
-Page 13
-
-         Copyright © 2006 The Apache Software Foundation. All rights reserved.
-Apache Lucene - Index File Formats
-
     position of the previous term's data (or zero, for the first term in the file. For fields with
     omitTf true, this will be 0 since prox information is not stored.
 
@@ -586,16 +605,16 @@ Page 13
     fewer accelerable cases, while smaller values result in bigger indexes, less acceleration
     (in case of a small value for MaxSkipLevels) and more accelerable cases.
 
-    MaxSkipLevels is the max. number of skip levels stored for each term in the .frq file. A
-    low value results in smaller indexes but less acceleration, a larger value results in slighly
-    larger indexes but greater acceleration. See format of .frq file for more information about
-    skip levels.
-
                                                                        Page 14
 
 Copyright © 2006 The Apache Software Foundation. All rights reserved.
 Apache Lucene - Index File Formats
 
+    MaxSkipLevels is the max. number of skip levels stored for each term in the .frq file. A
+    low value results in smaller indexes but less acceleration, a larger value results in slighly
+    larger indexes but greater acceleration. See format of .frq file for more information about
+    skip levels.
+
 7.3. Frequencies
 
 The .frq file contains the lists of documents which contain each term, along with the
@@ -637,17 +656,16 @@ If omitTf were true it would be this sequence of VInts instead:
 
 7,4
 
-DocSkip records the document number before every SkipInterval th document in TermFreqs.
-If payloads are disabled for the term's field, then DocSkip represents the difference from the
-previous value in the sequence. If payloads are enabled for the term's field, then DocSkip/2
-represents the difference from the previous value in the sequence. If payloads are enabled
-and DocSkip is odd, then PayloadLength is stored indicating the length of the last payload
-
 Page 15
 
          Copyright © 2006 The Apache Software Foundation. All rights reserved.
 Apache Lucene - Index File Formats
 
+DocSkip records the document number before every SkipInterval th document in TermFreqs.
+If payloads are disabled for the term's field, then DocSkip represents the difference from the
+previous value in the sequence. If payloads are enabled for the term's field, then DocSkip/2
+represents the difference from the previous value in the sequence. If payloads are enabled
+and DocSkip is odd, then PayloadLength is stored indicating the length of the last payload
 before the SkipIntervalth document in TermPositions. FreqSkip and ProxSkip record the
 position of every SkipInterval th entry in FreqFile and ProxFile, respectively. File positions
 are relative to the start of TermFreqs and Positions, to the previous SkipDatum in the
@@ -686,17 +704,17 @@ Positions --> <PositionDelta,Payload?> Freq
 
 Payload --> <PayloadLength?,PayloadData>
 
+                                                                       Page 16
+
+Copyright © 2006 The Apache Software Foundation. All rights reserved.
+Apache Lucene - Index File Formats
+
 PositionDelta --> VInt
 
 PayloadLength --> VInt
 
 PayloadData --> bytePayloadLength
 
-                                                                       Page 16
-
-Copyright © 2006 The Apache Software Foundation. All rights reserved.
-Apache Lucene - Index File Formats
-
 TermPositions are ordered by term (the term is implicit, from the .tis file).
 
 Positions entries are ordered by increasing document number (the document number is
@@ -737,18 +755,17 @@ NormsHeader --> 'N','R','M',Version
 
 Version --> Byte
 
+Page 17
+
+         Copyright © 2006 The Apache Software Foundation. All rights reserved.
+Apache Lucene - Index File Formats
+
 NormsHeader has 4 bytes, last of which is the format version for this file, currently -1.
 
 Each byte encodes a floating point value. Bits 0-2 contain the 3-bit mantissa, and bits 3-8
 contain the 5-bit exponent.
 
 These are converted to an IEEE single float value as follows:
-
-Page 17
-
-         Copyright © 2006 The Apache Software Foundation. All rights reserved.
-Apache Lucene - Index File Formats
-
 1. If the byte is zero, use a zero float.
 2. Otherwise, set the sign bit of the float to zero;
 3. add 48 to the exponent and use this as the float's exponent;
@@ -787,17 +804,17 @@ Term Vector support is an optional on a field by field basis. It consists of 3 f
 
     Document (.tvd) --> TVDVersion<NumFields, FieldNums, FieldPositions> NumDocs
 
+                                                                       Page 18
+
+Copyright © 2006 The Apache Software Foundation. All rights reserved.
+Apache Lucene - Index File Formats
+
     TVDVersion --> Int (3 (TermVectorsReader.FORMAT_VERSION2) for Lucene 2.4)
 
     NumFields --> VInt
 
     FieldNums --> <FieldNumDelta> NumFields
 
-                                                                       Page 18
-
-Copyright © 2006 The Apache Software Foundation. All rights reserved.
-Apache Lucene - Index File Formats
-
     FieldNumDelta --> VInt
 
     FieldPositions --> <FieldPositionDelta> NumFields-1
@@ -841,17 +858,20 @@ Copyright © 2006 The Apache Software Foundation. All rights reserved.
 
          from the previous term which must be pre-pended to a term's suffix in order to form
          the term's text. Thus, if the previous term's text was "bone" and the term is "boy", the
-         PrefixLength is two and the suffix is "y".
-    ?? Positions are stored as delta encoded VInts. This means we only store the difference
-         of the current position from the last position
-    ?? Offsets are stored as delta encoded VInts. The first VInt is the startOffset, the second
-         is the endOffset.
 
 Page 19
 
          Copyright © 2006 The Apache Software Foundation. All rights reserved.
 Apache Lucene - Index File Formats
 
+         PrefixLength is two and the suffix is "y".
+    ?? Positions are stored as delta encoded VInts. This means we only store the difference
+
+         of the current position from the last position
+    ?? Offsets are stored as delta encoded VInts. The first VInt is the startOffset, the second
+
+         is the endOffset.
+
 7.7. Deleted Documents
 
 The .del file is optional, and only exists when a segment contains deletions.
@@ -893,17 +913,16 @@ For example, if there are 8000 bits and only bits 10,12,32 are set, DGaps would
 
 (VInt) 1 , (byte) 20 , (VInt) 3 , (Byte) 1
 
-8. Limitations
-
-When referring to term numbers, Lucene's current implementation uses a Java int, which
-means the maximum number of unique terms in any single index segment is 2,147,483,648.
-This is technically not a limitation of the index file format, just of Lucene's current
-
                                                                        Page 20
 
 Copyright © 2006 The Apache Software Foundation. All rights reserved.
 Apache Lucene - Index File Formats
 
+8. Limitations
+
+When referring to term numbers, Lucene's current implementation uses a Java int, which
+means the maximum number of unique terms in any single index segment is 2,147,483,648.
+This is technically not a limitation of the index file format, just of Lucene's current
 implementation.
 Similarly, Lucene uses a Java int to refer to document numbers, and the index file format
 uses an Int32 on-disk to store document numbers. This is a limitation of both the index file
diff --git a/src/java/org/apache/lucene/index/CheckIndex.java b/src/java/org/apache/lucene/index/CheckIndex.java
index 6f8dd87..6dbd07e 100644
--- a/src/java/org/apache/lucene/index/CheckIndex.java
+++ b/src/java/org/apache/lucene/index/CheckIndex.java
@@ -30,6 +30,7 @@ import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.ArrayList;
+import java.util.Map;
 
 /**
  * Basic tool and API to check the health of an index and
@@ -113,6 +114,9 @@ public class CheckIndex {
      * argument). */
     public boolean partial;
 
+    /** Holds the userData of the last commit in the index */
+    public Map userData;
+
     /** Holds the status of each segment in the index.
      *  See {@link #segmentInfos}.
      *
@@ -169,6 +173,11 @@ public class CheckIndex {
        *  does not omitTermFreqAndPositions.
        *  @see AbstractField#setOmitTermFreqAndPositions */
       public boolean hasProx;
+
+      /** Map<String, String> that includes certain
+       *  debugging details that IndexWriter records into
+       *  each segment it creates */
+      public Map diagnostics;
     }
   }
 
@@ -310,6 +319,8 @@ public class CheckIndex {
         sFormat = "FORMAT_HAS_PROX [Lucene 2.4]";
       else if (format == SegmentInfos.FORMAT_USER_DATA)
         sFormat = "FORMAT_USER_DATA [Lucene 2.9]";
+      else if (format == SegmentInfos.FORMAT_DIAGNOSTICS)
+        sFormat = "FORMAT_DIAGNOSTICS [Lucene 2.9]";
       else if (format < SegmentInfos.CURRENT_FORMAT) {
         sFormat = "int=" + format + " [newer version of Lucene than this tool]";
         skip = true;
@@ -318,10 +329,18 @@ public class CheckIndex {
       }
     }
 
-    msg("Segments file=" + segmentsFileName + " numSegments=" + numSegments + " version=" + sFormat);
     result.segmentsFileName = segmentsFileName;
     result.numSegments = numSegments;
     result.segmentFormat = sFormat;
+    result.userData = sis.getUserData();
+    String userDataString;
+    if (sis.getUserData().size() > 0) {
+      userDataString = " userData=" + sis.getUserData();
+    } else {
+      userDataString = "";
+    }
+
+    msg("Segments file=" + segmentsFileName + " numSegments=" + numSegments + " version=" + sFormat + userDataString);
 
     if (onlySegments != null) {
       result.partial = true;
@@ -369,7 +388,11 @@ public class CheckIndex {
         segInfoStat.numFiles = info.files().size();
         msg("    size (MB)=" + nf.format(info.sizeInBytes()/(1024.*1024.)));
         segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);
-
+        Map diagnostics = info.getDiagnostics();
+        segInfoStat.diagnostics = diagnostics;
+        if (diagnostics.size() > 0) {
+          msg("    diagnostics = " + diagnostics);
+        }
 
         final int docStoreOffset = info.getDocStoreOffset();
         if (docStoreOffset != -1) {
diff --git a/src/java/org/apache/lucene/index/DirectoryIndexReader.java b/src/java/org/apache/lucene/index/DirectoryIndexReader.java
index 183e7b0..7e32cce 100644
--- a/src/java/org/apache/lucene/index/DirectoryIndexReader.java
+++ b/src/java/org/apache/lucene/index/DirectoryIndexReader.java
@@ -25,6 +25,7 @@ import java.util.Collection;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.Collections;
+import java.util.Map;
 
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.Lock;
@@ -344,7 +345,7 @@ abstract class DirectoryIndexReader extends IndexReader implements Cloneable {
     return segmentInfos.getVersion();
   }
 
-  public String getCommitUserData() {
+  public Map getCommitUserData() {
     ensureOpen();
     return segmentInfos.getUserData();
   }
@@ -396,7 +397,7 @@ abstract class DirectoryIndexReader extends IndexReader implements Cloneable {
    * (transactional semantics).
    * @throws IOException if there is a low-level IO error
    */
-  protected void doCommit(String commitUserData) throws IOException {
+  protected void doCommit(Map commitUserData) throws IOException {
     if (hasChanges) {
       if (segmentInfos != null) {
         segmentInfos.setUserData(commitUserData);
@@ -557,7 +558,7 @@ abstract class DirectoryIndexReader extends IndexReader implements Cloneable {
     long generation;
     long version;
     final boolean isOptimized;
-    final String userData;
+    final Map userData;
 
     ReaderCommit(SegmentInfos infos, Directory dir) throws IOException {
       segmentsFileName = infos.getCurrentSegmentFileName();
@@ -590,7 +591,7 @@ abstract class DirectoryIndexReader extends IndexReader implements Cloneable {
     public boolean isDeleted() {
       return false;
     }
-    public String getUserData() {
+    public Map getUserData() {
       return userData;
     }
   }
diff --git a/src/java/org/apache/lucene/index/FilterIndexReader.java b/src/java/org/apache/lucene/index/FilterIndexReader.java
index 2e45029..3d6434c 100644
--- a/src/java/org/apache/lucene/index/FilterIndexReader.java
+++ b/src/java/org/apache/lucene/index/FilterIndexReader.java
@@ -23,6 +23,7 @@ import org.apache.lucene.store.Directory;
 
 import java.io.IOException;
 import java.util.Collection;
+import java.util.Map;
 
 /**  A <code>FilterIndexReader</code> contains another IndexReader, which it
  * uses as its basic source of data, possibly transforming the data along the
@@ -213,7 +214,7 @@ public class FilterIndexReader extends IndexReader {
   /** @deprecated */
   protected void doCommit() throws IOException { doCommit(null); }
   
-  protected void doCommit(String commitUserData) throws IOException { in.commit(commitUserData); }
+  protected void doCommit(Map commitUserData) throws IOException { in.commit(commitUserData); }
   
   protected void doClose() throws IOException { in.close(); }
 
diff --git a/src/java/org/apache/lucene/index/IndexCommit.java b/src/java/org/apache/lucene/index/IndexCommit.java
index f9c8bbf..7884fa5 100644
--- a/src/java/org/apache/lucene/index/IndexCommit.java
+++ b/src/java/org/apache/lucene/index/IndexCommit.java
@@ -18,6 +18,7 @@ package org.apache.lucene.index;
 */
 
 import java.util.Collection;
+import java.util.Map;
 import java.io.IOException;
 import org.apache.lucene.store.Directory;
 
@@ -122,8 +123,9 @@ public abstract class IndexCommit implements IndexCommitPoint {
   }
 
   /** Returns userData, previously passed to {@link
-   *  IndexWriter#commit(String)} for this commit.  */
-  public String getUserData() throws IOException {
+   *  IndexWriter#commit(Map)} for this commit.  Map is
+   *  String -> String. */
+  public Map getUserData() throws IOException {
     throw new UnsupportedOperationException("This IndexCommit does not support this method.");
   }
 }
diff --git a/src/java/org/apache/lucene/index/IndexFileDeleter.java b/src/java/org/apache/lucene/index/IndexFileDeleter.java
index 757cfe5..074facb 100644
--- a/src/java/org/apache/lucene/index/IndexFileDeleter.java
+++ b/src/java/org/apache/lucene/index/IndexFileDeleter.java
@@ -585,7 +585,7 @@ final class IndexFileDeleter {
     long version;
     long generation;
     final boolean isOptimized;
-    final String userData;
+    final Map userData;
 
     public CommitPoint(Collection commitsToDelete, Directory directory, SegmentInfos segmentInfos) throws IOException {
       this.directory = directory;
@@ -625,7 +625,7 @@ final class IndexFileDeleter {
       return generation;
     }
 
-    public String getUserData() {
+    public Map getUserData() {
       return userData;
     }
 
diff --git a/src/java/org/apache/lucene/index/IndexReader.java b/src/java/org/apache/lucene/index/IndexReader.java
index cafad75..8557c78 100644
--- a/src/java/org/apache/lucene/index/IndexReader.java
+++ b/src/java/org/apache/lucene/index/IndexReader.java
@@ -27,6 +27,7 @@ import java.io.FileOutputStream;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Collection;
+import java.util.Map;
 
 /** IndexReader is an abstract class, providing an interface for accessing an
  index.  Search of an index is done entirely through this abstract interface,
@@ -525,9 +526,9 @@ public abstract class IndexReader implements Cloneable {
 
   /**
    * Reads commitUserData, previously passed to {@link
-   * IndexWriter#commit(String)}, from current index
+   * IndexWriter#commit(Map)}, from current index
    * segments file.  This will return null if {@link
-   * IndexWriter#commit(String)} has never been called for
+   * IndexWriter#commit(Map)} has never been called for
    * this index.
    * 
    * @param directory where the index resides.
@@ -537,7 +538,7 @@ public abstract class IndexReader implements Cloneable {
    *
    * @see #getCommitUserData()
    */
-  public static String getCommitUserData(Directory directory) throws CorruptIndexException, IOException {
+  public static Map getCommitUserData(Directory directory) throws CorruptIndexException, IOException {
     return SegmentInfos.readCurrentUserData(directory);
   }
 
@@ -552,12 +553,12 @@ public abstract class IndexReader implements Cloneable {
   /**
    * Retrieve the String userData optionally passed to
    * IndexWriter#commit.  This will return null if {@link
-   * IndexWriter#commit(String)} has never been called for
+   * IndexWriter#commit(Map)} has never been called for
    * this index.
    *
    * @see #getCommitUserData(Directory)
    */
-  public String getCommitUserData() {
+  public Map getCommitUserData() {
     throw new UnsupportedOperationException("This reader does not support this method.");
   }
 
@@ -1017,12 +1018,13 @@ public abstract class IndexReader implements Cloneable {
   }
 
   /**
-   * @param commitUserData Opaque String that's recorded
-   *  into the segments file in the index, and retrievable
-   *  by {@link IndexReader#getCommitUserData}.
+   * @param commitUserData Opaque Map (String -> String)
+   *  that's recorded into the segments file in the index,
+   *  and retrievable by {@link
+   *  IndexReader#getCommitUserData}.
    * @throws IOException
    */
-  public final synchronized void flush(String commitUserData) throws IOException {
+  public final synchronized void flush(Map commitUserData) throws IOException {
     ensureOpen();
     commit(commitUserData);
   }
@@ -1049,7 +1051,7 @@ public abstract class IndexReader implements Cloneable {
    * (transactional semantics).
    * @throws IOException if there is a low-level IO error
    */
-  protected final synchronized void commit(String commitUserData) throws IOException {
+  protected final synchronized void commit(Map commitUserData) throws IOException {
     if (hasChanges) {
       doCommit(commitUserData);
     }
@@ -1057,13 +1059,13 @@ public abstract class IndexReader implements Cloneable {
   }
 
   /** Implements commit.
-   *  @deprecated Please implement {@link #doCommit(String)
+   *  @deprecated Please implement {@link #doCommit(Map)
    *  instead}. */
   protected abstract void doCommit() throws IOException;
 
   /** Implements commit.  NOTE: subclasses should override
    *  this.  In 3.0 this will become an abstract method. */
-  void doCommit(String commitUserData) throws IOException {
+  void doCommit(Map commitUserData) throws IOException {
     // Default impl discards commitUserData; all Lucene
     // subclasses override this (do not discard it).
     doCommit();
diff --git a/src/java/org/apache/lucene/index/IndexWriter.java b/src/java/org/apache/lucene/index/IndexWriter.java
index 9630f16..87355e2 100644
--- a/src/java/org/apache/lucene/index/IndexWriter.java
+++ b/src/java/org/apache/lucene/index/IndexWriter.java
@@ -3718,6 +3718,7 @@ public class IndexWriter {
             segmentInfos.clear();                      // pop old infos & add new
             info = new SegmentInfo(mergedName, docCount, directory, false, true,
                                    -1, null, false, merger.hasProx());
+            setDiagnostics(info, "addIndexes(IndexReader[])");
             segmentInfos.add(info);
           }
 
@@ -3831,16 +3832,16 @@ public class IndexWriter {
    * you should immediately close the writer.  See <a
    * href="#OOME">above</a> for details.</p>
    *
-   * @see #prepareCommit(String) */
+   * @see #prepareCommit(Map) */
   public final void prepareCommit() throws CorruptIndexException, IOException {
     ensureOpen();
     prepareCommit(null);
   }
 
   /** <p>Expert: prepare for commit, specifying
-   *  commitUserData String.  This does the first phase of
-   *  2-phase commit.  You can only call this when
-   *  autoCommit is false.  This method does all steps
+   *  commitUserData Map (String -> String).  This does the
+   *  first phase of 2-phase commit.  You can only call this
+   *  when autoCommit is false.  This method does all steps
    *  necessary to commit changes since this writer was
    *  opened: flushes pending added and deleted docs, syncs
    *  the index files, writes most of next segments_N file.
@@ -3849,7 +3850,7 @@ public class IndexWriter {
    *  #rollback()} to revert the commit and undo all changes
    *  done since the writer was opened.</p>
    * 
-   *  You can also just call {@link #commit(String)} directly
+   *  You can also just call {@link #commit(Map)} directly
    *  without prepareCommit first in which case that method
    *  will internally call prepareCommit.
    *
@@ -3857,11 +3858,12 @@ public class IndexWriter {
    *  you should immediately close the writer.  See <a
    *  href="#OOME">above</a> for details.</p>
    *
-   *  @param commitUserData Opaque String that's recorded
-   *  into the segments file in the index, and retrievable
-   *  by {@link IndexReader#getCommitUserData}.  Note that
-   *  when IndexWriter commits itself, for example if open
-   *  with autoCommit=true, or, during {@link #close}, the
+   *  @param commitUserData Opaque Map (String->String)
+   *  that's recorded into the segments file in the index,
+   *  and retrievable by {@link
+   *  IndexReader#getCommitUserData}.  Note that when
+   *  IndexWriter commits itself, for example if open with
+   *  autoCommit=true, or, during {@link #close}, the
    *  commitUserData is unchanged (just carried over from
    *  the prior commit).  If this is null then the previous
    *  commitUserData is kept.  Also, the commitUserData will
@@ -3869,11 +3871,11 @@ public class IndexWriter {
    *  index to commit.  Therefore it's best to use this
    *  feature only when autoCommit is false.
    */
-  public final void prepareCommit(String commitUserData) throws CorruptIndexException, IOException {
+  public final void prepareCommit(Map commitUserData) throws CorruptIndexException, IOException {
     prepareCommit(commitUserData, false);
   }
 
-  private final void prepareCommit(String commitUserData, boolean internal) throws CorruptIndexException, IOException {
+  private final void prepareCommit(Map commitUserData, boolean internal) throws CorruptIndexException, IOException {
 
     if (hitOOM) {
       throw new IllegalStateException("this writer hit an OutOfMemoryError; cannot commit");
@@ -3926,22 +3928,22 @@ public class IndexWriter {
    * href="#OOME">above</a> for details.</p>
    *
    * @see #prepareCommit
-   * @see #commit(String)
+   * @see #commit(Map)
    */
   public final void commit() throws CorruptIndexException, IOException {
     commit(null);
   }
 
   /** Commits all changes to the index, specifying a
-   *  commitUserData String.  This just calls {@link
-   *  #prepareCommit(String)} (if you didn't already call
-   *  it) and then {@link #finishCommit}.
+   *  commitUserData Map (String -> String).  This just
+   *  calls {@link #prepareCommit(Map)} (if you didn't
+   *  already call it) and then {@link #finishCommit}.
    *
    * <p><b>NOTE</b>: if this method hits an OutOfMemoryError
    * you should immediately close the writer.  See <a
    * href="#OOME">above</a> for details.</p>
    */
-  public final void commit(String commitUserData) throws CorruptIndexException, IOException {
+  public final void commit(Map commitUserData) throws CorruptIndexException, IOException {
 
     ensureOpen();
 
@@ -4136,6 +4138,7 @@ public class IndexWriter {
                                      docStoreOffset, docStoreSegment,
                                      docStoreIsCompoundFile,    
                                      docWriter.hasProx());
+        setDiagnostics(newSegment, "flush");
       }
 
       docWriter.pushDeletes();
@@ -4646,6 +4649,13 @@ public class IndexWriter {
                                  docStoreIsCompoundFile,
                                  false);
 
+
+    Map details = new HashMap();
+    details.put("optimize", merge.optimize+"");
+    details.put("mergeFactor", end+"");
+    details.put("mergeDocStores", mergeDocStores+"");
+    setDiagnostics(merge.info, "merge", details);
+
     // Also enroll the merged segment into mergingSegments;
     // this prevents it from getting selected for a merge
     // after our merge is done but while we are building the
@@ -4653,6 +4663,25 @@ public class IndexWriter {
     mergingSegments.add(merge.info);
   }
 
+  private void setDiagnostics(SegmentInfo info, String source) {
+    setDiagnostics(info, source, null);
+  }
+
+  private void setDiagnostics(SegmentInfo info, String source, Map details) {
+    Map diagnostics = new HashMap();
+    diagnostics.put("source", source);
+    diagnostics.put("lucene.version", Constants.LUCENE_VERSION);
+    diagnostics.put("os", Constants.OS_NAME+"");
+    diagnostics.put("os.arch", Constants.OS_ARCH+"");
+    diagnostics.put("os.version", Constants.OS_VERSION+"");
+    diagnostics.put("java.version", Constants.JAVA_VERSION+"");
+    diagnostics.put("java.vendor", Constants.JAVA_VENDOR+"");
+    if (details != null) {
+      diagnostics.putAll(details);
+    }
+    info.setDiagnostics(diagnostics);
+  }
+
   /** This is called after merging a segment and before
    *  building its CFS.  Return true if the files should be
    *  sync'd.  If you return false, then the source segment
@@ -5142,7 +5171,7 @@ public class IndexWriter {
    *  if it wasn't already.  If that succeeds, then we
    *  prepare a new segments_N file but do not fully commit
    *  it. */
-  private void startCommit(long sizeInBytes, String commitUserData) throws IOException {
+  private void startCommit(long sizeInBytes, Map commitUserData) throws IOException {
 
     assert testPoint("startStartCommit");
 
diff --git a/src/java/org/apache/lucene/index/MultiReader.java b/src/java/org/apache/lucene/index/MultiReader.java
index 8253f44..378323f 100644
--- a/src/java/org/apache/lucene/index/MultiReader.java
+++ b/src/java/org/apache/lucene/index/MultiReader.java
@@ -360,7 +360,7 @@ public class MultiReader extends IndexReader implements Cloneable {
     doCommit(null);
   }
   
-  protected void doCommit(String commitUserData) throws IOException {
+  protected void doCommit(Map commitUserData) throws IOException {
     for (int i = 0; i < subReaders.length; i++)
       subReaders[i].commit(commitUserData);
   }
diff --git a/src/java/org/apache/lucene/index/ParallelReader.java b/src/java/org/apache/lucene/index/ParallelReader.java
index fa00282..0da28b0 100644
--- a/src/java/org/apache/lucene/index/ParallelReader.java
+++ b/src/java/org/apache/lucene/index/ParallelReader.java
@@ -441,7 +441,7 @@ public class ParallelReader extends IndexReader {
     doCommit(null);
   }
 
-  protected void doCommit(String commitUserData) throws IOException {
+  protected void doCommit(Map commitUserData) throws IOException {
     for (int i = 0; i < readers.size(); i++)
       ((IndexReader)readers.get(i)).commit(commitUserData);
   }
diff --git a/src/java/org/apache/lucene/index/SegmentInfo.java b/src/java/org/apache/lucene/index/SegmentInfo.java
index d79ae24..be8f838 100644
--- a/src/java/org/apache/lucene/index/SegmentInfo.java
+++ b/src/java/org/apache/lucene/index/SegmentInfo.java
@@ -23,7 +23,10 @@ import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.util.BitVector;
 import java.io.IOException;
 import java.util.List;
+import java.util.Map;
+import java.util.HashMap;
 import java.util.ArrayList;
+import java.util.Collections;
 
 final class SegmentInfo {
 
@@ -79,6 +82,8 @@ final class SegmentInfo {
 
   private boolean hasProx;                        // True if this segment has any fields with omitTermFreqAndPositions==false
 
+  private Map diagnostics;
+
   public String toString() {
     return "si: "+dir.toString()+" "+name+" docCount: "+docCount+" delCount: "+delCount+" delFileName: "+getDelFileName();
   }
@@ -139,6 +144,16 @@ final class SegmentInfo {
     delCount = src.delCount;
   }
 
+  // must be Map<String, String>
+  void setDiagnostics(Map diagnostics) {
+    this.diagnostics = diagnostics;
+  }
+
+  // returns Map<String, String>
+  Map getDiagnostics() {
+    return diagnostics;
+  }
+
   /**
    * Construct a new SegmentInfo instance by reading a
    * previously saved SegmentInfo from input.
@@ -192,6 +207,12 @@ final class SegmentInfo {
         hasProx = input.readByte() == 1;
       else
         hasProx = true;
+
+      if (format <= SegmentInfos.FORMAT_DIAGNOSTICS) {
+        diagnostics = input.readStringStringMap();
+      } else {
+        diagnostics = Collections.EMPTY_MAP;
+      }
     } else {
       delGen = CHECK_DIR;
       normGen = null;
@@ -203,6 +224,7 @@ final class SegmentInfo {
       docStoreSegment = null;
       delCount = -1;
       hasProx = true;
+      diagnostics = Collections.EMPTY_MAP;
     }
   }
   
@@ -290,8 +312,10 @@ final class SegmentInfo {
     si.isCompoundFile = isCompoundFile;
     si.delGen = delGen;
     si.delCount = delCount;
+    si.hasProx = hasProx;
     si.preLockless = preLockless;
     si.hasSingleNormFile = hasSingleNormFile;
+    si.diagnostics = new HashMap(diagnostics);
     if (normGen != null) {
       si.normGen = (long[]) normGen.clone();
     }
@@ -527,6 +551,7 @@ final class SegmentInfo {
     output.writeByte(isCompoundFile);
     output.writeInt(delCount);
     output.writeByte((byte) (hasProx ? 1:0));
+    output.writeStringStringMap(diagnostics);
   }
 
   void setHasProx(boolean hasProx) {
diff --git a/src/java/org/apache/lucene/index/SegmentInfos.java b/src/java/org/apache/lucene/index/SegmentInfos.java
index 787bda8..35c9db5 100644
--- a/src/java/org/apache/lucene/index/SegmentInfos.java
+++ b/src/java/org/apache/lucene/index/SegmentInfos.java
@@ -31,7 +31,10 @@ import java.io.IOException;
 import java.io.PrintStream;
 import java.util.Vector;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.HashSet;
+import java.util.HashMap;
+import java.util.Map;
 
 final class SegmentInfos extends Vector {
 
@@ -76,8 +79,12 @@ final class SegmentInfos extends Vector {
   /** This format adds optional commit userData (String) storage. */
   public static final int FORMAT_USER_DATA = -8;
 
+  /** This format adds optional per-segment String
+   *  dianostics storage, and switches userData to Map */
+  public static final int FORMAT_DIAGNOSTICS = -9;
+
   /* This must always point to the most recent file format. */
-  static final int CURRENT_FORMAT = FORMAT_USER_DATA;
+  static final int CURRENT_FORMAT = FORMAT_DIAGNOSTICS;
   
   public int counter = 0;    // used to name new segments
   /**
@@ -91,7 +98,7 @@ final class SegmentInfos extends Vector {
                                    // or wrote; this is normally the same as generation except if
                                    // there was an IOException that had interrupted a commit
 
-  private String userData;                        // Opaque String that user can specify during IndexWriter.commit
+  private Map userData = Collections.EMPTY_MAP;       // Opaque Map<String, String> that user can specify during IndexWriter.commit
 
   /**
    * If non-null, information about loading segments_N files
@@ -252,10 +259,16 @@ final class SegmentInfos extends Vector {
       }
 
       if (format <= FORMAT_USER_DATA) {
-        if (0 == input.readByte())
-          userData = null;
-        else
-          userData = input.readString();
+        if (format <= FORMAT_DIAGNOSTICS) {
+          userData = input.readStringStringMap();
+        } else {
+          userData = Collections.EMPTY_MAP;
+          if (0 != input.readByte()) {
+            userData.put("userData", input.readString());
+          }
+        }
+      } else {
+        userData = Collections.EMPTY_MAP;
       }
 
       if (format <= FORMAT_CHECKSUM) {
@@ -323,12 +336,7 @@ final class SegmentInfos extends Vector {
       for (int i = 0; i < size(); i++) {
         info(i).write(segnOutput);
       }
-      if (userData == null)
-        segnOutput.writeByte((byte) 0);
-      else {
-        segnOutput.writeByte((byte) 1);
-        segnOutput.writeString(userData);
-      }
+      segnOutput.writeStringStringMap(userData);
       segnOutput.prepareCommit();
       success = true;
       pendingSegnOutput = segnOutput;
@@ -362,6 +370,7 @@ final class SegmentInfos extends Vector {
     for(int i=0;i<sis.size();i++) {
       sis.set(i, sis.info(i).clone());
     }
+    sis.userData = new HashMap(userData);
     return sis;
   }
 
@@ -422,7 +431,7 @@ final class SegmentInfos extends Vector {
    * @throws CorruptIndexException if the index is corrupt
    * @throws IOException if there is a low-level IO error
    */
-  public static String readCurrentUserData(Directory directory)
+  public static Map readCurrentUserData(Directory directory)
     throws CorruptIndexException, IOException {
     SegmentInfos sis = new SegmentInfos();
     sis.read(directory);
@@ -899,12 +908,16 @@ final class SegmentInfos extends Vector {
     return buffer.toString();
   }
 
-  public String getUserData() {
+  public Map getUserData() {
     return userData;
   }
 
-  public void setUserData(String data) {
-    userData = data;
+  public void setUserData(Map data) {
+    if (data == null) {
+      userData = Collections.EMPTY_MAP;
+    } else {
+      userData = data;
+    }
   }
 
   /** Replaces all segments in this instance, but keeps
diff --git a/src/java/org/apache/lucene/index/SnapshotDeletionPolicy.java b/src/java/org/apache/lucene/index/SnapshotDeletionPolicy.java
index 064baf1..20fb5e0 100644
--- a/src/java/org/apache/lucene/index/SnapshotDeletionPolicy.java
+++ b/src/java/org/apache/lucene/index/SnapshotDeletionPolicy.java
@@ -20,6 +20,7 @@ package org.apache.lucene.index;
 import java.util.Collection;
 import java.util.List;
 import java.util.ArrayList;
+import java.util.Map;
 import java.io.IOException;
 import org.apache.lucene.store.Directory;
 
@@ -118,7 +119,7 @@ public class SnapshotDeletionPolicy implements IndexDeletionPolicy {
     public long getGeneration() {
       return cp.getGeneration();
     }
-    public String getUserData() throws IOException {
+    public Map getUserData() throws IOException {
       return cp.getUserData();
     }
   }
diff --git a/src/java/org/apache/lucene/store/IndexInput.java b/src/java/org/apache/lucene/store/IndexInput.java
index d414ed8..cd9b1703 100644
--- a/src/java/org/apache/lucene/store/IndexInput.java
+++ b/src/java/org/apache/lucene/store/IndexInput.java
@@ -18,6 +18,8 @@ package org.apache.lucene.store;
  */
 
 import java.io.IOException;
+import java.util.Map;
+import java.util.HashMap;
 
 /** Abstract base class for input from a file in a {@link Directory}.  A
  * random-access input stream.  Used for all Lucene index input operations.
@@ -226,4 +228,16 @@ public abstract class IndexInput implements Cloneable {
     return clone;
   }
 
+  // returns Map<String, String>
+  public Map readStringStringMap() throws IOException {
+    final Map map = new HashMap();
+    final int count = readInt();
+    for(int i=0;i<count;i++) {
+      final String key = readString();
+      final String val = readString();
+      map.put(key, val);
+    }
+
+    return map;
+  }
 }
diff --git a/src/java/org/apache/lucene/store/IndexOutput.java b/src/java/org/apache/lucene/store/IndexOutput.java
index acd4dcf..977881f 100644
--- a/src/java/org/apache/lucene/store/IndexOutput.java
+++ b/src/java/org/apache/lucene/store/IndexOutput.java
@@ -18,6 +18,8 @@ package org.apache.lucene.store;
  */
 
 import java.io.IOException;
+import java.util.Map;
+import java.util.Iterator;
 import org.apache.lucene.util.UnicodeUtil;
 
 /** Abstract base class for output to a file in a Directory.  A random-access
@@ -206,4 +208,19 @@ public abstract class IndexOutput {
    * @param length file length
    */
   public void setLength(long length) throws IOException {};
+
+  // map must be Map<String, String>
+  public void writeStringStringMap(Map map) throws IOException {
+    if (map == null) {
+      writeInt(0);
+    } else {
+      writeInt(map.size());
+      final Iterator it = map.entrySet().iterator();
+      while(it.hasNext()) {
+        Map.Entry entry = (Map.Entry) it.next();
+        writeString((String) entry.getKey());
+        writeString((String) entry.getValue());
+      }
+    }
+  }
 }
diff --git a/src/java/org/apache/lucene/util/Constants.java b/src/java/org/apache/lucene/util/Constants.java
index 4023fea..6d9da3f 100644
--- a/src/java/org/apache/lucene/util/Constants.java
+++ b/src/java/org/apache/lucene/util/Constants.java
@@ -17,6 +17,11 @@ package org.apache.lucene.util;
  * limitations under the License.
  */
 
+import java.util.jar.Manifest;
+import java.util.jar.Attributes;
+import java.io.InputStream;
+import java.net.URL;
+
 /**
  * Some useful constants.
  *
@@ -44,4 +49,36 @@ public final class Constants {
   public static final boolean WINDOWS = OS_NAME.startsWith("Windows");
   /** True iff running on SunOS. */
   public static final boolean SUN_OS = OS_NAME.startsWith("SunOS");
+
+  public static final String OS_ARCH = System.getProperty("os.arch");
+  public static final String OS_VERSION = System.getProperty("os.version");
+  public static final String JAVA_VENDOR = System.getProperty("java.vendor");
+
+  public static final String LUCENE_VERSION;
+
+  public static final String LUCENE_MAIN_VERSION = "2.9-dev";
+
+  static {
+    String v = LUCENE_MAIN_VERSION;
+    try {
+      // TODO: this should have worked, but doesn't seem to?
+      // Package.getPackage("org.apache.lucene.util").getImplementationVersion();
+      String classContainer = Constants.class.getProtectionDomain().getCodeSource().getLocation().toString();
+      URL manifestUrl = new URL("jar:" + classContainer + "!/META-INF/MANIFEST.MF");
+      InputStream s = manifestUrl.openStream();
+      try {
+        Manifest manifest = new Manifest(s);
+        Attributes attr = manifest.getMainAttributes();
+        v = attr.getValue(Attributes.Name.IMPLEMENTATION_VERSION);
+      } finally {
+        if (s != null) {
+          s.close();
+        }
+      }
+    } catch (Throwable t) {
+      // ignore
+    }
+
+    LUCENE_VERSION = v;
+  }
 }
diff --git a/src/site/src/documentation/content/xdocs/fileformats.xml b/src/site/src/documentation/content/xdocs/fileformats.xml
index b561f9e..50853e1 100644
--- a/src/site/src/documentation/content/xdocs/fileformats.xml
+++ b/src/site/src/documentation/content/xdocs/fileformats.xml
@@ -757,6 +757,21 @@
                 </p>
 
             </section>
+        </section>
+
+        <section id="Compound Types"><title>Compound Types</title>
+            <section id="String"><title>Map&lt;String,String&gt;</title>
+
+                <p>
+		    In a couple places Lucene stores a Map
+                    String-&gt;String.
+                </p>
+
+                <p>
+  		    Map&lt;String,String&gt; --&gt; Count&lt;String,String&gt;<sup>Count</sup>
+                </p>
+
+            </section>
 
         </section>
 
@@ -834,7 +849,7 @@
                     <b>2.9 and above:</b>
                     Segments --&gt; Format, Version, NameCounter, SegCount, &lt;SegName, SegSize, DelGen, DocStoreOffset, [DocStoreSegment, DocStoreIsCompoundFile], HasSingleNormFile, NumField,
                     NormGen<sup>NumField</sup>,
-                    IsCompoundFile, DeletionCount, HasProx&gt;<sup>SegCount</sup>, HasUserData, CommitUserData?, Checksum
+                    IsCompoundFile, DeletionCount, HasProx, Diagnostics&gt;<sup>SegCount</sup>, CommitUserData, Checksum
                 </p>
 
                 <p>
@@ -842,21 +857,29 @@
                     DocStoreOffset, DeletionCount --&gt; Int32
                 </p>
 
-                <p>
+               <p>
                     Version, DelGen, NormGen, Checksum --&gt; Int64
                 </p>
 
                 <p>
-                    SegName, DocStoreSegment, CommitUserData --&gt; String
+                   SegName, DocStoreSegment --&gt; String
                 </p>
 
+		<p>
+		   Diagnostics --&gt; Map&lt;String,String&gt;
+		</p>
+
                 <p>
                     IsCompoundFile, HasSingleNormFile,
-                    DocStoreIsCompoundFile, HasProx, HasUserData --&gt; Int8
+                    DocStoreIsCompoundFile, HasProx --&gt; Int8
+                </p>
+
+		<p>
+		    CommitUserData --&gt; Map&lt;String,String&gt;
                 </p>
 
                 <p>
-                    Format is -1 as of Lucene 1.4, -3 (SegmentInfos.FORMAT_SINGLE_NORM_FILE) as of Lucene 2.1 and 2.2, -4 (SegmentInfos.FORMAT_SHARED_DOC_STORE) as of Lucene 2.3, -7 (SegmentInfos.FORMAT_HAS_PROX) as of Lucene 2.4, and -8 (SegmentInfos.FORMAT_USER_DATA) as of Lucene 2.9.
+                    Format is -1 as of Lucene 1.4, -3 (SegmentInfos.FORMAT_SINGLE_NORM_FILE) as of Lucene 2.1 and 2.2, -4 (SegmentInfos.FORMAT_SHARED_DOC_STORE) as of Lucene 2.3, -7 (SegmentInfos.FORMAT_HAS_PROX) as of Lucene 2.4, and -9 (SegmentInfos.FORMAT_DIAGNOSTICS) as of Lucene 2.9.
                 </p>
 
                 <p>
@@ -958,10 +981,17 @@
 		</p>
 
 		<p>
-		    If HasUserData is 1, then the string
-		    CommitUserData is non-null and is stored.  This is
-		    a string previously passed to IndexWriter's commit
-		    or prepareCommit method.
+		    CommitUserData stores an optional user-supplied
+		    opaque Map&lt;String,String&gt; that was passed to
+		    IndexWriter's commit or prepareCommit, or
+		    IndexReader's flush methods.
+                </p>
+		<p>
+		    The Diagnostics Map is privately written by
+		    IndexWriter, as a debugging aid, for each segment
+		    it creates.  It includes metadata like the current
+		    Lucene version, OS, Java version, why the segment
+		    was created (merge, flush, addIndexes), etc.
                 </p>
 
             </section>
diff --git a/src/test/org/apache/lucene/index/TestCheckIndex.java b/src/test/org/apache/lucene/index/TestCheckIndex.java
index cf30147..85f1521 100644
--- a/src/test/org/apache/lucene/index/TestCheckIndex.java
+++ b/src/test/org/apache/lucene/index/TestCheckIndex.java
@@ -28,6 +28,7 @@ import org.apache.lucene.store.MockRAMDirectory;
 import org.apache.lucene.analysis.WhitespaceAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
+import org.apache.lucene.util.Constants;
 
 public class TestCheckIndex extends LuceneTestCase {
 
@@ -55,11 +56,22 @@ public class TestCheckIndex extends LuceneTestCase {
       System.out.println(bos.toString());
       fail();
     }
-    assertTrue(((CheckIndex.Status.SegmentInfoStatus) indexStatus.segmentInfos.get(0)).openReaderPassed);
+    
+    final CheckIndex.Status.SegmentInfoStatus seg = (CheckIndex.Status.SegmentInfoStatus) indexStatus.segmentInfos.get(0);
+    assertTrue(seg.openReaderPassed);
 
+    assertNotNull(seg.diagnostics);
+    assertTrue(seg.diagnostics.size() > 0);
     final List onlySegments = new ArrayList();
     onlySegments.add("_0");
     
     assertTrue(checker.checkIndex(onlySegments).clean == true);
   }
+
+  public void testLuceneConstantVersion() throws IOException {
+    // common-build.xml sets lucene.version
+    final String version = System.getProperty("lucene.version");
+    assertEquals(version, Constants.LUCENE_MAIN_VERSION);
+    assertTrue(Constants.LUCENE_VERSION.startsWith(version));
+  }
 }
diff --git a/src/test/org/apache/lucene/index/TestIndexReader.java b/src/test/org/apache/lucene/index/TestIndexReader.java
index 858a724..88176f6 100644
--- a/src/test/org/apache/lucene/index/TestIndexReader.java
+++ b/src/test/org/apache/lucene/index/TestIndexReader.java
@@ -26,6 +26,7 @@ import java.util.Collection;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
+import java.util.HashMap;
 import java.util.Set;
 
 import junit.framework.TestSuite;
@@ -70,8 +71,9 @@ public class TestIndexReader extends LuceneTestCase
     
     public void testCommitUserData() throws Exception {
       RAMDirectory d = new MockRAMDirectory();
-      
-      String cmpCommitUserData = "foo fighters";
+
+      Map commitUserData = new HashMap();
+      commitUserData.put("foo", "fighters");
       
       // set up writer
       IndexWriter writer = new IndexWriter(d, new StandardAnalyzer(), true, IndexWriter.MaxFieldLength.LIMITED);
@@ -82,14 +84,14 @@ public class TestIndexReader extends LuceneTestCase
       
       IndexReader r = IndexReader.open(d);
       r.deleteDocument(5);
-      r.flush(cmpCommitUserData);
+      r.flush(commitUserData);
       r.close();
       
       SegmentInfos sis = new SegmentInfos();
       sis.read(d);
       IndexReader r2 = IndexReader.open(d);
       IndexCommit c = r.getIndexCommit();
-      assertEquals(c.getUserData(), cmpCommitUserData);
+      assertEquals(c.getUserData(), commitUserData);
 
       assertEquals(sis.getCurrentSegmentFileName(), c.getSegmentsFileName());
 
diff --git a/src/test/org/apache/lucene/index/TestIndexReaderReopen.java b/src/test/org/apache/lucene/index/TestIndexReaderReopen.java
index 479bd77..a25e642 100644
--- a/src/test/org/apache/lucene/index/TestIndexReaderReopen.java
+++ b/src/test/org/apache/lucene/index/TestIndexReaderReopen.java
@@ -25,6 +25,8 @@ import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
+import java.util.Map;
+import java.util.HashMap;
 import java.util.Set;
 
 import org.apache.lucene.analysis.KeywordAnalyzer;
@@ -1233,11 +1235,15 @@ public class TestIndexReaderReopen extends LuceneTestCase {
       Document doc = new Document();
       doc.add(new Field("id", ""+i, Field.Store.NO, Field.Index.NOT_ANALYZED));
       writer.addDocument(doc);
-      writer.commit(""+i);
+      Map data = new HashMap();
+      data.put("index", i+"");
+      writer.commit(data);
     }
     for(int i=0;i<4;i++) {
       writer.deleteDocuments(new Term("id", ""+i));
-      writer.commit(""+(4+i));
+      Map data = new HashMap();
+      data.put("index", (4+i)+"");
+      writer.commit(data);
     }
     writer.close();
 
@@ -1259,13 +1265,13 @@ public class TestIndexReaderReopen extends LuceneTestCase {
         // expected
       }
 
-      final String s = commit.getUserData();
+      final Map s = commit.getUserData();
       final int v;
-      if (s == null) {
+      if (s.size() == 0) {
         // First commit created by IW
         v = -1;
       } else {
-        v = Integer.parseInt(s);
+        v = Integer.parseInt((String) s.get("index"));
       }
       if (v < 4) {
         assertEquals(1+v, r2.numDocs());
diff --git a/src/test/org/apache/lucene/index/TestIndexWriter.java b/src/test/org/apache/lucene/index/TestIndexWriter.java
index 092d059..f63939b 100644
--- a/src/test/org/apache/lucene/index/TestIndexWriter.java
+++ b/src/test/org/apache/lucene/index/TestIndexWriter.java
@@ -26,6 +26,8 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Random;
+import java.util.Map;
+import java.util.HashMap;
 
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.SinkTokenizer;
@@ -4096,31 +4098,33 @@ public class TestIndexWriter extends LuceneTestCase
       addDoc(w);
     w.close();
 
-    assertEquals(null, IndexReader.getCommitUserData(dir));
+    assertEquals(0, IndexReader.getCommitUserData(dir).size());
 
     IndexReader r = IndexReader.open(dir);
-    // commit(String) never called for this index
-    assertEquals(null, r.getCommitUserData());
+    // commit(Map) never called for this index
+    assertEquals(0, r.getCommitUserData().size());
     r.close();
       
     w = new IndexWriter(dir, new WhitespaceAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);
     w.setMaxBufferedDocs(2);
     for(int j=0;j<17;j++)
       addDoc(w);
-    w.commit("test1");
+    Map data = new HashMap();
+    data.put("label", "test1");
+    w.commit(data);
     w.close();
       
-    assertEquals("test1", IndexReader.getCommitUserData(dir));
+    assertEquals("test1", IndexReader.getCommitUserData(dir).get("label"));
 
     r = IndexReader.open(dir);
-    assertEquals("test1", r.getCommitUserData());
+    assertEquals("test1", r.getCommitUserData().get("label"));
     r.close();
 
     w = new IndexWriter(dir, new WhitespaceAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);
     w.optimize();
     w.close();
 
-    assertEquals("test1", IndexReader.getCommitUserData(dir));
+    assertEquals("test1", IndexReader.getCommitUserData(dir).get("label"));
       
     dir.close();
   }
diff --git a/src/test/org/apache/lucene/index/TestTransactionRollback.java b/src/test/org/apache/lucene/index/TestTransactionRollback.java
index 1a60771..4c61559 100644
--- a/src/test/org/apache/lucene/index/TestTransactionRollback.java
+++ b/src/test/org/apache/lucene/index/TestTransactionRollback.java
@@ -23,6 +23,8 @@ import java.util.BitSet;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
+import java.util.HashMap;
 
 import junit.framework.TestCase;
 
@@ -55,9 +57,9 @@ public class TestTransactionRollback extends TestCase {
     Collection commits = IndexReader.listCommits(dir);
     for (Iterator iterator = commits.iterator(); iterator.hasNext();) {
       IndexCommit commit = (IndexCommit) iterator.next();
-      String ud=commit.getUserData();
-      if (ud != null)
-        if (ud.endsWith(ids))
+      Map ud=commit.getUserData();
+      if (ud.size() > 0)
+        if (((String) ud.get("index")).endsWith(ids))
           last=commit;
     }
 
@@ -66,7 +68,9 @@ public class TestTransactionRollback extends TestCase {
 		
     IndexWriter w = new IndexWriter(dir, new WhitespaceAnalyzer(),
                                     new RollbackDeletionPolicy(id), MaxFieldLength.UNLIMITED, last);
-    w.commit("Rolled back to 1-"+id);
+    Map data = new HashMap();
+    data.put("index", "Rolled back to 1-"+id);
+    w.commit(data);
     w.close();
   }
 
@@ -101,6 +105,7 @@ public class TestTransactionRollback extends TestCase {
     assertEquals("Should have 0 docs remaining ", 0 ,expecteds.cardinality());
   }
 
+  /*
   private void showAvailableCommitPoints() throws Exception {
     Collection commits = IndexReader.listCommits(dir);
     for (Iterator iterator = commits.iterator(); iterator.hasNext();) {
@@ -114,6 +119,7 @@ public class TestTransactionRollback extends TestCase {
       System.out.println();
     }
   }
+  */
 
   protected void setUp() throws Exception {
     dir = new MockRAMDirectory();
@@ -126,15 +132,15 @@ public class TestTransactionRollback extends TestCase {
     //Build index, of records 1 to 100, committing after each batch of 10
     IndexDeletionPolicy sdp=new KeepAllDeletionPolicy();
     IndexWriter w=new IndexWriter(dir,new WhitespaceAnalyzer(),sdp,MaxFieldLength.UNLIMITED);
-    int firstRecordIdInThisTransaction=1;
     for(int currentRecordId=1;currentRecordId<=100;currentRecordId++) {
       Document doc=new Document();
       doc.add(new Field(FIELD_RECORD_ID,""+currentRecordId,Field.Store.YES,Field.Index.ANALYZED));
       w.addDocument(doc);
 			
       if (currentRecordId%10 == 0) {
-        String userData="records 1-"+currentRecordId;
-        w.commit(userData);
+        Map data = new HashMap();
+        data.put("index", "records 1-"+currentRecordId);
+        w.commit(data);
       }
     }
 
@@ -155,12 +161,13 @@ public class TestTransactionRollback extends TestCase {
     public void onInit(List commits) throws IOException {
       for (Iterator iterator = commits.iterator(); iterator.hasNext();) {
         IndexCommit commit = (IndexCommit) iterator.next();
-        String userData=commit.getUserData();
-        if (userData != null) {
+        Map userData=commit.getUserData();
+        if (userData.size() > 0) {
           // Label for a commit point is "Records 1-30"
           // This code reads the last id ("30" in this example) and deletes it
           // if it is after the desired rollback point
-          String lastVal = userData.substring(userData.lastIndexOf("-")+1);
+          String x = (String) userData.get("index");
+          String lastVal = x.substring(x.lastIndexOf("-")+1);
           int last = Integer.parseInt(lastVal);
           if (last>rollbackPoint) {
             /*

