GitDiffStart: eb1542030e489c947bef59d3afc4d9aa03cf06c8 | Wed Jun 24 12:50:19 2015 +0000
diff --git a/lucene/ivy-versions.properties b/lucene/ivy-versions.properties
index bd05786..78cebbb 100644
--- a/lucene/ivy-versions.properties
+++ b/lucene/ivy-versions.properties
@@ -22,10 +22,11 @@ com.codahale.metrics.version = 3.0.1
 
 /com.facebook.presto/presto-parser = 0.107
 
-com.fasterxml.jackson.core.version = 2.3.1
+com.fasterxml.jackson.core.version = 2.5.4
 /com.fasterxml.jackson.core/jackson-annotations = ${com.fasterxml.jackson.core.version}
 /com.fasterxml.jackson.core/jackson-core = ${com.fasterxml.jackson.core.version}
 /com.fasterxml.jackson.core/jackson-databind = ${com.fasterxml.jackson.core.version}
+/com.fasterxml.jackson.dataformat/jackson-dataformat-smile = ${com.fasterxml.jackson.core.version}
 
 /com.github.ben-manes.caffeine/caffeine = 1.0.1
 
diff --git a/solr/CHANGES.txt b/solr/CHANGES.txt
index 92cee0d..0bcb94b 100644
--- a/solr/CHANGES.txt
+++ b/solr/CHANGES.txt
@@ -139,6 +139,8 @@ New Features
 * SOLR-7182: Make the Schema-API a first class citizen of SolrJ. The new SchemaRequest and its inner
   classes can be used to make requests to the Schema API. (Sven Windisch, Marius Grama via shalin)
 
+* SOLR-7651: New response format added wt=smile (noble)
+
 Bug Fixes
 ----------------------
 
diff --git a/solr/core/ivy.xml b/solr/core/ivy.xml
index 79308d6..912d5c2 100644
--- a/solr/core/ivy.xml
+++ b/solr/core/ivy.xml
@@ -53,6 +53,12 @@
     <dependency org="org.objenesis" name="objenesis" rev="${/org.objenesis/objenesis}" conf="test"/>
     <dependency org="org.slf4j" name="jcl-over-slf4j" rev="${/org.slf4j/jcl-over-slf4j}" conf="test"/>
 
+    <dependency org="com.fasterxml.jackson.core" name="jackson-core" rev="${/com.fasterxml.jackson.core/jackson-core}" conf="compile"/>
+    <dependency org="com.fasterxml.jackson.core" name="jackson-databind" rev="${/com.fasterxml.jackson.core/jackson-databind}" conf="test"/>
+    <dependency org="com.fasterxml.jackson.core" name="jackson-annotations" rev="${/com.fasterxml.jackson.core/jackson-annotations}" conf="test"/>
+    <dependency org="com.fasterxml.jackson.dataformat" name="jackson-dataformat-smile" rev="${/com.fasterxml.jackson.dataformat/jackson-dataformat-smile}" conf="compile"/>
+
+
     <dependency org="org.apache.hadoop" name="hadoop-common" rev="${/org.apache.hadoop/hadoop-common}" conf="compile.hadoop"/>
     <!--
       hadoop-hdfs, hadoop-annotations and hadoop-auth are runtime dependencies,
diff --git a/solr/core/src/java/org/apache/solr/core/SolrCore.java b/solr/core/src/java/org/apache/solr/core/SolrCore.java
index 8f0cb70..04f3c48 100644
--- a/solr/core/src/java/org/apache/solr/core/SolrCore.java
+++ b/solr/core/src/java/org/apache/solr/core/SolrCore.java
@@ -103,6 +103,7 @@ import org.apache.solr.response.QueryResponseWriter;
 import org.apache.solr.response.RawResponseWriter;
 import org.apache.solr.response.RubyResponseWriter;
 import org.apache.solr.response.SchemaXmlResponseWriter;
+import org.apache.solr.response.SmileResponseWriter;
 import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.response.SortingResponseWriter;
 import org.apache.solr.response.XMLResponseWriter;
@@ -2160,6 +2161,7 @@ public final class SolrCore implements SolrInfoMBean, Closeable {
     m.put("csv", new CSVResponseWriter());
     m.put("xsort", new SortingResponseWriter());
     m.put("schema.xml", new SchemaXmlResponseWriter());
+    m.put("smile", new SmileResponseWriter());
     m.put(ReplicationHandler.FILE_STREAM, getFileStreamWriter());
     DEFAULT_RESPONSE_WRITERS = Collections.unmodifiableMap(m);
   }
diff --git a/solr/core/src/java/org/apache/solr/response/JSONResponseWriter.java b/solr/core/src/java/org/apache/solr/response/JSONResponseWriter.java
index 27ab93c..92f568d 100644
--- a/solr/core/src/java/org/apache/solr/response/JSONResponseWriter.java
+++ b/solr/core/src/java/org/apache/solr/response/JSONResponseWriter.java
@@ -310,16 +310,6 @@ class JSONWriter extends TextResponseWriter {
   }
 
 
-  protected static class MultiValueField {
-    final SchemaField sfield;
-    final ArrayList<IndexableField> fields;
-    MultiValueField(SchemaField sfield, IndexableField firstVal) {
-      this.sfield = sfield;
-      this.fields = new ArrayList<>(4);
-      this.fields.add(firstVal);
-    }
-  }
-
   @Override
   public void writeSolrDocument(String name, SolrDocument doc, ReturnFields returnFields, int idx) throws IOException {
     if( idx > 0 ) {
diff --git a/solr/core/src/java/org/apache/solr/response/SmileResponseWriter.java b/solr/core/src/java/org/apache/solr/response/SmileResponseWriter.java
new file mode 100644
index 0000000..31aa8b3
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/response/SmileResponseWriter.java
@@ -0,0 +1,199 @@
+package org.apache.solr.response;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+
+import com.fasterxml.jackson.dataformat.smile.SmileFactory;
+import com.fasterxml.jackson.dataformat.smile.SmileGenerator;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.request.SolrQueryRequest;
+
+public class SmileResponseWriter extends BinaryResponseWriter {
+
+  @Override
+  public void write(OutputStream out, SolrQueryRequest request, SolrQueryResponse response) throws IOException {
+    new SmileWriter(out, request, response).writeResponse();
+  }
+
+  @Override
+  public void init(NamedList args) {
+
+  }
+  //smile format is an equivalent of JSON format . So we extend JSONWriter and override the relevant methods
+
+  public static class SmileWriter extends JSONWriter {
+    protected final SmileGenerator gen;
+    protected final OutputStream out;
+
+    public SmileWriter(OutputStream out, SolrQueryRequest req, SolrQueryResponse rsp) {
+      super(null, req, rsp);
+      this.out = out;
+      SmileFactory smileFactory = new SmileFactory();
+      smileFactory.enable(SmileGenerator.Feature.CHECK_SHARED_NAMES);
+      try {
+        gen = smileFactory.createGenerator(this.out, null);
+      } catch (IOException e) {
+        throw new RuntimeException(e);
+      }
+    }
+
+
+    @Override
+    public void writeResponse() throws IOException {
+      //we always write header , it is just 4 bytes and not worth optimizing
+      gen.writeHeader();
+      super.writeNamedList(null, rsp.getValues());
+      gen.close();
+    }
+
+    @Override
+    protected void writeNumber(String name, Number val) throws IOException {
+      if (val instanceof Integer) {
+        gen.writeNumber(val.intValue());
+      } else if (val instanceof Long) {
+        gen.writeNumber(val.longValue());
+      } else if (val instanceof Float) {
+        gen.writeNumber(val.floatValue());
+      } else if (val instanceof Double) {
+        gen.writeNumber(val.floatValue());
+      } else if (val instanceof Short) {
+        gen.writeNumber(val.shortValue());
+      } else if (val instanceof Byte) {
+        gen.writeNumber(val.byteValue());
+      } else if (val instanceof BigInteger) {
+        gen.writeNumber((BigInteger) val);
+      } else if (val instanceof BigDecimal) {
+        gen.writeNumber((BigDecimal) val);
+      } else {
+        gen.writeString(val.getClass().getName() + ':' + val.toString());
+        // default... for debugging only
+      }
+    }
+
+    @Override
+    public void writeBool(String name, Boolean val) throws IOException {
+      gen.writeBoolean(val);
+    }
+
+    @Override
+    public void writeNull(String name) throws IOException {
+      gen.writeNull();
+    }
+
+    @Override
+    public void writeStr(String name, String val, boolean needsEscaping) throws IOException {
+      gen.writeString(val);
+    }
+
+    @Override
+    public void writeLong(String name, long val) throws IOException {
+      gen.writeNumber(val);
+    }
+
+    @Override
+    public void writeInt(String name, int val) throws IOException {
+      gen.writeNumber(val);
+    }
+
+    @Override
+    public void writeBool(String name, boolean val) throws IOException {
+      gen.writeBoolean(val);
+    }
+
+    @Override
+    public void writeFloat(String name, float val) throws IOException {
+      gen.writeNumber(val);
+    }
+
+    @Override
+    public void writeArrayCloser() throws IOException {
+      gen.writeEndArray();
+    }
+
+    @Override
+    public void writeArraySeparator() throws IOException {
+      //do nothing
+    }
+
+    @Override
+    public void writeArrayOpener(int size) throws IOException, IllegalArgumentException {
+      gen.writeStartArray();
+    }
+
+    @Override
+    public void writeMapCloser() throws IOException {
+      gen.writeEndObject();
+    }
+
+    @Override
+    public void writeMapSeparator() throws IOException {
+      //do nothing
+    }
+
+    @Override
+    public void writeMapOpener(int size) throws IOException, IllegalArgumentException {
+      gen.writeStartObject();
+    }
+
+    @Override
+    protected void writeKey(String fname, boolean needsEscaping) throws IOException {
+      gen.writeFieldName(fname);
+    }
+
+    @Override
+    public void writeByteArr(String name, byte[] buf, int offset, int len) throws IOException {
+      gen.writeBinary(buf, offset, len);
+
+    }
+
+    @Override
+    public void setLevel(int level) {
+      //do nothing
+    }
+
+    @Override
+    public int level() {
+      return 0;
+    }
+
+    @Override
+    public void indent() throws IOException {
+      //do nothing
+    }
+
+    @Override
+    public void indent(int lev) throws IOException {
+      //do nothing
+    }
+
+    @Override
+    public int incLevel() {
+      return 0;
+    }
+
+    @Override
+    public int decLevel() {
+      return 0;
+    }
+  }
+}
diff --git a/solr/core/src/java/org/apache/solr/response/TextResponseWriter.java b/solr/core/src/java/org/apache/solr/response/TextResponseWriter.java
index e23de07..0ed17f5 100644
--- a/solr/core/src/java/org/apache/solr/response/TextResponseWriter.java
+++ b/solr/core/src/java/org/apache/solr/response/TextResponseWriter.java
@@ -68,7 +68,7 @@ public abstract class TextResponseWriter {
 
 
   public TextResponseWriter(Writer writer, SolrQueryRequest req, SolrQueryResponse rsp) {
-    this.writer = FastWriter.wrap(writer);
+    this.writer = writer == null ? null: FastWriter.wrap(writer);
     this.schema = req.getSchema();
     this.req = req;
     this.rsp = rsp;
@@ -81,7 +81,7 @@ public abstract class TextResponseWriter {
 
   /** done with this ResponseWriter... make sure any buffers are flushed to writer */
   public void close() throws IOException {
-    writer.flushBuffer();
+    if(writer != null) writer.flushBuffer();
   }
 
   /** returns the Writer that the response is being written to */
@@ -132,26 +132,9 @@ public abstract class TextResponseWriter {
         writeStr(name, f.stringValue(), true);
       }
     } else if (val instanceof Number) {
-      if (val instanceof Integer) {
-        writeInt(name, val.toString());
-      } else if (val instanceof Long) {
-        writeLong(name, val.toString());
-      } else if (val instanceof Float) {
-        // we pass the float instead of using toString() because
-        // it may need special formatting. same for double.
-        writeFloat(name, ((Float)val).floatValue());
-      } else if (val instanceof Double) {
-        writeDouble(name, ((Double)val).doubleValue());        
-      } else if (val instanceof Short) {
-        writeInt(name, val.toString());
-      } else if (val instanceof Byte) {
-        writeInt(name, val.toString());
-      } else {
-        // default... for debugging only
-        writeStr(name, val.getClass().getName() + ':' + val.toString(), true);
-      }
+      writeNumber(name, (Number)val);
     } else if (val instanceof Boolean) {
-      writeBool(name, val.toString());
+      writeBool(name, (Boolean)val);
     } else if (val instanceof Date) {
       writeDate(name,(Date)val);
     } else if (val instanceof StoredDocument) {
@@ -202,6 +185,31 @@ public abstract class TextResponseWriter {
     }
   }
 
+  protected void writeBool(String name , Boolean val) throws IOException {
+    writeBool(name, val.toString());
+  }
+
+  protected void writeNumber(String name, Number val) throws IOException {
+    if (val instanceof Integer) {
+      writeInt(name, val.toString());
+    } else if (val instanceof Long) {
+      writeLong(name, val.toString());
+    } else if (val instanceof Float) {
+      // we pass the float instead of using toString() because
+      // it may need special formatting. same for double.
+      writeFloat(name, ((Float)val).floatValue());
+    } else if (val instanceof Double) {
+      writeDouble(name, ((Double)val).doubleValue());
+    } else if (val instanceof Short) {
+      writeInt(name, val.toString());
+    } else if (val instanceof Byte) {
+      writeInt(name, val.toString());
+    } else {
+      // default... for debugging only
+      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);
+    }
+  }
+
   // names are passed when writing primitives like writeInt to allow many different
   // types of formats, including those where the name may come after the value (like
   // some XML formats).
diff --git a/solr/core/src/test/org/apache/solr/request/SmileWriterTest.java b/solr/core/src/test/org/apache/solr/request/SmileWriterTest.java
new file mode 100644
index 0000000..8be90f2
--- /dev/null
+++ b/solr/core/src/test/org/apache/solr/request/SmileWriterTest.java
@@ -0,0 +1,255 @@
+package org.apache.solr.request;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.StringReader;
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.node.ArrayNode;
+import com.fasterxml.jackson.databind.node.BinaryNode;
+import com.fasterxml.jackson.databind.node.BooleanNode;
+import com.fasterxml.jackson.databind.node.NullNode;
+import com.fasterxml.jackson.databind.node.NumericNode;
+import com.fasterxml.jackson.databind.node.ObjectNode;
+import com.fasterxml.jackson.dataformat.smile.SmileFactory;
+import org.apache.solr.SolrTestCaseJ4;
+import org.apache.solr.common.SolrDocument;
+import org.apache.solr.common.SolrDocumentList;
+import org.apache.solr.common.cloud.ZkStateReader;
+import org.apache.solr.common.params.CommonParams;
+import org.apache.solr.common.params.ModifiableSolrParams;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.response.SmileResponseWriter;
+import org.apache.solr.response.SolrQueryResponse;
+import org.apache.solr.search.ReturnFields;
+import org.apache.solr.search.SolrReturnFields;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.noggit.CharArr;
+import org.noggit.JSONParser;
+import org.noggit.JSONWriter;
+import org.noggit.ObjectBuilder;
+
+public class SmileWriterTest extends SolrTestCaseJ4 {
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    initCore("solrconfig.xml","schema.xml");
+  }
+
+  @Test
+  public void testTypes() throws IOException {
+    SolrQueryRequest req = req("dummy");
+    SolrQueryResponse rsp = new SolrQueryResponse();
+    rsp.add("data1", Float.NaN);
+    rsp.add("data2", Double.NEGATIVE_INFINITY);
+    rsp.add("data3", Float.POSITIVE_INFINITY);
+    SmileResponseWriter smileResponseWriter = new SmileResponseWriter();
+    ByteArrayOutputStream baos = new ByteArrayOutputStream();
+    smileResponseWriter.write(baos,req,rsp);
+    Map m = (Map) decodeSmile(new ByteArrayInputStream(baos.toByteArray()));
+    CharArr out = new CharArr();
+    JSONWriter jsonWriter = new JSONWriter(out, 2);
+    jsonWriter.setIndentSize(-1); // indentation by default
+    jsonWriter.write(m);
+    String s = new String(ZkStateReader.toUTF8(out), StandardCharsets.UTF_8);
+    assertEquals(s , "{\"data1\":NaN,\"data2\":-Infinity,\"data3\":Infinity}");
+
+    req.close();
+  }
+
+  @Test
+  public void testJSON() throws IOException {
+    SolrQueryRequest req = req("wt","json","json.nl","arrarr");
+    SolrQueryResponse rsp = new SolrQueryResponse();
+    SmileResponseWriter w = new SmileResponseWriter();
+
+    ByteArrayOutputStream buf = new ByteArrayOutputStream();
+    NamedList nl = new NamedList();
+    nl.add("data1", "he\u2028llo\u2029!");       // make sure that 2028 and 2029 are both escaped (they are illegal in javascript)
+    nl.add(null, 42);
+    rsp.add("nl", nl);
+
+    rsp.add("byte", Byte.valueOf((byte)-3));
+    rsp.add("short", Short.valueOf((short)-4));
+    String expected = "{\"nl\":[[\"data1\",\"he\\u2028llo\\u2029!\"],[null,42]],byte:-3,short:-4}";
+    w.write(buf, req, rsp);
+    Map m = (Map) decodeSmile(new ByteArrayInputStream(buf.toByteArray()));
+    Map o2 = (Map) new ObjectBuilder(new JSONParser(new StringReader(expected))).getObject();
+    assertEquals(ZkStateReader.toJSONString(m),ZkStateReader.toJSONString(o2));
+    req.close();
+  }
+
+  @Test
+  public void testJSONSolrDocument() throws IOException {
+    SolrQueryRequest req = req(CommonParams.WT,"json",
+        CommonParams.FL,"id,score");
+    SolrQueryResponse rsp = new SolrQueryResponse();
+    SmileResponseWriter w = new SmileResponseWriter();
+
+    ReturnFields returnFields = new SolrReturnFields(req);
+    rsp.setReturnFields(returnFields);
+
+    ByteArrayOutputStream buf = new ByteArrayOutputStream();
+
+    SolrDocument solrDoc = new SolrDocument();
+    solrDoc.addField("id", "1");
+    solrDoc.addField("subject", "hello2");
+    solrDoc.addField("title", "hello3");
+    solrDoc.addField("score", "0.7");
+
+    SolrDocumentList list = new SolrDocumentList();
+    list.setNumFound(1);
+    list.setStart(0);
+    list.setMaxScore(0.7f);
+    list.add(solrDoc);
+
+    rsp.add("response", list);
+
+    w.write(buf, req, rsp);
+
+    byte[] bytes = buf.toByteArray();
+    Map m = (Map) decodeSmile(new ByteArrayInputStream(bytes));
+    m = (Map) m.get("response");
+    List l = (List) m.get("docs");
+    Map doc = (Map) l.get(0);
+    assertFalse(doc.containsKey("subject"));
+    assertFalse(doc.containsKey("title"));
+    assertTrue(doc.containsKey("id"));
+    assertTrue(doc.containsKey("score"));
+    req.close();
+  }
+
+
+  @Test
+  public void test10Docs() throws IOException {
+    SolrDocumentList l = new SolrDocumentList();
+    for(int i=0;i<10; i++){
+      l.add(sampleDoc(random(), i));
+    }
+
+    SolrQueryResponse response = new SolrQueryResponse();
+    response.getValues().add("results", l);
+    ByteArrayOutputStream baos = new ByteArrayOutputStream();
+    new SmileResponseWriter().write(baos, new LocalSolrQueryRequest(null, new ModifiableSolrParams()), response);
+
+    byte[] bytes = baos.toByteArray();
+    Map m = (Map) decodeSmile(new ByteArrayInputStream(bytes, 0, bytes.length));
+    m = (Map) m.get("results");
+    List lst = (List) m.get("docs");
+    assertEquals(lst.size(),10);
+    for (int i = 0; i < lst.size(); i++) {
+      m = (Map) lst.get(i);
+      SolrDocument d = new SolrDocument();
+      d.putAll(m);
+      compareSolrDocument(l.get(i), d);
+    }
+
+  }
+
+  public static SolrDocument sampleDoc(Random r, int bufnum) {
+    SolrDocument sdoc = new SolrDocument();
+    sdoc.put("id", "my_id_" + bufnum);
+    sdoc.put("author", str(r, 10 + r.nextInt(10)));
+    sdoc.put("address", str(r, 20 + r.nextInt(20)));
+    sdoc.put("license", str(r, 10));
+    sdoc.put("title", str(r, 5 + r.nextInt(10)));
+    sdoc.put("title_bin", str(r, 5 + r.nextInt(10)).getBytes(StandardCharsets.UTF_8));
+    sdoc.put("modified_dt", r.nextInt(1000000));
+    sdoc.put("creation_dt", r.nextInt(1000000));
+    sdoc.put("birthdate_dt", r.nextInt(1000000));
+    sdoc.put("clean", r.nextBoolean());
+    sdoc.put("dirty", r.nextBoolean());
+    sdoc.put("employed", r.nextBoolean());
+    sdoc.put("priority", r.nextInt(100));
+    sdoc.put("dependents", r.nextInt(6));
+    sdoc.put("level", r.nextInt(101));
+    sdoc.put("education_level", r.nextInt(10));
+    // higher level of reuse for string values
+    sdoc.put("state", "S"+r.nextInt(50));
+    sdoc.put("country", "Country"+r.nextInt(20));
+    sdoc.put("some_boolean", ""+r.nextBoolean());
+    sdoc.put("another_boolean", ""+r.nextBoolean());
+    return sdoc;
+  }
+  // common-case ascii
+  static String str(Random r, int sz) {
+    StringBuffer sb = new StringBuffer(sz);
+    for (int i=0; i<sz; i++) {
+      sb.append('\n' + r.nextInt(128-'\n'));
+    }
+    return sb.toString();
+  }
+
+
+  public static Object decodeSmile( InputStream is) throws IOException {
+    final SmileFactory smileFactory = new SmileFactory();
+    com.fasterxml.jackson.databind.ObjectMapper mapper = new  com.fasterxml.jackson.databind.ObjectMapper(smileFactory);
+    JsonNode jsonNode = mapper.readTree(is);
+    return getVal(jsonNode);
+  }
+
+
+  public static Object getVal(JsonNode value) {
+    if (value instanceof NullNode) {
+      return null;
+    }
+    if (value instanceof NumericNode) {
+      return ((NumericNode) value).numberValue();
+    }
+    if (value instanceof BooleanNode) {
+      ((BooleanNode) value).booleanValue();
+    }
+    if(value instanceof ObjectNode){
+      Iterator<Map.Entry<String, JsonNode>> it = ((ObjectNode)value).fields();
+      Map result = new LinkedHashMap<>();
+      while(it.hasNext()){
+        Map.Entry<String, JsonNode> e = it.next();
+        result.put(e.getKey(),getVal(e.getValue()));
+      }
+      return result;
+    }
+    if (value instanceof ArrayNode) {
+      ArrayList result =  new ArrayList();
+      Iterator<JsonNode> it = ((ArrayNode) value).elements();
+      while (it.hasNext()) {
+        result.add(getVal(it.next()));
+      }
+      return result;
+
+    }
+    if(value instanceof BinaryNode) {
+      return ((BinaryNode) value).binaryValue();
+    }
+
+    return value.textValue();
+  }
+
+
+}
diff --git a/solr/core/src/test/org/apache/solr/search/TestSmileRequest.java b/solr/core/src/test/org/apache/solr/search/TestSmileRequest.java
new file mode 100644
index 0000000..63faec0
--- /dev/null
+++ b/solr/core/src/test/org/apache/solr/search/TestSmileRequest.java
@@ -0,0 +1,112 @@
+package org.apache.solr.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Map;
+
+import org.apache.solr.JSONTestUtil;
+import org.apache.solr.SolrTestCaseHS;
+import org.apache.solr.SolrTestCaseJ4;
+import org.apache.solr.client.solrj.SolrClient;
+import org.apache.solr.client.solrj.impl.BinaryResponseParser;
+import org.apache.solr.client.solrj.impl.HttpSolrClient;
+import org.apache.solr.client.solrj.request.QueryRequest;
+import org.apache.solr.common.cloud.ZkStateReader;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.request.SmileWriterTest;
+import org.apache.solr.search.json.TestJsonRequest;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+@SolrTestCaseJ4.SuppressSSL
+public class TestSmileRequest extends SolrTestCaseJ4 {
+  private static SolrTestCaseHS.SolrInstances servers;  // for distributed testing
+
+  @BeforeClass
+  public static void beforeTests() throws Exception {
+    JSONTestUtil.failRepeatedKeys = true;
+    initCore("solrconfig-tlog.xml", "schema_latest.xml");
+  }
+
+  public static void initServers() throws Exception {
+    if (servers == null) {
+      servers = new SolrTestCaseHS.SolrInstances(3, "solrconfig-tlog.xml", "schema_latest.xml");
+    }
+  }
+
+  @AfterClass
+  public static void afterTests() throws Exception {
+    JSONTestUtil.failRepeatedKeys = false;
+    if (servers != null) {
+      servers.stop();
+      servers = null;
+    }
+  }
+
+  @Test
+  public void testDistribJsonRequest() throws Exception {
+    initServers();
+    SolrTestCaseHS.Client client = servers.getClient(random().nextInt());
+    client.tester = new SolrTestCaseHS.Client.Tester() {
+      @Override
+      public void assertJQ(SolrClient client, SolrParams args, String... tests) throws Exception {
+        ((HttpSolrClient) client).setParser(SmileResponseParser.inst);
+        QueryRequest query = new QueryRequest(args);
+        String path = args.get("qt");
+        if (path != null) {
+          query.setPath(path);
+        }
+        NamedList<Object> rsp = client.request(query);
+        Map m = rsp.asMap(5);
+        String jsonStr = ZkStateReader.toJSONString(m);
+        SolrTestCaseHS.matchJSON(jsonStr, tests);
+      }
+    };
+    client.queryDefaults().set("shards", servers.getShards());
+    TestJsonRequest.doJsonRequest(client);
+
+  }
+
+  //adding this to core adds the dependency on a few extra jars to our distribution.
+  // So this is not added there
+  public static class SmileResponseParser extends BinaryResponseParser {
+    public static final SmileResponseParser inst = new SmileResponseParser();
+
+    @Override
+    public String getWriterType() {
+      return "smile";
+    }
+
+    @Override
+    public NamedList<Object> processResponse(InputStream body, String encoding) {
+      try {
+        Map m = (Map) SmileWriterTest.decodeSmile(body);
+        return new NamedList(m);
+      } catch (IOException e) {
+        throw new RuntimeException(e);
+
+      }
+    }
+
+  }
+}
diff --git a/solr/core/src/test/org/apache/solr/search/json/TestJsonRequest.java b/solr/core/src/test/org/apache/solr/search/json/TestJsonRequest.java
index a9e7831..2544a76 100644
--- a/solr/core/src/test/org/apache/solr/search/json/TestJsonRequest.java
+++ b/solr/core/src/test/org/apache/solr/search/json/TestJsonRequest.java
@@ -66,7 +66,7 @@ public class TestJsonRequest extends SolrTestCaseHS {
   }
 
 
-  public void doJsonRequest(Client client) throws Exception {
+  public static void doJsonRequest(Client client) throws Exception {
     client.deleteByQuery("*:*", null);
     client.add(sdoc("id", "1", "cat_s", "A", "where_s", "NY"), null);
     client.add(sdoc("id", "2", "cat_s", "B", "where_s", "NJ"), null);
diff --git a/solr/licenses/jackson-annotations-2.3.1.jar.sha1 b/solr/licenses/jackson-annotations-2.3.1.jar.sha1
deleted file mode 100644
index 17b893f..0000000
--- a/solr/licenses/jackson-annotations-2.3.1.jar.sha1
+++ /dev/null
@@ -1 +0,0 @@
-cbf0cc07675681a7703c900dd5f60288f654f1ba
diff --git a/solr/licenses/jackson-annotations-2.5.4.jar.sha1 b/solr/licenses/jackson-annotations-2.5.4.jar.sha1
new file mode 100644
index 0000000..76bf71f
--- /dev/null
+++ b/solr/licenses/jackson-annotations-2.5.4.jar.sha1
@@ -0,0 +1 @@
+7a93b60f5d2d43024f34e15893552ee6defdb971
diff --git a/solr/licenses/jackson-core-2.3.1.jar.sha1 b/solr/licenses/jackson-core-2.3.1.jar.sha1
deleted file mode 100644
index 2971b46..0000000
--- a/solr/licenses/jackson-core-2.3.1.jar.sha1
+++ /dev/null
@@ -1 +0,0 @@
-f9f7185c92ca5fefe2fb3efdeb477a67c96ea2d0
diff --git a/solr/licenses/jackson-core-2.5.4.jar.sha1 b/solr/licenses/jackson-core-2.5.4.jar.sha1
new file mode 100644
index 0000000..da83a8b
--- /dev/null
+++ b/solr/licenses/jackson-core-2.5.4.jar.sha1
@@ -0,0 +1 @@
+0a57a2df1a23ca1ee32f129173ba7f5feaa9ac24
diff --git a/solr/licenses/jackson-databind-2.3.1.jar.sha1 b/solr/licenses/jackson-databind-2.3.1.jar.sha1
deleted file mode 100644
index 453e8ab..0000000
--- a/solr/licenses/jackson-databind-2.3.1.jar.sha1
+++ /dev/null
@@ -1 +0,0 @@
-c4096a8323bbbcbeda072e3def123a9b66783361
diff --git a/solr/licenses/jackson-databind-2.5.4.jar.sha1 b/solr/licenses/jackson-databind-2.5.4.jar.sha1
new file mode 100644
index 0000000..0fa583e
--- /dev/null
+++ b/solr/licenses/jackson-databind-2.5.4.jar.sha1
@@ -0,0 +1 @@
+5dfa42af84584b4a862ea488da84bbbebbb06c35
diff --git a/solr/licenses/jackson-dataformat-smile-2.5.4.jar.sha1 b/solr/licenses/jackson-dataformat-smile-2.5.4.jar.sha1
new file mode 100644
index 0000000..e15996c
--- /dev/null
+++ b/solr/licenses/jackson-dataformat-smile-2.5.4.jar.sha1
@@ -0,0 +1 @@
+db0c5f1b6e16cb5f5e0505abfcd4b36f3e8bfdc6
diff --git a/solr/licenses/jackson-dataformat-smile-LICENSE-ASL.txt b/solr/licenses/jackson-dataformat-smile-LICENSE-ASL.txt
new file mode 100644
index 0000000..261eeb9
--- /dev/null
+++ b/solr/licenses/jackson-dataformat-smile-LICENSE-ASL.txt
@@ -0,0 +1,201 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/solr/licenses/jackson-dataformat-smile-NOTICE.txt b/solr/licenses/jackson-dataformat-smile-NOTICE.txt
new file mode 100644
index 0000000..8c71682
--- /dev/null
+++ b/solr/licenses/jackson-dataformat-smile-NOTICE.txt
@@ -0,0 +1,20 @@
+# Jackson JSON processor
+
+Jackson is a high-performance, Free/Open Source JSON processing library.
+It was originally written by Tatu Saloranta (tatu.saloranta@iki.fi), and has
+been in development since 2007.
+It is currently developed by a community of developers, as well as supported
+commercially by FasterXML.com.
+
+## Licensing
+
+Jackson core and extension components may be licensed under different licenses.
+To find the details that apply to this artifact see the accompanying LICENSE file.
+For more information, including possible other licensing options, contact
+FasterXML.com (http://fasterxml.com).
+
+## Credits
+
+A list of contributors may be found from CREDITS file, which is included
+in some artifacts (usually source distributions); but is always available
+from the source code management (SCM) system project uses.
\ No newline at end of file
diff --git a/solr/licenses/presto-parser-0.107.jar.sha1 b/solr/licenses/presto-parser-0.107.jar.sha1
index 0d0d9c6..d163a06 100644
--- a/solr/licenses/presto-parser-0.107.jar.sha1
+++ b/solr/licenses/presto-parser-0.107.jar.sha1
@@ -1 +1 @@
-f6f1363553855d1b70548721ce6cd5050b88a6bd
\ No newline at end of file
+f6f1363553855d1b70548721ce6cd5050b88a6bd
diff --git a/solr/test-framework/src/java/org/apache/solr/SolrTestCaseHS.java b/solr/test-framework/src/java/org/apache/solr/SolrTestCaseHS.java
index 8db0457..c96dc81 100644
--- a/solr/test-framework/src/java/org/apache/solr/SolrTestCaseHS.java
+++ b/solr/test-framework/src/java/org/apache/solr/SolrTestCaseHS.java
@@ -61,7 +61,7 @@ import java.util.Set;
 
 
 @SolrTestCaseJ4.SuppressSSL
-@LuceneTestCase.SuppressCodecs({"Lucene3x","Lucene40","Lucene41","Lucene42","Lucene45","Appending","Asserting"})
+//@LuceneTestCase.SuppressCodecs({"Lucene3x","Lucene40","Lucene41","Lucene42","Lucene45","Appending","Asserting"})
 public class SolrTestCaseHS extends SolrTestCaseJ4 {
 
   @SafeVarargs
@@ -247,6 +247,13 @@ public class SolrTestCaseHS extends SolrTestCaseJ4 {
   public static class Client {
     ClientProvider provider;
     ModifiableSolrParams queryDefaults;
+    public Tester tester = new Tester();
+
+    public static class Tester {
+      public  void assertJQ(SolrClient client, SolrParams args, String... tests) throws Exception {
+        SolrTestCaseHS.assertJQ(client, args, tests);
+      }
+    }
 
     public static Client localClient = new Client(null, 1);
     public static Client localClient() {
@@ -285,7 +292,7 @@ public class SolrTestCaseHS extends SolrTestCaseJ4 {
         args = newParams;
       }
       SolrClient client = provider==null ? null : provider.client(null, args);
-      SolrTestCaseHS.assertJQ(client, args, tests);
+      tester.assertJQ(client, args, tests);
     }
 
     public Long add(SolrInputDocument sdoc, ModifiableSolrParams params) throws Exception {

