GitDiffStart: 94aecff6c33affad2795f0ffc18f58deb0825e39 | Mon Jul 30 22:15:06 2012 +0000
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsReader.java b/lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsReader.java
index 482a3e2..fb776f7 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsReader.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsReader.java
@@ -24,7 +24,6 @@ import java.nio.IntBuffer;
 import org.apache.lucene.codecs.BlockTermState;
 import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.PostingsReaderBase;
-import org.apache.lucene.codecs.pfor.ForUtil;
 import org.apache.lucene.index.DocsAndPositionsEnum;
 import org.apache.lucene.index.DocsEnum;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
@@ -43,8 +42,6 @@ import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.IOUtils;
 
-// nocommit move ForUtil here?
-
 // nocommit javadocs
 public final class BlockPostingsReader extends PostingsReaderBase {
 
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsWriter.java
index 68e4c40..a4b530d 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsWriter.java
@@ -26,7 +26,6 @@ import java.util.List;
 import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.PostingsWriterBase;
 import org.apache.lucene.codecs.TermStats;
-import org.apache.lucene.codecs.pfor.ForUtil;  // nocommit move here?
 import org.apache.lucene.index.CorruptIndexException;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
 import org.apache.lucene.index.FieldInfo;
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/block/ForUtil.java b/lucene/core/src/java/org/apache/lucene/codecs/block/ForUtil.java
new file mode 100644
index 0000000..374c0aa
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/codecs/block/ForUtil.java
@@ -0,0 +1,199 @@
+package org.apache.lucene.codecs.block;
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.nio.IntBuffer;
+
+/**
+ * Encode all values in normal area with fixed bit width, 
+ * which is determined by the max value in this block.
+ */
+public class ForUtil {
+  protected static final int[] MASK = {   0x00000000,
+    0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f,
+    0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff,
+    0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff, 0x0001ffff, 0x0003ffff,
+    0x0007ffff, 0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff, 0x00ffffff,
+    0x01ffffff, 0x03ffffff, 0x07ffffff, 0x0fffffff, 0x1fffffff, 0x3fffffff,
+    0x7fffffff, 0xffffffff};
+
+  /** Compress given int[] into Integer buffer, with For format
+   *
+   * @param data        uncompressed data
+   * @param size        num of ints to compress
+   * @param intBuffer   integer buffer to hold compressed data
+   * @return encoded block byte size
+   */
+  public static int compress(final int[] data, IntBuffer intBuffer) {
+    int numBits=getNumBits(data);
+    if (numBits == 0) {
+      return compressDuplicateBlock(data,intBuffer);
+    }
+ 
+    int size=data.length;
+    int encodedSize = (size*numBits+31)/32;
+
+    for (int i=0; i<size; ++i) {
+      encodeNormalValue(intBuffer,i,data[i], numBits);
+    }
+
+    return getHeader(encodedSize, numBits);
+  }
+
+  /**
+   * Save only one int when the whole block equals to 1
+   */
+  static int compressDuplicateBlock(final int[] data, IntBuffer intBuffer) {
+    intBuffer.put(0,data[0]);
+    return getHeader(1, 0);
+  }
+
+  /** Decompress given Integer buffer into int array.
+   *
+   * @param intBuffer   integer buffer to hold compressed data
+   * @param data        int array to hold uncompressed data
+   */
+  public static void decompress(IntBuffer intBuffer, int[] data, int header) {
+    // since this buffer is reused at upper level, rewind first
+    intBuffer.rewind();
+
+    // nocommit assert header isn't "malformed", ie besides
+    // numBytes / bit-width there is nothing else!
+
+    int numBits = ((header >> 8) & MASK[6]);
+
+    decompressCore(intBuffer, data, numBits);
+  }
+
+  /**
+   * IntBuffer will not be rewinded in this method, therefore
+   * caller should ensure that the position is set to the first
+   * encoded int before decoding.
+   */
+  static void decompressCore(IntBuffer intBuffer, int[] data, int numBits) {
+    assert numBits<=32;
+    assert numBits>=0;
+
+    // TODO: PackedIntsDecompress is hardewired to size==128 only
+    switch(numBits) {
+      case 0: PackedIntsDecompress.decode0(intBuffer, data); break;
+      case 1: PackedIntsDecompress.decode1(intBuffer, data); break;
+      case 2: PackedIntsDecompress.decode2(intBuffer, data); break;
+      case 3: PackedIntsDecompress.decode3(intBuffer, data); break;
+      case 4: PackedIntsDecompress.decode4(intBuffer, data); break;
+      case 5: PackedIntsDecompress.decode5(intBuffer, data); break;
+      case 6: PackedIntsDecompress.decode6(intBuffer, data); break;
+      case 7: PackedIntsDecompress.decode7(intBuffer, data); break;
+      case 8: PackedIntsDecompress.decode8(intBuffer, data); break;
+      case 9: PackedIntsDecompress.decode9(intBuffer, data); break;
+      case 10: PackedIntsDecompress.decode10(intBuffer, data); break;
+      case 11: PackedIntsDecompress.decode11(intBuffer, data); break;
+      case 12: PackedIntsDecompress.decode12(intBuffer, data); break;
+      case 13: PackedIntsDecompress.decode13(intBuffer, data); break;
+      case 14: PackedIntsDecompress.decode14(intBuffer, data); break;
+      case 15: PackedIntsDecompress.decode15(intBuffer, data); break;
+      case 16: PackedIntsDecompress.decode16(intBuffer, data); break;
+      case 17: PackedIntsDecompress.decode17(intBuffer, data); break;
+      case 18: PackedIntsDecompress.decode18(intBuffer, data); break;
+      case 19: PackedIntsDecompress.decode19(intBuffer, data); break;
+      case 20: PackedIntsDecompress.decode20(intBuffer, data); break;
+      case 21: PackedIntsDecompress.decode21(intBuffer, data); break;
+      case 22: PackedIntsDecompress.decode22(intBuffer, data); break;
+      case 23: PackedIntsDecompress.decode23(intBuffer, data); break;
+      case 24: PackedIntsDecompress.decode24(intBuffer, data); break;
+      case 25: PackedIntsDecompress.decode25(intBuffer, data); break;
+      case 26: PackedIntsDecompress.decode26(intBuffer, data); break;
+      case 27: PackedIntsDecompress.decode27(intBuffer, data); break;
+      case 28: PackedIntsDecompress.decode28(intBuffer, data); break;
+      case 29: PackedIntsDecompress.decode29(intBuffer, data); break;
+      case 30: PackedIntsDecompress.decode30(intBuffer, data); break;
+      case 31: PackedIntsDecompress.decode31(intBuffer, data); break;
+      case 32: PackedIntsDecompress.decode32(intBuffer, data); break;
+    }
+  }
+
+  static void encodeNormalValue(IntBuffer intBuffer, int pos, int value, int numBits) {
+    final int globalBitPos = numBits*pos;           // position in bit stream
+    final int localBitPos = globalBitPos & 31;      // position inside an int
+    int intPos = globalBitPos/32; // which integer to locate 
+    setBufferIntBits(intBuffer, intPos, localBitPos, numBits, value);
+    if ((localBitPos + numBits) > 32) { // value does not fit in this int, fill tail
+      setBufferIntBits(intBuffer, intPos+1, 0, 
+                       (localBitPos+numBits-32), 
+                       (value >>> (32-localBitPos)));
+    }
+  }
+
+  static void setBufferIntBits(IntBuffer intBuffer, int intPos, int firstBitPos, int numBits, int value) {
+    assert (value & ~MASK[numBits]) == 0;
+    // safely discards those msb parts when firstBitPos+numBits>32
+    intBuffer.put(intPos,
+          (intBuffer.get(intPos) & ~(MASK[numBits] << firstBitPos)) 
+          | (value << firstBitPos));
+  }
+
+  /**
+   * Estimate best num of frame bits according to the largest value.
+   */
+  static int getNumBits(final int[] data) {
+    if (isAllEqual(data)) {
+      return 0;
+    }
+    int size=data.length;
+    int optBits=1;
+    for (int i=0; i<size; ++i) {
+      while ((data[i] & ~MASK[optBits]) != 0) {
+        optBits++;
+      }
+    }
+    return optBits;
+  }
+
+  protected static boolean isAllEqual(final int[] data) {
+    int len = data.length;
+    int v = data[0];
+    for (int i=1; i<len; i++) {
+      if (data[i] != v) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  /** 
+   * Generate the 4 byte header, which contains (from lsb to msb):
+   *
+   * 8 bits for encoded block int size (excluded header, this limits DEFAULT_BLOCK_SIZE <= 2^8)
+   * 6 bits for num of frame bits (when 0, values in this block are all the same)
+   * other bits unused
+   *
+   */
+  static int getHeader(int encodedSize, int numBits) {
+    return  (encodedSize)
+          | ((numBits) << 8);
+  }
+
+  /** 
+   * Expert: get metadata from header. 
+   */
+  public static int getEncodedSize(int header) {
+    return ((header & MASK[8]))*4;
+  }
+  public static int getNumBits(int header) {
+    return ((header >> 8) & MASK[6]);
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/block/PackedIntsDecompress.java b/lucene/core/src/java/org/apache/lucene/codecs/block/PackedIntsDecompress.java
new file mode 100644
index 0000000..7960040
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/codecs/block/PackedIntsDecompress.java
@@ -0,0 +1,1841 @@
+package org.apache.lucene.codecs.block;
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ 
+/* This code is generated, do not modify. See gendecompress.py */
+
+import java.nio.IntBuffer;
+import java.util.Arrays;
+
+final class PackedIntsDecompress {
+
+  // nocommit: assess perf of this to see if specializing is really needed
+
+  // NOTE: hardwired to blockSize == 128
+
+  public static void decode0(final IntBuffer compressedBuffer, final int[] output) {
+    Arrays.fill(output, compressedBuffer.get());
+  }
+  public static void decode1(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 1;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = (intValue0 >>> 1) & mask;
+      output[2 + outputOffset] = (intValue0 >>> 2) & mask;
+      output[3 + outputOffset] = (intValue0 >>> 3) & mask;
+      output[4 + outputOffset] = (intValue0 >>> 4) & mask;
+      output[5 + outputOffset] = (intValue0 >>> 5) & mask;
+      output[6 + outputOffset] = (intValue0 >>> 6) & mask;
+      output[7 + outputOffset] = (intValue0 >>> 7) & mask;
+      output[8 + outputOffset] = (intValue0 >>> 8) & mask;
+      output[9 + outputOffset] = (intValue0 >>> 9) & mask;
+      output[10 + outputOffset] = (intValue0 >>> 10) & mask;
+      output[11 + outputOffset] = (intValue0 >>> 11) & mask;
+      output[12 + outputOffset] = (intValue0 >>> 12) & mask;
+      output[13 + outputOffset] = (intValue0 >>> 13) & mask;
+      output[14 + outputOffset] = (intValue0 >>> 14) & mask;
+      output[15 + outputOffset] = (intValue0 >>> 15) & mask;
+      output[16 + outputOffset] = (intValue0 >>> 16) & mask;
+      output[17 + outputOffset] = (intValue0 >>> 17) & mask;
+      output[18 + outputOffset] = (intValue0 >>> 18) & mask;
+      output[19 + outputOffset] = (intValue0 >>> 19) & mask;
+      output[20 + outputOffset] = (intValue0 >>> 20) & mask;
+      output[21 + outputOffset] = (intValue0 >>> 21) & mask;
+      output[22 + outputOffset] = (intValue0 >>> 22) & mask;
+      output[23 + outputOffset] = (intValue0 >>> 23) & mask;
+      output[24 + outputOffset] = (intValue0 >>> 24) & mask;
+      output[25 + outputOffset] = (intValue0 >>> 25) & mask;
+      output[26 + outputOffset] = (intValue0 >>> 26) & mask;
+      output[27 + outputOffset] = (intValue0 >>> 27) & mask;
+      output[28 + outputOffset] = (intValue0 >>> 28) & mask;
+      output[29 + outputOffset] = (intValue0 >>> 29) & mask;
+      output[30 + outputOffset] = (intValue0 >>> 30) & mask;
+      output[31 + outputOffset] = intValue0 >>> 31;
+      outputOffset += 32;
+    }
+  }
+  public static void decode2(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 2;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = (intValue0 >>> 2) & mask;
+      output[2 + outputOffset] = (intValue0 >>> 4) & mask;
+      output[3 + outputOffset] = (intValue0 >>> 6) & mask;
+      output[4 + outputOffset] = (intValue0 >>> 8) & mask;
+      output[5 + outputOffset] = (intValue0 >>> 10) & mask;
+      output[6 + outputOffset] = (intValue0 >>> 12) & mask;
+      output[7 + outputOffset] = (intValue0 >>> 14) & mask;
+      output[8 + outputOffset] = (intValue0 >>> 16) & mask;
+      output[9 + outputOffset] = (intValue0 >>> 18) & mask;
+      output[10 + outputOffset] = (intValue0 >>> 20) & mask;
+      output[11 + outputOffset] = (intValue0 >>> 22) & mask;
+      output[12 + outputOffset] = (intValue0 >>> 24) & mask;
+      output[13 + outputOffset] = (intValue0 >>> 26) & mask;
+      output[14 + outputOffset] = (intValue0 >>> 28) & mask;
+      output[15 + outputOffset] = intValue0 >>> 30;
+      output[16 + outputOffset] = intValue1 & mask;
+      output[17 + outputOffset] = (intValue1 >>> 2) & mask;
+      output[18 + outputOffset] = (intValue1 >>> 4) & mask;
+      output[19 + outputOffset] = (intValue1 >>> 6) & mask;
+      output[20 + outputOffset] = (intValue1 >>> 8) & mask;
+      output[21 + outputOffset] = (intValue1 >>> 10) & mask;
+      output[22 + outputOffset] = (intValue1 >>> 12) & mask;
+      output[23 + outputOffset] = (intValue1 >>> 14) & mask;
+      output[24 + outputOffset] = (intValue1 >>> 16) & mask;
+      output[25 + outputOffset] = (intValue1 >>> 18) & mask;
+      output[26 + outputOffset] = (intValue1 >>> 20) & mask;
+      output[27 + outputOffset] = (intValue1 >>> 22) & mask;
+      output[28 + outputOffset] = (intValue1 >>> 24) & mask;
+      output[29 + outputOffset] = (intValue1 >>> 26) & mask;
+      output[30 + outputOffset] = (intValue1 >>> 28) & mask;
+      output[31 + outputOffset] = intValue1 >>> 30;
+      outputOffset += 32;
+    }
+  }
+  public static void decode3(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 3;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = (intValue0 >>> 3) & mask;
+      output[2 + outputOffset] = (intValue0 >>> 6) & mask;
+      output[3 + outputOffset] = (intValue0 >>> 9) & mask;
+      output[4 + outputOffset] = (intValue0 >>> 12) & mask;
+      output[5 + outputOffset] = (intValue0 >>> 15) & mask;
+      output[6 + outputOffset] = (intValue0 >>> 18) & mask;
+      output[7 + outputOffset] = (intValue0 >>> 21) & mask;
+      output[8 + outputOffset] = (intValue0 >>> 24) & mask;
+      output[9 + outputOffset] = (intValue0 >>> 27) & mask;
+      output[10 + outputOffset] = ((intValue0 >>> 30) | (intValue1 << 2)) & mask;
+      output[11 + outputOffset] = (intValue1 >>> 1) & mask;
+      output[12 + outputOffset] = (intValue1 >>> 4) & mask;
+      output[13 + outputOffset] = (intValue1 >>> 7) & mask;
+      output[14 + outputOffset] = (intValue1 >>> 10) & mask;
+      output[15 + outputOffset] = (intValue1 >>> 13) & mask;
+      output[16 + outputOffset] = (intValue1 >>> 16) & mask;
+      output[17 + outputOffset] = (intValue1 >>> 19) & mask;
+      output[18 + outputOffset] = (intValue1 >>> 22) & mask;
+      output[19 + outputOffset] = (intValue1 >>> 25) & mask;
+      output[20 + outputOffset] = (intValue1 >>> 28) & mask;
+      output[21 + outputOffset] = ((intValue1 >>> 31) | (intValue2 << 1)) & mask;
+      output[22 + outputOffset] = (intValue2 >>> 2) & mask;
+      output[23 + outputOffset] = (intValue2 >>> 5) & mask;
+      output[24 + outputOffset] = (intValue2 >>> 8) & mask;
+      output[25 + outputOffset] = (intValue2 >>> 11) & mask;
+      output[26 + outputOffset] = (intValue2 >>> 14) & mask;
+      output[27 + outputOffset] = (intValue2 >>> 17) & mask;
+      output[28 + outputOffset] = (intValue2 >>> 20) & mask;
+      output[29 + outputOffset] = (intValue2 >>> 23) & mask;
+      output[30 + outputOffset] = (intValue2 >>> 26) & mask;
+      output[31 + outputOffset] = intValue2 >>> 29;
+      outputOffset += 32;
+    }
+  }
+  public static void decode4(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 4;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = (intValue0 >>> 4) & mask;
+      output[2 + outputOffset] = (intValue0 >>> 8) & mask;
+      output[3 + outputOffset] = (intValue0 >>> 12) & mask;
+      output[4 + outputOffset] = (intValue0 >>> 16) & mask;
+      output[5 + outputOffset] = (intValue0 >>> 20) & mask;
+      output[6 + outputOffset] = (intValue0 >>> 24) & mask;
+      output[7 + outputOffset] = intValue0 >>> 28;
+      output[8 + outputOffset] = intValue1 & mask;
+      output[9 + outputOffset] = (intValue1 >>> 4) & mask;
+      output[10 + outputOffset] = (intValue1 >>> 8) & mask;
+      output[11 + outputOffset] = (intValue1 >>> 12) & mask;
+      output[12 + outputOffset] = (intValue1 >>> 16) & mask;
+      output[13 + outputOffset] = (intValue1 >>> 20) & mask;
+      output[14 + outputOffset] = (intValue1 >>> 24) & mask;
+      output[15 + outputOffset] = intValue1 >>> 28;
+      output[16 + outputOffset] = intValue2 & mask;
+      output[17 + outputOffset] = (intValue2 >>> 4) & mask;
+      output[18 + outputOffset] = (intValue2 >>> 8) & mask;
+      output[19 + outputOffset] = (intValue2 >>> 12) & mask;
+      output[20 + outputOffset] = (intValue2 >>> 16) & mask;
+      output[21 + outputOffset] = (intValue2 >>> 20) & mask;
+      output[22 + outputOffset] = (intValue2 >>> 24) & mask;
+      output[23 + outputOffset] = intValue2 >>> 28;
+      output[24 + outputOffset] = intValue3 & mask;
+      output[25 + outputOffset] = (intValue3 >>> 4) & mask;
+      output[26 + outputOffset] = (intValue3 >>> 8) & mask;
+      output[27 + outputOffset] = (intValue3 >>> 12) & mask;
+      output[28 + outputOffset] = (intValue3 >>> 16) & mask;
+      output[29 + outputOffset] = (intValue3 >>> 20) & mask;
+      output[30 + outputOffset] = (intValue3 >>> 24) & mask;
+      output[31 + outputOffset] = intValue3 >>> 28;
+      outputOffset += 32;
+    }
+  }
+  public static void decode5(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 5;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = (intValue0 >>> 5) & mask;
+      output[2 + outputOffset] = (intValue0 >>> 10) & mask;
+      output[3 + outputOffset] = (intValue0 >>> 15) & mask;
+      output[4 + outputOffset] = (intValue0 >>> 20) & mask;
+      output[5 + outputOffset] = (intValue0 >>> 25) & mask;
+      output[6 + outputOffset] = ((intValue0 >>> 30) | (intValue1 << 2)) & mask;
+      output[7 + outputOffset] = (intValue1 >>> 3) & mask;
+      output[8 + outputOffset] = (intValue1 >>> 8) & mask;
+      output[9 + outputOffset] = (intValue1 >>> 13) & mask;
+      output[10 + outputOffset] = (intValue1 >>> 18) & mask;
+      output[11 + outputOffset] = (intValue1 >>> 23) & mask;
+      output[12 + outputOffset] = ((intValue1 >>> 28) | (intValue2 << 4)) & mask;
+      output[13 + outputOffset] = (intValue2 >>> 1) & mask;
+      output[14 + outputOffset] = (intValue2 >>> 6) & mask;
+      output[15 + outputOffset] = (intValue2 >>> 11) & mask;
+      output[16 + outputOffset] = (intValue2 >>> 16) & mask;
+      output[17 + outputOffset] = (intValue2 >>> 21) & mask;
+      output[18 + outputOffset] = (intValue2 >>> 26) & mask;
+      output[19 + outputOffset] = ((intValue2 >>> 31) | (intValue3 << 1)) & mask;
+      output[20 + outputOffset] = (intValue3 >>> 4) & mask;
+      output[21 + outputOffset] = (intValue3 >>> 9) & mask;
+      output[22 + outputOffset] = (intValue3 >>> 14) & mask;
+      output[23 + outputOffset] = (intValue3 >>> 19) & mask;
+      output[24 + outputOffset] = (intValue3 >>> 24) & mask;
+      output[25 + outputOffset] = ((intValue3 >>> 29) | (intValue4 << 3)) & mask;
+      output[26 + outputOffset] = (intValue4 >>> 2) & mask;
+      output[27 + outputOffset] = (intValue4 >>> 7) & mask;
+      output[28 + outputOffset] = (intValue4 >>> 12) & mask;
+      output[29 + outputOffset] = (intValue4 >>> 17) & mask;
+      output[30 + outputOffset] = (intValue4 >>> 22) & mask;
+      output[31 + outputOffset] = intValue4 >>> 27;
+      outputOffset += 32;
+    }
+  }
+  public static void decode6(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 6;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      int intValue5 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = (intValue0 >>> 6) & mask;
+      output[2 + outputOffset] = (intValue0 >>> 12) & mask;
+      output[3 + outputOffset] = (intValue0 >>> 18) & mask;
+      output[4 + outputOffset] = (intValue0 >>> 24) & mask;
+      output[5 + outputOffset] = ((intValue0 >>> 30) | (intValue1 << 2)) & mask;
+      output[6 + outputOffset] = (intValue1 >>> 4) & mask;
+      output[7 + outputOffset] = (intValue1 >>> 10) & mask;
+      output[8 + outputOffset] = (intValue1 >>> 16) & mask;
+      output[9 + outputOffset] = (intValue1 >>> 22) & mask;
+      output[10 + outputOffset] = ((intValue1 >>> 28) | (intValue2 << 4)) & mask;
+      output[11 + outputOffset] = (intValue2 >>> 2) & mask;
+      output[12 + outputOffset] = (intValue2 >>> 8) & mask;
+      output[13 + outputOffset] = (intValue2 >>> 14) & mask;
+      output[14 + outputOffset] = (intValue2 >>> 20) & mask;
+      output[15 + outputOffset] = intValue2 >>> 26;
+      output[16 + outputOffset] = intValue3 & mask;
+      output[17 + outputOffset] = (intValue3 >>> 6) & mask;
+      output[18 + outputOffset] = (intValue3 >>> 12) & mask;
+      output[19 + outputOffset] = (intValue3 >>> 18) & mask;
+      output[20 + outputOffset] = (intValue3 >>> 24) & mask;
+      output[21 + outputOffset] = ((intValue3 >>> 30) | (intValue4 << 2)) & mask;
+      output[22 + outputOffset] = (intValue4 >>> 4) & mask;
+      output[23 + outputOffset] = (intValue4 >>> 10) & mask;
+      output[24 + outputOffset] = (intValue4 >>> 16) & mask;
+      output[25 + outputOffset] = (intValue4 >>> 22) & mask;
+      output[26 + outputOffset] = ((intValue4 >>> 28) | (intValue5 << 4)) & mask;
+      output[27 + outputOffset] = (intValue5 >>> 2) & mask;
+      output[28 + outputOffset] = (intValue5 >>> 8) & mask;
+      output[29 + outputOffset] = (intValue5 >>> 14) & mask;
+      output[30 + outputOffset] = (intValue5 >>> 20) & mask;
+      output[31 + outputOffset] = intValue5 >>> 26;
+      outputOffset += 32;
+    }
+  }
+  public static void decode7(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 7;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      int intValue5 = compressedBuffer.get();
+      int intValue6 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = (intValue0 >>> 7) & mask;
+      output[2 + outputOffset] = (intValue0 >>> 14) & mask;
+      output[3 + outputOffset] = (intValue0 >>> 21) & mask;
+      output[4 + outputOffset] = ((intValue0 >>> 28) | (intValue1 << 4)) & mask;
+      output[5 + outputOffset] = (intValue1 >>> 3) & mask;
+      output[6 + outputOffset] = (intValue1 >>> 10) & mask;
+      output[7 + outputOffset] = (intValue1 >>> 17) & mask;
+      output[8 + outputOffset] = (intValue1 >>> 24) & mask;
+      output[9 + outputOffset] = ((intValue1 >>> 31) | (intValue2 << 1)) & mask;
+      output[10 + outputOffset] = (intValue2 >>> 6) & mask;
+      output[11 + outputOffset] = (intValue2 >>> 13) & mask;
+      output[12 + outputOffset] = (intValue2 >>> 20) & mask;
+      output[13 + outputOffset] = ((intValue2 >>> 27) | (intValue3 << 5)) & mask;
+      output[14 + outputOffset] = (intValue3 >>> 2) & mask;
+      output[15 + outputOffset] = (intValue3 >>> 9) & mask;
+      output[16 + outputOffset] = (intValue3 >>> 16) & mask;
+      output[17 + outputOffset] = (intValue3 >>> 23) & mask;
+      output[18 + outputOffset] = ((intValue3 >>> 30) | (intValue4 << 2)) & mask;
+      output[19 + outputOffset] = (intValue4 >>> 5) & mask;
+      output[20 + outputOffset] = (intValue4 >>> 12) & mask;
+      output[21 + outputOffset] = (intValue4 >>> 19) & mask;
+      output[22 + outputOffset] = ((intValue4 >>> 26) | (intValue5 << 6)) & mask;
+      output[23 + outputOffset] = (intValue5 >>> 1) & mask;
+      output[24 + outputOffset] = (intValue5 >>> 8) & mask;
+      output[25 + outputOffset] = (intValue5 >>> 15) & mask;
+      output[26 + outputOffset] = (intValue5 >>> 22) & mask;
+      output[27 + outputOffset] = ((intValue5 >>> 29) | (intValue6 << 3)) & mask;
+      output[28 + outputOffset] = (intValue6 >>> 4) & mask;
+      output[29 + outputOffset] = (intValue6 >>> 11) & mask;
+      output[30 + outputOffset] = (intValue6 >>> 18) & mask;
+      output[31 + outputOffset] = intValue6 >>> 25;
+      outputOffset += 32;
+    }
+  }
+  public static void decode8(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 8;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      int intValue5 = compressedBuffer.get();
+      int intValue6 = compressedBuffer.get();
+      int intValue7 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = (intValue0 >>> 8) & mask;
+      output[2 + outputOffset] = (intValue0 >>> 16) & mask;
+      output[3 + outputOffset] = intValue0 >>> 24;
+      output[4 + outputOffset] = intValue1 & mask;
+      output[5 + outputOffset] = (intValue1 >>> 8) & mask;
+      output[6 + outputOffset] = (intValue1 >>> 16) & mask;
+      output[7 + outputOffset] = intValue1 >>> 24;
+      output[8 + outputOffset] = intValue2 & mask;
+      output[9 + outputOffset] = (intValue2 >>> 8) & mask;
+      output[10 + outputOffset] = (intValue2 >>> 16) & mask;
+      output[11 + outputOffset] = intValue2 >>> 24;
+      output[12 + outputOffset] = intValue3 & mask;
+      output[13 + outputOffset] = (intValue3 >>> 8) & mask;
+      output[14 + outputOffset] = (intValue3 >>> 16) & mask;
+      output[15 + outputOffset] = intValue3 >>> 24;
+      output[16 + outputOffset] = intValue4 & mask;
+      output[17 + outputOffset] = (intValue4 >>> 8) & mask;
+      output[18 + outputOffset] = (intValue4 >>> 16) & mask;
+      output[19 + outputOffset] = intValue4 >>> 24;
+      output[20 + outputOffset] = intValue5 & mask;
+      output[21 + outputOffset] = (intValue5 >>> 8) & mask;
+      output[22 + outputOffset] = (intValue5 >>> 16) & mask;
+      output[23 + outputOffset] = intValue5 >>> 24;
+      output[24 + outputOffset] = intValue6 & mask;
+      output[25 + outputOffset] = (intValue6 >>> 8) & mask;
+      output[26 + outputOffset] = (intValue6 >>> 16) & mask;
+      output[27 + outputOffset] = intValue6 >>> 24;
+      output[28 + outputOffset] = intValue7 & mask;
+      output[29 + outputOffset] = (intValue7 >>> 8) & mask;
+      output[30 + outputOffset] = (intValue7 >>> 16) & mask;
+      output[31 + outputOffset] = intValue7 >>> 24;
+      outputOffset += 32;
+    }
+  }
+  public static void decode9(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 9;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      int intValue5 = compressedBuffer.get();
+      int intValue6 = compressedBuffer.get();
+      int intValue7 = compressedBuffer.get();
+      int intValue8 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = (intValue0 >>> 9) & mask;
+      output[2 + outputOffset] = (intValue0 >>> 18) & mask;
+      output[3 + outputOffset] = ((intValue0 >>> 27) | (intValue1 << 5)) & mask;
+      output[4 + outputOffset] = (intValue1 >>> 4) & mask;
+      output[5 + outputOffset] = (intValue1 >>> 13) & mask;
+      output[6 + outputOffset] = (intValue1 >>> 22) & mask;
+      output[7 + outputOffset] = ((intValue1 >>> 31) | (intValue2 << 1)) & mask;
+      output[8 + outputOffset] = (intValue2 >>> 8) & mask;
+      output[9 + outputOffset] = (intValue2 >>> 17) & mask;
+      output[10 + outputOffset] = ((intValue2 >>> 26) | (intValue3 << 6)) & mask;
+      output[11 + outputOffset] = (intValue3 >>> 3) & mask;
+      output[12 + outputOffset] = (intValue3 >>> 12) & mask;
+      output[13 + outputOffset] = (intValue3 >>> 21) & mask;
+      output[14 + outputOffset] = ((intValue3 >>> 30) | (intValue4 << 2)) & mask;
+      output[15 + outputOffset] = (intValue4 >>> 7) & mask;
+      output[16 + outputOffset] = (intValue4 >>> 16) & mask;
+      output[17 + outputOffset] = ((intValue4 >>> 25) | (intValue5 << 7)) & mask;
+      output[18 + outputOffset] = (intValue5 >>> 2) & mask;
+      output[19 + outputOffset] = (intValue5 >>> 11) & mask;
+      output[20 + outputOffset] = (intValue5 >>> 20) & mask;
+      output[21 + outputOffset] = ((intValue5 >>> 29) | (intValue6 << 3)) & mask;
+      output[22 + outputOffset] = (intValue6 >>> 6) & mask;
+      output[23 + outputOffset] = (intValue6 >>> 15) & mask;
+      output[24 + outputOffset] = ((intValue6 >>> 24) | (intValue7 << 8)) & mask;
+      output[25 + outputOffset] = (intValue7 >>> 1) & mask;
+      output[26 + outputOffset] = (intValue7 >>> 10) & mask;
+      output[27 + outputOffset] = (intValue7 >>> 19) & mask;
+      output[28 + outputOffset] = ((intValue7 >>> 28) | (intValue8 << 4)) & mask;
+      output[29 + outputOffset] = (intValue8 >>> 5) & mask;
+      output[30 + outputOffset] = (intValue8 >>> 14) & mask;
+      output[31 + outputOffset] = intValue8 >>> 23;
+      outputOffset += 32;
+    }
+  }
+  public static void decode10(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 10;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      int intValue5 = compressedBuffer.get();
+      int intValue6 = compressedBuffer.get();
+      int intValue7 = compressedBuffer.get();
+      int intValue8 = compressedBuffer.get();
+      int intValue9 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = (intValue0 >>> 10) & mask;
+      output[2 + outputOffset] = (intValue0 >>> 20) & mask;
+      output[3 + outputOffset] = ((intValue0 >>> 30) | (intValue1 << 2)) & mask;
+      output[4 + outputOffset] = (intValue1 >>> 8) & mask;
+      output[5 + outputOffset] = (intValue1 >>> 18) & mask;
+      output[6 + outputOffset] = ((intValue1 >>> 28) | (intValue2 << 4)) & mask;
+      output[7 + outputOffset] = (intValue2 >>> 6) & mask;
+      output[8 + outputOffset] = (intValue2 >>> 16) & mask;
+      output[9 + outputOffset] = ((intValue2 >>> 26) | (intValue3 << 6)) & mask;
+      output[10 + outputOffset] = (intValue3 >>> 4) & mask;
+      output[11 + outputOffset] = (intValue3 >>> 14) & mask;
+      output[12 + outputOffset] = ((intValue3 >>> 24) | (intValue4 << 8)) & mask;
+      output[13 + outputOffset] = (intValue4 >>> 2) & mask;
+      output[14 + outputOffset] = (intValue4 >>> 12) & mask;
+      output[15 + outputOffset] = intValue4 >>> 22;
+      output[16 + outputOffset] = intValue5 & mask;
+      output[17 + outputOffset] = (intValue5 >>> 10) & mask;
+      output[18 + outputOffset] = (intValue5 >>> 20) & mask;
+      output[19 + outputOffset] = ((intValue5 >>> 30) | (intValue6 << 2)) & mask;
+      output[20 + outputOffset] = (intValue6 >>> 8) & mask;
+      output[21 + outputOffset] = (intValue6 >>> 18) & mask;
+      output[22 + outputOffset] = ((intValue6 >>> 28) | (intValue7 << 4)) & mask;
+      output[23 + outputOffset] = (intValue7 >>> 6) & mask;
+      output[24 + outputOffset] = (intValue7 >>> 16) & mask;
+      output[25 + outputOffset] = ((intValue7 >>> 26) | (intValue8 << 6)) & mask;
+      output[26 + outputOffset] = (intValue8 >>> 4) & mask;
+      output[27 + outputOffset] = (intValue8 >>> 14) & mask;
+      output[28 + outputOffset] = ((intValue8 >>> 24) | (intValue9 << 8)) & mask;
+      output[29 + outputOffset] = (intValue9 >>> 2) & mask;
+      output[30 + outputOffset] = (intValue9 >>> 12) & mask;
+      output[31 + outputOffset] = intValue9 >>> 22;
+      outputOffset += 32;
+    }
+  }
+  public static void decode11(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 11;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      int intValue5 = compressedBuffer.get();
+      int intValue6 = compressedBuffer.get();
+      int intValue7 = compressedBuffer.get();
+      int intValue8 = compressedBuffer.get();
+      int intValue9 = compressedBuffer.get();
+      int intValue10 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = (intValue0 >>> 11) & mask;
+      output[2 + outputOffset] = ((intValue0 >>> 22) | (intValue1 << 10)) & mask;
+      output[3 + outputOffset] = (intValue1 >>> 1) & mask;
+      output[4 + outputOffset] = (intValue1 >>> 12) & mask;
+      output[5 + outputOffset] = ((intValue1 >>> 23) | (intValue2 << 9)) & mask;
+      output[6 + outputOffset] = (intValue2 >>> 2) & mask;
+      output[7 + outputOffset] = (intValue2 >>> 13) & mask;
+      output[8 + outputOffset] = ((intValue2 >>> 24) | (intValue3 << 8)) & mask;
+      output[9 + outputOffset] = (intValue3 >>> 3) & mask;
+      output[10 + outputOffset] = (intValue3 >>> 14) & mask;
+      output[11 + outputOffset] = ((intValue3 >>> 25) | (intValue4 << 7)) & mask;
+      output[12 + outputOffset] = (intValue4 >>> 4) & mask;
+      output[13 + outputOffset] = (intValue4 >>> 15) & mask;
+      output[14 + outputOffset] = ((intValue4 >>> 26) | (intValue5 << 6)) & mask;
+      output[15 + outputOffset] = (intValue5 >>> 5) & mask;
+      output[16 + outputOffset] = (intValue5 >>> 16) & mask;
+      output[17 + outputOffset] = ((intValue5 >>> 27) | (intValue6 << 5)) & mask;
+      output[18 + outputOffset] = (intValue6 >>> 6) & mask;
+      output[19 + outputOffset] = (intValue6 >>> 17) & mask;
+      output[20 + outputOffset] = ((intValue6 >>> 28) | (intValue7 << 4)) & mask;
+      output[21 + outputOffset] = (intValue7 >>> 7) & mask;
+      output[22 + outputOffset] = (intValue7 >>> 18) & mask;
+      output[23 + outputOffset] = ((intValue7 >>> 29) | (intValue8 << 3)) & mask;
+      output[24 + outputOffset] = (intValue8 >>> 8) & mask;
+      output[25 + outputOffset] = (intValue8 >>> 19) & mask;
+      output[26 + outputOffset] = ((intValue8 >>> 30) | (intValue9 << 2)) & mask;
+      output[27 + outputOffset] = (intValue9 >>> 9) & mask;
+      output[28 + outputOffset] = (intValue9 >>> 20) & mask;
+      output[29 + outputOffset] = ((intValue9 >>> 31) | (intValue10 << 1)) & mask;
+      output[30 + outputOffset] = (intValue10 >>> 10) & mask;
+      output[31 + outputOffset] = intValue10 >>> 21;
+      outputOffset += 32;
+    }
+  }
+  public static void decode12(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 12;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      int intValue5 = compressedBuffer.get();
+      int intValue6 = compressedBuffer.get();
+      int intValue7 = compressedBuffer.get();
+      int intValue8 = compressedBuffer.get();
+      int intValue9 = compressedBuffer.get();
+      int intValue10 = compressedBuffer.get();
+      int intValue11 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = (intValue0 >>> 12) & mask;
+      output[2 + outputOffset] = ((intValue0 >>> 24) | (intValue1 << 8)) & mask;
+      output[3 + outputOffset] = (intValue1 >>> 4) & mask;
+      output[4 + outputOffset] = (intValue1 >>> 16) & mask;
+      output[5 + outputOffset] = ((intValue1 >>> 28) | (intValue2 << 4)) & mask;
+      output[6 + outputOffset] = (intValue2 >>> 8) & mask;
+      output[7 + outputOffset] = intValue2 >>> 20;
+      output[8 + outputOffset] = intValue3 & mask;
+      output[9 + outputOffset] = (intValue3 >>> 12) & mask;
+      output[10 + outputOffset] = ((intValue3 >>> 24) | (intValue4 << 8)) & mask;
+      output[11 + outputOffset] = (intValue4 >>> 4) & mask;
+      output[12 + outputOffset] = (intValue4 >>> 16) & mask;
+      output[13 + outputOffset] = ((intValue4 >>> 28) | (intValue5 << 4)) & mask;
+      output[14 + outputOffset] = (intValue5 >>> 8) & mask;
+      output[15 + outputOffset] = intValue5 >>> 20;
+      output[16 + outputOffset] = intValue6 & mask;
+      output[17 + outputOffset] = (intValue6 >>> 12) & mask;
+      output[18 + outputOffset] = ((intValue6 >>> 24) | (intValue7 << 8)) & mask;
+      output[19 + outputOffset] = (intValue7 >>> 4) & mask;
+      output[20 + outputOffset] = (intValue7 >>> 16) & mask;
+      output[21 + outputOffset] = ((intValue7 >>> 28) | (intValue8 << 4)) & mask;
+      output[22 + outputOffset] = (intValue8 >>> 8) & mask;
+      output[23 + outputOffset] = intValue8 >>> 20;
+      output[24 + outputOffset] = intValue9 & mask;
+      output[25 + outputOffset] = (intValue9 >>> 12) & mask;
+      output[26 + outputOffset] = ((intValue9 >>> 24) | (intValue10 << 8)) & mask;
+      output[27 + outputOffset] = (intValue10 >>> 4) & mask;
+      output[28 + outputOffset] = (intValue10 >>> 16) & mask;
+      output[29 + outputOffset] = ((intValue10 >>> 28) | (intValue11 << 4)) & mask;
+      output[30 + outputOffset] = (intValue11 >>> 8) & mask;
+      output[31 + outputOffset] = intValue11 >>> 20;
+      outputOffset += 32;
+    }
+  }
+  public static void decode13(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 13;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      int intValue5 = compressedBuffer.get();
+      int intValue6 = compressedBuffer.get();
+      int intValue7 = compressedBuffer.get();
+      int intValue8 = compressedBuffer.get();
+      int intValue9 = compressedBuffer.get();
+      int intValue10 = compressedBuffer.get();
+      int intValue11 = compressedBuffer.get();
+      int intValue12 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = (intValue0 >>> 13) & mask;
+      output[2 + outputOffset] = ((intValue0 >>> 26) | (intValue1 << 6)) & mask;
+      output[3 + outputOffset] = (intValue1 >>> 7) & mask;
+      output[4 + outputOffset] = ((intValue1 >>> 20) | (intValue2 << 12)) & mask;
+      output[5 + outputOffset] = (intValue2 >>> 1) & mask;
+      output[6 + outputOffset] = (intValue2 >>> 14) & mask;
+      output[7 + outputOffset] = ((intValue2 >>> 27) | (intValue3 << 5)) & mask;
+      output[8 + outputOffset] = (intValue3 >>> 8) & mask;
+      output[9 + outputOffset] = ((intValue3 >>> 21) | (intValue4 << 11)) & mask;
+      output[10 + outputOffset] = (intValue4 >>> 2) & mask;
+      output[11 + outputOffset] = (intValue4 >>> 15) & mask;
+      output[12 + outputOffset] = ((intValue4 >>> 28) | (intValue5 << 4)) & mask;
+      output[13 + outputOffset] = (intValue5 >>> 9) & mask;
+      output[14 + outputOffset] = ((intValue5 >>> 22) | (intValue6 << 10)) & mask;
+      output[15 + outputOffset] = (intValue6 >>> 3) & mask;
+      output[16 + outputOffset] = (intValue6 >>> 16) & mask;
+      output[17 + outputOffset] = ((intValue6 >>> 29) | (intValue7 << 3)) & mask;
+      output[18 + outputOffset] = (intValue7 >>> 10) & mask;
+      output[19 + outputOffset] = ((intValue7 >>> 23) | (intValue8 << 9)) & mask;
+      output[20 + outputOffset] = (intValue8 >>> 4) & mask;
+      output[21 + outputOffset] = (intValue8 >>> 17) & mask;
+      output[22 + outputOffset] = ((intValue8 >>> 30) | (intValue9 << 2)) & mask;
+      output[23 + outputOffset] = (intValue9 >>> 11) & mask;
+      output[24 + outputOffset] = ((intValue9 >>> 24) | (intValue10 << 8)) & mask;
+      output[25 + outputOffset] = (intValue10 >>> 5) & mask;
+      output[26 + outputOffset] = (intValue10 >>> 18) & mask;
+      output[27 + outputOffset] = ((intValue10 >>> 31) | (intValue11 << 1)) & mask;
+      output[28 + outputOffset] = (intValue11 >>> 12) & mask;
+      output[29 + outputOffset] = ((intValue11 >>> 25) | (intValue12 << 7)) & mask;
+      output[30 + outputOffset] = (intValue12 >>> 6) & mask;
+      output[31 + outputOffset] = intValue12 >>> 19;
+      outputOffset += 32;
+    }
+  }
+  public static void decode14(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 14;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      int intValue5 = compressedBuffer.get();
+      int intValue6 = compressedBuffer.get();
+      int intValue7 = compressedBuffer.get();
+      int intValue8 = compressedBuffer.get();
+      int intValue9 = compressedBuffer.get();
+      int intValue10 = compressedBuffer.get();
+      int intValue11 = compressedBuffer.get();
+      int intValue12 = compressedBuffer.get();
+      int intValue13 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = (intValue0 >>> 14) & mask;
+      output[2 + outputOffset] = ((intValue0 >>> 28) | (intValue1 << 4)) & mask;
+      output[3 + outputOffset] = (intValue1 >>> 10) & mask;
+      output[4 + outputOffset] = ((intValue1 >>> 24) | (intValue2 << 8)) & mask;
+      output[5 + outputOffset] = (intValue2 >>> 6) & mask;
+      output[6 + outputOffset] = ((intValue2 >>> 20) | (intValue3 << 12)) & mask;
+      output[7 + outputOffset] = (intValue3 >>> 2) & mask;
+      output[8 + outputOffset] = (intValue3 >>> 16) & mask;
+      output[9 + outputOffset] = ((intValue3 >>> 30) | (intValue4 << 2)) & mask;
+      output[10 + outputOffset] = (intValue4 >>> 12) & mask;
+      output[11 + outputOffset] = ((intValue4 >>> 26) | (intValue5 << 6)) & mask;
+      output[12 + outputOffset] = (intValue5 >>> 8) & mask;
+      output[13 + outputOffset] = ((intValue5 >>> 22) | (intValue6 << 10)) & mask;
+      output[14 + outputOffset] = (intValue6 >>> 4) & mask;
+      output[15 + outputOffset] = intValue6 >>> 18;
+      output[16 + outputOffset] = intValue7 & mask;
+      output[17 + outputOffset] = (intValue7 >>> 14) & mask;
+      output[18 + outputOffset] = ((intValue7 >>> 28) | (intValue8 << 4)) & mask;
+      output[19 + outputOffset] = (intValue8 >>> 10) & mask;
+      output[20 + outputOffset] = ((intValue8 >>> 24) | (intValue9 << 8)) & mask;
+      output[21 + outputOffset] = (intValue9 >>> 6) & mask;
+      output[22 + outputOffset] = ((intValue9 >>> 20) | (intValue10 << 12)) & mask;
+      output[23 + outputOffset] = (intValue10 >>> 2) & mask;
+      output[24 + outputOffset] = (intValue10 >>> 16) & mask;
+      output[25 + outputOffset] = ((intValue10 >>> 30) | (intValue11 << 2)) & mask;
+      output[26 + outputOffset] = (intValue11 >>> 12) & mask;
+      output[27 + outputOffset] = ((intValue11 >>> 26) | (intValue12 << 6)) & mask;
+      output[28 + outputOffset] = (intValue12 >>> 8) & mask;
+      output[29 + outputOffset] = ((intValue12 >>> 22) | (intValue13 << 10)) & mask;
+      output[30 + outputOffset] = (intValue13 >>> 4) & mask;
+      output[31 + outputOffset] = intValue13 >>> 18;
+      outputOffset += 32;
+    }
+  }
+  public static void decode15(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 15;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      int intValue5 = compressedBuffer.get();
+      int intValue6 = compressedBuffer.get();
+      int intValue7 = compressedBuffer.get();
+      int intValue8 = compressedBuffer.get();
+      int intValue9 = compressedBuffer.get();
+      int intValue10 = compressedBuffer.get();
+      int intValue11 = compressedBuffer.get();
+      int intValue12 = compressedBuffer.get();
+      int intValue13 = compressedBuffer.get();
+      int intValue14 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = (intValue0 >>> 15) & mask;
+      output[2 + outputOffset] = ((intValue0 >>> 30) | (intValue1 << 2)) & mask;
+      output[3 + outputOffset] = (intValue1 >>> 13) & mask;
+      output[4 + outputOffset] = ((intValue1 >>> 28) | (intValue2 << 4)) & mask;
+      output[5 + outputOffset] = (intValue2 >>> 11) & mask;
+      output[6 + outputOffset] = ((intValue2 >>> 26) | (intValue3 << 6)) & mask;
+      output[7 + outputOffset] = (intValue3 >>> 9) & mask;
+      output[8 + outputOffset] = ((intValue3 >>> 24) | (intValue4 << 8)) & mask;
+      output[9 + outputOffset] = (intValue4 >>> 7) & mask;
+      output[10 + outputOffset] = ((intValue4 >>> 22) | (intValue5 << 10)) & mask;
+      output[11 + outputOffset] = (intValue5 >>> 5) & mask;
+      output[12 + outputOffset] = ((intValue5 >>> 20) | (intValue6 << 12)) & mask;
+      output[13 + outputOffset] = (intValue6 >>> 3) & mask;
+      output[14 + outputOffset] = ((intValue6 >>> 18) | (intValue7 << 14)) & mask;
+      output[15 + outputOffset] = (intValue7 >>> 1) & mask;
+      output[16 + outputOffset] = (intValue7 >>> 16) & mask;
+      output[17 + outputOffset] = ((intValue7 >>> 31) | (intValue8 << 1)) & mask;
+      output[18 + outputOffset] = (intValue8 >>> 14) & mask;
+      output[19 + outputOffset] = ((intValue8 >>> 29) | (intValue9 << 3)) & mask;
+      output[20 + outputOffset] = (intValue9 >>> 12) & mask;
+      output[21 + outputOffset] = ((intValue9 >>> 27) | (intValue10 << 5)) & mask;
+      output[22 + outputOffset] = (intValue10 >>> 10) & mask;
+      output[23 + outputOffset] = ((intValue10 >>> 25) | (intValue11 << 7)) & mask;
+      output[24 + outputOffset] = (intValue11 >>> 8) & mask;
+      output[25 + outputOffset] = ((intValue11 >>> 23) | (intValue12 << 9)) & mask;
+      output[26 + outputOffset] = (intValue12 >>> 6) & mask;
+      output[27 + outputOffset] = ((intValue12 >>> 21) | (intValue13 << 11)) & mask;
+      output[28 + outputOffset] = (intValue13 >>> 4) & mask;
+      output[29 + outputOffset] = ((intValue13 >>> 19) | (intValue14 << 13)) & mask;
+      output[30 + outputOffset] = (intValue14 >>> 2) & mask;
+      output[31 + outputOffset] = intValue14 >>> 17;
+      outputOffset += 32;
+    }
+  }
+  public static void decode16(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 16;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      int intValue5 = compressedBuffer.get();
+      int intValue6 = compressedBuffer.get();
+      int intValue7 = compressedBuffer.get();
+      int intValue8 = compressedBuffer.get();
+      int intValue9 = compressedBuffer.get();
+      int intValue10 = compressedBuffer.get();
+      int intValue11 = compressedBuffer.get();
+      int intValue12 = compressedBuffer.get();
+      int intValue13 = compressedBuffer.get();
+      int intValue14 = compressedBuffer.get();
+      int intValue15 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = intValue0 >>> 16;
+      output[2 + outputOffset] = intValue1 & mask;
+      output[3 + outputOffset] = intValue1 >>> 16;
+      output[4 + outputOffset] = intValue2 & mask;
+      output[5 + outputOffset] = intValue2 >>> 16;
+      output[6 + outputOffset] = intValue3 & mask;
+      output[7 + outputOffset] = intValue3 >>> 16;
+      output[8 + outputOffset] = intValue4 & mask;
+      output[9 + outputOffset] = intValue4 >>> 16;
+      output[10 + outputOffset] = intValue5 & mask;
+      output[11 + outputOffset] = intValue5 >>> 16;
+      output[12 + outputOffset] = intValue6 & mask;
+      output[13 + outputOffset] = intValue6 >>> 16;
+      output[14 + outputOffset] = intValue7 & mask;
+      output[15 + outputOffset] = intValue7 >>> 16;
+      output[16 + outputOffset] = intValue8 & mask;
+      output[17 + outputOffset] = intValue8 >>> 16;
+      output[18 + outputOffset] = intValue9 & mask;
+      output[19 + outputOffset] = intValue9 >>> 16;
+      output[20 + outputOffset] = intValue10 & mask;
+      output[21 + outputOffset] = intValue10 >>> 16;
+      output[22 + outputOffset] = intValue11 & mask;
+      output[23 + outputOffset] = intValue11 >>> 16;
+      output[24 + outputOffset] = intValue12 & mask;
+      output[25 + outputOffset] = intValue12 >>> 16;
+      output[26 + outputOffset] = intValue13 & mask;
+      output[27 + outputOffset] = intValue13 >>> 16;
+      output[28 + outputOffset] = intValue14 & mask;
+      output[29 + outputOffset] = intValue14 >>> 16;
+      output[30 + outputOffset] = intValue15 & mask;
+      output[31 + outputOffset] = intValue15 >>> 16;
+      outputOffset += 32;
+    }
+  }
+  public static void decode17(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 17;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      int intValue5 = compressedBuffer.get();
+      int intValue6 = compressedBuffer.get();
+      int intValue7 = compressedBuffer.get();
+      int intValue8 = compressedBuffer.get();
+      int intValue9 = compressedBuffer.get();
+      int intValue10 = compressedBuffer.get();
+      int intValue11 = compressedBuffer.get();
+      int intValue12 = compressedBuffer.get();
+      int intValue13 = compressedBuffer.get();
+      int intValue14 = compressedBuffer.get();
+      int intValue15 = compressedBuffer.get();
+      int intValue16 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = ((intValue0 >>> 17) | (intValue1 << 15)) & mask;
+      output[2 + outputOffset] = (intValue1 >>> 2) & mask;
+      output[3 + outputOffset] = ((intValue1 >>> 19) | (intValue2 << 13)) & mask;
+      output[4 + outputOffset] = (intValue2 >>> 4) & mask;
+      output[5 + outputOffset] = ((intValue2 >>> 21) | (intValue3 << 11)) & mask;
+      output[6 + outputOffset] = (intValue3 >>> 6) & mask;
+      output[7 + outputOffset] = ((intValue3 >>> 23) | (intValue4 << 9)) & mask;
+      output[8 + outputOffset] = (intValue4 >>> 8) & mask;
+      output[9 + outputOffset] = ((intValue4 >>> 25) | (intValue5 << 7)) & mask;
+      output[10 + outputOffset] = (intValue5 >>> 10) & mask;
+      output[11 + outputOffset] = ((intValue5 >>> 27) | (intValue6 << 5)) & mask;
+      output[12 + outputOffset] = (intValue6 >>> 12) & mask;
+      output[13 + outputOffset] = ((intValue6 >>> 29) | (intValue7 << 3)) & mask;
+      output[14 + outputOffset] = (intValue7 >>> 14) & mask;
+      output[15 + outputOffset] = ((intValue7 >>> 31) | (intValue8 << 1)) & mask;
+      output[16 + outputOffset] = ((intValue8 >>> 16) | (intValue9 << 16)) & mask;
+      output[17 + outputOffset] = (intValue9 >>> 1) & mask;
+      output[18 + outputOffset] = ((intValue9 >>> 18) | (intValue10 << 14)) & mask;
+      output[19 + outputOffset] = (intValue10 >>> 3) & mask;
+      output[20 + outputOffset] = ((intValue10 >>> 20) | (intValue11 << 12)) & mask;
+      output[21 + outputOffset] = (intValue11 >>> 5) & mask;
+      output[22 + outputOffset] = ((intValue11 >>> 22) | (intValue12 << 10)) & mask;
+      output[23 + outputOffset] = (intValue12 >>> 7) & mask;
+      output[24 + outputOffset] = ((intValue12 >>> 24) | (intValue13 << 8)) & mask;
+      output[25 + outputOffset] = (intValue13 >>> 9) & mask;
+      output[26 + outputOffset] = ((intValue13 >>> 26) | (intValue14 << 6)) & mask;
+      output[27 + outputOffset] = (intValue14 >>> 11) & mask;
+      output[28 + outputOffset] = ((intValue14 >>> 28) | (intValue15 << 4)) & mask;
+      output[29 + outputOffset] = (intValue15 >>> 13) & mask;
+      output[30 + outputOffset] = ((intValue15 >>> 30) | (intValue16 << 2)) & mask;
+      output[31 + outputOffset] = intValue16 >>> 15;
+      outputOffset += 32;
+    }
+  }
+  public static void decode18(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 18;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      int intValue5 = compressedBuffer.get();
+      int intValue6 = compressedBuffer.get();
+      int intValue7 = compressedBuffer.get();
+      int intValue8 = compressedBuffer.get();
+      int intValue9 = compressedBuffer.get();
+      int intValue10 = compressedBuffer.get();
+      int intValue11 = compressedBuffer.get();
+      int intValue12 = compressedBuffer.get();
+      int intValue13 = compressedBuffer.get();
+      int intValue14 = compressedBuffer.get();
+      int intValue15 = compressedBuffer.get();
+      int intValue16 = compressedBuffer.get();
+      int intValue17 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = ((intValue0 >>> 18) | (intValue1 << 14)) & mask;
+      output[2 + outputOffset] = (intValue1 >>> 4) & mask;
+      output[3 + outputOffset] = ((intValue1 >>> 22) | (intValue2 << 10)) & mask;
+      output[4 + outputOffset] = (intValue2 >>> 8) & mask;
+      output[5 + outputOffset] = ((intValue2 >>> 26) | (intValue3 << 6)) & mask;
+      output[6 + outputOffset] = (intValue3 >>> 12) & mask;
+      output[7 + outputOffset] = ((intValue3 >>> 30) | (intValue4 << 2)) & mask;
+      output[8 + outputOffset] = ((intValue4 >>> 16) | (intValue5 << 16)) & mask;
+      output[9 + outputOffset] = (intValue5 >>> 2) & mask;
+      output[10 + outputOffset] = ((intValue5 >>> 20) | (intValue6 << 12)) & mask;
+      output[11 + outputOffset] = (intValue6 >>> 6) & mask;
+      output[12 + outputOffset] = ((intValue6 >>> 24) | (intValue7 << 8)) & mask;
+      output[13 + outputOffset] = (intValue7 >>> 10) & mask;
+      output[14 + outputOffset] = ((intValue7 >>> 28) | (intValue8 << 4)) & mask;
+      output[15 + outputOffset] = intValue8 >>> 14;
+      output[16 + outputOffset] = intValue9 & mask;
+      output[17 + outputOffset] = ((intValue9 >>> 18) | (intValue10 << 14)) & mask;
+      output[18 + outputOffset] = (intValue10 >>> 4) & mask;
+      output[19 + outputOffset] = ((intValue10 >>> 22) | (intValue11 << 10)) & mask;
+      output[20 + outputOffset] = (intValue11 >>> 8) & mask;
+      output[21 + outputOffset] = ((intValue11 >>> 26) | (intValue12 << 6)) & mask;
+      output[22 + outputOffset] = (intValue12 >>> 12) & mask;
+      output[23 + outputOffset] = ((intValue12 >>> 30) | (intValue13 << 2)) & mask;
+      output[24 + outputOffset] = ((intValue13 >>> 16) | (intValue14 << 16)) & mask;
+      output[25 + outputOffset] = (intValue14 >>> 2) & mask;
+      output[26 + outputOffset] = ((intValue14 >>> 20) | (intValue15 << 12)) & mask;
+      output[27 + outputOffset] = (intValue15 >>> 6) & mask;
+      output[28 + outputOffset] = ((intValue15 >>> 24) | (intValue16 << 8)) & mask;
+      output[29 + outputOffset] = (intValue16 >>> 10) & mask;
+      output[30 + outputOffset] = ((intValue16 >>> 28) | (intValue17 << 4)) & mask;
+      output[31 + outputOffset] = intValue17 >>> 14;
+      outputOffset += 32;
+    }
+  }
+  public static void decode19(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 19;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      int intValue5 = compressedBuffer.get();
+      int intValue6 = compressedBuffer.get();
+      int intValue7 = compressedBuffer.get();
+      int intValue8 = compressedBuffer.get();
+      int intValue9 = compressedBuffer.get();
+      int intValue10 = compressedBuffer.get();
+      int intValue11 = compressedBuffer.get();
+      int intValue12 = compressedBuffer.get();
+      int intValue13 = compressedBuffer.get();
+      int intValue14 = compressedBuffer.get();
+      int intValue15 = compressedBuffer.get();
+      int intValue16 = compressedBuffer.get();
+      int intValue17 = compressedBuffer.get();
+      int intValue18 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = ((intValue0 >>> 19) | (intValue1 << 13)) & mask;
+      output[2 + outputOffset] = (intValue1 >>> 6) & mask;
+      output[3 + outputOffset] = ((intValue1 >>> 25) | (intValue2 << 7)) & mask;
+      output[4 + outputOffset] = (intValue2 >>> 12) & mask;
+      output[5 + outputOffset] = ((intValue2 >>> 31) | (intValue3 << 1)) & mask;
+      output[6 + outputOffset] = ((intValue3 >>> 18) | (intValue4 << 14)) & mask;
+      output[7 + outputOffset] = (intValue4 >>> 5) & mask;
+      output[8 + outputOffset] = ((intValue4 >>> 24) | (intValue5 << 8)) & mask;
+      output[9 + outputOffset] = (intValue5 >>> 11) & mask;
+      output[10 + outputOffset] = ((intValue5 >>> 30) | (intValue6 << 2)) & mask;
+      output[11 + outputOffset] = ((intValue6 >>> 17) | (intValue7 << 15)) & mask;
+      output[12 + outputOffset] = (intValue7 >>> 4) & mask;
+      output[13 + outputOffset] = ((intValue7 >>> 23) | (intValue8 << 9)) & mask;
+      output[14 + outputOffset] = (intValue8 >>> 10) & mask;
+      output[15 + outputOffset] = ((intValue8 >>> 29) | (intValue9 << 3)) & mask;
+      output[16 + outputOffset] = ((intValue9 >>> 16) | (intValue10 << 16)) & mask;
+      output[17 + outputOffset] = (intValue10 >>> 3) & mask;
+      output[18 + outputOffset] = ((intValue10 >>> 22) | (intValue11 << 10)) & mask;
+      output[19 + outputOffset] = (intValue11 >>> 9) & mask;
+      output[20 + outputOffset] = ((intValue11 >>> 28) | (intValue12 << 4)) & mask;
+      output[21 + outputOffset] = ((intValue12 >>> 15) | (intValue13 << 17)) & mask;
+      output[22 + outputOffset] = (intValue13 >>> 2) & mask;
+      output[23 + outputOffset] = ((intValue13 >>> 21) | (intValue14 << 11)) & mask;
+      output[24 + outputOffset] = (intValue14 >>> 8) & mask;
+      output[25 + outputOffset] = ((intValue14 >>> 27) | (intValue15 << 5)) & mask;
+      output[26 + outputOffset] = ((intValue15 >>> 14) | (intValue16 << 18)) & mask;
+      output[27 + outputOffset] = (intValue16 >>> 1) & mask;
+      output[28 + outputOffset] = ((intValue16 >>> 20) | (intValue17 << 12)) & mask;
+      output[29 + outputOffset] = (intValue17 >>> 7) & mask;
+      output[30 + outputOffset] = ((intValue17 >>> 26) | (intValue18 << 6)) & mask;
+      output[31 + outputOffset] = intValue18 >>> 13;
+      outputOffset += 32;
+    }
+  }
+  public static void decode20(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 20;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      int intValue5 = compressedBuffer.get();
+      int intValue6 = compressedBuffer.get();
+      int intValue7 = compressedBuffer.get();
+      int intValue8 = compressedBuffer.get();
+      int intValue9 = compressedBuffer.get();
+      int intValue10 = compressedBuffer.get();
+      int intValue11 = compressedBuffer.get();
+      int intValue12 = compressedBuffer.get();
+      int intValue13 = compressedBuffer.get();
+      int intValue14 = compressedBuffer.get();
+      int intValue15 = compressedBuffer.get();
+      int intValue16 = compressedBuffer.get();
+      int intValue17 = compressedBuffer.get();
+      int intValue18 = compressedBuffer.get();
+      int intValue19 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = ((intValue0 >>> 20) | (intValue1 << 12)) & mask;
+      output[2 + outputOffset] = (intValue1 >>> 8) & mask;
+      output[3 + outputOffset] = ((intValue1 >>> 28) | (intValue2 << 4)) & mask;
+      output[4 + outputOffset] = ((intValue2 >>> 16) | (intValue3 << 16)) & mask;
+      output[5 + outputOffset] = (intValue3 >>> 4) & mask;
+      output[6 + outputOffset] = ((intValue3 >>> 24) | (intValue4 << 8)) & mask;
+      output[7 + outputOffset] = intValue4 >>> 12;
+      output[8 + outputOffset] = intValue5 & mask;
+      output[9 + outputOffset] = ((intValue5 >>> 20) | (intValue6 << 12)) & mask;
+      output[10 + outputOffset] = (intValue6 >>> 8) & mask;
+      output[11 + outputOffset] = ((intValue6 >>> 28) | (intValue7 << 4)) & mask;
+      output[12 + outputOffset] = ((intValue7 >>> 16) | (intValue8 << 16)) & mask;
+      output[13 + outputOffset] = (intValue8 >>> 4) & mask;
+      output[14 + outputOffset] = ((intValue8 >>> 24) | (intValue9 << 8)) & mask;
+      output[15 + outputOffset] = intValue9 >>> 12;
+      output[16 + outputOffset] = intValue10 & mask;
+      output[17 + outputOffset] = ((intValue10 >>> 20) | (intValue11 << 12)) & mask;
+      output[18 + outputOffset] = (intValue11 >>> 8) & mask;
+      output[19 + outputOffset] = ((intValue11 >>> 28) | (intValue12 << 4)) & mask;
+      output[20 + outputOffset] = ((intValue12 >>> 16) | (intValue13 << 16)) & mask;
+      output[21 + outputOffset] = (intValue13 >>> 4) & mask;
+      output[22 + outputOffset] = ((intValue13 >>> 24) | (intValue14 << 8)) & mask;
+      output[23 + outputOffset] = intValue14 >>> 12;
+      output[24 + outputOffset] = intValue15 & mask;
+      output[25 + outputOffset] = ((intValue15 >>> 20) | (intValue16 << 12)) & mask;
+      output[26 + outputOffset] = (intValue16 >>> 8) & mask;
+      output[27 + outputOffset] = ((intValue16 >>> 28) | (intValue17 << 4)) & mask;
+      output[28 + outputOffset] = ((intValue17 >>> 16) | (intValue18 << 16)) & mask;
+      output[29 + outputOffset] = (intValue18 >>> 4) & mask;
+      output[30 + outputOffset] = ((intValue18 >>> 24) | (intValue19 << 8)) & mask;
+      output[31 + outputOffset] = intValue19 >>> 12;
+      outputOffset += 32;
+    }
+  }
+  public static void decode21(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 21;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      int intValue5 = compressedBuffer.get();
+      int intValue6 = compressedBuffer.get();
+      int intValue7 = compressedBuffer.get();
+      int intValue8 = compressedBuffer.get();
+      int intValue9 = compressedBuffer.get();
+      int intValue10 = compressedBuffer.get();
+      int intValue11 = compressedBuffer.get();
+      int intValue12 = compressedBuffer.get();
+      int intValue13 = compressedBuffer.get();
+      int intValue14 = compressedBuffer.get();
+      int intValue15 = compressedBuffer.get();
+      int intValue16 = compressedBuffer.get();
+      int intValue17 = compressedBuffer.get();
+      int intValue18 = compressedBuffer.get();
+      int intValue19 = compressedBuffer.get();
+      int intValue20 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = ((intValue0 >>> 21) | (intValue1 << 11)) & mask;
+      output[2 + outputOffset] = (intValue1 >>> 10) & mask;
+      output[3 + outputOffset] = ((intValue1 >>> 31) | (intValue2 << 1)) & mask;
+      output[4 + outputOffset] = ((intValue2 >>> 20) | (intValue3 << 12)) & mask;
+      output[5 + outputOffset] = (intValue3 >>> 9) & mask;
+      output[6 + outputOffset] = ((intValue3 >>> 30) | (intValue4 << 2)) & mask;
+      output[7 + outputOffset] = ((intValue4 >>> 19) | (intValue5 << 13)) & mask;
+      output[8 + outputOffset] = (intValue5 >>> 8) & mask;
+      output[9 + outputOffset] = ((intValue5 >>> 29) | (intValue6 << 3)) & mask;
+      output[10 + outputOffset] = ((intValue6 >>> 18) | (intValue7 << 14)) & mask;
+      output[11 + outputOffset] = (intValue7 >>> 7) & mask;
+      output[12 + outputOffset] = ((intValue7 >>> 28) | (intValue8 << 4)) & mask;
+      output[13 + outputOffset] = ((intValue8 >>> 17) | (intValue9 << 15)) & mask;
+      output[14 + outputOffset] = (intValue9 >>> 6) & mask;
+      output[15 + outputOffset] = ((intValue9 >>> 27) | (intValue10 << 5)) & mask;
+      output[16 + outputOffset] = ((intValue10 >>> 16) | (intValue11 << 16)) & mask;
+      output[17 + outputOffset] = (intValue11 >>> 5) & mask;
+      output[18 + outputOffset] = ((intValue11 >>> 26) | (intValue12 << 6)) & mask;
+      output[19 + outputOffset] = ((intValue12 >>> 15) | (intValue13 << 17)) & mask;
+      output[20 + outputOffset] = (intValue13 >>> 4) & mask;
+      output[21 + outputOffset] = ((intValue13 >>> 25) | (intValue14 << 7)) & mask;
+      output[22 + outputOffset] = ((intValue14 >>> 14) | (intValue15 << 18)) & mask;
+      output[23 + outputOffset] = (intValue15 >>> 3) & mask;
+      output[24 + outputOffset] = ((intValue15 >>> 24) | (intValue16 << 8)) & mask;
+      output[25 + outputOffset] = ((intValue16 >>> 13) | (intValue17 << 19)) & mask;
+      output[26 + outputOffset] = (intValue17 >>> 2) & mask;
+      output[27 + outputOffset] = ((intValue17 >>> 23) | (intValue18 << 9)) & mask;
+      output[28 + outputOffset] = ((intValue18 >>> 12) | (intValue19 << 20)) & mask;
+      output[29 + outputOffset] = (intValue19 >>> 1) & mask;
+      output[30 + outputOffset] = ((intValue19 >>> 22) | (intValue20 << 10)) & mask;
+      output[31 + outputOffset] = intValue20 >>> 11;
+      outputOffset += 32;
+    }
+  }
+  public static void decode22(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 22;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      int intValue5 = compressedBuffer.get();
+      int intValue6 = compressedBuffer.get();
+      int intValue7 = compressedBuffer.get();
+      int intValue8 = compressedBuffer.get();
+      int intValue9 = compressedBuffer.get();
+      int intValue10 = compressedBuffer.get();
+      int intValue11 = compressedBuffer.get();
+      int intValue12 = compressedBuffer.get();
+      int intValue13 = compressedBuffer.get();
+      int intValue14 = compressedBuffer.get();
+      int intValue15 = compressedBuffer.get();
+      int intValue16 = compressedBuffer.get();
+      int intValue17 = compressedBuffer.get();
+      int intValue18 = compressedBuffer.get();
+      int intValue19 = compressedBuffer.get();
+      int intValue20 = compressedBuffer.get();
+      int intValue21 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = ((intValue0 >>> 22) | (intValue1 << 10)) & mask;
+      output[2 + outputOffset] = ((intValue1 >>> 12) | (intValue2 << 20)) & mask;
+      output[3 + outputOffset] = (intValue2 >>> 2) & mask;
+      output[4 + outputOffset] = ((intValue2 >>> 24) | (intValue3 << 8)) & mask;
+      output[5 + outputOffset] = ((intValue3 >>> 14) | (intValue4 << 18)) & mask;
+      output[6 + outputOffset] = (intValue4 >>> 4) & mask;
+      output[7 + outputOffset] = ((intValue4 >>> 26) | (intValue5 << 6)) & mask;
+      output[8 + outputOffset] = ((intValue5 >>> 16) | (intValue6 << 16)) & mask;
+      output[9 + outputOffset] = (intValue6 >>> 6) & mask;
+      output[10 + outputOffset] = ((intValue6 >>> 28) | (intValue7 << 4)) & mask;
+      output[11 + outputOffset] = ((intValue7 >>> 18) | (intValue8 << 14)) & mask;
+      output[12 + outputOffset] = (intValue8 >>> 8) & mask;
+      output[13 + outputOffset] = ((intValue8 >>> 30) | (intValue9 << 2)) & mask;
+      output[14 + outputOffset] = ((intValue9 >>> 20) | (intValue10 << 12)) & mask;
+      output[15 + outputOffset] = intValue10 >>> 10;
+      output[16 + outputOffset] = intValue11 & mask;
+      output[17 + outputOffset] = ((intValue11 >>> 22) | (intValue12 << 10)) & mask;
+      output[18 + outputOffset] = ((intValue12 >>> 12) | (intValue13 << 20)) & mask;
+      output[19 + outputOffset] = (intValue13 >>> 2) & mask;
+      output[20 + outputOffset] = ((intValue13 >>> 24) | (intValue14 << 8)) & mask;
+      output[21 + outputOffset] = ((intValue14 >>> 14) | (intValue15 << 18)) & mask;
+      output[22 + outputOffset] = (intValue15 >>> 4) & mask;
+      output[23 + outputOffset] = ((intValue15 >>> 26) | (intValue16 << 6)) & mask;
+      output[24 + outputOffset] = ((intValue16 >>> 16) | (intValue17 << 16)) & mask;
+      output[25 + outputOffset] = (intValue17 >>> 6) & mask;
+      output[26 + outputOffset] = ((intValue17 >>> 28) | (intValue18 << 4)) & mask;
+      output[27 + outputOffset] = ((intValue18 >>> 18) | (intValue19 << 14)) & mask;
+      output[28 + outputOffset] = (intValue19 >>> 8) & mask;
+      output[29 + outputOffset] = ((intValue19 >>> 30) | (intValue20 << 2)) & mask;
+      output[30 + outputOffset] = ((intValue20 >>> 20) | (intValue21 << 12)) & mask;
+      output[31 + outputOffset] = intValue21 >>> 10;
+      outputOffset += 32;
+    }
+  }
+  public static void decode23(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 23;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      int intValue5 = compressedBuffer.get();
+      int intValue6 = compressedBuffer.get();
+      int intValue7 = compressedBuffer.get();
+      int intValue8 = compressedBuffer.get();
+      int intValue9 = compressedBuffer.get();
+      int intValue10 = compressedBuffer.get();
+      int intValue11 = compressedBuffer.get();
+      int intValue12 = compressedBuffer.get();
+      int intValue13 = compressedBuffer.get();
+      int intValue14 = compressedBuffer.get();
+      int intValue15 = compressedBuffer.get();
+      int intValue16 = compressedBuffer.get();
+      int intValue17 = compressedBuffer.get();
+      int intValue18 = compressedBuffer.get();
+      int intValue19 = compressedBuffer.get();
+      int intValue20 = compressedBuffer.get();
+      int intValue21 = compressedBuffer.get();
+      int intValue22 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = ((intValue0 >>> 23) | (intValue1 << 9)) & mask;
+      output[2 + outputOffset] = ((intValue1 >>> 14) | (intValue2 << 18)) & mask;
+      output[3 + outputOffset] = (intValue2 >>> 5) & mask;
+      output[4 + outputOffset] = ((intValue2 >>> 28) | (intValue3 << 4)) & mask;
+      output[5 + outputOffset] = ((intValue3 >>> 19) | (intValue4 << 13)) & mask;
+      output[6 + outputOffset] = ((intValue4 >>> 10) | (intValue5 << 22)) & mask;
+      output[7 + outputOffset] = (intValue5 >>> 1) & mask;
+      output[8 + outputOffset] = ((intValue5 >>> 24) | (intValue6 << 8)) & mask;
+      output[9 + outputOffset] = ((intValue6 >>> 15) | (intValue7 << 17)) & mask;
+      output[10 + outputOffset] = (intValue7 >>> 6) & mask;
+      output[11 + outputOffset] = ((intValue7 >>> 29) | (intValue8 << 3)) & mask;
+      output[12 + outputOffset] = ((intValue8 >>> 20) | (intValue9 << 12)) & mask;
+      output[13 + outputOffset] = ((intValue9 >>> 11) | (intValue10 << 21)) & mask;
+      output[14 + outputOffset] = (intValue10 >>> 2) & mask;
+      output[15 + outputOffset] = ((intValue10 >>> 25) | (intValue11 << 7)) & mask;
+      output[16 + outputOffset] = ((intValue11 >>> 16) | (intValue12 << 16)) & mask;
+      output[17 + outputOffset] = (intValue12 >>> 7) & mask;
+      output[18 + outputOffset] = ((intValue12 >>> 30) | (intValue13 << 2)) & mask;
+      output[19 + outputOffset] = ((intValue13 >>> 21) | (intValue14 << 11)) & mask;
+      output[20 + outputOffset] = ((intValue14 >>> 12) | (intValue15 << 20)) & mask;
+      output[21 + outputOffset] = (intValue15 >>> 3) & mask;
+      output[22 + outputOffset] = ((intValue15 >>> 26) | (intValue16 << 6)) & mask;
+      output[23 + outputOffset] = ((intValue16 >>> 17) | (intValue17 << 15)) & mask;
+      output[24 + outputOffset] = (intValue17 >>> 8) & mask;
+      output[25 + outputOffset] = ((intValue17 >>> 31) | (intValue18 << 1)) & mask;
+      output[26 + outputOffset] = ((intValue18 >>> 22) | (intValue19 << 10)) & mask;
+      output[27 + outputOffset] = ((intValue19 >>> 13) | (intValue20 << 19)) & mask;
+      output[28 + outputOffset] = (intValue20 >>> 4) & mask;
+      output[29 + outputOffset] = ((intValue20 >>> 27) | (intValue21 << 5)) & mask;
+      output[30 + outputOffset] = ((intValue21 >>> 18) | (intValue22 << 14)) & mask;
+      output[31 + outputOffset] = intValue22 >>> 9;
+      outputOffset += 32;
+    }
+  }
+  public static void decode24(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 24;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      int intValue5 = compressedBuffer.get();
+      int intValue6 = compressedBuffer.get();
+      int intValue7 = compressedBuffer.get();
+      int intValue8 = compressedBuffer.get();
+      int intValue9 = compressedBuffer.get();
+      int intValue10 = compressedBuffer.get();
+      int intValue11 = compressedBuffer.get();
+      int intValue12 = compressedBuffer.get();
+      int intValue13 = compressedBuffer.get();
+      int intValue14 = compressedBuffer.get();
+      int intValue15 = compressedBuffer.get();
+      int intValue16 = compressedBuffer.get();
+      int intValue17 = compressedBuffer.get();
+      int intValue18 = compressedBuffer.get();
+      int intValue19 = compressedBuffer.get();
+      int intValue20 = compressedBuffer.get();
+      int intValue21 = compressedBuffer.get();
+      int intValue22 = compressedBuffer.get();
+      int intValue23 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = ((intValue0 >>> 24) | (intValue1 << 8)) & mask;
+      output[2 + outputOffset] = ((intValue1 >>> 16) | (intValue2 << 16)) & mask;
+      output[3 + outputOffset] = intValue2 >>> 8;
+      output[4 + outputOffset] = intValue3 & mask;
+      output[5 + outputOffset] = ((intValue3 >>> 24) | (intValue4 << 8)) & mask;
+      output[6 + outputOffset] = ((intValue4 >>> 16) | (intValue5 << 16)) & mask;
+      output[7 + outputOffset] = intValue5 >>> 8;
+      output[8 + outputOffset] = intValue6 & mask;
+      output[9 + outputOffset] = ((intValue6 >>> 24) | (intValue7 << 8)) & mask;
+      output[10 + outputOffset] = ((intValue7 >>> 16) | (intValue8 << 16)) & mask;
+      output[11 + outputOffset] = intValue8 >>> 8;
+      output[12 + outputOffset] = intValue9 & mask;
+      output[13 + outputOffset] = ((intValue9 >>> 24) | (intValue10 << 8)) & mask;
+      output[14 + outputOffset] = ((intValue10 >>> 16) | (intValue11 << 16)) & mask;
+      output[15 + outputOffset] = intValue11 >>> 8;
+      output[16 + outputOffset] = intValue12 & mask;
+      output[17 + outputOffset] = ((intValue12 >>> 24) | (intValue13 << 8)) & mask;
+      output[18 + outputOffset] = ((intValue13 >>> 16) | (intValue14 << 16)) & mask;
+      output[19 + outputOffset] = intValue14 >>> 8;
+      output[20 + outputOffset] = intValue15 & mask;
+      output[21 + outputOffset] = ((intValue15 >>> 24) | (intValue16 << 8)) & mask;
+      output[22 + outputOffset] = ((intValue16 >>> 16) | (intValue17 << 16)) & mask;
+      output[23 + outputOffset] = intValue17 >>> 8;
+      output[24 + outputOffset] = intValue18 & mask;
+      output[25 + outputOffset] = ((intValue18 >>> 24) | (intValue19 << 8)) & mask;
+      output[26 + outputOffset] = ((intValue19 >>> 16) | (intValue20 << 16)) & mask;
+      output[27 + outputOffset] = intValue20 >>> 8;
+      output[28 + outputOffset] = intValue21 & mask;
+      output[29 + outputOffset] = ((intValue21 >>> 24) | (intValue22 << 8)) & mask;
+      output[30 + outputOffset] = ((intValue22 >>> 16) | (intValue23 << 16)) & mask;
+      output[31 + outputOffset] = intValue23 >>> 8;
+      outputOffset += 32;
+    }
+  }
+  public static void decode25(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 25;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      int intValue5 = compressedBuffer.get();
+      int intValue6 = compressedBuffer.get();
+      int intValue7 = compressedBuffer.get();
+      int intValue8 = compressedBuffer.get();
+      int intValue9 = compressedBuffer.get();
+      int intValue10 = compressedBuffer.get();
+      int intValue11 = compressedBuffer.get();
+      int intValue12 = compressedBuffer.get();
+      int intValue13 = compressedBuffer.get();
+      int intValue14 = compressedBuffer.get();
+      int intValue15 = compressedBuffer.get();
+      int intValue16 = compressedBuffer.get();
+      int intValue17 = compressedBuffer.get();
+      int intValue18 = compressedBuffer.get();
+      int intValue19 = compressedBuffer.get();
+      int intValue20 = compressedBuffer.get();
+      int intValue21 = compressedBuffer.get();
+      int intValue22 = compressedBuffer.get();
+      int intValue23 = compressedBuffer.get();
+      int intValue24 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = ((intValue0 >>> 25) | (intValue1 << 7)) & mask;
+      output[2 + outputOffset] = ((intValue1 >>> 18) | (intValue2 << 14)) & mask;
+      output[3 + outputOffset] = ((intValue2 >>> 11) | (intValue3 << 21)) & mask;
+      output[4 + outputOffset] = (intValue3 >>> 4) & mask;
+      output[5 + outputOffset] = ((intValue3 >>> 29) | (intValue4 << 3)) & mask;
+      output[6 + outputOffset] = ((intValue4 >>> 22) | (intValue5 << 10)) & mask;
+      output[7 + outputOffset] = ((intValue5 >>> 15) | (intValue6 << 17)) & mask;
+      output[8 + outputOffset] = ((intValue6 >>> 8) | (intValue7 << 24)) & mask;
+      output[9 + outputOffset] = (intValue7 >>> 1) & mask;
+      output[10 + outputOffset] = ((intValue7 >>> 26) | (intValue8 << 6)) & mask;
+      output[11 + outputOffset] = ((intValue8 >>> 19) | (intValue9 << 13)) & mask;
+      output[12 + outputOffset] = ((intValue9 >>> 12) | (intValue10 << 20)) & mask;
+      output[13 + outputOffset] = (intValue10 >>> 5) & mask;
+      output[14 + outputOffset] = ((intValue10 >>> 30) | (intValue11 << 2)) & mask;
+      output[15 + outputOffset] = ((intValue11 >>> 23) | (intValue12 << 9)) & mask;
+      output[16 + outputOffset] = ((intValue12 >>> 16) | (intValue13 << 16)) & mask;
+      output[17 + outputOffset] = ((intValue13 >>> 9) | (intValue14 << 23)) & mask;
+      output[18 + outputOffset] = (intValue14 >>> 2) & mask;
+      output[19 + outputOffset] = ((intValue14 >>> 27) | (intValue15 << 5)) & mask;
+      output[20 + outputOffset] = ((intValue15 >>> 20) | (intValue16 << 12)) & mask;
+      output[21 + outputOffset] = ((intValue16 >>> 13) | (intValue17 << 19)) & mask;
+      output[22 + outputOffset] = (intValue17 >>> 6) & mask;
+      output[23 + outputOffset] = ((intValue17 >>> 31) | (intValue18 << 1)) & mask;
+      output[24 + outputOffset] = ((intValue18 >>> 24) | (intValue19 << 8)) & mask;
+      output[25 + outputOffset] = ((intValue19 >>> 17) | (intValue20 << 15)) & mask;
+      output[26 + outputOffset] = ((intValue20 >>> 10) | (intValue21 << 22)) & mask;
+      output[27 + outputOffset] = (intValue21 >>> 3) & mask;
+      output[28 + outputOffset] = ((intValue21 >>> 28) | (intValue22 << 4)) & mask;
+      output[29 + outputOffset] = ((intValue22 >>> 21) | (intValue23 << 11)) & mask;
+      output[30 + outputOffset] = ((intValue23 >>> 14) | (intValue24 << 18)) & mask;
+      output[31 + outputOffset] = intValue24 >>> 7;
+      outputOffset += 32;
+    }
+  }
+  public static void decode26(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 26;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      int intValue5 = compressedBuffer.get();
+      int intValue6 = compressedBuffer.get();
+      int intValue7 = compressedBuffer.get();
+      int intValue8 = compressedBuffer.get();
+      int intValue9 = compressedBuffer.get();
+      int intValue10 = compressedBuffer.get();
+      int intValue11 = compressedBuffer.get();
+      int intValue12 = compressedBuffer.get();
+      int intValue13 = compressedBuffer.get();
+      int intValue14 = compressedBuffer.get();
+      int intValue15 = compressedBuffer.get();
+      int intValue16 = compressedBuffer.get();
+      int intValue17 = compressedBuffer.get();
+      int intValue18 = compressedBuffer.get();
+      int intValue19 = compressedBuffer.get();
+      int intValue20 = compressedBuffer.get();
+      int intValue21 = compressedBuffer.get();
+      int intValue22 = compressedBuffer.get();
+      int intValue23 = compressedBuffer.get();
+      int intValue24 = compressedBuffer.get();
+      int intValue25 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = ((intValue0 >>> 26) | (intValue1 << 6)) & mask;
+      output[2 + outputOffset] = ((intValue1 >>> 20) | (intValue2 << 12)) & mask;
+      output[3 + outputOffset] = ((intValue2 >>> 14) | (intValue3 << 18)) & mask;
+      output[4 + outputOffset] = ((intValue3 >>> 8) | (intValue4 << 24)) & mask;
+      output[5 + outputOffset] = (intValue4 >>> 2) & mask;
+      output[6 + outputOffset] = ((intValue4 >>> 28) | (intValue5 << 4)) & mask;
+      output[7 + outputOffset] = ((intValue5 >>> 22) | (intValue6 << 10)) & mask;
+      output[8 + outputOffset] = ((intValue6 >>> 16) | (intValue7 << 16)) & mask;
+      output[9 + outputOffset] = ((intValue7 >>> 10) | (intValue8 << 22)) & mask;
+      output[10 + outputOffset] = (intValue8 >>> 4) & mask;
+      output[11 + outputOffset] = ((intValue8 >>> 30) | (intValue9 << 2)) & mask;
+      output[12 + outputOffset] = ((intValue9 >>> 24) | (intValue10 << 8)) & mask;
+      output[13 + outputOffset] = ((intValue10 >>> 18) | (intValue11 << 14)) & mask;
+      output[14 + outputOffset] = ((intValue11 >>> 12) | (intValue12 << 20)) & mask;
+      output[15 + outputOffset] = intValue12 >>> 6;
+      output[16 + outputOffset] = intValue13 & mask;
+      output[17 + outputOffset] = ((intValue13 >>> 26) | (intValue14 << 6)) & mask;
+      output[18 + outputOffset] = ((intValue14 >>> 20) | (intValue15 << 12)) & mask;
+      output[19 + outputOffset] = ((intValue15 >>> 14) | (intValue16 << 18)) & mask;
+      output[20 + outputOffset] = ((intValue16 >>> 8) | (intValue17 << 24)) & mask;
+      output[21 + outputOffset] = (intValue17 >>> 2) & mask;
+      output[22 + outputOffset] = ((intValue17 >>> 28) | (intValue18 << 4)) & mask;
+      output[23 + outputOffset] = ((intValue18 >>> 22) | (intValue19 << 10)) & mask;
+      output[24 + outputOffset] = ((intValue19 >>> 16) | (intValue20 << 16)) & mask;
+      output[25 + outputOffset] = ((intValue20 >>> 10) | (intValue21 << 22)) & mask;
+      output[26 + outputOffset] = (intValue21 >>> 4) & mask;
+      output[27 + outputOffset] = ((intValue21 >>> 30) | (intValue22 << 2)) & mask;
+      output[28 + outputOffset] = ((intValue22 >>> 24) | (intValue23 << 8)) & mask;
+      output[29 + outputOffset] = ((intValue23 >>> 18) | (intValue24 << 14)) & mask;
+      output[30 + outputOffset] = ((intValue24 >>> 12) | (intValue25 << 20)) & mask;
+      output[31 + outputOffset] = intValue25 >>> 6;
+      outputOffset += 32;
+    }
+  }
+  public static void decode27(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 27;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      int intValue5 = compressedBuffer.get();
+      int intValue6 = compressedBuffer.get();
+      int intValue7 = compressedBuffer.get();
+      int intValue8 = compressedBuffer.get();
+      int intValue9 = compressedBuffer.get();
+      int intValue10 = compressedBuffer.get();
+      int intValue11 = compressedBuffer.get();
+      int intValue12 = compressedBuffer.get();
+      int intValue13 = compressedBuffer.get();
+      int intValue14 = compressedBuffer.get();
+      int intValue15 = compressedBuffer.get();
+      int intValue16 = compressedBuffer.get();
+      int intValue17 = compressedBuffer.get();
+      int intValue18 = compressedBuffer.get();
+      int intValue19 = compressedBuffer.get();
+      int intValue20 = compressedBuffer.get();
+      int intValue21 = compressedBuffer.get();
+      int intValue22 = compressedBuffer.get();
+      int intValue23 = compressedBuffer.get();
+      int intValue24 = compressedBuffer.get();
+      int intValue25 = compressedBuffer.get();
+      int intValue26 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = ((intValue0 >>> 27) | (intValue1 << 5)) & mask;
+      output[2 + outputOffset] = ((intValue1 >>> 22) | (intValue2 << 10)) & mask;
+      output[3 + outputOffset] = ((intValue2 >>> 17) | (intValue3 << 15)) & mask;
+      output[4 + outputOffset] = ((intValue3 >>> 12) | (intValue4 << 20)) & mask;
+      output[5 + outputOffset] = ((intValue4 >>> 7) | (intValue5 << 25)) & mask;
+      output[6 + outputOffset] = (intValue5 >>> 2) & mask;
+      output[7 + outputOffset] = ((intValue5 >>> 29) | (intValue6 << 3)) & mask;
+      output[8 + outputOffset] = ((intValue6 >>> 24) | (intValue7 << 8)) & mask;
+      output[9 + outputOffset] = ((intValue7 >>> 19) | (intValue8 << 13)) & mask;
+      output[10 + outputOffset] = ((intValue8 >>> 14) | (intValue9 << 18)) & mask;
+      output[11 + outputOffset] = ((intValue9 >>> 9) | (intValue10 << 23)) & mask;
+      output[12 + outputOffset] = (intValue10 >>> 4) & mask;
+      output[13 + outputOffset] = ((intValue10 >>> 31) | (intValue11 << 1)) & mask;
+      output[14 + outputOffset] = ((intValue11 >>> 26) | (intValue12 << 6)) & mask;
+      output[15 + outputOffset] = ((intValue12 >>> 21) | (intValue13 << 11)) & mask;
+      output[16 + outputOffset] = ((intValue13 >>> 16) | (intValue14 << 16)) & mask;
+      output[17 + outputOffset] = ((intValue14 >>> 11) | (intValue15 << 21)) & mask;
+      output[18 + outputOffset] = ((intValue15 >>> 6) | (intValue16 << 26)) & mask;
+      output[19 + outputOffset] = (intValue16 >>> 1) & mask;
+      output[20 + outputOffset] = ((intValue16 >>> 28) | (intValue17 << 4)) & mask;
+      output[21 + outputOffset] = ((intValue17 >>> 23) | (intValue18 << 9)) & mask;
+      output[22 + outputOffset] = ((intValue18 >>> 18) | (intValue19 << 14)) & mask;
+      output[23 + outputOffset] = ((intValue19 >>> 13) | (intValue20 << 19)) & mask;
+      output[24 + outputOffset] = ((intValue20 >>> 8) | (intValue21 << 24)) & mask;
+      output[25 + outputOffset] = (intValue21 >>> 3) & mask;
+      output[26 + outputOffset] = ((intValue21 >>> 30) | (intValue22 << 2)) & mask;
+      output[27 + outputOffset] = ((intValue22 >>> 25) | (intValue23 << 7)) & mask;
+      output[28 + outputOffset] = ((intValue23 >>> 20) | (intValue24 << 12)) & mask;
+      output[29 + outputOffset] = ((intValue24 >>> 15) | (intValue25 << 17)) & mask;
+      output[30 + outputOffset] = ((intValue25 >>> 10) | (intValue26 << 22)) & mask;
+      output[31 + outputOffset] = intValue26 >>> 5;
+      outputOffset += 32;
+    }
+  }
+  public static void decode28(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 28;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      int intValue5 = compressedBuffer.get();
+      int intValue6 = compressedBuffer.get();
+      int intValue7 = compressedBuffer.get();
+      int intValue8 = compressedBuffer.get();
+      int intValue9 = compressedBuffer.get();
+      int intValue10 = compressedBuffer.get();
+      int intValue11 = compressedBuffer.get();
+      int intValue12 = compressedBuffer.get();
+      int intValue13 = compressedBuffer.get();
+      int intValue14 = compressedBuffer.get();
+      int intValue15 = compressedBuffer.get();
+      int intValue16 = compressedBuffer.get();
+      int intValue17 = compressedBuffer.get();
+      int intValue18 = compressedBuffer.get();
+      int intValue19 = compressedBuffer.get();
+      int intValue20 = compressedBuffer.get();
+      int intValue21 = compressedBuffer.get();
+      int intValue22 = compressedBuffer.get();
+      int intValue23 = compressedBuffer.get();
+      int intValue24 = compressedBuffer.get();
+      int intValue25 = compressedBuffer.get();
+      int intValue26 = compressedBuffer.get();
+      int intValue27 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = ((intValue0 >>> 28) | (intValue1 << 4)) & mask;
+      output[2 + outputOffset] = ((intValue1 >>> 24) | (intValue2 << 8)) & mask;
+      output[3 + outputOffset] = ((intValue2 >>> 20) | (intValue3 << 12)) & mask;
+      output[4 + outputOffset] = ((intValue3 >>> 16) | (intValue4 << 16)) & mask;
+      output[5 + outputOffset] = ((intValue4 >>> 12) | (intValue5 << 20)) & mask;
+      output[6 + outputOffset] = ((intValue5 >>> 8) | (intValue6 << 24)) & mask;
+      output[7 + outputOffset] = intValue6 >>> 4;
+      output[8 + outputOffset] = intValue7 & mask;
+      output[9 + outputOffset] = ((intValue7 >>> 28) | (intValue8 << 4)) & mask;
+      output[10 + outputOffset] = ((intValue8 >>> 24) | (intValue9 << 8)) & mask;
+      output[11 + outputOffset] = ((intValue9 >>> 20) | (intValue10 << 12)) & mask;
+      output[12 + outputOffset] = ((intValue10 >>> 16) | (intValue11 << 16)) & mask;
+      output[13 + outputOffset] = ((intValue11 >>> 12) | (intValue12 << 20)) & mask;
+      output[14 + outputOffset] = ((intValue12 >>> 8) | (intValue13 << 24)) & mask;
+      output[15 + outputOffset] = intValue13 >>> 4;
+      output[16 + outputOffset] = intValue14 & mask;
+      output[17 + outputOffset] = ((intValue14 >>> 28) | (intValue15 << 4)) & mask;
+      output[18 + outputOffset] = ((intValue15 >>> 24) | (intValue16 << 8)) & mask;
+      output[19 + outputOffset] = ((intValue16 >>> 20) | (intValue17 << 12)) & mask;
+      output[20 + outputOffset] = ((intValue17 >>> 16) | (intValue18 << 16)) & mask;
+      output[21 + outputOffset] = ((intValue18 >>> 12) | (intValue19 << 20)) & mask;
+      output[22 + outputOffset] = ((intValue19 >>> 8) | (intValue20 << 24)) & mask;
+      output[23 + outputOffset] = intValue20 >>> 4;
+      output[24 + outputOffset] = intValue21 & mask;
+      output[25 + outputOffset] = ((intValue21 >>> 28) | (intValue22 << 4)) & mask;
+      output[26 + outputOffset] = ((intValue22 >>> 24) | (intValue23 << 8)) & mask;
+      output[27 + outputOffset] = ((intValue23 >>> 20) | (intValue24 << 12)) & mask;
+      output[28 + outputOffset] = ((intValue24 >>> 16) | (intValue25 << 16)) & mask;
+      output[29 + outputOffset] = ((intValue25 >>> 12) | (intValue26 << 20)) & mask;
+      output[30 + outputOffset] = ((intValue26 >>> 8) | (intValue27 << 24)) & mask;
+      output[31 + outputOffset] = intValue27 >>> 4;
+      outputOffset += 32;
+    }
+  }
+  public static void decode29(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 29;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      int intValue5 = compressedBuffer.get();
+      int intValue6 = compressedBuffer.get();
+      int intValue7 = compressedBuffer.get();
+      int intValue8 = compressedBuffer.get();
+      int intValue9 = compressedBuffer.get();
+      int intValue10 = compressedBuffer.get();
+      int intValue11 = compressedBuffer.get();
+      int intValue12 = compressedBuffer.get();
+      int intValue13 = compressedBuffer.get();
+      int intValue14 = compressedBuffer.get();
+      int intValue15 = compressedBuffer.get();
+      int intValue16 = compressedBuffer.get();
+      int intValue17 = compressedBuffer.get();
+      int intValue18 = compressedBuffer.get();
+      int intValue19 = compressedBuffer.get();
+      int intValue20 = compressedBuffer.get();
+      int intValue21 = compressedBuffer.get();
+      int intValue22 = compressedBuffer.get();
+      int intValue23 = compressedBuffer.get();
+      int intValue24 = compressedBuffer.get();
+      int intValue25 = compressedBuffer.get();
+      int intValue26 = compressedBuffer.get();
+      int intValue27 = compressedBuffer.get();
+      int intValue28 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = ((intValue0 >>> 29) | (intValue1 << 3)) & mask;
+      output[2 + outputOffset] = ((intValue1 >>> 26) | (intValue2 << 6)) & mask;
+      output[3 + outputOffset] = ((intValue2 >>> 23) | (intValue3 << 9)) & mask;
+      output[4 + outputOffset] = ((intValue3 >>> 20) | (intValue4 << 12)) & mask;
+      output[5 + outputOffset] = ((intValue4 >>> 17) | (intValue5 << 15)) & mask;
+      output[6 + outputOffset] = ((intValue5 >>> 14) | (intValue6 << 18)) & mask;
+      output[7 + outputOffset] = ((intValue6 >>> 11) | (intValue7 << 21)) & mask;
+      output[8 + outputOffset] = ((intValue7 >>> 8) | (intValue8 << 24)) & mask;
+      output[9 + outputOffset] = ((intValue8 >>> 5) | (intValue9 << 27)) & mask;
+      output[10 + outputOffset] = (intValue9 >>> 2) & mask;
+      output[11 + outputOffset] = ((intValue9 >>> 31) | (intValue10 << 1)) & mask;
+      output[12 + outputOffset] = ((intValue10 >>> 28) | (intValue11 << 4)) & mask;
+      output[13 + outputOffset] = ((intValue11 >>> 25) | (intValue12 << 7)) & mask;
+      output[14 + outputOffset] = ((intValue12 >>> 22) | (intValue13 << 10)) & mask;
+      output[15 + outputOffset] = ((intValue13 >>> 19) | (intValue14 << 13)) & mask;
+      output[16 + outputOffset] = ((intValue14 >>> 16) | (intValue15 << 16)) & mask;
+      output[17 + outputOffset] = ((intValue15 >>> 13) | (intValue16 << 19)) & mask;
+      output[18 + outputOffset] = ((intValue16 >>> 10) | (intValue17 << 22)) & mask;
+      output[19 + outputOffset] = ((intValue17 >>> 7) | (intValue18 << 25)) & mask;
+      output[20 + outputOffset] = ((intValue18 >>> 4) | (intValue19 << 28)) & mask;
+      output[21 + outputOffset] = (intValue19 >>> 1) & mask;
+      output[22 + outputOffset] = ((intValue19 >>> 30) | (intValue20 << 2)) & mask;
+      output[23 + outputOffset] = ((intValue20 >>> 27) | (intValue21 << 5)) & mask;
+      output[24 + outputOffset] = ((intValue21 >>> 24) | (intValue22 << 8)) & mask;
+      output[25 + outputOffset] = ((intValue22 >>> 21) | (intValue23 << 11)) & mask;
+      output[26 + outputOffset] = ((intValue23 >>> 18) | (intValue24 << 14)) & mask;
+      output[27 + outputOffset] = ((intValue24 >>> 15) | (intValue25 << 17)) & mask;
+      output[28 + outputOffset] = ((intValue25 >>> 12) | (intValue26 << 20)) & mask;
+      output[29 + outputOffset] = ((intValue26 >>> 9) | (intValue27 << 23)) & mask;
+      output[30 + outputOffset] = ((intValue27 >>> 6) | (intValue28 << 26)) & mask;
+      output[31 + outputOffset] = intValue28 >>> 3;
+      outputOffset += 32;
+    }
+  }
+  public static void decode30(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 30;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      int intValue5 = compressedBuffer.get();
+      int intValue6 = compressedBuffer.get();
+      int intValue7 = compressedBuffer.get();
+      int intValue8 = compressedBuffer.get();
+      int intValue9 = compressedBuffer.get();
+      int intValue10 = compressedBuffer.get();
+      int intValue11 = compressedBuffer.get();
+      int intValue12 = compressedBuffer.get();
+      int intValue13 = compressedBuffer.get();
+      int intValue14 = compressedBuffer.get();
+      int intValue15 = compressedBuffer.get();
+      int intValue16 = compressedBuffer.get();
+      int intValue17 = compressedBuffer.get();
+      int intValue18 = compressedBuffer.get();
+      int intValue19 = compressedBuffer.get();
+      int intValue20 = compressedBuffer.get();
+      int intValue21 = compressedBuffer.get();
+      int intValue22 = compressedBuffer.get();
+      int intValue23 = compressedBuffer.get();
+      int intValue24 = compressedBuffer.get();
+      int intValue25 = compressedBuffer.get();
+      int intValue26 = compressedBuffer.get();
+      int intValue27 = compressedBuffer.get();
+      int intValue28 = compressedBuffer.get();
+      int intValue29 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = ((intValue0 >>> 30) | (intValue1 << 2)) & mask;
+      output[2 + outputOffset] = ((intValue1 >>> 28) | (intValue2 << 4)) & mask;
+      output[3 + outputOffset] = ((intValue2 >>> 26) | (intValue3 << 6)) & mask;
+      output[4 + outputOffset] = ((intValue3 >>> 24) | (intValue4 << 8)) & mask;
+      output[5 + outputOffset] = ((intValue4 >>> 22) | (intValue5 << 10)) & mask;
+      output[6 + outputOffset] = ((intValue5 >>> 20) | (intValue6 << 12)) & mask;
+      output[7 + outputOffset] = ((intValue6 >>> 18) | (intValue7 << 14)) & mask;
+      output[8 + outputOffset] = ((intValue7 >>> 16) | (intValue8 << 16)) & mask;
+      output[9 + outputOffset] = ((intValue8 >>> 14) | (intValue9 << 18)) & mask;
+      output[10 + outputOffset] = ((intValue9 >>> 12) | (intValue10 << 20)) & mask;
+      output[11 + outputOffset] = ((intValue10 >>> 10) | (intValue11 << 22)) & mask;
+      output[12 + outputOffset] = ((intValue11 >>> 8) | (intValue12 << 24)) & mask;
+      output[13 + outputOffset] = ((intValue12 >>> 6) | (intValue13 << 26)) & mask;
+      output[14 + outputOffset] = ((intValue13 >>> 4) | (intValue14 << 28)) & mask;
+      output[15 + outputOffset] = intValue14 >>> 2;
+      output[16 + outputOffset] = intValue15 & mask;
+      output[17 + outputOffset] = ((intValue15 >>> 30) | (intValue16 << 2)) & mask;
+      output[18 + outputOffset] = ((intValue16 >>> 28) | (intValue17 << 4)) & mask;
+      output[19 + outputOffset] = ((intValue17 >>> 26) | (intValue18 << 6)) & mask;
+      output[20 + outputOffset] = ((intValue18 >>> 24) | (intValue19 << 8)) & mask;
+      output[21 + outputOffset] = ((intValue19 >>> 22) | (intValue20 << 10)) & mask;
+      output[22 + outputOffset] = ((intValue20 >>> 20) | (intValue21 << 12)) & mask;
+      output[23 + outputOffset] = ((intValue21 >>> 18) | (intValue22 << 14)) & mask;
+      output[24 + outputOffset] = ((intValue22 >>> 16) | (intValue23 << 16)) & mask;
+      output[25 + outputOffset] = ((intValue23 >>> 14) | (intValue24 << 18)) & mask;
+      output[26 + outputOffset] = ((intValue24 >>> 12) | (intValue25 << 20)) & mask;
+      output[27 + outputOffset] = ((intValue25 >>> 10) | (intValue26 << 22)) & mask;
+      output[28 + outputOffset] = ((intValue26 >>> 8) | (intValue27 << 24)) & mask;
+      output[29 + outputOffset] = ((intValue27 >>> 6) | (intValue28 << 26)) & mask;
+      output[30 + outputOffset] = ((intValue28 >>> 4) | (intValue29 << 28)) & mask;
+      output[31 + outputOffset] = intValue29 >>> 2;
+      outputOffset += 32;
+    }
+  }
+  public static void decode31(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 31;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      int intValue5 = compressedBuffer.get();
+      int intValue6 = compressedBuffer.get();
+      int intValue7 = compressedBuffer.get();
+      int intValue8 = compressedBuffer.get();
+      int intValue9 = compressedBuffer.get();
+      int intValue10 = compressedBuffer.get();
+      int intValue11 = compressedBuffer.get();
+      int intValue12 = compressedBuffer.get();
+      int intValue13 = compressedBuffer.get();
+      int intValue14 = compressedBuffer.get();
+      int intValue15 = compressedBuffer.get();
+      int intValue16 = compressedBuffer.get();
+      int intValue17 = compressedBuffer.get();
+      int intValue18 = compressedBuffer.get();
+      int intValue19 = compressedBuffer.get();
+      int intValue20 = compressedBuffer.get();
+      int intValue21 = compressedBuffer.get();
+      int intValue22 = compressedBuffer.get();
+      int intValue23 = compressedBuffer.get();
+      int intValue24 = compressedBuffer.get();
+      int intValue25 = compressedBuffer.get();
+      int intValue26 = compressedBuffer.get();
+      int intValue27 = compressedBuffer.get();
+      int intValue28 = compressedBuffer.get();
+      int intValue29 = compressedBuffer.get();
+      int intValue30 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0 & mask;
+      output[1 + outputOffset] = ((intValue0 >>> 31) | (intValue1 << 1)) & mask;
+      output[2 + outputOffset] = ((intValue1 >>> 30) | (intValue2 << 2)) & mask;
+      output[3 + outputOffset] = ((intValue2 >>> 29) | (intValue3 << 3)) & mask;
+      output[4 + outputOffset] = ((intValue3 >>> 28) | (intValue4 << 4)) & mask;
+      output[5 + outputOffset] = ((intValue4 >>> 27) | (intValue5 << 5)) & mask;
+      output[6 + outputOffset] = ((intValue5 >>> 26) | (intValue6 << 6)) & mask;
+      output[7 + outputOffset] = ((intValue6 >>> 25) | (intValue7 << 7)) & mask;
+      output[8 + outputOffset] = ((intValue7 >>> 24) | (intValue8 << 8)) & mask;
+      output[9 + outputOffset] = ((intValue8 >>> 23) | (intValue9 << 9)) & mask;
+      output[10 + outputOffset] = ((intValue9 >>> 22) | (intValue10 << 10)) & mask;
+      output[11 + outputOffset] = ((intValue10 >>> 21) | (intValue11 << 11)) & mask;
+      output[12 + outputOffset] = ((intValue11 >>> 20) | (intValue12 << 12)) & mask;
+      output[13 + outputOffset] = ((intValue12 >>> 19) | (intValue13 << 13)) & mask;
+      output[14 + outputOffset] = ((intValue13 >>> 18) | (intValue14 << 14)) & mask;
+      output[15 + outputOffset] = ((intValue14 >>> 17) | (intValue15 << 15)) & mask;
+      output[16 + outputOffset] = ((intValue15 >>> 16) | (intValue16 << 16)) & mask;
+      output[17 + outputOffset] = ((intValue16 >>> 15) | (intValue17 << 17)) & mask;
+      output[18 + outputOffset] = ((intValue17 >>> 14) | (intValue18 << 18)) & mask;
+      output[19 + outputOffset] = ((intValue18 >>> 13) | (intValue19 << 19)) & mask;
+      output[20 + outputOffset] = ((intValue19 >>> 12) | (intValue20 << 20)) & mask;
+      output[21 + outputOffset] = ((intValue20 >>> 11) | (intValue21 << 21)) & mask;
+      output[22 + outputOffset] = ((intValue21 >>> 10) | (intValue22 << 22)) & mask;
+      output[23 + outputOffset] = ((intValue22 >>> 9) | (intValue23 << 23)) & mask;
+      output[24 + outputOffset] = ((intValue23 >>> 8) | (intValue24 << 24)) & mask;
+      output[25 + outputOffset] = ((intValue24 >>> 7) | (intValue25 << 25)) & mask;
+      output[26 + outputOffset] = ((intValue25 >>> 6) | (intValue26 << 26)) & mask;
+      output[27 + outputOffset] = ((intValue26 >>> 5) | (intValue27 << 27)) & mask;
+      output[28 + outputOffset] = ((intValue27 >>> 4) | (intValue28 << 28)) & mask;
+      output[29 + outputOffset] = ((intValue28 >>> 3) | (intValue29 << 29)) & mask;
+      output[30 + outputOffset] = ((intValue29 >>> 2) | (intValue30 << 30)) & mask;
+      output[31 + outputOffset] = intValue30 >>> 1;
+      outputOffset += 32;
+    }
+  }
+  public static void decode32(final IntBuffer compressedBuffer, final int[] output) {
+    final int numFrameBits = 32;
+    final int mask = (int) ((1L<<numFrameBits) - 1);
+    int outputOffset = 0;
+    for(int step=0;step<4;step++) {
+      int intValue0 = compressedBuffer.get();
+      int intValue1 = compressedBuffer.get();
+      int intValue2 = compressedBuffer.get();
+      int intValue3 = compressedBuffer.get();
+      int intValue4 = compressedBuffer.get();
+      int intValue5 = compressedBuffer.get();
+      int intValue6 = compressedBuffer.get();
+      int intValue7 = compressedBuffer.get();
+      int intValue8 = compressedBuffer.get();
+      int intValue9 = compressedBuffer.get();
+      int intValue10 = compressedBuffer.get();
+      int intValue11 = compressedBuffer.get();
+      int intValue12 = compressedBuffer.get();
+      int intValue13 = compressedBuffer.get();
+      int intValue14 = compressedBuffer.get();
+      int intValue15 = compressedBuffer.get();
+      int intValue16 = compressedBuffer.get();
+      int intValue17 = compressedBuffer.get();
+      int intValue18 = compressedBuffer.get();
+      int intValue19 = compressedBuffer.get();
+      int intValue20 = compressedBuffer.get();
+      int intValue21 = compressedBuffer.get();
+      int intValue22 = compressedBuffer.get();
+      int intValue23 = compressedBuffer.get();
+      int intValue24 = compressedBuffer.get();
+      int intValue25 = compressedBuffer.get();
+      int intValue26 = compressedBuffer.get();
+      int intValue27 = compressedBuffer.get();
+      int intValue28 = compressedBuffer.get();
+      int intValue29 = compressedBuffer.get();
+      int intValue30 = compressedBuffer.get();
+      int intValue31 = compressedBuffer.get();
+      output[0 + outputOffset] = intValue0;
+      output[1 + outputOffset] = intValue1;
+      output[2 + outputOffset] = intValue2;
+      output[3 + outputOffset] = intValue3;
+      output[4 + outputOffset] = intValue4;
+      output[5 + outputOffset] = intValue5;
+      output[6 + outputOffset] = intValue6;
+      output[7 + outputOffset] = intValue7;
+      output[8 + outputOffset] = intValue8;
+      output[9 + outputOffset] = intValue9;
+      output[10 + outputOffset] = intValue10;
+      output[11 + outputOffset] = intValue11;
+      output[12 + outputOffset] = intValue12;
+      output[13 + outputOffset] = intValue13;
+      output[14 + outputOffset] = intValue14;
+      output[15 + outputOffset] = intValue15;
+      output[16 + outputOffset] = intValue16;
+      output[17 + outputOffset] = intValue17;
+      output[18 + outputOffset] = intValue18;
+      output[19 + outputOffset] = intValue19;
+      output[20 + outputOffset] = intValue20;
+      output[21 + outputOffset] = intValue21;
+      output[22 + outputOffset] = intValue22;
+      output[23 + outputOffset] = intValue23;
+      output[24 + outputOffset] = intValue24;
+      output[25 + outputOffset] = intValue25;
+      output[26 + outputOffset] = intValue26;
+      output[27 + outputOffset] = intValue27;
+      output[28 + outputOffset] = intValue28;
+      output[29 + outputOffset] = intValue29;
+      output[30 + outputOffset] = intValue30;
+      output[31 + outputOffset] = intValue31;
+      outputOffset += 32;
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/block/gendecompress.py b/lucene/core/src/java/org/apache/lucene/codecs/block/gendecompress.py
new file mode 100755
index 0000000..29b4467
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/codecs/block/gendecompress.py
@@ -0,0 +1,107 @@
+#!/usr/bin/env python2
+"""
+  Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the "License"); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
+  
+     http://www.apache.org/licenses/LICENSE-2.0
+  
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+"""
+
+"""
+Generate source code for java classes for For or PFor decompression.
+"""
+
+def bitsExpr(i, numFrameBits):
+  framePos = i * numFrameBits
+  intValNum = (framePos / 32)
+  bitPos = framePos % 32
+  bitsInInt = "intValue" + str(intValNum)
+  needBrackets = 0
+  if bitPos > 0:
+    bitsInInt +=  " >>> " + str(bitPos)
+    needBrackets = 1
+  if bitPos + numFrameBits > 32:
+    if needBrackets:
+      bitsInInt = "(" + bitsInInt + ")"
+    bitsInInt += " | (intValue" + str(intValNum+1) + " << "+ str(32 - bitPos) + ")"
+    needBrackets = 1
+  if bitPos + numFrameBits != 32:
+    if needBrackets:
+      bitsInInt = "(" + bitsInInt + ")"
+    bitsInInt += " & mask"
+  return bitsInInt
+
+
+def genDecompress():
+  className = "PackedIntsDecompress"
+  fileName = className + ".java"
+  imports = "import java.nio.IntBuffer;\n"
+  f = open(fileName, 'w')
+  w = f.write
+  try:
+    w("package org.apache.lucene.codecs.block;\n")
+    w("""/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ """)
+
+    w("\n/* This code is generated, do not modify. See gendecompress.py */\n\n")
+
+    w("import java.nio.IntBuffer;\n")
+    w("import java.util.Arrays;\n\n")
+
+    w("final class PackedIntsDecompress {\n")
+
+    w('\n  // nocommit: assess perf of this to see if specializing is really needed\n')
+    w('\n  // NOTE: hardwired to blockSize == 128\n\n')
+
+    w('  public static void decode0(final IntBuffer compressedBuffer, final int[] output) {\n')
+    w('    Arrays.fill(output, compressedBuffer.get());\n')
+    w('  }\n')
+
+    for numFrameBits in xrange(1, 33):
+      w('  public static void decode%d(final IntBuffer compressedBuffer, final int[] output) {\n' % numFrameBits)
+      w('    final int numFrameBits = %d;\n' % numFrameBits)
+      w('    final int mask = (int) ((1L<<numFrameBits) - 1);\n')
+      w('    int outputOffset = 0;\n')
+      w('    for(int step=0;step<4;step++) {\n')
+
+      for i in range(numFrameBits): # declare int vars and init from buffer
+        w("      int intValue" + str(i) + " = compressedBuffer.get();\n")
+
+      for i in range(32): # set output from int vars
+        w("      output[" + str(i) + " + outputOffset] = " + bitsExpr(i, numFrameBits) + ";\n")
+
+      w('      outputOffset += 32;\n')
+      w('    }\n')
+      w('  }\n')
+
+    w('}\n')
+      
+  finally:
+    f.close()
+
+if __name__ == "__main__":
+  genDecompress()
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/blockpacked/BlockPackedPostingsFormat.java b/lucene/core/src/java/org/apache/lucene/codecs/blockpacked/BlockPackedPostingsFormat.java
new file mode 100644
index 0000000..211d551
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/codecs/blockpacked/BlockPackedPostingsFormat.java
@@ -0,0 +1,108 @@
+package org.apache.lucene.codecs.blockpacked;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.codecs.BlockTreeTermsReader;
+import org.apache.lucene.codecs.BlockTreeTermsWriter;
+import org.apache.lucene.codecs.FieldsConsumer;
+import org.apache.lucene.codecs.FieldsProducer;
+import org.apache.lucene.codecs.PostingsFormat;
+import org.apache.lucene.codecs.PostingsReaderBase;
+import org.apache.lucene.codecs.PostingsWriterBase;
+import org.apache.lucene.index.SegmentReadState;
+import org.apache.lucene.index.SegmentWriteState;
+import org.apache.lucene.util.IOUtils;
+
+/**
+ * Pass ForFactory to a PostingsWriter/ReaderBase, and get 
+ * customized postings format plugged.
+ */
+public final class BlockPackedPostingsFormat extends PostingsFormat {
+  public static final String DOC_EXTENSION = "doc";
+  public static final String POS_EXTENSION = "pos";
+  public static final String PAY_EXTENSION = "pay";
+
+  private final int minTermBlockSize;
+  private final int maxTermBlockSize;
+  public final static int DEFAULT_BLOCK_SIZE = 128;
+
+  public BlockPackedPostingsFormat() {
+    this(BlockTreeTermsWriter.DEFAULT_MIN_BLOCK_SIZE, BlockTreeTermsWriter.DEFAULT_MAX_BLOCK_SIZE);
+  }
+
+  public BlockPackedPostingsFormat(int minTermBlockSize, int maxTermBlockSize) {
+    super("BlockPacked");
+    this.minTermBlockSize = minTermBlockSize;
+    assert minTermBlockSize > 1;
+    this.maxTermBlockSize = maxTermBlockSize;
+    assert minTermBlockSize <= maxTermBlockSize;
+  }
+
+  @Override
+  public String toString() {
+    return getName() + "(blocksize=" + DEFAULT_BLOCK_SIZE + ")";
+  }
+
+  @Override
+  public FieldsConsumer fieldsConsumer(SegmentWriteState state) throws IOException {
+    // TODO: implement a new PostingsWriterBase to improve skip-settings
+    PostingsWriterBase postingsWriter = new BlockPackedPostingsWriter(state, 128);
+
+    boolean success = false;
+    try {
+      FieldsConsumer ret = new BlockTreeTermsWriter(state, 
+                                                    postingsWriter,
+                                                    minTermBlockSize, 
+                                                    maxTermBlockSize);
+      success = true;
+      return ret;
+    } finally {
+      if (!success) {
+        IOUtils.closeWhileHandlingException(postingsWriter);
+      }
+    }
+  }
+
+  @Override
+  public FieldsProducer fieldsProducer(SegmentReadState state) throws IOException {
+    PostingsReaderBase postingsReader = new BlockPackedPostingsReader(state.dir,
+                                                                      state.fieldInfos,
+                                                                      state.segmentInfo,
+                                                                      state.context,
+                                                                      state.segmentSuffix,
+                                                                      128);
+    boolean success = false;
+    try {
+      FieldsProducer ret = new BlockTreeTermsReader(state.dir,
+                                                    state.fieldInfos,
+                                                    state.segmentInfo.name,
+                                                    postingsReader,
+                                                    state.context,
+                                                    state.segmentSuffix,
+                                                    state.termsIndexDivisor);
+      success = true;
+      return ret;
+    } finally {
+      if (!success) {
+        IOUtils.closeWhileHandlingException(postingsReader);
+      }
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/blockpacked/BlockPackedPostingsReader.java b/lucene/core/src/java/org/apache/lucene/codecs/blockpacked/BlockPackedPostingsReader.java
new file mode 100644
index 0000000..08312c4
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/codecs/blockpacked/BlockPackedPostingsReader.java
@@ -0,0 +1,1527 @@
+package org.apache.lucene.codecs.blockpacked;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.IntBuffer;
+import java.nio.LongBuffer;
+
+import org.apache.lucene.codecs.BlockTermState;
+import org.apache.lucene.codecs.CodecUtil;
+import org.apache.lucene.codecs.PostingsReaderBase;
+import org.apache.lucene.index.DocsAndPositionsEnum;
+import org.apache.lucene.index.DocsEnum;
+import org.apache.lucene.index.FieldInfo.IndexOptions;
+import org.apache.lucene.index.FieldInfo;
+import org.apache.lucene.index.FieldInfos;
+import org.apache.lucene.index.IndexFileNames;
+import org.apache.lucene.index.SegmentInfo;
+import org.apache.lucene.index.TermState;
+import org.apache.lucene.store.ByteArrayDataInput;
+import org.apache.lucene.store.DataInput;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.store.IndexInput;
+import org.apache.lucene.util.ArrayUtil;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.IOUtils;
+
+// nocommit javadocs
+public final class BlockPackedPostingsReader extends PostingsReaderBase {
+
+  private final IndexInput docIn;
+  private final IndexInput posIn;
+  private final IndexInput payIn;
+
+  public static boolean DEBUG = false;
+
+  // nocommit
+  final String segment;
+
+  // NOTE: not private to avoid access$NNN methods:
+  final int blockSize;
+
+  public BlockPackedPostingsReader(Directory dir, FieldInfos fieldInfos, SegmentInfo segmentInfo, IOContext ioContext, String segmentSuffix, int blockSize) throws IOException {
+    boolean success = false;
+    segment = segmentInfo.name;
+    IndexInput docIn = null;
+    IndexInput posIn = null;
+    IndexInput payIn = null;
+    try {
+      docIn = dir.openInput(IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, BlockPackedPostingsFormat.DOC_EXTENSION),
+                            ioContext);
+      CodecUtil.checkHeader(docIn,
+                            BlockPackedPostingsWriter.DOC_CODEC,
+                            BlockPackedPostingsWriter.VERSION_START,
+                            BlockPackedPostingsWriter.VERSION_START);
+
+      if (fieldInfos.hasProx()) {
+        posIn = dir.openInput(IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, BlockPackedPostingsFormat.POS_EXTENSION),
+                              ioContext);
+        CodecUtil.checkHeader(posIn,
+                              BlockPackedPostingsWriter.POS_CODEC,
+                              BlockPackedPostingsWriter.VERSION_START,
+                              BlockPackedPostingsWriter.VERSION_START);
+
+        if (fieldInfos.hasPayloads() || fieldInfos.hasOffsets()) {
+          payIn = dir.openInput(IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, BlockPackedPostingsFormat.PAY_EXTENSION),
+                                ioContext);
+          CodecUtil.checkHeader(payIn,
+                                BlockPackedPostingsWriter.PAY_CODEC,
+                                BlockPackedPostingsWriter.VERSION_START,
+                                BlockPackedPostingsWriter.VERSION_START);
+        }
+      }
+
+      this.docIn = docIn;
+      this.posIn = posIn;
+      this.payIn = payIn;
+      success = true;
+    } finally {
+      if (!success) {
+        IOUtils.closeWhileHandlingException(docIn, posIn, payIn);
+      }
+    }
+
+    this.blockSize = blockSize;
+  }
+
+  @Override
+  public void init(IndexInput termsIn) throws IOException {
+    // Make sure we are talking to the matching past writer
+    CodecUtil.checkHeader(termsIn,
+                          BlockPackedPostingsWriter.TERMS_CODEC,
+                          BlockPackedPostingsWriter.VERSION_START,
+                          BlockPackedPostingsWriter.VERSION_START);
+    final int indexBlockSize = termsIn.readVInt();
+    if (indexBlockSize != blockSize) {
+      throw new IllegalStateException("index-time blockSize (" + indexBlockSize + ") != read-time blockSize (" + blockSize + ")");
+    }
+  }
+
+  static void readBlock(IndexInput in, byte[] encoded, LongBuffer encodedBuffer, LongBuffer buffer) throws IOException {
+    int header = in.readVInt();
+    in.readBytes(encoded, 0, ForUtil.getEncodedSize(header));
+    ForUtil.decompress(buffer, encodedBuffer, header);
+  }
+
+  static void skipBlock(IndexInput in) throws IOException {
+    int header = in.readVInt();
+    in.seek(in.getFilePointer() + ForUtil.getEncodedSize(header));
+  }
+
+  // Must keep final because we do non-standard clone
+  private final static class IntBlockTermState extends BlockTermState {
+    long docStartFP;
+    long posStartFP;
+    long payStartFP;
+    int skipOffset;
+    int lastPosBlockOffset;
+
+    // Only used by the "primary" TermState -- clones don't
+    // copy this (basically they are "transient"):
+    ByteArrayDataInput bytesReader;  // TODO: should this NOT be in the TermState...?
+    byte[] bytes;
+
+    @Override
+    public IntBlockTermState clone() {
+      IntBlockTermState other = new IntBlockTermState();
+      other.copyFrom(this);
+      return other;
+    }
+
+    @Override
+    public void copyFrom(TermState _other) {
+      super.copyFrom(_other);
+      IntBlockTermState other = (IntBlockTermState) _other;
+      docStartFP = other.docStartFP;
+      posStartFP = other.posStartFP;
+      payStartFP = other.payStartFP;
+      lastPosBlockOffset = other.lastPosBlockOffset;
+      skipOffset = other.skipOffset;
+
+      // Do not copy bytes, bytesReader (else TermState is
+      // very heavy, ie drags around the entire block's
+      // byte[]).  On seek back, if next() is in fact used
+      // (rare!), they will be re-read from disk.
+    }
+
+    @Override
+    public String toString() {
+      return super.toString() + " docStartFP=" + docStartFP + " posStartFP=" + posStartFP + " payStartFP=" + payStartFP + " lastPosBlockOffset=" + lastPosBlockOffset;
+    }
+  }
+
+  @Override
+  public IntBlockTermState newTermState() {
+    return new IntBlockTermState();
+  }
+
+  @Override
+  public void close() throws IOException {
+    IOUtils.close(docIn, posIn, payIn);
+  }
+
+  /* Reads but does not decode the byte[] blob holding
+     metadata for the current terms block */
+  @Override
+  public void readTermsBlock(IndexInput termsIn, FieldInfo fieldInfo, BlockTermState _termState) throws IOException {
+    final IntBlockTermState termState = (IntBlockTermState) _termState;
+
+    final int numBytes = termsIn.readVInt();
+
+    if (termState.bytes == null) {
+      termState.bytes = new byte[ArrayUtil.oversize(numBytes, 1)];
+      termState.bytesReader = new ByteArrayDataInput();
+    } else if (termState.bytes.length < numBytes) {
+      termState.bytes = new byte[ArrayUtil.oversize(numBytes, 1)];
+    }
+
+    termsIn.readBytes(termState.bytes, 0, numBytes);
+    termState.bytesReader.reset(termState.bytes, 0, numBytes);
+  }
+
+  @Override
+  public void nextTerm(FieldInfo fieldInfo, BlockTermState _termState)
+    throws IOException {
+    final IntBlockTermState termState = (IntBlockTermState) _termState;
+    final boolean isFirstTerm = termState.termBlockOrd == 0;
+    final boolean fieldHasPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;
+    final boolean fieldHasOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;
+    final boolean fieldHasPayloads = fieldInfo.hasPayloads();
+
+    final DataInput in = termState.bytesReader;
+    if (isFirstTerm) {
+      termState.docStartFP = in.readVLong();
+      if (fieldHasPositions) {
+        termState.posStartFP = in.readVLong();
+        if (termState.totalTermFreq > blockSize) {
+          termState.lastPosBlockOffset = in.readVInt();
+        } else {
+          termState.lastPosBlockOffset = -1;
+        }
+        if ((fieldHasPayloads || fieldHasOffsets) && termState.totalTermFreq >= blockSize) {
+          termState.payStartFP = in.readVLong();
+        } else {
+          termState.payStartFP = -1;
+        }
+      }
+    } else {
+      termState.docStartFP += in.readVLong();
+      if (fieldHasPositions) {
+        termState.posStartFP += in.readVLong();
+        if (termState.totalTermFreq > blockSize) {
+          termState.lastPosBlockOffset = in.readVInt();
+        } else {
+          termState.lastPosBlockOffset = -1;
+        }
+        if ((fieldHasPayloads || fieldHasOffsets) && termState.totalTermFreq >= blockSize) {
+          long delta = in.readVLong();
+          if (termState.payStartFP == -1) {
+            termState.payStartFP = delta;
+          } else {
+            termState.payStartFP += delta;
+          }
+        }
+      }
+    }
+
+    if (termState.docFreq > blockSize) {
+      termState.skipOffset = in.readVInt();
+    } else {
+      termState.skipOffset = -1;
+    }
+  }
+    
+  @Override
+  public DocsEnum docs(FieldInfo fieldInfo, BlockTermState termState, Bits liveDocs, DocsEnum reuse, boolean needsFreqs) throws IOException {
+    BlockDocsEnum docsEnum;
+    if (reuse instanceof BlockDocsEnum) {
+      docsEnum = (BlockDocsEnum) reuse;
+      if (!docsEnum.canReuse(docIn, fieldInfo)) {
+        docsEnum = new BlockDocsEnum(fieldInfo);
+      }
+    } else {
+      docsEnum = new BlockDocsEnum(fieldInfo);
+    }
+    return docsEnum.reset(liveDocs, (IntBlockTermState) termState);
+  }
+
+  // TODO: specialize to liveDocs vs not, and freqs vs not
+  
+  @Override
+  public DocsAndPositionsEnum docsAndPositions(FieldInfo fieldInfo, BlockTermState termState, Bits liveDocs,
+                                               DocsAndPositionsEnum reuse, boolean needsOffsets)
+    throws IOException {
+
+    // nocommit use needsPayloads here:
+    if (!needsOffsets && !fieldInfo.hasPayloads()) {
+      BlockDocsAndPositionsEnum docsAndPositionsEnum;
+      if (reuse instanceof BlockDocsAndPositionsEnum) {
+        docsAndPositionsEnum = (BlockDocsAndPositionsEnum) reuse;
+        if (!docsAndPositionsEnum.canReuse(docIn, fieldInfo)) {
+          docsAndPositionsEnum = new BlockDocsAndPositionsEnum(fieldInfo);
+        }
+      } else {
+        docsAndPositionsEnum = new BlockDocsAndPositionsEnum(fieldInfo);
+      }
+      return docsAndPositionsEnum.reset(liveDocs, (IntBlockTermState) termState);
+    } else {
+      EverythingEnum everythingEnum;
+      if (reuse instanceof EverythingEnum) {
+        everythingEnum = (EverythingEnum) reuse;
+        if (!everythingEnum.canReuse(docIn, fieldInfo)) {
+          everythingEnum = new EverythingEnum(fieldInfo);
+        }
+      } else {
+        everythingEnum = new EverythingEnum(fieldInfo);
+      }
+      return everythingEnum.reset(liveDocs, (IntBlockTermState) termState);
+    }
+  }
+
+  final class BlockDocsEnum extends DocsEnum {
+    private final byte[] encoded;
+    private final LongBuffer encodedBuffer;
+    
+    private final long[] docDeltaBuffer = new long[blockSize];
+    private final long[] freqBuffer = new long[blockSize];
+    private final LongBuffer docDeltaLBuffer = LongBuffer.wrap(docDeltaBuffer);
+    private final LongBuffer freqLBuffer = LongBuffer.wrap(freqBuffer);
+
+    private int docBufferUpto;
+
+    private BlockPackedSkipReader skipper;
+    private boolean skipped;
+
+    final IndexInput startDocIn;
+
+    final IndexInput docIn;
+    final boolean indexHasFreq;
+    final boolean indexHasPos;
+    final boolean indexHasOffsets;
+    final boolean indexHasPayloads;
+
+    private int docFreq;                              // number of docs in this posting list
+    private int docUpto;                              // how many docs we've read
+    private int doc;                                  // doc we last read
+    private int accum;                                // accumulator for doc deltas
+    private int freq;                                 // freq we last read
+
+    // Where this term's postings start in the .doc file:
+    private long docTermStartFP;
+
+    // Where this term's skip data starts (after
+    // docTermStartFP) in the .doc file (or -1 if there is
+    // no skip data for this term):
+    private int skipOffset;
+
+    private Bits liveDocs;
+
+    public BlockDocsEnum(FieldInfo fieldInfo) throws IOException {
+      this.startDocIn = BlockPackedPostingsReader.this.docIn;
+      this.docIn = (IndexInput) startDocIn.clone();
+      indexHasFreq = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;
+      indexHasPos = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;
+      indexHasOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;
+      indexHasPayloads = fieldInfo.hasPayloads();
+      encoded = new byte[blockSize*4];
+      encodedBuffer = ByteBuffer.wrap(encoded).asLongBuffer();      
+    }
+
+    public boolean canReuse(IndexInput docIn, FieldInfo fieldInfo) {
+      return docIn == startDocIn &&
+        indexHasFreq == (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0) &&
+        indexHasPos == (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0) &&
+        indexHasPayloads == fieldInfo.hasPayloads();
+    }
+    
+    public DocsEnum reset(Bits liveDocs, IntBlockTermState termState) throws IOException {
+      this.liveDocs = liveDocs;
+      if (DEBUG) {
+        System.out.println("  FPR.reset: seg=" + segment + " termState=" + termState);
+      }
+      docFreq = termState.docFreq;
+      docTermStartFP = termState.docStartFP;
+      docIn.seek(docTermStartFP);
+      skipOffset = termState.skipOffset;
+
+      doc = -1;
+      accum = 0;
+      docUpto = 0;
+      docBufferUpto = blockSize;
+      skipped = false;
+      return this;
+    }
+    
+    @Override
+    public int freq() throws IOException {
+      return freq;
+    }
+
+    @Override
+    public int docID() {
+      return doc;
+    }
+    
+    private void refillDocs() throws IOException {
+      final int left = docFreq - docUpto;
+      assert left > 0;
+
+      if (left >= blockSize) {
+        if (DEBUG) {
+          System.out.println("    fill doc block from fp=" + docIn.getFilePointer());
+        }
+        readBlock(docIn, encoded, encodedBuffer, docDeltaLBuffer);
+
+        if (indexHasFreq) {
+          if (DEBUG) {
+            System.out.println("    fill freq block from fp=" + docIn.getFilePointer());
+          }
+          readBlock(docIn, encoded, encodedBuffer, freqLBuffer);
+        }
+      } else {
+        // Read vInts:
+        if (DEBUG) {
+          System.out.println("    fill last vInt block from fp=" + docIn.getFilePointer());
+        }
+        for(int i=0;i<left;i++) {
+          final int code = docIn.readVInt();
+          if (indexHasFreq) {
+            docDeltaBuffer[i] = code >>> 1;
+            if ((code & 1) != 0) {
+              freqBuffer[i] = 1;
+            } else {
+              freqBuffer[i] = docIn.readVInt();
+            }
+          } else {
+            docDeltaBuffer[i] = code;
+          }
+        }
+      }
+      docBufferUpto = 0;
+    }
+
+    @Override
+    public int nextDoc() throws IOException {
+
+      if (DEBUG) {
+        System.out.println("\nFPR.nextDoc");
+      }
+
+      while (true) {
+        if (DEBUG) {
+          System.out.println("  docUpto=" + docUpto + " (of df=" + docFreq + ") docBufferUpto=" + docBufferUpto);
+        }
+
+        if (docUpto == docFreq) {
+          if (DEBUG) {
+            System.out.println("  return doc=END");
+          }
+          return doc = NO_MORE_DOCS;
+        }
+
+        if (docBufferUpto == blockSize) {
+          refillDocs();
+        }
+
+        if (DEBUG) {
+          System.out.println("    accum=" + accum + " docDeltaBuffer[" + docBufferUpto + "]=" + docDeltaBuffer[docBufferUpto]);
+        }
+        accum += docDeltaBuffer[docBufferUpto];
+        docUpto++;
+
+        if (liveDocs == null || liveDocs.get(accum)) {
+          doc = accum;
+          freq = (int)freqBuffer[docBufferUpto];
+          docBufferUpto++;
+          if (DEBUG) {
+            System.out.println("  return doc=" + doc + " freq=" + freq);
+          }
+          return doc;
+        }
+
+        if (DEBUG) {
+          System.out.println("  doc=" + accum + " is deleted; try next doc");
+        }
+
+        docBufferUpto++;
+      }
+    }
+    
+    @Override
+    public int advance(int target) throws IOException {
+      // nocommit make frq block load lazy/skippable
+
+      // nocommit 2 is heuristic guess!!
+      // nocommit put cheating back!  does it help?
+      // nocommit use skipper!!!  it has next last doc id!!
+      //if (docFreq > blockSize && target - (blockSize - docBufferUpto) - 2*blockSize > accum) {
+      if (docFreq > blockSize && target - accum > blockSize) {
+
+        if (DEBUG) {
+          System.out.println("load skipper");
+        }
+
+        if (skipper == null) {
+          // Lazy init: first time this enum has ever been used for skipping
+          skipper = new BlockPackedSkipReader((IndexInput) docIn.clone(),
+                                        BlockPackedPostingsWriter.maxSkipLevels,
+                                        blockSize,
+                                        indexHasPos,
+                                        indexHasOffsets,
+                                        indexHasPayloads);
+        }
+
+        if (!skipped) {
+          assert skipOffset != -1;
+          // This is the first time this enum has skipped
+          // since reset() was called; load the skip data:
+          skipper.init(docTermStartFP+skipOffset, docTermStartFP, 0, 0, docFreq);
+          skipped = true;
+        }
+
+        final int newDocUpto = skipper.skipTo(target); 
+
+        if (newDocUpto > docUpto) {
+          // Skipper moved
+
+          if (DEBUG) {
+            System.out.println("skipper moved to docUpto=" + newDocUpto + " vs current=" + docUpto + "; docID=" + skipper.getDoc() + " fp=" + skipper.getDocPointer());
+          }
+
+          assert newDocUpto % blockSize == (blockSize-1): "got " + newDocUpto;
+          docUpto = newDocUpto+1;
+
+          // Force block read next:
+          docBufferUpto = blockSize;
+          accum = skipper.getDoc();
+          docIn.seek(skipper.getDocPointer());
+        }
+      }
+
+      // Now scan:
+      while (nextDoc() != NO_MORE_DOCS) {
+        if (doc >= target) {
+          if (DEBUG) {
+            System.out.println("  advance return doc=" + doc);
+          }
+          return doc;
+        }
+      }
+
+      if (DEBUG) {
+        System.out.println("  advance return doc=END");
+      }
+
+      return NO_MORE_DOCS;
+    }
+  }
+
+
+  final class BlockDocsAndPositionsEnum extends DocsAndPositionsEnum {
+    
+    private final byte[] encoded;
+    private final LongBuffer encodedBuffer;
+
+    private final long[] docDeltaBuffer = new long[blockSize];
+    private final long[] freqBuffer = new long[blockSize];
+    private final long[] posDeltaBuffer = new long[blockSize];
+
+
+    private final LongBuffer docDeltaLBuffer = LongBuffer.wrap(docDeltaBuffer);
+    private final LongBuffer freqLBuffer = LongBuffer.wrap(freqBuffer);
+    private final LongBuffer posDeltaLBuffer = LongBuffer.wrap(posDeltaBuffer);
+
+    private int docBufferUpto;
+    private int posBufferUpto;
+
+    private BlockPackedSkipReader skipper;
+    private boolean skipped;
+
+    final IndexInput startDocIn;
+
+    final IndexInput docIn;
+    final IndexInput posIn;
+
+    final boolean indexHasOffsets;
+    final boolean indexHasPayloads;
+
+    private int docFreq;                              // number of docs in this posting list
+    private int docUpto;                              // how many docs we've read
+    private int doc;                                  // doc we last read
+    private int accum;                                // accumulator for doc deltas
+    private int freq;                                 // freq we last read
+    private int position;                             // current position
+
+    // how many positions "behind" we are; nextPosition must
+    // skip these to "catch up":
+    private int posPendingCount;
+
+    // Lazy pos seek: if != -1 then we must seek to this FP
+    // before reading positions:
+    private long posPendingFP;
+
+    // Where this term's postings start in the .doc file:
+    private long docTermStartFP;
+
+    // Where this term's postings start in the .pos file:
+    private long posTermStartFP;
+
+    // Where this term's payloads/offsets start in the .pay
+    // file:
+    private long payTermStartFP;
+
+    // File pointer where the last (vInt encoded) pos delta
+    // block is.  We need this to know whether to bulk
+    // decode vs vInt decode the block:
+    private long lastPosBlockFP;
+
+    // Where this term's skip data starts (after
+    // docTermStartFP) in the .doc file (or -1 if there is
+    // no skip data for this term):
+    private int skipOffset;
+
+    private Bits liveDocs;
+    
+    public BlockDocsAndPositionsEnum(FieldInfo fieldInfo) throws IOException {
+      this.startDocIn = BlockPackedPostingsReader.this.docIn;
+      this.docIn = (IndexInput) startDocIn.clone();
+      this.posIn = (IndexInput) BlockPackedPostingsReader.this.posIn.clone();
+      encoded = new byte[blockSize*4];
+      encodedBuffer = ByteBuffer.wrap(encoded).asLongBuffer();
+      indexHasOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;
+      indexHasPayloads = fieldInfo.hasPayloads();
+    }
+
+    public boolean canReuse(IndexInput docIn, FieldInfo fieldInfo) {
+      return docIn == startDocIn &&
+        indexHasOffsets == (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0) &&
+        indexHasPayloads == fieldInfo.hasPayloads();
+    }
+    
+    public DocsAndPositionsEnum reset(Bits liveDocs, IntBlockTermState termState) throws IOException {
+      this.liveDocs = liveDocs;
+      if (DEBUG) {
+        System.out.println("  FPR.reset: termState=" + termState);
+      }
+      docFreq = termState.docFreq;
+      docTermStartFP = termState.docStartFP;
+      posTermStartFP = termState.posStartFP;
+      payTermStartFP = termState.payStartFP;
+      docIn.seek(docTermStartFP);
+      skipOffset = termState.skipOffset;
+      posPendingFP = posTermStartFP;
+      posPendingCount = 0;
+      if (termState.totalTermFreq < blockSize) {
+        lastPosBlockFP = posTermStartFP;
+      } else if (termState.totalTermFreq == blockSize) {
+        lastPosBlockFP = -1;
+      } else {
+        lastPosBlockFP = posTermStartFP + termState.lastPosBlockOffset;
+      }
+
+      doc = -1;
+      accum = 0;
+      docUpto = 0;
+      docBufferUpto = blockSize;
+      skipped = false;
+      return this;
+    }
+    
+    @Override
+    public int freq() throws IOException {
+      return freq;
+    }
+
+    @Override
+    public int docID() {
+      return doc;
+    }
+
+    private void refillDocs() throws IOException {
+      final int left = docFreq - docUpto;
+      assert left > 0;
+
+      if (left >= blockSize) {
+        if (DEBUG) {
+          System.out.println("    fill doc block from fp=" + docIn.getFilePointer());
+        }
+
+        readBlock(docIn, encoded, encodedBuffer, docDeltaLBuffer);
+
+        if (DEBUG) {
+          System.out.println("    fill freq block from fp=" + docIn.getFilePointer());
+        }
+
+        readBlock(docIn, encoded, encodedBuffer, freqLBuffer);
+      } else {
+        // Read vInts:
+        if (DEBUG) {
+          System.out.println("    fill last vInt doc block from fp=" + docIn.getFilePointer());
+        }
+        for(int i=0;i<left;i++) {
+          final int code = docIn.readVInt();
+          docDeltaBuffer[i] = code >>> 1;
+          if ((code & 1) != 0) {
+            freqBuffer[i] = 1;
+          } else {
+            freqBuffer[i] = docIn.readVInt();
+          }
+        }
+      }
+      docBufferUpto = 0;
+    }
+    
+    private void refillPositions() throws IOException {
+      if (DEBUG) {
+        System.out.println("      refillPositions");
+      }
+      if (posIn.getFilePointer() == lastPosBlockFP) {
+        if (DEBUG) {
+          System.out.println("        vInt pos block @ fp=" + posIn.getFilePointer() + " hasPayloads=" + indexHasPayloads + " hasOffsets=" + indexHasOffsets);
+        }
+        final int count = posIn.readVInt();
+        int payloadLength = 0;
+        for(int i=0;i<count;i++) {
+          int code = posIn.readVInt();
+          if (indexHasPayloads) {
+            if ((code & 1) != 0) {
+              payloadLength = posIn.readVInt();
+            }
+            posDeltaBuffer[i] = code >>> 1;
+            if (payloadLength != 0) {
+              posIn.seek(posIn.getFilePointer() + payloadLength);
+            }
+          } else {
+            posDeltaBuffer[i] = code;
+          }
+
+          if (indexHasOffsets) {
+            posIn.readVInt();
+            posIn.readVInt();
+          }
+        }
+      } else {
+        if (DEBUG) {
+          System.out.println("        bulk pos block @ fp=" + posIn.getFilePointer());
+        }
+        readBlock(posIn, encoded, encodedBuffer, posDeltaLBuffer);
+      }
+    }
+
+    @Override
+    public int nextDoc() throws IOException {
+
+      if (DEBUG) {
+        System.out.println("  FPR.nextDoc");
+      }
+
+      while (true) {
+        if (DEBUG) {
+          System.out.println("    docUpto=" + docUpto + " (of df=" + docFreq + ") docBufferUpto=" + docBufferUpto);
+        }
+
+        if (docUpto == docFreq) {
+          return doc = NO_MORE_DOCS;
+        }
+
+        if (docBufferUpto == blockSize) {
+          refillDocs();
+        }
+
+        if (DEBUG) {
+          System.out.println("    accum=" + accum + " docDeltaBuffer[" + docBufferUpto + "]=" + docDeltaBuffer[docBufferUpto]);
+        }
+        accum += (int)docDeltaBuffer[docBufferUpto];
+        freq = (int)freqBuffer[docBufferUpto];
+        posPendingCount += freq;
+        docBufferUpto++;
+        docUpto++;
+
+        if (liveDocs == null || liveDocs.get(accum)) {
+          doc = accum;
+          if (DEBUG) {
+            System.out.println("    return doc=" + doc + " freq=" + freq + " posPendingCount=" + posPendingCount);
+          }
+          position = 0;
+          return doc;
+        }
+
+        if (DEBUG) {
+          System.out.println("    doc=" + accum + " is deleted; try next doc");
+        }
+      }
+    }
+    
+    @Override
+    public int advance(int target) throws IOException {
+      // nocommit make frq block load lazy/skippable
+      if (DEBUG) {
+        System.out.println("  FPR.advance target=" + target);
+      }
+
+      // nocommit 2 is heuristic guess!!
+      // nocommit put cheating back!  does it help?
+      // nocommit use skipper!!!  it has next last doc id!!
+      //if (docFreq > blockSize && target - (blockSize - docBufferUpto) - 2*blockSize > accum) {
+      if (docFreq > blockSize && target - accum > blockSize) {
+
+        if (DEBUG) {
+          System.out.println("    try skipper");
+        }
+
+        if (skipper == null) {
+          // Lazy init: first time this enum has ever been used for skipping
+          if (DEBUG) {
+            System.out.println("    create skipper");
+          }
+          skipper = new BlockPackedSkipReader((IndexInput) docIn.clone(),
+                                        BlockPackedPostingsWriter.maxSkipLevels,
+                                        blockSize,
+                                        true,
+                                        indexHasOffsets,
+                                        indexHasPayloads);
+        }
+
+        if (!skipped) {
+          assert skipOffset != -1;
+          // This is the first time this enum has skipped
+          // since reset() was called; load the skip data:
+          if (DEBUG) {
+            System.out.println("    init skipper");
+          }
+          skipper.init(docTermStartFP+skipOffset, docTermStartFP, posTermStartFP, payTermStartFP, docFreq);
+          skipped = true;
+        }
+
+        final int newDocUpto = skipper.skipTo(target); 
+
+        if (newDocUpto > docUpto) {
+          // Skipper moved
+
+          if (DEBUG) {
+            System.out.println("    skipper moved to docUpto=" + newDocUpto + " vs current=" + docUpto + "; docID=" + skipper.getDoc() + " fp=" + skipper.getDocPointer() + " pos.fp=" + skipper.getPosPointer() + " pos.bufferUpto=" + skipper.getPosBufferUpto());
+          }
+
+          assert newDocUpto % blockSize == (blockSize-1): "got " + newDocUpto;
+          docUpto = newDocUpto+1;
+
+          // Force block read next:
+          docBufferUpto = blockSize;
+          accum = skipper.getDoc();
+          docIn.seek(skipper.getDocPointer());
+          posPendingFP = skipper.getPosPointer();
+          posPendingCount = skipper.getPosBufferUpto();
+        }
+      }
+
+      // Now scan:
+      while (nextDoc() != NO_MORE_DOCS) {
+        if (doc >= target) {
+          if (DEBUG) {
+            System.out.println("  advance return doc=" + doc);
+          }
+          return doc;
+        }
+      }
+
+      if (DEBUG) {
+        System.out.println("  advance return doc=END");
+      }
+
+      return NO_MORE_DOCS;
+    }
+
+    // nocommit in theory we could avoid loading frq block
+    // when not needed, ie, use skip data to load how far to
+    // seek the pos pointe ... instead of having to load frq
+    // blocks only to sum up how many positions to skip
+    private void skipPositions() throws IOException {
+      // Skip positions now:
+      int toSkip = posPendingCount - freq;
+      if (DEBUG) {
+        System.out.println("      FPR.skipPositions: toSkip=" + toSkip);
+      }
+
+      final int leftInBlock = blockSize - posBufferUpto;
+      if (toSkip < leftInBlock) {
+        posBufferUpto += toSkip;
+        if (DEBUG) {
+          System.out.println("        skip w/in block to posBufferUpto=" + posBufferUpto);
+        }
+      } else {
+        toSkip -= leftInBlock;
+        while(toSkip >= blockSize) {
+          if (DEBUG) {
+            System.out.println("        skip whole block @ fp=" + posIn.getFilePointer());
+          }
+          assert posIn.getFilePointer() != lastPosBlockFP;
+          skipBlock(posIn);
+          toSkip -= blockSize;
+        }
+        refillPositions();
+        posBufferUpto = toSkip;
+        if (DEBUG) {
+          System.out.println("        skip w/in block to posBufferUpto=" + posBufferUpto);
+        }
+      }
+
+      position = 0;
+    }
+
+    @Override
+    public int nextPosition() throws IOException {
+      if (DEBUG) {
+        System.out.println("    FPR.nextPosition posPendingCount=" + posPendingCount + " posBufferUpto=" + posBufferUpto);
+      }
+      if (posPendingFP != -1) {
+        if (DEBUG) {
+          System.out.println("      seek to pendingFP=" + posPendingFP);
+        }
+        posIn.seek(posPendingFP);
+        posPendingFP = -1;
+
+        // Force buffer refill:
+        posBufferUpto = blockSize;
+      }
+
+      if (posPendingCount > freq) {
+        skipPositions();
+        posPendingCount = freq;
+      }
+
+      if (posBufferUpto == blockSize) {
+        refillPositions();
+        posBufferUpto = 0;
+      }
+      position += (int)posDeltaBuffer[posBufferUpto++];
+      posPendingCount--;
+      if (DEBUG) {
+        System.out.println("      return pos=" + position);
+      }
+      return position;
+    }
+
+    @Override
+    public int startOffset() {
+      return -1;
+    }
+  
+    @Override
+    public int endOffset() {
+      return -1;
+    }
+  
+    @Override
+    public boolean hasPayload() {
+      return false;
+    }
+
+    @Override
+    public BytesRef getPayload() {
+      return null;
+    }
+  }
+
+  // Also handles payloads + offsets
+  final class EverythingEnum extends DocsAndPositionsEnum {
+    
+    private final byte[] encoded;
+    private final LongBuffer encodedBuffer;
+
+    private final long[] docDeltaBuffer = new long[blockSize];
+    private final long[] freqBuffer = new long[blockSize];
+    private final long[] posDeltaBuffer = new long[blockSize];
+
+    private final long[] payloadLengthBuffer;
+    private final long[] offsetStartDeltaBuffer;
+    private final long[] offsetLengthBuffer;
+
+
+    private final LongBuffer docDeltaLBuffer = LongBuffer.wrap(docDeltaBuffer);
+    private final LongBuffer freqLBuffer = LongBuffer.wrap(freqBuffer);
+    private final LongBuffer posDeltaLBuffer = LongBuffer.wrap(posDeltaBuffer);
+
+    private final LongBuffer payloadLengthLBuffer;
+    private final LongBuffer offsetStartDeltaLBuffer;
+    private final LongBuffer offsetLengthLBuffer;
+
+    private byte[] payloadBytes;
+    private int payloadByteUpto;
+    private int payloadLength;
+
+    private int lastEndOffset;
+    private int startOffset;
+    private int endOffset;
+
+    private int docBufferUpto;
+    private int posBufferUpto;
+
+    private BlockPackedSkipReader skipper;
+    private boolean skipped;
+
+    final IndexInput startDocIn;
+
+    final IndexInput docIn;
+    final IndexInput posIn;
+    final IndexInput payIn;
+    final BytesRef payload;
+
+    final boolean indexHasOffsets;
+    final boolean indexHasPayloads;
+
+    private int docFreq;                              // number of docs in this posting list
+    private int docUpto;                              // how many docs we've read
+    private int doc;                                  // doc we last read
+    private int accum;                                // accumulator for doc deltas
+    private int freq;                                 // freq we last read
+    private int position;                             // current position
+
+    // how many positions "behind" we are; nextPosition must
+    // skip these to "catch up":
+    private int posPendingCount;
+
+    // Lazy pos seek: if != -1 then we must seek to this FP
+    // before reading positions:
+    private long posPendingFP;
+
+    // Lazy pay seek: if != -1 then we must seek to this FP
+    // before reading payloads/offsets:
+    private long payPendingFP;
+
+    // Where this term's postings start in the .doc file:
+    private long docTermStartFP;
+
+    // Where this term's postings start in the .pos file:
+    private long posTermStartFP;
+
+    // Where this term's payloads/offsets start in the .pay
+    // file:
+    private long payTermStartFP;
+
+    // File pointer where the last (vInt encoded) pos delta
+    // block is.  We need this to know whether to bulk
+    // decode vs vInt decode the block:
+    private long lastPosBlockFP;
+
+    // Where this term's skip data starts (after
+    // docTermStartFP) in the .doc file (or -1 if there is
+    // no skip data for this term):
+    private int skipOffset;
+
+    private Bits liveDocs;
+    
+    public EverythingEnum(FieldInfo fieldInfo) throws IOException {
+      this.startDocIn = BlockPackedPostingsReader.this.docIn;
+      this.docIn = (IndexInput) startDocIn.clone();
+      this.posIn = (IndexInput) BlockPackedPostingsReader.this.posIn.clone();
+      this.payIn = (IndexInput) BlockPackedPostingsReader.this.payIn.clone();
+      encoded = new byte[blockSize*4];
+      encodedBuffer = ByteBuffer.wrap(encoded).asLongBuffer();
+      indexHasOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;
+      if (indexHasOffsets) {
+        offsetStartDeltaBuffer = new long[blockSize];
+        offsetLengthBuffer = new long[blockSize];
+        offsetStartDeltaLBuffer = LongBuffer.wrap(offsetStartDeltaBuffer); 
+        offsetLengthLBuffer = LongBuffer.wrap(offsetLengthBuffer); 
+      } else {
+        offsetStartDeltaBuffer = null;
+        offsetStartDeltaLBuffer = null;
+        offsetLengthBuffer = null;
+        offsetLengthLBuffer = null;
+        startOffset = -1;
+        endOffset = -1;
+      }
+
+      indexHasPayloads = fieldInfo.hasPayloads();
+      if (indexHasPayloads) {
+        payloadLengthBuffer = new long[blockSize];
+        payloadLengthLBuffer = LongBuffer.wrap(payloadLengthBuffer); 
+        payloadBytes = new byte[128];
+        payload = new BytesRef();
+      } else {
+        payloadLengthBuffer = null;
+        payloadLengthLBuffer = null;
+        payloadBytes = null;
+        payload = null;
+      }
+    }
+
+    public boolean canReuse(IndexInput docIn, FieldInfo fieldInfo) {
+      return docIn == startDocIn &&
+        indexHasOffsets == (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0) &&
+        indexHasPayloads == fieldInfo.hasPayloads();
+    }
+    
+    public EverythingEnum reset(Bits liveDocs, IntBlockTermState termState) throws IOException {
+      this.liveDocs = liveDocs;
+      if (DEBUG) {
+        System.out.println("  FPR.reset: termState=" + termState);
+      }
+      docFreq = termState.docFreq;
+      docTermStartFP = termState.docStartFP;
+      posTermStartFP = termState.posStartFP;
+      payTermStartFP = termState.payStartFP;
+      docIn.seek(docTermStartFP);
+      skipOffset = termState.skipOffset;
+      posPendingFP = posTermStartFP;
+      payPendingFP = payTermStartFP;
+      posPendingCount = 0;
+      if (termState.totalTermFreq < blockSize) {
+        lastPosBlockFP = posTermStartFP;
+      } else if (termState.totalTermFreq == blockSize) {
+        lastPosBlockFP = -1;
+      } else {
+        lastPosBlockFP = posTermStartFP + termState.lastPosBlockOffset;
+      }
+
+      doc = -1;
+      accum = 0;
+      docUpto = 0;
+      docBufferUpto = blockSize;
+      skipped = false;
+      return this;
+    }
+    
+    @Override
+    public int freq() throws IOException {
+      return freq;
+    }
+
+    @Override
+    public int docID() {
+      return doc;
+    }
+
+    private void refillDocs() throws IOException {
+      final int left = docFreq - docUpto;
+      assert left > 0;
+
+      if (left >= blockSize) {
+        if (DEBUG) {
+          System.out.println("    fill doc block from fp=" + docIn.getFilePointer());
+        }
+
+        readBlock(docIn, encoded, encodedBuffer, docDeltaLBuffer);
+
+        if (DEBUG) {
+          System.out.println("    fill freq block from fp=" + docIn.getFilePointer());
+        }
+
+        readBlock(docIn, encoded, encodedBuffer, freqLBuffer);
+      } else {
+        // Read vInts:
+        if (DEBUG) {
+          System.out.println("    fill last vInt doc block from fp=" + docIn.getFilePointer());
+        }
+        for(int i=0;i<left;i++) {
+          final int code = docIn.readVInt();
+          docDeltaBuffer[i] = code >>> 1;
+          if ((code & 1) != 0) {
+            freqBuffer[i] = 1;
+          } else {
+            freqBuffer[i] = docIn.readVInt();
+          }
+        }
+      }
+      docBufferUpto = 0;
+    }
+    
+    private void refillPositions() throws IOException {
+      if (DEBUG) {
+        System.out.println("      refillPositions");
+      }
+      if (posIn.getFilePointer() == lastPosBlockFP) {
+        if (DEBUG) {
+          System.out.println("        vInt pos block @ fp=" + posIn.getFilePointer() + " hasPayloads=" + indexHasPayloads + " hasOffsets=" + indexHasOffsets);
+        }
+        final int count = posIn.readVInt();
+        int payloadLength = 0;
+        payloadByteUpto = 0;
+        for(int i=0;i<count;i++) {
+          int code = posIn.readVInt();
+          if (indexHasPayloads) {
+            if ((code & 1) != 0) {
+              payloadLength = posIn.readVInt();
+            }
+            if (DEBUG) {
+              System.out.println("        i=" + i + " payloadLen=" + payloadLength);
+            }
+            payloadLengthBuffer[i] = payloadLength;
+            posDeltaBuffer[i] = code >>> 1;
+            if (payloadLength != 0) {
+              if (payloadByteUpto + payloadLength > payloadBytes.length) {
+                payloadBytes = ArrayUtil.grow(payloadBytes, payloadByteUpto + payloadLength);
+              }
+              //System.out.println("          read payload @ pos.fp=" + posIn.getFilePointer());
+              posIn.readBytes(payloadBytes, payloadByteUpto, payloadLength);
+              payloadByteUpto += payloadLength;
+            }
+          } else {
+            posDeltaBuffer[i] = code;
+          }
+
+          if (indexHasOffsets) {
+            if (DEBUG) {
+              System.out.println("        i=" + i + " read offsets from posIn.fp=" + posIn.getFilePointer());
+            }
+            offsetStartDeltaBuffer[i] = posIn.readVInt();
+            offsetLengthBuffer[i] = posIn.readVInt();
+            if (DEBUG) {
+              System.out.println("          startOffDelta=" + offsetStartDeltaBuffer[i] + " offsetLen=" + offsetLengthBuffer[i]);
+            }
+          }
+        }
+        payloadByteUpto = 0;
+      } else {
+        if (DEBUG) {
+          System.out.println("        bulk pos block @ fp=" + posIn.getFilePointer());
+        }
+        readBlock(posIn, encoded, encodedBuffer, posDeltaLBuffer);
+
+        if (indexHasPayloads) {
+          if (DEBUG) {
+            System.out.println("        bulk payload block @ pay.fp=" + payIn.getFilePointer());
+          }
+          readBlock(payIn, encoded, encodedBuffer, payloadLengthLBuffer);
+          int numBytes = payIn.readVInt();
+          if (DEBUG) {
+            System.out.println("        " + numBytes + " payload bytes @ pay.fp=" + payIn.getFilePointer());
+          }
+          if (numBytes > payloadBytes.length) {
+            payloadBytes = ArrayUtil.grow(payloadBytes, numBytes);
+          }
+          payIn.readBytes(payloadBytes, 0, numBytes);
+          payloadByteUpto = 0;
+        }
+
+        if (indexHasOffsets) {
+          if (DEBUG) {
+            System.out.println("        bulk offset block @ pay.fp=" + payIn.getFilePointer());
+          }
+          readBlock(payIn, encoded, encodedBuffer, offsetStartDeltaLBuffer);
+          readBlock(payIn, encoded, encodedBuffer, offsetLengthLBuffer);
+        }
+      }
+    }
+
+    @Override
+    public int nextDoc() throws IOException {
+
+      if (DEBUG) {
+        System.out.println("  FPR.nextDoc");
+      }
+
+      if (indexHasPayloads) {
+        payloadByteUpto += payloadLength;
+        payloadLength = 0;
+      }
+
+      while (true) {
+        if (DEBUG) {
+          System.out.println("    docUpto=" + docUpto + " (of df=" + docFreq + ") docBufferUpto=" + docBufferUpto);
+        }
+
+        if (docUpto == docFreq) {
+          return doc = NO_MORE_DOCS;
+        }
+
+        if (docBufferUpto == blockSize) {
+          refillDocs();
+        }
+
+        if (DEBUG) {
+          System.out.println("    accum=" + accum + " docDeltaBuffer[" + docBufferUpto + "]=" + docDeltaBuffer[docBufferUpto]);
+        }
+        accum += (int)docDeltaBuffer[docBufferUpto];
+        freq = (int)freqBuffer[docBufferUpto];
+        posPendingCount += freq;
+        docBufferUpto++;
+        docUpto++;
+
+        if (liveDocs == null || liveDocs.get(accum)) {
+          doc = accum;
+          if (DEBUG) {
+            System.out.println("    return doc=" + doc + " freq=" + freq + " posPendingCount=" + posPendingCount);
+          }
+          position = 0;
+          payloadLength = 0;
+          lastEndOffset = 0;
+          return doc;
+        }
+
+        if (DEBUG) {
+          System.out.println("    doc=" + accum + " is deleted; try next doc");
+        }
+      }
+    }
+    
+    @Override
+    public int advance(int target) throws IOException {
+      // nocommit make frq block load lazy/skippable
+      if (DEBUG) {
+        System.out.println("  FPR.advance target=" + target);
+      }
+
+      // nocommit 2 is heuristic guess!!
+      // nocommit put cheating back!  does it help?
+      // nocommit use skipper!!!  it has next last doc id!!
+      //if (docFreq > blockSize && target - (blockSize - docBufferUpto) - 2*blockSize > accum) {
+      if (docFreq > blockSize && target - accum > blockSize) {
+
+        if (DEBUG) {
+          System.out.println("    try skipper");
+        }
+
+        if (skipper == null) {
+          // Lazy init: first time this enum has ever been used for skipping
+          if (DEBUG) {
+            System.out.println("    create skipper");
+          }
+          skipper = new BlockPackedSkipReader((IndexInput) docIn.clone(),
+                                        BlockPackedPostingsWriter.maxSkipLevels,
+                                        blockSize,
+                                        true,
+                                        indexHasOffsets,
+                                        indexHasPayloads);
+        }
+
+        if (!skipped) {
+          assert skipOffset != -1;
+          // This is the first time this enum has skipped
+          // since reset() was called; load the skip data:
+          if (DEBUG) {
+            System.out.println("    init skipper");
+          }
+          skipper.init(docTermStartFP+skipOffset, docTermStartFP, posTermStartFP, payTermStartFP, docFreq);
+          skipped = true;
+        }
+
+        final int newDocUpto = skipper.skipTo(target); 
+
+        if (newDocUpto > docUpto) {
+          // Skipper moved
+
+          if (DEBUG) {
+            System.out.println("    skipper moved to docUpto=" + newDocUpto + " vs current=" + docUpto + "; docID=" + skipper.getDoc() + " fp=" + skipper.getDocPointer() + " pos.fp=" + skipper.getPosPointer() + " pos.bufferUpto=" + skipper.getPosBufferUpto() + " pay.fp=" + skipper.getPayPointer() + " lastEndOffset=" + lastEndOffset);
+          }
+
+          assert newDocUpto % blockSize == (blockSize-1): "got " + newDocUpto;
+          docUpto = newDocUpto+1;
+
+          // Force block read next:
+          docBufferUpto = blockSize;
+          accum = skipper.getDoc();
+          docIn.seek(skipper.getDocPointer());
+          posPendingFP = skipper.getPosPointer();
+          payPendingFP = skipper.getPayPointer();
+          posPendingCount = skipper.getPosBufferUpto();
+          lastEndOffset = skipper.getEndOffset();
+          payloadByteUpto = skipper.getPayloadByteUpto();
+        }
+      }
+
+      // Now scan:
+      while (nextDoc() != NO_MORE_DOCS) {
+        if (doc >= target) {
+          if (DEBUG) {
+            System.out.println("  advance return doc=" + doc);
+          }
+          return doc;
+        }
+      }
+
+      if (DEBUG) {
+        System.out.println("  advance return doc=END");
+      }
+
+      return NO_MORE_DOCS;
+    }
+
+    // nocommit in theory we could avoid loading frq block
+    // when not needed, ie, use skip data to load how far to
+    // seek the pos pointe ... instead of having to load frq
+    // blocks only to sum up how many positions to skip
+    private void skipPositions() throws IOException {
+      // Skip positions now:
+      int toSkip = posPendingCount - freq;
+      if (DEBUG) {
+        System.out.println("      FPR.skipPositions: toSkip=" + toSkip);
+      }
+
+      final int leftInBlock = blockSize - posBufferUpto;
+      if (toSkip < leftInBlock) {
+        int end = posBufferUpto + toSkip;
+        while(posBufferUpto < end) {
+          if (indexHasPayloads) {
+            payloadByteUpto += payloadLengthBuffer[posBufferUpto];
+          }
+          if (indexHasOffsets) {
+            lastEndOffset += offsetStartDeltaBuffer[posBufferUpto] + offsetLengthBuffer[posBufferUpto];
+          }
+          posBufferUpto++;
+        }
+        if (DEBUG) {
+          System.out.println("        skip w/in block to posBufferUpto=" + posBufferUpto);
+        }
+      } else {
+        toSkip -= leftInBlock;
+        while(toSkip >= blockSize) {
+          if (DEBUG) {
+            System.out.println("        skip whole block @ fp=" + posIn.getFilePointer());
+          }
+          assert posIn.getFilePointer() != lastPosBlockFP;
+          skipBlock(posIn);
+
+          if (indexHasPayloads) {
+            // Skip payloadLength block:
+            skipBlock(payIn);
+
+            // Skip payloadBytes block:
+            int numBytes = payIn.readVInt();
+            payIn.seek(payIn.getFilePointer() + numBytes);
+          }
+
+          if (indexHasOffsets) {
+            // Must load offset blocks merely to sum
+            // up into lastEndOffset:
+            readBlock(payIn, encoded, encodedBuffer, offsetStartDeltaLBuffer);
+            readBlock(payIn, encoded, encodedBuffer, offsetLengthLBuffer);
+            for(int i=0;i<blockSize;i++) {
+              lastEndOffset += offsetStartDeltaBuffer[i] + offsetLengthBuffer[i];
+            }
+          }
+          toSkip -= blockSize;
+        }
+        refillPositions();
+        payloadByteUpto = 0;
+        posBufferUpto = 0;
+        while(posBufferUpto < toSkip) {
+          if (indexHasPayloads) {
+            payloadByteUpto += payloadLengthBuffer[posBufferUpto];
+          }
+          if (indexHasOffsets) {
+            lastEndOffset += offsetStartDeltaBuffer[posBufferUpto] + offsetLengthBuffer[posBufferUpto];
+          }
+          posBufferUpto++;
+        }
+        if (DEBUG) {
+          System.out.println("        skip w/in block to posBufferUpto=" + posBufferUpto);
+        }
+      }
+
+      position = 0;
+      payloadLength = 0;
+      lastEndOffset = 0;
+    }
+
+    @Override
+    public int nextPosition() throws IOException {
+      if (DEBUG) {
+        System.out.println("    FPR.nextPosition posPendingCount=" + posPendingCount + " posBufferUpto=" + posBufferUpto + " payloadByteUpto=" + payloadByteUpto);
+      }
+      if (posPendingFP != -1) {
+        if (DEBUG) {
+          System.out.println("      seek pos to pendingFP=" + posPendingFP);
+        }
+        posIn.seek(posPendingFP);
+        posPendingFP = -1;
+
+        if (payPendingFP != -1) {
+          if (DEBUG) {
+            System.out.println("      seek pay to pendingFP=" + payPendingFP);
+          }
+          payIn.seek(payPendingFP);
+          payPendingFP = -1;
+        }
+
+        // Force buffer refill:
+        posBufferUpto = blockSize;
+      }
+
+      if (indexHasPayloads) {
+        if (DEBUG) {
+          if (payloadLength != 0) {
+            System.out.println("      skip unread payload length=" + payloadLength);
+          }
+        }
+        payloadByteUpto += payloadLength;
+        payloadLength = 0;
+      }
+
+      if (posPendingCount > freq) {
+        skipPositions();
+        posPendingCount = freq;
+      }
+
+      if (posBufferUpto == blockSize) {
+        refillPositions();
+        posBufferUpto = 0;
+      }
+      position += (int)posDeltaBuffer[posBufferUpto];
+
+      if (indexHasPayloads) {
+        payloadLength = (int)payloadLengthBuffer[posBufferUpto];
+      }
+
+      if (indexHasOffsets) {
+        startOffset = lastEndOffset + (int)offsetStartDeltaBuffer[posBufferUpto];
+        endOffset = startOffset + (int)offsetLengthBuffer[posBufferUpto];
+        lastEndOffset = endOffset;
+      }
+
+      posBufferUpto++;
+      posPendingCount--;
+      if (DEBUG) {
+        System.out.println("      return pos=" + position);
+      }
+      return position;
+    }
+
+    @Override
+    public int startOffset() {
+      return startOffset;
+    }
+  
+    @Override
+    public int endOffset() {
+      return endOffset;
+    }
+  
+    @Override
+    public boolean hasPayload() {
+      return payloadLength != 0;
+    }
+
+    @Override
+    public BytesRef getPayload() {
+      if (DEBUG) {
+        System.out.println("    FPR.getPayload payloadLength=" + payloadLength + " payloadByteUpto=" + payloadByteUpto);
+      }
+      payload.bytes = payloadBytes;
+      payload.offset = payloadByteUpto;
+      payload.length = payloadLength;
+      payloadByteUpto += payloadLength;
+      payloadLength = 0;
+      return payload;
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/blockpacked/BlockPackedPostingsWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/blockpacked/BlockPackedPostingsWriter.java
new file mode 100644
index 0000000..271ce32
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/codecs/blockpacked/BlockPackedPostingsWriter.java
@@ -0,0 +1,592 @@
+package org.apache.lucene.codecs.blockpacked;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.nio.ByteBuffer;      
+import java.nio.IntBuffer;
+import java.nio.LongBuffer;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.lucene.codecs.CodecUtil;
+import org.apache.lucene.codecs.PostingsWriterBase;
+import org.apache.lucene.codecs.TermStats;
+import org.apache.lucene.index.CorruptIndexException;
+import org.apache.lucene.index.FieldInfo.IndexOptions;
+import org.apache.lucene.index.FieldInfo;
+import org.apache.lucene.index.IndexFileNames;
+import org.apache.lucene.index.SegmentWriteState;
+import org.apache.lucene.store.IndexOutput;
+import org.apache.lucene.store.RAMOutputStream;
+import org.apache.lucene.util.ArrayUtil;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.IOUtils;
+
+// nocommit javadocs
+
+public final class BlockPackedPostingsWriter extends PostingsWriterBase {
+
+  private boolean DEBUG = BlockPackedPostingsReader.DEBUG;
+
+  // nocommit move these constants to the PF:
+
+  static final int maxSkipLevels = 10;
+
+  final static String TERMS_CODEC = "BlockPackedPostingsWriterTerms";
+  final static String DOC_CODEC = "BlockPackedPostingsWriterDoc";
+  final static String POS_CODEC = "BlockPackedPostingsWriterPos";
+  final static String PAY_CODEC = "BlockPackedPostingsWriterPay";
+
+  // Increment version to change it:
+  final static int VERSION_START = 0;
+  final static int VERSION_CURRENT = VERSION_START;
+
+  final IndexOutput docOut;
+  final IndexOutput posOut;
+  final IndexOutput payOut;
+
+  static final int DEFAULT_BLOCK_SIZE = 128;
+
+  final int blockSize;
+
+  private IndexOutput termsOut;
+
+  // How current field indexes postings:
+  private boolean fieldHasFreqs;
+  private boolean fieldHasPositions;
+  private boolean fieldHasOffsets;
+  private boolean fieldHasPayloads;
+
+  // Holds starting file pointers for each term:
+  private long docTermStartFP;
+  private long posTermStartFP;
+  private long payTermStartFP;
+
+  final long[] docDeltaBuffer;
+  final long[] freqBuffer;
+  final LongBuffer docDeltaLBuffer;
+  final LongBuffer freqLBuffer;
+  private int docBufferUpto;
+
+  final long[] posDeltaBuffer;
+  final long[] payloadLengthBuffer;
+  final long[] offsetStartDeltaBuffer;
+  final long[] offsetLengthBuffer;
+  final LongBuffer posDeltaLBuffer;
+  final LongBuffer payloadLengthLBuffer;
+  final LongBuffer offsetStartDeltaLBuffer;
+  final LongBuffer offsetLengthLBuffer;
+  private int posBufferUpto;
+
+  private byte[] payloadBytes;
+  private int payloadByteUpto;
+
+  private int lastBlockDocID;
+  private boolean saveNextPosBlock;
+  private long lastBlockPosFP;
+  private long lastBlockPayFP;
+  private int lastBlockPosBufferUpto;
+  private int lastBlockEndOffset;
+  private int lastBlockPayloadByteUpto;
+  private int lastDocID;
+  private int lastPosition;
+  private int lastEndOffset;
+  private int docCount;
+
+  final byte[] encoded;
+  final LongBuffer encodedBuffer;
+
+  private final BlockPackedSkipWriter skipWriter;
+  
+  public BlockPackedPostingsWriter(SegmentWriteState state, int blockSize) throws IOException {
+    super();
+    this.blockSize = blockSize;
+
+    docOut = state.directory.createOutput(IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, BlockPackedPostingsFormat.DOC_EXTENSION),
+                                          state.context);
+    IndexOutput posOut = null;
+    IndexOutput payOut = null;
+    boolean success = false;
+    try {
+      CodecUtil.writeHeader(docOut, DOC_CODEC, VERSION_CURRENT);
+      if (state.fieldInfos.hasProx()) {
+        posDeltaBuffer = new long[blockSize];
+        posDeltaLBuffer = LongBuffer.wrap(posDeltaBuffer);
+        posOut = state.directory.createOutput(IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, BlockPackedPostingsFormat.POS_EXTENSION),
+                                              state.context);
+        CodecUtil.writeHeader(posOut, POS_CODEC, VERSION_CURRENT);
+
+        if (state.fieldInfos.hasPayloads()) {
+          payloadBytes = new byte[128];
+          payloadLengthBuffer = new long[blockSize];
+          payloadLengthLBuffer = LongBuffer.wrap(payloadLengthBuffer);
+        } else {
+          payloadBytes = null;
+          payloadLengthBuffer = null;
+          payloadLengthLBuffer = null;
+        }
+
+        if (state.fieldInfos.hasOffsets()) {
+          offsetStartDeltaBuffer = new long[blockSize];
+          offsetLengthBuffer = new long[blockSize];
+          offsetStartDeltaLBuffer = LongBuffer.wrap(offsetStartDeltaBuffer);
+          offsetLengthLBuffer = LongBuffer.wrap(offsetLengthBuffer);
+        } else {
+          offsetStartDeltaBuffer = null;
+          offsetLengthBuffer = null;
+          offsetStartDeltaLBuffer = null;
+          offsetLengthLBuffer = null;
+        }
+
+        if (state.fieldInfos.hasPayloads() || state.fieldInfos.hasOffsets()) {
+          payOut = state.directory.createOutput(IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, BlockPackedPostingsFormat.PAY_EXTENSION),
+                                                state.context);
+          CodecUtil.writeHeader(payOut, PAY_CODEC, VERSION_CURRENT);
+        }
+      } else {
+        posDeltaBuffer = null;
+        payloadLengthBuffer = null;
+        offsetStartDeltaBuffer = null;
+        offsetLengthBuffer = null;
+        payloadBytes = null;
+        posDeltaLBuffer = null;
+        payloadLengthLBuffer = null;
+        offsetStartDeltaLBuffer = null;
+        offsetLengthLBuffer = null;
+      }
+      this.payOut = payOut;
+      this.posOut = posOut;
+      success = true;
+    } finally {
+      if (!success) {
+        IOUtils.closeWhileHandlingException(docOut, posOut, payOut);
+      }
+    }
+
+    docDeltaBuffer = new long[blockSize];
+    freqBuffer = new long[blockSize];
+    docDeltaLBuffer = LongBuffer.wrap(docDeltaBuffer);
+    freqLBuffer = LongBuffer.wrap(freqBuffer);
+
+    skipWriter = new BlockPackedSkipWriter(blockSize,
+                                     maxSkipLevels, 
+                                     state.segmentInfo.getDocCount(),
+                                     docOut,
+                                     posOut,
+                                     payOut);
+
+    encoded = new byte[blockSize*4];
+    encodedBuffer = ByteBuffer.wrap(encoded).asLongBuffer();
+  }
+
+  @Override
+  public void start(IndexOutput termsOut) throws IOException {
+    this.termsOut = termsOut;
+    CodecUtil.writeHeader(termsOut, TERMS_CODEC, VERSION_CURRENT);
+    termsOut.writeVInt(blockSize);
+  }
+
+  @Override
+  public void setField(FieldInfo fieldInfo) {
+    IndexOptions indexOptions = fieldInfo.getIndexOptions();
+    fieldHasFreqs = indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;
+    fieldHasPositions = indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;
+    fieldHasOffsets = indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;
+    fieldHasPayloads = fieldInfo.hasPayloads();
+    skipWriter.setField(fieldHasPositions, fieldHasOffsets, fieldHasPayloads);
+  }
+
+  @Override
+  public void startTerm() {
+    docTermStartFP = docOut.getFilePointer();
+    if (fieldHasPositions) {
+      posTermStartFP = posOut.getFilePointer();
+      if (fieldHasPayloads || fieldHasOffsets) {
+        payTermStartFP = payOut.getFilePointer();
+      }
+    }
+    lastBlockDocID = -1;
+    lastDocID = 0;
+    if (DEBUG) {
+      System.out.println("FPW.startTerm startFP=" + docTermStartFP);
+    }
+    skipWriter.resetSkip();
+  }
+
+  private void writeBlock(LongBuffer buffer, IndexOutput out) throws IOException {
+    final int header = ForUtil.compress(buffer, encodedBuffer);
+    out.writeVInt(header);
+    out.writeBytes(encoded, ForUtil.getEncodedSize(header));
+  }
+
+  @Override
+  public void startDoc(int docID, int termDocFreq) throws IOException {
+    if (DEBUG) {
+      System.out.println("FPW.startDoc docID=" + docID);
+    }
+
+    // nocommit do this in finishDoc... but does it fail...?
+    // is it not always called...?
+    if (posOut != null && saveNextPosBlock) {
+      lastBlockPosFP = posOut.getFilePointer();
+      if (payOut != null) {
+        lastBlockPayFP = payOut.getFilePointer();
+      }
+      lastBlockPosBufferUpto = posBufferUpto;
+      lastBlockEndOffset = lastEndOffset;
+      lastBlockPayloadByteUpto = payloadByteUpto;
+      saveNextPosBlock = false;
+      if (DEBUG) {
+        System.out.println("  now save lastBlockPosFP=" + lastBlockPosFP + " lastBlockPosBufferUpto=" + lastBlockPosBufferUpto + " lastBlockPayloadByteUpto=" + lastBlockPayloadByteUpto);
+      }
+    }
+
+    final int docDelta = docID - lastDocID;
+    if (docID < 0 || (docCount > 0 && docDelta <= 0)) {
+      throw new CorruptIndexException("docs out of order (" + docID + " <= " + lastDocID + " ) (docOut: " + docOut + ")");
+    }
+    lastDocID = docID;
+
+    docDeltaBuffer[docBufferUpto] = docDelta;
+    if (DEBUG) {
+      System.out.println("  docDeltaBuffer[" + docBufferUpto + "]=" + docDelta);
+    }
+    if (fieldHasFreqs) {
+      freqBuffer[docBufferUpto] = termDocFreq;
+    }
+
+    docBufferUpto++;
+    docCount++;
+
+    if (docBufferUpto == blockSize) {
+      // nocommit maybe instead of buffering skip before
+      // writing a block based on last block's end data
+      // ... we could buffer after writing the block?  only
+      // iffiness with that approach is it could be a
+      // pointlness skip?  like we may stop adding docs
+      // right after that, then we have skip point AFTER
+      // last doc.  the thing is, in finishTerm we are
+      // already sometimes adding a skip point AFTER the
+      // last doc?
+      if (lastBlockDocID != -1) {
+        if (DEBUG) {
+          System.out.println("  bufferSkip at writeBlock: lastDocID=" + lastBlockDocID + " docCount=" + (docCount-blockSize));
+        }
+        skipWriter.bufferSkip(lastBlockDocID, docCount-blockSize, lastBlockPosFP, lastBlockPayFP, lastBlockPosBufferUpto, lastBlockEndOffset, lastBlockPayloadByteUpto);
+      }
+      lastBlockDocID = docID;
+      saveNextPosBlock = true;
+
+      if (DEBUG) {
+        System.out.println("  write docDelta block @ fp=" + docOut.getFilePointer());
+      }
+      writeBlock(docDeltaLBuffer, docOut);
+      if (fieldHasFreqs) {
+        if (DEBUG) {
+          System.out.println("  write freq block @ fp=" + docOut.getFilePointer());
+        }
+        writeBlock(freqLBuffer, docOut);
+      }
+      docBufferUpto = 0;
+    }
+
+    lastPosition = 0;
+    lastEndOffset = 0;
+  }
+
+  /** Add a new position & payload */
+  @Override
+  public void addPosition(int position, BytesRef payload, int startOffset, int endOffset) throws IOException {
+    if (DEBUG) {
+      System.out.println("FPW.addPosition pos=" + position + " posBufferUpto=" + posBufferUpto + (fieldHasPayloads ? " payloadByteUpto=" + payloadByteUpto: ""));
+    }
+    posDeltaBuffer[posBufferUpto] = position - lastPosition;
+    if (fieldHasPayloads) {
+      if (payload == null || payload.length == 0) {
+        // no payload
+        payloadLengthBuffer[posBufferUpto] = 0;
+      } else {
+        payloadLengthBuffer[posBufferUpto] = payload.length;
+        if (payloadByteUpto + payload.length > payloadBytes.length) {
+          payloadBytes = ArrayUtil.grow(payloadBytes, payloadByteUpto + payload.length);
+        }
+        System.arraycopy(payload.bytes, payload.offset, payloadBytes, payloadByteUpto, payload.length);
+        payloadByteUpto += payload.length;
+      }
+    }
+
+    if (fieldHasOffsets) {
+      assert startOffset >= lastEndOffset;
+      assert endOffset >= startOffset;
+      offsetStartDeltaBuffer[posBufferUpto] = startOffset - lastEndOffset;
+      offsetLengthBuffer[posBufferUpto] = endOffset - startOffset;
+      lastEndOffset = endOffset;
+    }
+    
+    posBufferUpto++;
+    lastPosition = position;
+    if (posBufferUpto == blockSize) {
+      if (DEBUG) {
+        System.out.println("  write pos bulk block @ fp=" + posOut.getFilePointer());
+      }
+      writeBlock(posDeltaLBuffer, posOut);
+
+      if (fieldHasPayloads) {
+        writeBlock(payloadLengthLBuffer, payOut);
+        payOut.writeVInt(payloadByteUpto);
+        payOut.writeBytes(payloadBytes, 0, payloadByteUpto);
+        payloadByteUpto = 0;
+      }
+      if (fieldHasOffsets) {
+        writeBlock(offsetStartDeltaLBuffer, payOut);
+        writeBlock(offsetLengthLBuffer, payOut);
+      }
+      posBufferUpto = 0;
+    }
+  }
+
+  @Override
+  public void finishDoc() {
+  }
+
+  private static class PendingTerm {
+    public final long docStartFP;
+    public final long posStartFP;
+    public final long payStartFP;
+    public final int skipOffset;
+    public final int lastPosBlockOffset;
+
+    public PendingTerm(long docStartFP, long posStartFP, long payStartFP, int skipOffset, int lastPosBlockOffset) {
+      this.docStartFP = docStartFP;
+      this.posStartFP = posStartFP;
+      this.payStartFP = payStartFP;
+      this.skipOffset = skipOffset;
+      this.lastPosBlockOffset = lastPosBlockOffset;
+    }
+  }
+
+  private final List<PendingTerm> pendingTerms = new ArrayList<PendingTerm>();
+
+  /** Called when we are done adding docs to this term */
+  @Override
+  public void finishTerm(TermStats stats) throws IOException {
+
+    assert stats.docFreq > 0;
+
+    // TODO: wasteful we are counting this (counting # docs
+    // for this term) in two places?
+    assert stats.docFreq == docCount: stats.docFreq + " vs " + docCount;
+
+    if (DEBUG) {
+      System.out.println("FPW.finishTerm docFreq=" + stats.docFreq);
+    }
+
+    // nocommit silly that skipper must write skip when we no
+    // postings come after it, but if we don't do this, skip
+    // reader incorrectly thinks it can read another level 0
+    // skip entry here!:
+    //if (docCount > blockSize && docBufferUpto > 0) {
+    if (docCount > blockSize) {
+      final int lastDocCount = blockSize*(docCount/blockSize);
+      if (DEBUG) {
+        System.out.println("  bufferSkip at finishTerm: lastDocID=" + lastBlockDocID + " docCount=" + lastDocCount);
+      }
+      skipWriter.bufferSkip(lastBlockDocID, lastDocCount, lastBlockPosFP, lastBlockPayFP, lastBlockPosBufferUpto, lastBlockEndOffset, lastBlockPayloadByteUpto);
+    }
+
+    if (DEBUG) {
+      if (docBufferUpto > 0) {
+        System.out.println("  write doc/freq vInt block (count=" + docBufferUpto + ") at fp=" + docOut.getFilePointer() + " docTermStartFP=" + docTermStartFP);
+      }
+    }
+
+    // vInt encode the remaining doc deltas and freqs:
+    for(int i=0;i<docBufferUpto;i++) {
+      final int docDelta = (int)docDeltaBuffer[i];
+      final int freq = (int)freqBuffer[i];
+      if (!fieldHasFreqs) {
+        docOut.writeVInt(docDelta);
+      } else if (freqBuffer[i] == 1) {
+        docOut.writeVInt((docDelta<<1)|1);
+      } else {
+        docOut.writeVInt(docDelta<<1);
+        docOut.writeVInt(freq);
+      }
+    }
+
+    final int lastPosBlockOffset;
+
+    if (fieldHasPositions) {
+      if (DEBUG) {
+        if (posBufferUpto > 0) {
+          System.out.println("  write pos vInt block (count=" + posBufferUpto + ") at fp=" + posOut.getFilePointer() + " posTermStartFP=" + posTermStartFP + " hasPayloads=" + fieldHasPayloads + " hasOffsets=" + fieldHasOffsets);
+        }
+      }
+
+      assert stats.totalTermFreq != -1;
+      if (stats.totalTermFreq > blockSize) {
+        lastPosBlockOffset = (int) (posOut.getFilePointer() - posTermStartFP);
+      } else {
+        lastPosBlockOffset = -1;
+      }
+      if (posBufferUpto > 0) {
+        posOut.writeVInt(posBufferUpto);
+        
+        // nocommit should we send offsets/payloads to
+        // .pay...?  seems wasteful (have to store extra
+        // vLong for low (< blockSize) DF terms = vast vast
+        // majority)
+
+        // vInt encode the remaining positions/payloads/offsets:
+        int lastPayloadLength = -1;
+        int payloadBytesReadUpto = 0;
+        for(int i=0;i<posBufferUpto;i++) {
+          final int posDelta = (int)posDeltaBuffer[i];
+          if (fieldHasPayloads) {
+            final int payloadLength = (int)payloadLengthBuffer[i];
+            if (payloadLength != lastPayloadLength) {
+              lastPayloadLength = payloadLength;
+              posOut.writeVInt((posDelta<<1)|1);
+              posOut.writeVInt(payloadLength);
+            } else {
+              posOut.writeVInt(posDelta<<1);
+            }
+
+            if (DEBUG) {
+              System.out.println("        i=" + i + " payloadLen=" + payloadLength);
+            }
+
+            if (payloadLength != 0) {
+              if (DEBUG) {
+                System.out.println("          write payload @ pos.fp=" + posOut.getFilePointer());
+              }
+              posOut.writeBytes(payloadBytes, payloadBytesReadUpto, payloadLength);
+              payloadBytesReadUpto += payloadLength;
+            }
+          } else {
+            posOut.writeVInt(posDelta);
+          }
+
+          if (fieldHasOffsets) {
+            if (DEBUG) {
+              System.out.println("          write offset @ pos.fp=" + posOut.getFilePointer());
+            }
+            posOut.writeVInt((int)offsetStartDeltaBuffer[i]);
+            posOut.writeVInt((int)offsetLengthBuffer[i]);
+          }
+        }
+
+        if (fieldHasPayloads) {
+          assert payloadBytesReadUpto == payloadByteUpto;
+          payloadByteUpto = 0;
+        }
+      }
+      if (DEBUG) {
+        System.out.println("  totalTermFreq=" + stats.totalTermFreq + " lastPosBlockOffset=" + lastPosBlockOffset);
+      }
+    } else {
+      lastPosBlockOffset = -1;
+    }
+
+    int skipOffset;
+    if (docCount > blockSize) {
+      skipOffset = (int) (skipWriter.writeSkip(docOut)-docTermStartFP);
+      
+      if (DEBUG) {
+        System.out.println("skip packet " + (docOut.getFilePointer() - (docTermStartFP + skipOffset)) + " bytes");
+      }
+    } else {
+      skipOffset = -1;
+      if (DEBUG) {
+        System.out.println("  no skip: docCount=" + docCount);
+      }
+    }
+
+    long payStartFP;
+    if (stats.totalTermFreq >= blockSize) {
+      payStartFP = payTermStartFP;
+    } else {
+      payStartFP = -1;
+    }
+
+    if (DEBUG) {
+      System.out.println("  payStartFP=" + payStartFP);
+    }
+
+    pendingTerms.add(new PendingTerm(docTermStartFP, posTermStartFP, payStartFP, skipOffset, lastPosBlockOffset));
+    docBufferUpto = 0;
+    posBufferUpto = 0;
+    lastDocID = 0;
+    docCount = 0;
+  }
+
+  private final RAMOutputStream bytesWriter = new RAMOutputStream();
+
+  @Override
+  public void flushTermsBlock(int start, int count) throws IOException {
+
+    if (count == 0) {
+      termsOut.writeByte((byte) 0);
+      return;
+    }
+
+    assert start <= pendingTerms.size();
+    assert count <= start;
+
+    final int limit = pendingTerms.size() - start + count;
+
+    long lastDocStartFP = 0;
+    long lastPosStartFP = 0;
+    long lastPayStartFP = 0;
+    for(int idx=limit-count; idx<limit; idx++) {
+      PendingTerm term = pendingTerms.get(idx);
+
+      bytesWriter.writeVLong(term.docStartFP - lastDocStartFP);
+      lastDocStartFP = term.docStartFP;
+
+      if (fieldHasPositions) {
+        bytesWriter.writeVLong(term.posStartFP - lastPosStartFP);
+        lastPosStartFP = term.posStartFP;
+        if (term.lastPosBlockOffset != -1) {
+          bytesWriter.writeVInt(term.lastPosBlockOffset);
+        }
+        if ((fieldHasPayloads || fieldHasOffsets) && term.payStartFP != -1) {
+          bytesWriter.writeVLong(term.payStartFP - lastPayStartFP);
+          lastPayStartFP = term.payStartFP;
+        }
+      }
+
+      if (term.skipOffset != -1) {
+        bytesWriter.writeVInt(term.skipOffset);
+      }
+    }
+
+    termsOut.writeVInt((int) bytesWriter.getFilePointer());
+    bytesWriter.writeTo(termsOut);
+    bytesWriter.reset();
+
+    // Remove the terms we just wrote:
+    pendingTerms.subList(limit-count, limit).clear();
+  }
+
+  @Override
+  public void close() throws IOException {
+    IOUtils.close(docOut, posOut, payOut);
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/blockpacked/BlockPackedSkipReader.java b/lucene/core/src/java/org/apache/lucene/codecs/blockpacked/BlockPackedSkipReader.java
new file mode 100644
index 0000000..c6511ab
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/codecs/blockpacked/BlockPackedSkipReader.java
@@ -0,0 +1,205 @@
+package org.apache.lucene.codecs.blockpacked;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Arrays;
+
+import org.apache.lucene.codecs.MultiLevelSkipListReader;
+import org.apache.lucene.store.IndexInput;
+
+/**
+ * Implements the skip list reader for the 4.0 posting list format
+ * that stores positions and payloads.
+ * 
+ * @see Lucene40PostingsFormat
+ * @lucene.experimental
+ */
+final class BlockPackedSkipReader extends MultiLevelSkipListReader {
+  private boolean DEBUG = BlockPackedPostingsReader.DEBUG;
+
+  private long docPointer[];
+  private long posPointer[];
+  private long payPointer[];
+  private int posBufferUpto[];
+  private int endOffset[];
+  private int payloadByteUpto[];
+
+  private long lastPosPointer;
+  private long lastPayPointer;
+  private int lastEndOffset;
+  private int lastPayloadByteUpto;
+  private long lastDocPointer;
+  private int lastPosBufferUpto;
+
+  public BlockPackedSkipReader(IndexInput skipStream, int maxSkipLevels, int skipInterval, boolean hasPos, boolean hasOffsets, boolean hasPayloads) {
+    super(skipStream, maxSkipLevels, skipInterval);
+    docPointer = new long[maxSkipLevels];
+    if (hasPos) {
+      posPointer = new long[maxSkipLevels];
+      posBufferUpto = new int[maxSkipLevels];
+      if (hasPayloads) {
+        payloadByteUpto = new int[maxSkipLevels];
+      } else {
+        payloadByteUpto = null;
+      }
+      if (hasOffsets) {
+        endOffset = new int[maxSkipLevels];
+      } else {
+        endOffset = null;
+      }
+      if (hasOffsets || hasPayloads) {
+        payPointer = new long[maxSkipLevels];
+      } else {
+        payPointer = null;
+      }
+    } else {
+      posPointer = null;
+    }
+  }
+
+  public void init(long skipPointer, long docBasePointer, long posBasePointer, long payBasePointer, int df) {
+    super.init(skipPointer, df);
+    lastDocPointer = docBasePointer;
+    lastPosPointer = posBasePointer;
+    lastPayPointer = payBasePointer;
+
+    Arrays.fill(docPointer, docBasePointer);
+    if (posPointer != null) {
+      Arrays.fill(posPointer, posBasePointer);
+      if (payPointer != null) {
+        Arrays.fill(payPointer, payBasePointer);
+      }
+    } else {
+      assert posBasePointer == 0;
+    }
+  }
+
+  /** Returns the doc pointer of the doc to which the last call of 
+   * {@link MultiLevelSkipListReader#skipTo(int)} has skipped.  */
+  public long getDocPointer() {
+    return lastDocPointer;
+  }
+
+  public long getPosPointer() {
+    return lastPosPointer;
+  }
+
+  public int getPosBufferUpto() {
+    return lastPosBufferUpto;
+  }
+
+  public long getPayPointer() {
+    return lastPayPointer;
+  }
+
+  public int getEndOffset() {
+    return lastEndOffset;
+  }
+
+  public int getPayloadByteUpto() {
+    return lastPayloadByteUpto;
+  }
+
+  @Override
+  protected void seekChild(int level) throws IOException {
+    super.seekChild(level);
+    if (DEBUG) {
+      System.out.println("seekChild level=" + level);
+    }
+    docPointer[level] = lastDocPointer;
+    if (posPointer != null) {
+      posPointer[level] = lastPosPointer;
+      posBufferUpto[level] = lastPosBufferUpto;
+      if (endOffset != null) {
+        endOffset[level] = lastEndOffset;
+      }
+      if (payloadByteUpto != null) {
+        payloadByteUpto[level] = lastPayloadByteUpto;
+      }
+      if (payPointer != null) {
+        payPointer[level] = lastPayPointer;
+      }
+    }
+  }
+  
+  @Override
+  protected void setLastSkipData(int level) {
+    super.setLastSkipData(level);
+    lastDocPointer = docPointer[level];
+    if (DEBUG) {
+      System.out.println("setLastSkipData level=" + level);
+      System.out.println("  lastDocPointer=" + lastDocPointer);
+    }
+    if (posPointer != null) {
+      lastPosPointer = posPointer[level];
+      lastPosBufferUpto = posBufferUpto[level];
+      if (DEBUG) {
+        System.out.println("  lastPosPointer=" + lastPosPointer + " lastPosBUfferUpto=" + lastPosBufferUpto);
+      }
+      if (payPointer != null) {
+        lastPayPointer = payPointer[level];
+      }
+      if (endOffset != null) {
+        lastEndOffset = endOffset[level];
+      }
+      if (payloadByteUpto != null) {
+        lastPayloadByteUpto = payloadByteUpto[level];
+      }
+    }
+  }
+
+  @Override
+  protected int readSkipData(int level, IndexInput skipStream) throws IOException {
+    if (DEBUG) {
+      System.out.println("readSkipData level=" + level);
+    }
+    int delta = skipStream.readVInt();
+    if (DEBUG) {
+      System.out.println("  delta=" + delta);
+    }
+    docPointer[level] += skipStream.readVInt();
+    if (DEBUG) {
+      System.out.println("  docFP=" + docPointer[level]);
+    }
+
+    if (posPointer != null) {
+      posPointer[level] += skipStream.readVInt();
+      if (DEBUG) {
+        System.out.println("  posFP=" + posPointer[level]);
+      }
+      posBufferUpto[level] = skipStream.readVInt();
+      if (DEBUG) {
+        System.out.println("  posBufferUpto=" + posBufferUpto[level]);
+      }
+
+      if (payloadByteUpto != null) {
+        payloadByteUpto[level] = skipStream.readVInt();
+      }
+
+      if (endOffset != null) {
+        endOffset[level] += skipStream.readVInt();
+      }
+
+      if (payPointer != null) {
+        payPointer[level] += skipStream.readVInt();
+      }
+    }
+    return delta;
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/blockpacked/BlockPackedSkipWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/blockpacked/BlockPackedSkipWriter.java
new file mode 100644
index 0000000..8105fac
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/codecs/blockpacked/BlockPackedSkipWriter.java
@@ -0,0 +1,147 @@
+package org.apache.lucene.codecs.blockpacked;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Arrays;
+
+import org.apache.lucene.store.IndexOutput;
+import org.apache.lucene.codecs.MultiLevelSkipListWriter;
+
+// nocommit do we need more frequent skips at level > 0?
+// 128*128 is immense?  may need to decouple
+// baseSkipInterval & theRestSkipInterval?
+
+final class BlockPackedSkipWriter extends MultiLevelSkipListWriter {
+  private boolean DEBUG = BlockPackedPostingsReader.DEBUG;
+  
+  private int[] lastSkipDoc;
+  private long[] lastSkipDocPointer;
+  private long[] lastSkipPosPointer;
+  private long[] lastSkipPayPointer;
+  private int[] lastEndOffset;
+  private int[] lastPayloadByteUpto;
+
+  private final IndexOutput docOut;
+  private final IndexOutput posOut;
+  private final IndexOutput payOut;
+
+  private int curDoc;
+  private long curDocPointer;
+  private long curPosPointer;
+  private long curPayPointer;
+  private int curPosBufferUpto;
+  private int curEndOffset;
+  private int curPayloadByteUpto;
+  private boolean fieldHasPositions;
+  private boolean fieldHasOffsets;
+  private boolean fieldHasPayloads;
+
+  public BlockPackedSkipWriter(int skipInterval, int maxSkipLevels, int docCount, IndexOutput docOut, IndexOutput posOut, IndexOutput payOut) {
+    super(skipInterval, maxSkipLevels, docCount);
+    this.docOut = docOut;
+    this.posOut = posOut;
+    this.payOut = payOut;
+    
+    lastSkipDoc = new int[maxSkipLevels];
+    lastSkipDocPointer = new long[maxSkipLevels];
+    if (posOut != null) {
+      lastSkipPosPointer = new long[maxSkipLevels];
+      if (payOut != null) {
+        lastSkipPayPointer = new long[maxSkipLevels];
+      }
+      lastEndOffset = new int[maxSkipLevels];
+      lastPayloadByteUpto = new int[maxSkipLevels];
+    }
+  }
+
+  public void setField(boolean fieldHasPositions, boolean fieldHasOffsets, boolean fieldHasPayloads) {
+    this.fieldHasPositions = fieldHasPositions;
+    this.fieldHasOffsets = fieldHasOffsets;
+    this.fieldHasPayloads = fieldHasPayloads;
+  }
+
+  @Override
+  public void resetSkip() {
+    super.resetSkip();
+    Arrays.fill(lastSkipDoc, 0);
+    Arrays.fill(lastSkipDocPointer, docOut.getFilePointer());
+    if (fieldHasPositions) {
+      Arrays.fill(lastSkipPosPointer, posOut.getFilePointer());
+      if (fieldHasOffsets) {
+        Arrays.fill(lastEndOffset, 0);
+      }
+      if (fieldHasPayloads) {
+        Arrays.fill(lastPayloadByteUpto, 0);
+      }
+      if (fieldHasOffsets || fieldHasPayloads) {
+        Arrays.fill(lastSkipPayPointer, payOut.getFilePointer());
+      }
+    }
+  }
+
+  /**
+   * Sets the values for the current skip data. 
+   */
+  public void bufferSkip(int doc, int numDocs, long posFP, long payFP, int posBufferUpto, int endOffset, int payloadByteUpto) throws IOException {
+    this.curDoc = doc;
+    this.curDocPointer = docOut.getFilePointer();
+    this.curPosPointer = posFP;
+    this.curPayPointer = payFP;
+    this.curPosBufferUpto = posBufferUpto;
+    this.curPayloadByteUpto = payloadByteUpto;
+    this.curEndOffset = endOffset;
+    bufferSkip(numDocs);
+  }
+  
+  @Override
+  protected void writeSkipData(int level, IndexOutput skipBuffer) throws IOException {
+    int delta = curDoc - lastSkipDoc[level];
+    if (DEBUG) {
+      System.out.println("writeSkipData level=" + level + " lastDoc=" + curDoc + " delta=" + delta + " curDocPointer=" + curDocPointer);
+    }
+    skipBuffer.writeVInt(delta);
+    lastSkipDoc[level] = curDoc;
+
+    skipBuffer.writeVInt((int) (curDocPointer - lastSkipDocPointer[level]));
+    lastSkipDocPointer[level] = curDocPointer;
+
+    if (fieldHasPositions) {
+      if (DEBUG) {
+        System.out.println("  curPosPointer=" + curPosPointer + " curPosBufferUpto=" + curPosBufferUpto);
+      }
+      skipBuffer.writeVInt((int) (curPosPointer - lastSkipPosPointer[level]));
+      lastSkipPosPointer[level] = curPosPointer;
+      skipBuffer.writeVInt(curPosBufferUpto);
+
+      if (fieldHasPayloads) {
+        skipBuffer.writeVInt(curPayloadByteUpto);
+      }
+
+      if (fieldHasOffsets) {
+        skipBuffer.writeVInt(curEndOffset - lastEndOffset[level]);
+        lastEndOffset[level] = curEndOffset;
+      }
+
+      if (fieldHasOffsets || fieldHasPayloads) {
+        skipBuffer.writeVInt((int) (curPayPointer - lastSkipPayPointer[level]));
+        lastSkipPayPointer[level] = curPayPointer;
+      }
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/blockpacked/ForUtil.java b/lucene/core/src/java/org/apache/lucene/codecs/blockpacked/ForUtil.java
new file mode 100644
index 0000000..022e73b
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/codecs/blockpacked/ForUtil.java
@@ -0,0 +1,130 @@
+package org.apache.lucene.codecs.blockpacked;
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.nio.LongBuffer;
+import java.nio.IntBuffer;
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+import org.apache.lucene.util.packed.PackedInts;
+import org.apache.lucene.util.packed.PackedInts.Reader;
+import org.apache.lucene.util.packed.PackedInts.Writer;
+import org.apache.lucene.util.packed.PackedInts.Mutable;
+import org.apache.lucene.util.packed.PackedInts.Encoder;
+import org.apache.lucene.util.packed.PackedInts.Decoder;
+
+/**
+ * Encode all values in normal area with fixed bit width, 
+ * which is determined by the max value in this block.
+ */
+public class ForUtil {
+  protected static final int[] MASK = {   0x00000000,
+    0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f,
+    0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff,
+    0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff, 0x0001ffff, 0x0003ffff,
+    0x0007ffff, 0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff, 0x00ffffff,
+    0x01ffffff, 0x03ffffff, 0x07ffffff, 0x0fffffff, 0x1fffffff, 0x3fffffff,
+    0x7fffffff, 0xffffffff};
+
+  /** Compress given int[] into output stream, with For format
+   */
+  public static int compress(final LongBuffer data, LongBuffer packed) throws IOException {
+    int numBits=getNumBits(data.array());
+
+    if (numBits == 0) { // when block is equal, save the value once
+      packed.put(0, data.get(0)<<32); // java uses big endian for LongBuffer impl 
+      return (getHeader(1,numBits));
+    }
+
+    PackedInts.Format format = PackedInts.fastestFormatAndBits(128, numBits, PackedInts.FASTEST).format;
+    PackedInts.Encoder encoder = PackedInts.getEncoder(format, PackedInts.VERSION_CURRENT, numBits);
+    int perIter = encoder.values();
+    int iters = 128/perIter;
+    int nblocks = encoder.blocks()*iters;
+    assert 128 % perIter == 0;
+
+    packed.rewind();
+    data.rewind();
+
+    encoder.encode(data, packed, iters);
+
+    int encodedSize = nblocks*2;
+    return getHeader(encodedSize,numBits);
+  }
+
+  /** Decompress given ouput stream into int array.
+   */
+  public static void decompress(LongBuffer data, LongBuffer packed, int header) throws IOException {
+    // nocommit assert header isn't "malformed", ie besides
+    // numBytes / bit-width there is nothing else!
+    
+    packed.rewind();
+    data.rewind();
+    int numBits = ((header >> 8) & MASK[6]);
+
+    if (numBits == 0) {
+      Arrays.fill(data.array(), (int)(packed.get(0)>>>32));
+      return;
+    }
+
+    PackedInts.Format format = PackedInts.fastestFormatAndBits(128, numBits, PackedInts.FASTEST).format;
+    PackedInts.Decoder decoder = PackedInts.getDecoder(format, PackedInts.VERSION_CURRENT, numBits);
+    int perIter = decoder.values();
+    int iters = 128/perIter;
+    int nblocks = decoder.blocks()*iters;
+    assert 128 % perIter == 0;
+
+    decoder.decode(packed, data, iters);
+  }
+
+  static int getNumBits(final long[] data) {
+    if (isAllEqual(data)) {
+      return 0;
+    }
+    int size=data.length;
+    int optBits=1;
+    for (int i=0; i<size; ++i) {
+      while ((data[i] & ~MASK[optBits]) != 0) {
+        optBits++;
+      }
+    }
+    return optBits;
+  }
+
+  protected static boolean isAllEqual(final long[] data) {
+    int len = data.length;
+    long v = data[0];
+    for (int i=1; i<len; i++) {
+      if (data[i] != v) {
+        return false;
+      }
+    }
+    return true;
+  }
+  static int getHeader(int encodedSize, int numBits) {
+    return  (encodedSize)
+          | ((numBits) << 8);
+  }
+  public static int getEncodedSize(int header) {
+    return ((header & MASK[8]))*4;
+  }
+  public static int getNumBits(int header) {
+    return ((header >> 8) & MASK[6]);
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/pfor/ForFactory.java b/lucene/core/src/java/org/apache/lucene/codecs/pfor/ForFactory.java
deleted file mode 100644
index 1c636b9..0000000
--- a/lucene/core/src/java/org/apache/lucene/codecs/pfor/ForFactory.java
+++ /dev/null
@@ -1,128 +0,0 @@
-package org.apache.lucene.codecs.pfor;
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.IntBuffer;
-
-import org.apache.lucene.util.IOUtils;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IOContext;
-import org.apache.lucene.store.IndexInput;
-import org.apache.lucene.store.IndexOutput;
-import org.apache.lucene.codecs.sep.IntStreamFactory;
-import org.apache.lucene.codecs.sep.IntIndexInput;
-import org.apache.lucene.codecs.sep.IntIndexOutput;
-import org.apache.lucene.codecs.intblock.FixedIntBlockIndexInput;
-import org.apache.lucene.codecs.intblock.FixedIntBlockIndexOutput;
-
-/** 
- * Used to plug to PostingsReader/WriterBase.
- * Encoder and decoder in lower layers are called by 
- * flushBlock() and readBlock()
- */
-
-public final class ForFactory extends IntStreamFactory {
-
-  public ForFactory() {
-  }
-
-  @Override
-  public IntIndexOutput createOutput(Directory dir, String fileName, IOContext context)  throws IOException {
-    boolean success = false;
-    IndexOutput out = dir.createOutput(fileName, context);
-    try {
-      IntIndexOutput ret = new ForIndexOutput(out);
-      success = true;
-      return ret;
-    } finally {
-      if (!success) {
-        // For some cases (e.g. disk full), the IntIndexOutput may not be 
-        // properly created. So we should close those opened files. 
-        IOUtils.closeWhileHandlingException(out);
-      }
-    }
-  }
-
-  @Override
-  public IntIndexInput openInput(Directory dir, String fileName, IOContext context) throws IOException {
-    return new ForIndexInput(dir.openInput(fileName, context));
-  }
-
-  /**
-   * Here we'll hold both input buffer and output buffer for 
-   * encoder/decoder.
-   */
-  private class ForIndexInput extends FixedIntBlockIndexInput {
-
-    ForIndexInput(final IndexInput in) throws IOException {
-      super(in);
-    }
-
-    class ForBlockReader implements FixedIntBlockIndexInput.BlockReader {
-      private final byte[] encoded;
-      private final int[] buffer;
-      private final IndexInput in;
-      private final IntBuffer encodedBuffer;
-
-      ForBlockReader(final IndexInput in, final int[] buffer) {
-        // upperbound for encoded value should include(here header is not buffered):
-        // blockSize of normal value when numFrameBits=32(4x bytes); 
-        this.encoded = new byte[ForPostingsFormat.DEFAULT_BLOCK_SIZE*4]; 
-        this.in = in;
-        this.buffer = buffer;
-        this.encodedBuffer = ByteBuffer.wrap(encoded).asIntBuffer();
-      }
-
-      // TODO: implement public void skipBlock() {} ?
-      @Override
-      public void readBlock() throws IOException {
-        final int header = in.readInt();
-        final int numBytes = ForUtil.getEncodedSize(header);
-        assert numBytes <= ForPostingsFormat.DEFAULT_BLOCK_SIZE*4;
-        in.readBytes(encoded,0,numBytes);
-        ForUtil.decompress(encodedBuffer,buffer,header);
-      }
-    }
-
-    @Override
-    protected BlockReader getBlockReader(final IndexInput in, final int[] buffer) throws IOException {
-      return new ForBlockReader(in,buffer);
-    }
-  }
-
-  private class ForIndexOutput extends FixedIntBlockIndexOutput {
-    private final byte[] encoded;
-    private final IntBuffer encodedBuffer;
-
-    ForIndexOutput(IndexOutput out) throws IOException {
-      super(out,ForPostingsFormat.DEFAULT_BLOCK_SIZE);
-      this.encoded = new byte[ForPostingsFormat.DEFAULT_BLOCK_SIZE*4];
-      this.encodedBuffer=ByteBuffer.wrap(encoded).asIntBuffer();
-    }
-
-    @Override
-    protected void flushBlock() throws IOException {
-      final int header = ForUtil.compress(buffer,encodedBuffer);
-      final int numBytes = ForUtil.getEncodedSize(header);
-      // nocommit writeVInt instead?
-      out.writeInt(header);
-      out.writeBytes(encoded, numBytes);
-    }
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/pfor/ForPostingsFormat.java b/lucene/core/src/java/org/apache/lucene/codecs/pfor/ForPostingsFormat.java
deleted file mode 100644
index b1fb043..0000000
--- a/lucene/core/src/java/org/apache/lucene/codecs/pfor/ForPostingsFormat.java
+++ /dev/null
@@ -1,116 +0,0 @@
-package org.apache.lucene.codecs.pfor;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.Set;
-
-import org.apache.lucene.codecs.BlockTreeTermsReader;
-import org.apache.lucene.codecs.BlockTreeTermsWriter;
-import org.apache.lucene.codecs.FieldsConsumer;
-import org.apache.lucene.codecs.FieldsProducer;
-import org.apache.lucene.codecs.FixedGapTermsIndexReader;
-import org.apache.lucene.codecs.FixedGapTermsIndexWriter;
-import org.apache.lucene.codecs.PostingsFormat;
-import org.apache.lucene.codecs.PostingsReaderBase;
-import org.apache.lucene.codecs.PostingsWriterBase;
-import org.apache.lucene.codecs.TermsIndexReaderBase;
-import org.apache.lucene.codecs.TermsIndexWriterBase;
-import org.apache.lucene.codecs.sep.SepPostingsReader;
-import org.apache.lucene.codecs.sep.SepPostingsWriter;
-import org.apache.lucene.index.SegmentInfo;
-import org.apache.lucene.index.SegmentReadState;
-import org.apache.lucene.index.SegmentWriteState;
-import org.apache.lucene.store.IOContext;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.IOUtils;
-
-/**
- * Pass ForFactory to a PostingsWriter/ReaderBase, and get 
- * customized postings format plugged.
- */
-public final class ForPostingsFormat extends PostingsFormat {
-  private final int minBlockSize;
-  private final int maxBlockSize;
-  public final static int DEFAULT_BLOCK_SIZE = 128;
-
-  public ForPostingsFormat() {
-    super("For");
-    this.minBlockSize = BlockTreeTermsWriter.DEFAULT_MIN_BLOCK_SIZE;
-    this.maxBlockSize = BlockTreeTermsWriter.DEFAULT_MAX_BLOCK_SIZE;
-  }
-
-  public ForPostingsFormat(int minBlockSize, int maxBlockSize) {
-    super("For");
-    this.minBlockSize = minBlockSize;
-    assert minBlockSize > 1;
-    this.maxBlockSize = maxBlockSize;
-    assert minBlockSize <= maxBlockSize;
-  }
-
-  @Override
-  public String toString() {
-    return getName() + "(blocksize=" + DEFAULT_BLOCK_SIZE + ")";
-  }
-
-  @Override
-  public FieldsConsumer fieldsConsumer(SegmentWriteState state) throws IOException {
-    // TODO: implement a new PostingsWriterBase to improve skip-settings
-    PostingsWriterBase postingsWriter = new SepPostingsWriter(state, new ForFactory()); 
-    boolean success = false;
-    try {
-      FieldsConsumer ret = new BlockTreeTermsWriter(state, 
-                                                    postingsWriter,
-                                                    minBlockSize, 
-                                                    maxBlockSize);
-      success = true;
-      return ret;
-    } finally {
-      if (!success) {
-        IOUtils.closeWhileHandlingException(postingsWriter);
-      }
-    }
-  }
-
-  @Override
-  public FieldsProducer fieldsProducer(SegmentReadState state) throws IOException {
-    PostingsReaderBase postingsReader = new SepPostingsReader(state.dir,
-                                                              state.fieldInfos,
-                                                              state.segmentInfo,
-                                                              state.context,
-                                                              new ForFactory(),
-                                                              state.segmentSuffix);
-
-    boolean success = false;
-    try {
-      FieldsProducer ret = new BlockTreeTermsReader(state.dir,
-                                                    state.fieldInfos,
-                                                    state.segmentInfo.name,
-                                                    postingsReader,
-                                                    state.context,
-                                                    state.segmentSuffix,
-                                                    state.termsIndexDivisor);
-      success = true;
-      return ret;
-    } finally {
-      if (!success) {
-        IOUtils.closeWhileHandlingException(postingsReader);
-      }
-    }
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/pfor/ForUtil.java b/lucene/core/src/java/org/apache/lucene/codecs/pfor/ForUtil.java
deleted file mode 100644
index b660c0b..0000000
--- a/lucene/core/src/java/org/apache/lucene/codecs/pfor/ForUtil.java
+++ /dev/null
@@ -1,199 +0,0 @@
-package org.apache.lucene.codecs.pfor;
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.nio.IntBuffer;
-
-/**
- * Encode all values in normal area with fixed bit width, 
- * which is determined by the max value in this block.
- */
-public class ForUtil {
-  protected static final int[] MASK = {   0x00000000,
-    0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f,
-    0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff,
-    0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff, 0x0001ffff, 0x0003ffff,
-    0x0007ffff, 0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff, 0x00ffffff,
-    0x01ffffff, 0x03ffffff, 0x07ffffff, 0x0fffffff, 0x1fffffff, 0x3fffffff,
-    0x7fffffff, 0xffffffff};
-
-  /** Compress given int[] into Integer buffer, with For format
-   *
-   * @param data        uncompressed data
-   * @param size        num of ints to compress
-   * @param intBuffer   integer buffer to hold compressed data
-   * @return encoded block byte size
-   */
-  public static int compress(final int[] data, IntBuffer intBuffer) {
-    int numBits=getNumBits(data);
-    if (numBits == 0) {
-      return compressDuplicateBlock(data,intBuffer);
-    }
- 
-    int size=data.length;
-    int encodedSize = (size*numBits+31)/32;
-
-    for (int i=0; i<size; ++i) {
-      encodeNormalValue(intBuffer,i,data[i], numBits);
-    }
-
-    return getHeader(encodedSize, numBits);
-  }
-
-  /**
-   * Save only one int when the whole block equals to 1
-   */
-  static int compressDuplicateBlock(final int[] data, IntBuffer intBuffer) {
-    intBuffer.put(0,data[0]);
-    return getHeader(1, 0);
-  }
-
-  /** Decompress given Integer buffer into int array.
-   *
-   * @param intBuffer   integer buffer to hold compressed data
-   * @param data        int array to hold uncompressed data
-   */
-  public static void decompress(IntBuffer intBuffer, int[] data, int header) {
-    // since this buffer is reused at upper level, rewind first
-    intBuffer.rewind();
-
-    // nocommit assert header isn't "malformed", ie besides
-    // numBytes / bit-width there is nothing else!
-
-    int numBits = ((header >> 8) & MASK[6]);
-
-    decompressCore(intBuffer, data, numBits);
-  }
-
-  /**
-   * IntBuffer will not be rewinded in this method, therefore
-   * caller should ensure that the position is set to the first
-   * encoded int before decoding.
-   */
-  static void decompressCore(IntBuffer intBuffer, int[] data, int numBits) {
-    assert numBits<=32;
-    assert numBits>=0;
-
-    // TODO: PackedIntsDecompress is hardewired to size==128 only
-    switch(numBits) {
-      case 0: PackedIntsDecompress.decode0(intBuffer, data); break;
-      case 1: PackedIntsDecompress.decode1(intBuffer, data); break;
-      case 2: PackedIntsDecompress.decode2(intBuffer, data); break;
-      case 3: PackedIntsDecompress.decode3(intBuffer, data); break;
-      case 4: PackedIntsDecompress.decode4(intBuffer, data); break;
-      case 5: PackedIntsDecompress.decode5(intBuffer, data); break;
-      case 6: PackedIntsDecompress.decode6(intBuffer, data); break;
-      case 7: PackedIntsDecompress.decode7(intBuffer, data); break;
-      case 8: PackedIntsDecompress.decode8(intBuffer, data); break;
-      case 9: PackedIntsDecompress.decode9(intBuffer, data); break;
-      case 10: PackedIntsDecompress.decode10(intBuffer, data); break;
-      case 11: PackedIntsDecompress.decode11(intBuffer, data); break;
-      case 12: PackedIntsDecompress.decode12(intBuffer, data); break;
-      case 13: PackedIntsDecompress.decode13(intBuffer, data); break;
-      case 14: PackedIntsDecompress.decode14(intBuffer, data); break;
-      case 15: PackedIntsDecompress.decode15(intBuffer, data); break;
-      case 16: PackedIntsDecompress.decode16(intBuffer, data); break;
-      case 17: PackedIntsDecompress.decode17(intBuffer, data); break;
-      case 18: PackedIntsDecompress.decode18(intBuffer, data); break;
-      case 19: PackedIntsDecompress.decode19(intBuffer, data); break;
-      case 20: PackedIntsDecompress.decode20(intBuffer, data); break;
-      case 21: PackedIntsDecompress.decode21(intBuffer, data); break;
-      case 22: PackedIntsDecompress.decode22(intBuffer, data); break;
-      case 23: PackedIntsDecompress.decode23(intBuffer, data); break;
-      case 24: PackedIntsDecompress.decode24(intBuffer, data); break;
-      case 25: PackedIntsDecompress.decode25(intBuffer, data); break;
-      case 26: PackedIntsDecompress.decode26(intBuffer, data); break;
-      case 27: PackedIntsDecompress.decode27(intBuffer, data); break;
-      case 28: PackedIntsDecompress.decode28(intBuffer, data); break;
-      case 29: PackedIntsDecompress.decode29(intBuffer, data); break;
-      case 30: PackedIntsDecompress.decode30(intBuffer, data); break;
-      case 31: PackedIntsDecompress.decode31(intBuffer, data); break;
-      case 32: PackedIntsDecompress.decode32(intBuffer, data); break;
-    }
-  }
-
-  static void encodeNormalValue(IntBuffer intBuffer, int pos, int value, int numBits) {
-    final int globalBitPos = numBits*pos;           // position in bit stream
-    final int localBitPos = globalBitPos & 31;      // position inside an int
-    int intPos = globalBitPos/32; // which integer to locate 
-    setBufferIntBits(intBuffer, intPos, localBitPos, numBits, value);
-    if ((localBitPos + numBits) > 32) { // value does not fit in this int, fill tail
-      setBufferIntBits(intBuffer, intPos+1, 0, 
-                       (localBitPos+numBits-32), 
-                       (value >>> (32-localBitPos)));
-    }
-  }
-
-  static void setBufferIntBits(IntBuffer intBuffer, int intPos, int firstBitPos, int numBits, int value) {
-    assert (value & ~MASK[numBits]) == 0;
-    // safely discards those msb parts when firstBitPos+numBits>32
-    intBuffer.put(intPos,
-          (intBuffer.get(intPos) & ~(MASK[numBits] << firstBitPos)) 
-          | (value << firstBitPos));
-  }
-
-  /**
-   * Estimate best num of frame bits according to the largest value.
-   */
-  static int getNumBits(final int[] data) {
-    if (isAllEqual(data)) {
-      return 0;
-    }
-    int size=data.length;
-    int optBits=1;
-    for (int i=0; i<size; ++i) {
-      while ((data[i] & ~MASK[optBits]) != 0) {
-        optBits++;
-      }
-    }
-    return optBits;
-  }
-
-  protected static boolean isAllEqual(final int[] data) {
-    int len = data.length;
-    int v = data[0];
-    for (int i=1; i<len; i++) {
-      if (data[i] != v) {
-        return false;
-      }
-    }
-    return true;
-  }
-
-  /** 
-   * Generate the 4 byte header, which contains (from lsb to msb):
-   *
-   * 8 bits for encoded block int size (excluded header, this limits DEFAULT_BLOCK_SIZE <= 2^8)
-   * 6 bits for num of frame bits (when 0, values in this block are all the same)
-   * other bits unused
-   *
-   */
-  static int getHeader(int encodedSize, int numBits) {
-    return  (encodedSize)
-          | ((numBits) << 8);
-  }
-
-  /** 
-   * Expert: get metadata from header. 
-   */
-  public static int getEncodedSize(int header) {
-    return ((header & MASK[8]))*4;
-  }
-  public static int getNumBits(int header) {
-    return ((header >> 8) & MASK[6]);
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/pfor/PForFactory.java b/lucene/core/src/java/org/apache/lucene/codecs/pfor/PForFactory.java
deleted file mode 100644
index aa06f78..0000000
--- a/lucene/core/src/java/org/apache/lucene/codecs/pfor/PForFactory.java
+++ /dev/null
@@ -1,129 +0,0 @@
-package org.apache.lucene.codecs.pfor;
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.IntBuffer;
-
-import org.apache.lucene.util.IOUtils;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IOContext;
-import org.apache.lucene.store.IndexInput;
-import org.apache.lucene.store.IndexOutput;
-import org.apache.lucene.codecs.sep.IntStreamFactory;
-import org.apache.lucene.codecs.sep.IntIndexInput;
-import org.apache.lucene.codecs.sep.IntIndexOutput;
-import org.apache.lucene.codecs.intblock.FixedIntBlockIndexInput;
-import org.apache.lucene.codecs.intblock.FixedIntBlockIndexOutput;
-
-/** 
- * Used to plug to PostingsReader/WriterBase.
- * Encoder and decoder in lower layers are called by 
- * flushBlock() and readBlock()
- */
-
-public final class PForFactory extends IntStreamFactory {
-
-  public PForFactory() {
-  }
-
-  @Override
-  public IntIndexOutput createOutput(Directory dir, String fileName, IOContext context)  throws IOException {
-    boolean success = false;
-    IndexOutput out = dir.createOutput(fileName, context);
-    try {
-      IntIndexOutput ret = new PForIndexOutput(out);
-      success = true;
-      return ret;
-    } finally {
-      if (!success) {
-        // For some cases (e.g. disk full), the IntIndexOutput may not be 
-        // properly created. So we should close those opened files. 
-        IOUtils.closeWhileHandlingException(out);
-      }
-    }
-  }
-
-  @Override
-  public IntIndexInput openInput(Directory dir, String fileName, IOContext context) throws IOException {
-    return new PForIndexInput(dir.openInput(fileName, context));
-  }
-
-  /**
-   * Here we'll hold both input buffer and output buffer for 
-   * encoder/decoder.
-   */
-  private class PForIndexInput extends FixedIntBlockIndexInput {
-
-    PForIndexInput(final IndexInput in) throws IOException {
-      super(in);
-    }
-
-    class PForBlockReader implements FixedIntBlockIndexInput.BlockReader {
-      private final byte[] encoded;
-      private final int[] buffer;
-      private final IndexInput in;
-      private final IntBuffer encodedBuffer;
-
-      PForBlockReader(final IndexInput in, final int[] buffer) {
-        // upperbound for encoded value should include(here header is not buffered):
-        // 1. blockSize of normal value (4x bytes); 
-        // 2. blockSize of exception value (4x bytes);
-        this.encoded = new byte[PForPostingsFormat.DEFAULT_BLOCK_SIZE*8];
-        this.in = in;
-        this.buffer = buffer;
-        this.encodedBuffer = ByteBuffer.wrap(encoded).asIntBuffer();
-      }
-
-      // TODO: implement public void skipBlock() {} ?
-      @Override
-      public void readBlock() throws IOException {
-        final int header = in.readInt();
-        final int numBytes = PForUtil.getEncodedSize(header);
-        assert numBytes <= PForPostingsFormat.DEFAULT_BLOCK_SIZE*8;
-        in.readBytes(encoded,0,numBytes);
-        PForUtil.decompress(encodedBuffer,buffer,header);
-      }
-    }
-
-    @Override
-    protected BlockReader getBlockReader(final IndexInput in, final int[] buffer) throws IOException {
-      return new PForBlockReader(in,buffer);
-    }
-  }
-
-  private class PForIndexOutput extends FixedIntBlockIndexOutput {
-    private final byte[] encoded;
-    private final IntBuffer encodedBuffer;
-
-    PForIndexOutput(IndexOutput out) throws IOException {
-      super(out, PForPostingsFormat.DEFAULT_BLOCK_SIZE);
-      this.encoded = new byte[PForPostingsFormat.DEFAULT_BLOCK_SIZE*8];
-      this.encodedBuffer=ByteBuffer.wrap(encoded).asIntBuffer();
-    }
-
-    @Override
-    protected void flushBlock() throws IOException {
-      final int header = PForUtil.compress(buffer,encodedBuffer);
-      final int numBytes = PForUtil.getEncodedSize(header);
-      // nocommit writeVInt instead?
-      out.writeInt(header);
-      out.writeBytes(encoded, numBytes);
-    }
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/pfor/PForPostingsFormat.java b/lucene/core/src/java/org/apache/lucene/codecs/pfor/PForPostingsFormat.java
deleted file mode 100644
index 8704dcd..0000000
--- a/lucene/core/src/java/org/apache/lucene/codecs/pfor/PForPostingsFormat.java
+++ /dev/null
@@ -1,115 +0,0 @@
-package org.apache.lucene.codecs.pfor;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.Set;
-
-import org.apache.lucene.codecs.BlockTreeTermsReader;
-import org.apache.lucene.codecs.BlockTreeTermsWriter;
-import org.apache.lucene.codecs.FieldsConsumer;
-import org.apache.lucene.codecs.FieldsProducer;
-import org.apache.lucene.codecs.FixedGapTermsIndexReader;
-import org.apache.lucene.codecs.FixedGapTermsIndexWriter;
-import org.apache.lucene.codecs.PostingsFormat;
-import org.apache.lucene.codecs.PostingsReaderBase;
-import org.apache.lucene.codecs.PostingsWriterBase;
-import org.apache.lucene.codecs.TermsIndexReaderBase;
-import org.apache.lucene.codecs.TermsIndexWriterBase;
-import org.apache.lucene.codecs.sep.SepPostingsReader;
-import org.apache.lucene.codecs.sep.SepPostingsWriter;
-import org.apache.lucene.index.SegmentInfo;
-import org.apache.lucene.index.SegmentReadState;
-import org.apache.lucene.index.SegmentWriteState;
-import org.apache.lucene.store.IOContext;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.IOUtils;
-
-/**
- * Pass PForFactory to a PostingsWriter/ReaderBase, and get 
- * customized postings format plugged.
- */
-public final class PForPostingsFormat extends PostingsFormat {
-  private final int minBlockSize;
-  private final int maxBlockSize;
-  public final static int DEFAULT_BLOCK_SIZE = 128;
-
-  public PForPostingsFormat() {
-    super("PFor");
-    this.minBlockSize = BlockTreeTermsWriter.DEFAULT_MIN_BLOCK_SIZE;
-    this.maxBlockSize = BlockTreeTermsWriter.DEFAULT_MAX_BLOCK_SIZE;
-  }
-  public PForPostingsFormat(int minBlockSize, int maxBlockSize) {
-    super("PFor");
-    this.minBlockSize = minBlockSize;
-    assert minBlockSize > 1;
-    this.maxBlockSize = maxBlockSize;
-    assert minBlockSize <= maxBlockSize;
-  }
-
-  @Override
-  public String toString() {
-    return getName() + "(blocksize=" + DEFAULT_BLOCK_SIZE+ ")";
-  }
-
-  @Override
-  public FieldsConsumer fieldsConsumer(SegmentWriteState state) throws IOException {
-    // TODO: implement a new PostingsWriterBase to improve skip-settings
-    PostingsWriterBase postingsWriter = new SepPostingsWriter(state, new PForFactory()); 
-    boolean success = false;
-    try {
-      FieldsConsumer ret = new BlockTreeTermsWriter(state, 
-                                                    postingsWriter,
-                                                    minBlockSize, 
-                                                    maxBlockSize);
-      success = true;
-      return ret;
-    } finally {
-      if (!success) {
-        IOUtils.closeWhileHandlingException(postingsWriter);
-      }
-    }
-  }
-
-  @Override
-  public FieldsProducer fieldsProducer(SegmentReadState state) throws IOException {
-    PostingsReaderBase postingsReader = new SepPostingsReader(state.dir,
-                                                              state.fieldInfos,
-                                                              state.segmentInfo,
-                                                              state.context,
-                                                              new PForFactory(),
-                                                              state.segmentSuffix);
-
-    boolean success = false;
-    try {
-      FieldsProducer ret = new BlockTreeTermsReader(state.dir,
-                                                    state.fieldInfos,
-                                                    state.segmentInfo.name,
-                                                    postingsReader,
-                                                    state.context,
-                                                    state.segmentSuffix,
-                                                    state.termsIndexDivisor);
-      success = true;
-      return ret;
-    } finally {
-      if (!success) {
-        IOUtils.closeWhileHandlingException(postingsReader);
-      }
-    }
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/pfor/PForUtil.java b/lucene/core/src/java/org/apache/lucene/codecs/pfor/PForUtil.java
deleted file mode 100644
index 92baa3e..0000000
--- a/lucene/core/src/java/org/apache/lucene/codecs/pfor/PForUtil.java
+++ /dev/null
@@ -1,343 +0,0 @@
-package org.apache.lucene.codecs.pfor;
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.nio.IntBuffer;
-import java.nio.ByteBuffer;
-import java.util.Arrays;
-
-/**
- * Encode all small values and exception pointers in normal area;
- * Encode large values in exception area;
- * Size per exception is variable, possibly: 1byte, 2bytes, or 4bytes
- */
-public final class PForUtil extends ForUtil {
-
-  protected static final int[] PER_EXCEPTION_SIZE = {1,2,4};
-
-  /** Compress given int[] into Integer buffer, with PFor format
-   *
-   * @param data        uncompressed data
-   * @param intBuffer   integer buffer to hold compressed data
-   * @return block header
-   */
-  public static int compress(final int[] data, IntBuffer intBuffer) {
-    /** estimate minimum compress size to determine numFrameBits */
-    int numBits=getNumBits(data);
-    if (numBits == 0) {
-      return compressDuplicateBlock(data,intBuffer);
-    }
- 
-    int size = data.length;
-    int[] excValues = new int[size];
-    int excNum = 0, excLastPos = -1, excFirstPos = -1, excLastNonForcePos = -1; 
-
-    // num of exception until the last non-forced exception
-    int excNumBase = 0;          
-
-    // bytes per exception
-    int excBytes = 1;
-
-    // bytes before exception area, e.g. header and normal area
-    int excByteOffset = 0;
-
-    // the max value possible for current exception pointer, 
-    // value of the first pointer is limited by header as 254
-    // (first exception ranges from -1 ~ 254)
-    long maxChainFirst = 254;
-    long maxChain = maxChainFirst + 1;  
-
-    boolean conValue, conForce, conEnd;
-    int i=0;
-
-    /** estimate exceptions */
-    for (i=0; i<size; ++i) {
-      conValue = ((data[i] & MASK[numBits]) != data[i]); // value exception
-      conForce = (i >= maxChain + excLastPos);           // force exception
-      if (conValue || conForce) {
-        excValues[excNum++] = data[i];
-        if (excLastPos == -1) {
-          maxChain = 1L<<numBits; 
-          excFirstPos = i;
-        }
-        if (conValue) {
-          excLastNonForcePos = i;
-          excNumBase = excNum;
-        }
-        excLastPos = i;
-      }
-    }
-
-    /** encode normal area, record exception positions */
-    excNum = 0;
-    if (excFirstPos < 0) { // no exception 
-      for (i=0; i<size; ++i) {
-        encodeNormalValue(intBuffer,i,data[i], numBits);
-      }
-      excLastPos = -1;
-    } else {
-      for (i=0; i<excFirstPos; ++i) {
-        encodeNormalValue(intBuffer,i,data[i], numBits);
-      }
-      maxChain = 1L<<numBits;
-      excLastPos = excFirstPos;
-      excNum = i<size? 1:0;
-      for (i=excFirstPos+1; i<size; ++i) {
-        conValue = ((data[i] & MASK[numBits]) != data[i]); // value exception
-        conForce = (i >= maxChain + excLastPos);           // force exception
-        conEnd = (excNum == excNumBase);                   // following forced ignored
-        if ((!conValue && !conForce) || conEnd) {
-          encodeNormalValue(intBuffer,i,data[i], numBits);
-        } else {
-          encodeNormalValue(intBuffer, excLastPos, i-excLastPos-1, numBits); 
-          excNum++;
-          excLastPos = i;
-        }
-      }
-    }
-  
-    /** encode exception area */
-    for (i=0; i<excNum; ++i) {
-      if (excBytes < 2 && (excValues[i] & ~MASK[8]) != 0) {
-        excBytes=2;
-      }
-      if (excBytes < 4 && (excValues[i] & ~MASK[16]) != 0) {
-        excBytes=4;
-      }
-    }
-    excByteOffset = (size*numBits + 7)/8;
-    encodeExcValues(intBuffer, excValues, excNum, excBytes, excByteOffset);
-
-    /** encode header */
-    int encodedSize = (excByteOffset + excBytes*excNum + 3)/4;
-
-    return getHeader(encodedSize, numBits, excNum, excFirstPos, excBytes);
-  }
-  
-  /** Decompress given Integer buffer into int array.
-   *
-   * @param intBuffer   integer buffer to hold compressed data
-   * @param data        int array to hold uncompressed data
-   */
-  public static void decompress(IntBuffer intBuffer, int[] data, int header) {
-    // since this buffer is reused at upper level, rewind first
-    intBuffer.rewind();
-
-    int excNum = ((header >> 8) & MASK[8]) + 1;
-    int excFirstPos = ((header >> 16) & MASK[8]) - 1;
-    int excBytes = PER_EXCEPTION_SIZE[(header >> 30) & MASK[2]];
-    int numBits = ((header >> 24) & MASK[6]);
-
-    decompressCore(intBuffer, data, numBits);
-
-    patchException(intBuffer,data,excNum,excFirstPos,excBytes);
-  }
-
-  /**
-   * Encode exception values into exception area.
-   * The width for each exception will be fixed as:
-   * 1, 2, or 4 byte(s).
-   */
-  static void encodeExcValues(IntBuffer intBuffer, int[] values, int num, int perbytes, int byteOffset) {
-    if (num == 0)
-      return;
-    if (perbytes == 1) {
-      int curBytePos = byteOffset;
-      for (int i=0; i<num; ++i) {
-        int curIntPos = curBytePos / 4;
-        setBufferIntBits(intBuffer, curIntPos, (curBytePos & 3)*8, 8, values[i]);
-        curBytePos++;
-      }
-    } else if (perbytes == 2) {
-      int shortOffset = (byteOffset+1)/2;
-      int curIntPos = shortOffset/2;
-      int i=0;
-      if ((shortOffset & 1) == 1) {  // cut head to ensure remaining fit ints
-        setBufferIntBits(intBuffer, curIntPos++, 16, 16, values[i++]); 
-      }
-      for (; i<num-1; i+=2) {
-        intBuffer.put(curIntPos++, (values[i+1]<<16) | values[i]);
-      }
-      if (i<num) {
-        intBuffer.put(curIntPos, values[i]); // cut tail, also clear high 16 bits
-      }
-    } else if (perbytes == 4) {
-      int curIntPos = (byteOffset+3) / 4;
-      for (int i=0; i<num; ++i) {
-        intBuffer.put(curIntPos++, values[i]);
-      }
-    }
-  }
-
-  /**
-   * Save only header when the whole block equals to 1
-   */
-  static int compressDuplicateBlock(final int[] data, IntBuffer intBuffer) {
-    intBuffer.put(0,data[0]);
-    return getHeader(1, 0, 0, -1, 0);
-  }
-
-  /**
-   * Decode exception values base on the exception pointers in normal area,
-   * and values in exception area.
-   * As for current implementation, numInts is hardwired as 128, so the
-   * tail of normal area is naturally aligned to 32 bits, and we don't need to
-   * rewind intBuffer here.
-   * However, the normal area may share a same int with exception area, 
-   * when numFrameBits * numInts % 32 != 0,
-   * In this case we should preprocess patch several heading exceptions, 
-   * before calling this method.
-   *
-   */
-  public static void patchException(IntBuffer intBuffer, int[] data, int excNum, int excFirstPos, int excBytes) {
-    if (excFirstPos == -1) {
-      return;
-    }
-    int curPos=excFirstPos;
-    int i,j;
-
-    if (excBytes == 1) { // each exception consumes 1 byte
-      for (i=0; i+3<excNum; i+=4) {
-        final int curInt = intBuffer.get();
-        curPos = patch(data, curPos, (curInt) & MASK[8]);
-        curPos = patch(data, curPos, (curInt >>> 8)  & MASK[8]);
-        curPos = patch(data, curPos, (curInt >>> 16) & MASK[8]);
-        curPos = patch(data, curPos, (curInt >>> 24) & MASK[8]);
-      }
-      if (i<excNum) {
-        final int curInt = intBuffer.get();
-        for (j=0; j<32 && i<excNum; j+=8,i++) {
-          curPos = patch(data, curPos, (curInt >>> j) & MASK[8]);
-        }
-      }
-    } else if (excBytes == 2) { // each exception consumes 2 bytes
-      for (i=0; i+1<excNum; i+=2) {
-        final int curInt = intBuffer.get();
-        curPos = patch(data, curPos, (curInt) & MASK[16]);
-        curPos = patch(data, curPos, (curInt >>> 16) & MASK[16]);
-      }
-      if (i<excNum) {
-        final int curInt = intBuffer.get();
-        curPos = patch(data, curPos, (curInt) & MASK[16]);
-      }
-    } else if (excBytes == 4) { // each exception consumes 4 bytes
-      for (i=0; i<excNum; i++) {
-        curPos = patch(data, curPos, intBuffer.get());
-      }
-    }
-  }
-
-  static int patch(int[]data, int pos, int value) {
-    int nextPos = data[pos] + pos + 1;
-    data[pos] = value;
-    assert nextPos > pos;
-    return nextPos;
-  }
-
-  /**
-   * Estimate best number of frame bits according to minimum compressed size.
-   * It will run 32 times.
-   */
-  static int getNumBits(final int[] data) {
-    if (isAllEqual(data)) {
-      return 0;
-    }
-    int optBits=1;
-    int optSize=estimateCompressedSize(data,optBits);
-    for (int i=2; i<=32; ++i) {
-      int curSize=estimateCompressedSize(data,i);
-      if (curSize<optSize) {
-        optSize=curSize;
-        optBits=i;
-      }
-    }
-    return optBits;
-  }
-
-  /**
-   * Iterate the whole block to get maximum exception bits, 
-   * and estimate compressed size without forced exception.
-   * TODO: foresee forced exception for better estimation
-   */
-  static int estimateCompressedSize(final int[] data, int numBits) {
-    int size=data.length;
-    int totalBytes=(numBits*size+7)/8;   // always round to byte
-    int excNum=0;
-    int curExcBytes=1;
-    for (int i=0; i<size; ++i) {
-      if ((data[i] & ~MASK[numBits]) != 0) {   // exception
-        excNum++;
-        if (curExcBytes<2 && (data[i] & ~MASK[8]) != 0) { // exceed 1 byte exception
-          curExcBytes=2;
-        }
-        if (curExcBytes<4 && (data[i] & ~MASK[16]) != 0) { // exceed 2 byte exception
-          curExcBytes=4;
-        }
-      }
-    }
-    if (curExcBytes==2) {
-      totalBytes=((totalBytes+1)/2)*2;  // round up to 2x bytes before filling exceptions
-    }
-    else if (curExcBytes==4) {
-      totalBytes=((totalBytes+3)/4)*4;  // round up to 4x bytes
-    }
-    totalBytes+=excNum*curExcBytes;
-
-    return totalBytes/4*4;  // round up to ints
-  }
-
-  /** 
-   * Generate the 4 byte header which contains (from lsb to msb):
-   *
-   * 8 bits for encoded block int size (excluding header, this limits DEFAULT_BLOCK_SIZE <= 2^(8-1))
-   *
-   * 8 bits for exception num - 1 (when no exceptions, this is undefined)
-   *
-   * 8 bits for the index of the first exception + 1 (when no exception, this is 0)
-   *
-   * 6 bits for num of frame bits (when 0, values in this block are all the same)
-   * 2 bits for the exception code: 00: byte, 01: short, 10: int
-   *
-   */
-  static int getHeader(int encodedSize, int numBits, int excNum, int excFirstPos, int excBytes) {
-    return  (encodedSize)
-          | (((excNum-1) & MASK[8]) << 8)
-          | ((excFirstPos+1) << 16)
-          | ((numBits) << 24)
-          | ((excBytes/2) << 30);
-  }
-
-
-  /** 
-   * Expert: get metadata from header. 
-   */
-  public static int getEncodedSize(int header) {
-    return ((header & MASK[8]))*4;
-  }
-  public static int getExcNum(int header) {
-    return ((header >> 8) & MASK[8]) + 1;
-  }
-  public static int getFirstPos(int header) {
-    return ((header >> 16) & MASK[8]) - 1;
-  }
-  public static int getExcBytes(int header) {
-    return PER_EXCEPTION_SIZE[(header >> 30) & MASK[2]];
-  }
-  public static int getNumBits(int header) {
-    return ((header >> 24) & MASK[6]);
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/pfor/PackedIntsDecompress.java b/lucene/core/src/java/org/apache/lucene/codecs/pfor/PackedIntsDecompress.java
deleted file mode 100644
index 6f41d65..0000000
--- a/lucene/core/src/java/org/apache/lucene/codecs/pfor/PackedIntsDecompress.java
+++ /dev/null
@@ -1,1841 +0,0 @@
-package org.apache.lucene.codecs.pfor;
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
- 
-/* This code is generated, do not modify. See gendecompress.py */
-
-import java.nio.IntBuffer;
-import java.util.Arrays;
-
-final class PackedIntsDecompress {
-
-  // nocommit: assess perf of this to see if specializing is really needed
-
-  // NOTE: hardwired to blockSize == 128
-
-  public static void decode0(final IntBuffer compressedBuffer, final int[] output) {
-    Arrays.fill(output, compressedBuffer.get());
-  }
-  public static void decode1(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 1;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = (intValue0 >>> 1) & mask;
-      output[2 + outputOffset] = (intValue0 >>> 2) & mask;
-      output[3 + outputOffset] = (intValue0 >>> 3) & mask;
-      output[4 + outputOffset] = (intValue0 >>> 4) & mask;
-      output[5 + outputOffset] = (intValue0 >>> 5) & mask;
-      output[6 + outputOffset] = (intValue0 >>> 6) & mask;
-      output[7 + outputOffset] = (intValue0 >>> 7) & mask;
-      output[8 + outputOffset] = (intValue0 >>> 8) & mask;
-      output[9 + outputOffset] = (intValue0 >>> 9) & mask;
-      output[10 + outputOffset] = (intValue0 >>> 10) & mask;
-      output[11 + outputOffset] = (intValue0 >>> 11) & mask;
-      output[12 + outputOffset] = (intValue0 >>> 12) & mask;
-      output[13 + outputOffset] = (intValue0 >>> 13) & mask;
-      output[14 + outputOffset] = (intValue0 >>> 14) & mask;
-      output[15 + outputOffset] = (intValue0 >>> 15) & mask;
-      output[16 + outputOffset] = (intValue0 >>> 16) & mask;
-      output[17 + outputOffset] = (intValue0 >>> 17) & mask;
-      output[18 + outputOffset] = (intValue0 >>> 18) & mask;
-      output[19 + outputOffset] = (intValue0 >>> 19) & mask;
-      output[20 + outputOffset] = (intValue0 >>> 20) & mask;
-      output[21 + outputOffset] = (intValue0 >>> 21) & mask;
-      output[22 + outputOffset] = (intValue0 >>> 22) & mask;
-      output[23 + outputOffset] = (intValue0 >>> 23) & mask;
-      output[24 + outputOffset] = (intValue0 >>> 24) & mask;
-      output[25 + outputOffset] = (intValue0 >>> 25) & mask;
-      output[26 + outputOffset] = (intValue0 >>> 26) & mask;
-      output[27 + outputOffset] = (intValue0 >>> 27) & mask;
-      output[28 + outputOffset] = (intValue0 >>> 28) & mask;
-      output[29 + outputOffset] = (intValue0 >>> 29) & mask;
-      output[30 + outputOffset] = (intValue0 >>> 30) & mask;
-      output[31 + outputOffset] = intValue0 >>> 31;
-      outputOffset += 32;
-    }
-  }
-  public static void decode2(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 2;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = (intValue0 >>> 2) & mask;
-      output[2 + outputOffset] = (intValue0 >>> 4) & mask;
-      output[3 + outputOffset] = (intValue0 >>> 6) & mask;
-      output[4 + outputOffset] = (intValue0 >>> 8) & mask;
-      output[5 + outputOffset] = (intValue0 >>> 10) & mask;
-      output[6 + outputOffset] = (intValue0 >>> 12) & mask;
-      output[7 + outputOffset] = (intValue0 >>> 14) & mask;
-      output[8 + outputOffset] = (intValue0 >>> 16) & mask;
-      output[9 + outputOffset] = (intValue0 >>> 18) & mask;
-      output[10 + outputOffset] = (intValue0 >>> 20) & mask;
-      output[11 + outputOffset] = (intValue0 >>> 22) & mask;
-      output[12 + outputOffset] = (intValue0 >>> 24) & mask;
-      output[13 + outputOffset] = (intValue0 >>> 26) & mask;
-      output[14 + outputOffset] = (intValue0 >>> 28) & mask;
-      output[15 + outputOffset] = intValue0 >>> 30;
-      output[16 + outputOffset] = intValue1 & mask;
-      output[17 + outputOffset] = (intValue1 >>> 2) & mask;
-      output[18 + outputOffset] = (intValue1 >>> 4) & mask;
-      output[19 + outputOffset] = (intValue1 >>> 6) & mask;
-      output[20 + outputOffset] = (intValue1 >>> 8) & mask;
-      output[21 + outputOffset] = (intValue1 >>> 10) & mask;
-      output[22 + outputOffset] = (intValue1 >>> 12) & mask;
-      output[23 + outputOffset] = (intValue1 >>> 14) & mask;
-      output[24 + outputOffset] = (intValue1 >>> 16) & mask;
-      output[25 + outputOffset] = (intValue1 >>> 18) & mask;
-      output[26 + outputOffset] = (intValue1 >>> 20) & mask;
-      output[27 + outputOffset] = (intValue1 >>> 22) & mask;
-      output[28 + outputOffset] = (intValue1 >>> 24) & mask;
-      output[29 + outputOffset] = (intValue1 >>> 26) & mask;
-      output[30 + outputOffset] = (intValue1 >>> 28) & mask;
-      output[31 + outputOffset] = intValue1 >>> 30;
-      outputOffset += 32;
-    }
-  }
-  public static void decode3(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 3;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = (intValue0 >>> 3) & mask;
-      output[2 + outputOffset] = (intValue0 >>> 6) & mask;
-      output[3 + outputOffset] = (intValue0 >>> 9) & mask;
-      output[4 + outputOffset] = (intValue0 >>> 12) & mask;
-      output[5 + outputOffset] = (intValue0 >>> 15) & mask;
-      output[6 + outputOffset] = (intValue0 >>> 18) & mask;
-      output[7 + outputOffset] = (intValue0 >>> 21) & mask;
-      output[8 + outputOffset] = (intValue0 >>> 24) & mask;
-      output[9 + outputOffset] = (intValue0 >>> 27) & mask;
-      output[10 + outputOffset] = ((intValue0 >>> 30) | (intValue1 << 2)) & mask;
-      output[11 + outputOffset] = (intValue1 >>> 1) & mask;
-      output[12 + outputOffset] = (intValue1 >>> 4) & mask;
-      output[13 + outputOffset] = (intValue1 >>> 7) & mask;
-      output[14 + outputOffset] = (intValue1 >>> 10) & mask;
-      output[15 + outputOffset] = (intValue1 >>> 13) & mask;
-      output[16 + outputOffset] = (intValue1 >>> 16) & mask;
-      output[17 + outputOffset] = (intValue1 >>> 19) & mask;
-      output[18 + outputOffset] = (intValue1 >>> 22) & mask;
-      output[19 + outputOffset] = (intValue1 >>> 25) & mask;
-      output[20 + outputOffset] = (intValue1 >>> 28) & mask;
-      output[21 + outputOffset] = ((intValue1 >>> 31) | (intValue2 << 1)) & mask;
-      output[22 + outputOffset] = (intValue2 >>> 2) & mask;
-      output[23 + outputOffset] = (intValue2 >>> 5) & mask;
-      output[24 + outputOffset] = (intValue2 >>> 8) & mask;
-      output[25 + outputOffset] = (intValue2 >>> 11) & mask;
-      output[26 + outputOffset] = (intValue2 >>> 14) & mask;
-      output[27 + outputOffset] = (intValue2 >>> 17) & mask;
-      output[28 + outputOffset] = (intValue2 >>> 20) & mask;
-      output[29 + outputOffset] = (intValue2 >>> 23) & mask;
-      output[30 + outputOffset] = (intValue2 >>> 26) & mask;
-      output[31 + outputOffset] = intValue2 >>> 29;
-      outputOffset += 32;
-    }
-  }
-  public static void decode4(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 4;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = (intValue0 >>> 4) & mask;
-      output[2 + outputOffset] = (intValue0 >>> 8) & mask;
-      output[3 + outputOffset] = (intValue0 >>> 12) & mask;
-      output[4 + outputOffset] = (intValue0 >>> 16) & mask;
-      output[5 + outputOffset] = (intValue0 >>> 20) & mask;
-      output[6 + outputOffset] = (intValue0 >>> 24) & mask;
-      output[7 + outputOffset] = intValue0 >>> 28;
-      output[8 + outputOffset] = intValue1 & mask;
-      output[9 + outputOffset] = (intValue1 >>> 4) & mask;
-      output[10 + outputOffset] = (intValue1 >>> 8) & mask;
-      output[11 + outputOffset] = (intValue1 >>> 12) & mask;
-      output[12 + outputOffset] = (intValue1 >>> 16) & mask;
-      output[13 + outputOffset] = (intValue1 >>> 20) & mask;
-      output[14 + outputOffset] = (intValue1 >>> 24) & mask;
-      output[15 + outputOffset] = intValue1 >>> 28;
-      output[16 + outputOffset] = intValue2 & mask;
-      output[17 + outputOffset] = (intValue2 >>> 4) & mask;
-      output[18 + outputOffset] = (intValue2 >>> 8) & mask;
-      output[19 + outputOffset] = (intValue2 >>> 12) & mask;
-      output[20 + outputOffset] = (intValue2 >>> 16) & mask;
-      output[21 + outputOffset] = (intValue2 >>> 20) & mask;
-      output[22 + outputOffset] = (intValue2 >>> 24) & mask;
-      output[23 + outputOffset] = intValue2 >>> 28;
-      output[24 + outputOffset] = intValue3 & mask;
-      output[25 + outputOffset] = (intValue3 >>> 4) & mask;
-      output[26 + outputOffset] = (intValue3 >>> 8) & mask;
-      output[27 + outputOffset] = (intValue3 >>> 12) & mask;
-      output[28 + outputOffset] = (intValue3 >>> 16) & mask;
-      output[29 + outputOffset] = (intValue3 >>> 20) & mask;
-      output[30 + outputOffset] = (intValue3 >>> 24) & mask;
-      output[31 + outputOffset] = intValue3 >>> 28;
-      outputOffset += 32;
-    }
-  }
-  public static void decode5(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 5;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = (intValue0 >>> 5) & mask;
-      output[2 + outputOffset] = (intValue0 >>> 10) & mask;
-      output[3 + outputOffset] = (intValue0 >>> 15) & mask;
-      output[4 + outputOffset] = (intValue0 >>> 20) & mask;
-      output[5 + outputOffset] = (intValue0 >>> 25) & mask;
-      output[6 + outputOffset] = ((intValue0 >>> 30) | (intValue1 << 2)) & mask;
-      output[7 + outputOffset] = (intValue1 >>> 3) & mask;
-      output[8 + outputOffset] = (intValue1 >>> 8) & mask;
-      output[9 + outputOffset] = (intValue1 >>> 13) & mask;
-      output[10 + outputOffset] = (intValue1 >>> 18) & mask;
-      output[11 + outputOffset] = (intValue1 >>> 23) & mask;
-      output[12 + outputOffset] = ((intValue1 >>> 28) | (intValue2 << 4)) & mask;
-      output[13 + outputOffset] = (intValue2 >>> 1) & mask;
-      output[14 + outputOffset] = (intValue2 >>> 6) & mask;
-      output[15 + outputOffset] = (intValue2 >>> 11) & mask;
-      output[16 + outputOffset] = (intValue2 >>> 16) & mask;
-      output[17 + outputOffset] = (intValue2 >>> 21) & mask;
-      output[18 + outputOffset] = (intValue2 >>> 26) & mask;
-      output[19 + outputOffset] = ((intValue2 >>> 31) | (intValue3 << 1)) & mask;
-      output[20 + outputOffset] = (intValue3 >>> 4) & mask;
-      output[21 + outputOffset] = (intValue3 >>> 9) & mask;
-      output[22 + outputOffset] = (intValue3 >>> 14) & mask;
-      output[23 + outputOffset] = (intValue3 >>> 19) & mask;
-      output[24 + outputOffset] = (intValue3 >>> 24) & mask;
-      output[25 + outputOffset] = ((intValue3 >>> 29) | (intValue4 << 3)) & mask;
-      output[26 + outputOffset] = (intValue4 >>> 2) & mask;
-      output[27 + outputOffset] = (intValue4 >>> 7) & mask;
-      output[28 + outputOffset] = (intValue4 >>> 12) & mask;
-      output[29 + outputOffset] = (intValue4 >>> 17) & mask;
-      output[30 + outputOffset] = (intValue4 >>> 22) & mask;
-      output[31 + outputOffset] = intValue4 >>> 27;
-      outputOffset += 32;
-    }
-  }
-  public static void decode6(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 6;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      int intValue5 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = (intValue0 >>> 6) & mask;
-      output[2 + outputOffset] = (intValue0 >>> 12) & mask;
-      output[3 + outputOffset] = (intValue0 >>> 18) & mask;
-      output[4 + outputOffset] = (intValue0 >>> 24) & mask;
-      output[5 + outputOffset] = ((intValue0 >>> 30) | (intValue1 << 2)) & mask;
-      output[6 + outputOffset] = (intValue1 >>> 4) & mask;
-      output[7 + outputOffset] = (intValue1 >>> 10) & mask;
-      output[8 + outputOffset] = (intValue1 >>> 16) & mask;
-      output[9 + outputOffset] = (intValue1 >>> 22) & mask;
-      output[10 + outputOffset] = ((intValue1 >>> 28) | (intValue2 << 4)) & mask;
-      output[11 + outputOffset] = (intValue2 >>> 2) & mask;
-      output[12 + outputOffset] = (intValue2 >>> 8) & mask;
-      output[13 + outputOffset] = (intValue2 >>> 14) & mask;
-      output[14 + outputOffset] = (intValue2 >>> 20) & mask;
-      output[15 + outputOffset] = intValue2 >>> 26;
-      output[16 + outputOffset] = intValue3 & mask;
-      output[17 + outputOffset] = (intValue3 >>> 6) & mask;
-      output[18 + outputOffset] = (intValue3 >>> 12) & mask;
-      output[19 + outputOffset] = (intValue3 >>> 18) & mask;
-      output[20 + outputOffset] = (intValue3 >>> 24) & mask;
-      output[21 + outputOffset] = ((intValue3 >>> 30) | (intValue4 << 2)) & mask;
-      output[22 + outputOffset] = (intValue4 >>> 4) & mask;
-      output[23 + outputOffset] = (intValue4 >>> 10) & mask;
-      output[24 + outputOffset] = (intValue4 >>> 16) & mask;
-      output[25 + outputOffset] = (intValue4 >>> 22) & mask;
-      output[26 + outputOffset] = ((intValue4 >>> 28) | (intValue5 << 4)) & mask;
-      output[27 + outputOffset] = (intValue5 >>> 2) & mask;
-      output[28 + outputOffset] = (intValue5 >>> 8) & mask;
-      output[29 + outputOffset] = (intValue5 >>> 14) & mask;
-      output[30 + outputOffset] = (intValue5 >>> 20) & mask;
-      output[31 + outputOffset] = intValue5 >>> 26;
-      outputOffset += 32;
-    }
-  }
-  public static void decode7(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 7;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      int intValue5 = compressedBuffer.get();
-      int intValue6 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = (intValue0 >>> 7) & mask;
-      output[2 + outputOffset] = (intValue0 >>> 14) & mask;
-      output[3 + outputOffset] = (intValue0 >>> 21) & mask;
-      output[4 + outputOffset] = ((intValue0 >>> 28) | (intValue1 << 4)) & mask;
-      output[5 + outputOffset] = (intValue1 >>> 3) & mask;
-      output[6 + outputOffset] = (intValue1 >>> 10) & mask;
-      output[7 + outputOffset] = (intValue1 >>> 17) & mask;
-      output[8 + outputOffset] = (intValue1 >>> 24) & mask;
-      output[9 + outputOffset] = ((intValue1 >>> 31) | (intValue2 << 1)) & mask;
-      output[10 + outputOffset] = (intValue2 >>> 6) & mask;
-      output[11 + outputOffset] = (intValue2 >>> 13) & mask;
-      output[12 + outputOffset] = (intValue2 >>> 20) & mask;
-      output[13 + outputOffset] = ((intValue2 >>> 27) | (intValue3 << 5)) & mask;
-      output[14 + outputOffset] = (intValue3 >>> 2) & mask;
-      output[15 + outputOffset] = (intValue3 >>> 9) & mask;
-      output[16 + outputOffset] = (intValue3 >>> 16) & mask;
-      output[17 + outputOffset] = (intValue3 >>> 23) & mask;
-      output[18 + outputOffset] = ((intValue3 >>> 30) | (intValue4 << 2)) & mask;
-      output[19 + outputOffset] = (intValue4 >>> 5) & mask;
-      output[20 + outputOffset] = (intValue4 >>> 12) & mask;
-      output[21 + outputOffset] = (intValue4 >>> 19) & mask;
-      output[22 + outputOffset] = ((intValue4 >>> 26) | (intValue5 << 6)) & mask;
-      output[23 + outputOffset] = (intValue5 >>> 1) & mask;
-      output[24 + outputOffset] = (intValue5 >>> 8) & mask;
-      output[25 + outputOffset] = (intValue5 >>> 15) & mask;
-      output[26 + outputOffset] = (intValue5 >>> 22) & mask;
-      output[27 + outputOffset] = ((intValue5 >>> 29) | (intValue6 << 3)) & mask;
-      output[28 + outputOffset] = (intValue6 >>> 4) & mask;
-      output[29 + outputOffset] = (intValue6 >>> 11) & mask;
-      output[30 + outputOffset] = (intValue6 >>> 18) & mask;
-      output[31 + outputOffset] = intValue6 >>> 25;
-      outputOffset += 32;
-    }
-  }
-  public static void decode8(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 8;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      int intValue5 = compressedBuffer.get();
-      int intValue6 = compressedBuffer.get();
-      int intValue7 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = (intValue0 >>> 8) & mask;
-      output[2 + outputOffset] = (intValue0 >>> 16) & mask;
-      output[3 + outputOffset] = intValue0 >>> 24;
-      output[4 + outputOffset] = intValue1 & mask;
-      output[5 + outputOffset] = (intValue1 >>> 8) & mask;
-      output[6 + outputOffset] = (intValue1 >>> 16) & mask;
-      output[7 + outputOffset] = intValue1 >>> 24;
-      output[8 + outputOffset] = intValue2 & mask;
-      output[9 + outputOffset] = (intValue2 >>> 8) & mask;
-      output[10 + outputOffset] = (intValue2 >>> 16) & mask;
-      output[11 + outputOffset] = intValue2 >>> 24;
-      output[12 + outputOffset] = intValue3 & mask;
-      output[13 + outputOffset] = (intValue3 >>> 8) & mask;
-      output[14 + outputOffset] = (intValue3 >>> 16) & mask;
-      output[15 + outputOffset] = intValue3 >>> 24;
-      output[16 + outputOffset] = intValue4 & mask;
-      output[17 + outputOffset] = (intValue4 >>> 8) & mask;
-      output[18 + outputOffset] = (intValue4 >>> 16) & mask;
-      output[19 + outputOffset] = intValue4 >>> 24;
-      output[20 + outputOffset] = intValue5 & mask;
-      output[21 + outputOffset] = (intValue5 >>> 8) & mask;
-      output[22 + outputOffset] = (intValue5 >>> 16) & mask;
-      output[23 + outputOffset] = intValue5 >>> 24;
-      output[24 + outputOffset] = intValue6 & mask;
-      output[25 + outputOffset] = (intValue6 >>> 8) & mask;
-      output[26 + outputOffset] = (intValue6 >>> 16) & mask;
-      output[27 + outputOffset] = intValue6 >>> 24;
-      output[28 + outputOffset] = intValue7 & mask;
-      output[29 + outputOffset] = (intValue7 >>> 8) & mask;
-      output[30 + outputOffset] = (intValue7 >>> 16) & mask;
-      output[31 + outputOffset] = intValue7 >>> 24;
-      outputOffset += 32;
-    }
-  }
-  public static void decode9(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 9;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      int intValue5 = compressedBuffer.get();
-      int intValue6 = compressedBuffer.get();
-      int intValue7 = compressedBuffer.get();
-      int intValue8 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = (intValue0 >>> 9) & mask;
-      output[2 + outputOffset] = (intValue0 >>> 18) & mask;
-      output[3 + outputOffset] = ((intValue0 >>> 27) | (intValue1 << 5)) & mask;
-      output[4 + outputOffset] = (intValue1 >>> 4) & mask;
-      output[5 + outputOffset] = (intValue1 >>> 13) & mask;
-      output[6 + outputOffset] = (intValue1 >>> 22) & mask;
-      output[7 + outputOffset] = ((intValue1 >>> 31) | (intValue2 << 1)) & mask;
-      output[8 + outputOffset] = (intValue2 >>> 8) & mask;
-      output[9 + outputOffset] = (intValue2 >>> 17) & mask;
-      output[10 + outputOffset] = ((intValue2 >>> 26) | (intValue3 << 6)) & mask;
-      output[11 + outputOffset] = (intValue3 >>> 3) & mask;
-      output[12 + outputOffset] = (intValue3 >>> 12) & mask;
-      output[13 + outputOffset] = (intValue3 >>> 21) & mask;
-      output[14 + outputOffset] = ((intValue3 >>> 30) | (intValue4 << 2)) & mask;
-      output[15 + outputOffset] = (intValue4 >>> 7) & mask;
-      output[16 + outputOffset] = (intValue4 >>> 16) & mask;
-      output[17 + outputOffset] = ((intValue4 >>> 25) | (intValue5 << 7)) & mask;
-      output[18 + outputOffset] = (intValue5 >>> 2) & mask;
-      output[19 + outputOffset] = (intValue5 >>> 11) & mask;
-      output[20 + outputOffset] = (intValue5 >>> 20) & mask;
-      output[21 + outputOffset] = ((intValue5 >>> 29) | (intValue6 << 3)) & mask;
-      output[22 + outputOffset] = (intValue6 >>> 6) & mask;
-      output[23 + outputOffset] = (intValue6 >>> 15) & mask;
-      output[24 + outputOffset] = ((intValue6 >>> 24) | (intValue7 << 8)) & mask;
-      output[25 + outputOffset] = (intValue7 >>> 1) & mask;
-      output[26 + outputOffset] = (intValue7 >>> 10) & mask;
-      output[27 + outputOffset] = (intValue7 >>> 19) & mask;
-      output[28 + outputOffset] = ((intValue7 >>> 28) | (intValue8 << 4)) & mask;
-      output[29 + outputOffset] = (intValue8 >>> 5) & mask;
-      output[30 + outputOffset] = (intValue8 >>> 14) & mask;
-      output[31 + outputOffset] = intValue8 >>> 23;
-      outputOffset += 32;
-    }
-  }
-  public static void decode10(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 10;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      int intValue5 = compressedBuffer.get();
-      int intValue6 = compressedBuffer.get();
-      int intValue7 = compressedBuffer.get();
-      int intValue8 = compressedBuffer.get();
-      int intValue9 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = (intValue0 >>> 10) & mask;
-      output[2 + outputOffset] = (intValue0 >>> 20) & mask;
-      output[3 + outputOffset] = ((intValue0 >>> 30) | (intValue1 << 2)) & mask;
-      output[4 + outputOffset] = (intValue1 >>> 8) & mask;
-      output[5 + outputOffset] = (intValue1 >>> 18) & mask;
-      output[6 + outputOffset] = ((intValue1 >>> 28) | (intValue2 << 4)) & mask;
-      output[7 + outputOffset] = (intValue2 >>> 6) & mask;
-      output[8 + outputOffset] = (intValue2 >>> 16) & mask;
-      output[9 + outputOffset] = ((intValue2 >>> 26) | (intValue3 << 6)) & mask;
-      output[10 + outputOffset] = (intValue3 >>> 4) & mask;
-      output[11 + outputOffset] = (intValue3 >>> 14) & mask;
-      output[12 + outputOffset] = ((intValue3 >>> 24) | (intValue4 << 8)) & mask;
-      output[13 + outputOffset] = (intValue4 >>> 2) & mask;
-      output[14 + outputOffset] = (intValue4 >>> 12) & mask;
-      output[15 + outputOffset] = intValue4 >>> 22;
-      output[16 + outputOffset] = intValue5 & mask;
-      output[17 + outputOffset] = (intValue5 >>> 10) & mask;
-      output[18 + outputOffset] = (intValue5 >>> 20) & mask;
-      output[19 + outputOffset] = ((intValue5 >>> 30) | (intValue6 << 2)) & mask;
-      output[20 + outputOffset] = (intValue6 >>> 8) & mask;
-      output[21 + outputOffset] = (intValue6 >>> 18) & mask;
-      output[22 + outputOffset] = ((intValue6 >>> 28) | (intValue7 << 4)) & mask;
-      output[23 + outputOffset] = (intValue7 >>> 6) & mask;
-      output[24 + outputOffset] = (intValue7 >>> 16) & mask;
-      output[25 + outputOffset] = ((intValue7 >>> 26) | (intValue8 << 6)) & mask;
-      output[26 + outputOffset] = (intValue8 >>> 4) & mask;
-      output[27 + outputOffset] = (intValue8 >>> 14) & mask;
-      output[28 + outputOffset] = ((intValue8 >>> 24) | (intValue9 << 8)) & mask;
-      output[29 + outputOffset] = (intValue9 >>> 2) & mask;
-      output[30 + outputOffset] = (intValue9 >>> 12) & mask;
-      output[31 + outputOffset] = intValue9 >>> 22;
-      outputOffset += 32;
-    }
-  }
-  public static void decode11(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 11;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      int intValue5 = compressedBuffer.get();
-      int intValue6 = compressedBuffer.get();
-      int intValue7 = compressedBuffer.get();
-      int intValue8 = compressedBuffer.get();
-      int intValue9 = compressedBuffer.get();
-      int intValue10 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = (intValue0 >>> 11) & mask;
-      output[2 + outputOffset] = ((intValue0 >>> 22) | (intValue1 << 10)) & mask;
-      output[3 + outputOffset] = (intValue1 >>> 1) & mask;
-      output[4 + outputOffset] = (intValue1 >>> 12) & mask;
-      output[5 + outputOffset] = ((intValue1 >>> 23) | (intValue2 << 9)) & mask;
-      output[6 + outputOffset] = (intValue2 >>> 2) & mask;
-      output[7 + outputOffset] = (intValue2 >>> 13) & mask;
-      output[8 + outputOffset] = ((intValue2 >>> 24) | (intValue3 << 8)) & mask;
-      output[9 + outputOffset] = (intValue3 >>> 3) & mask;
-      output[10 + outputOffset] = (intValue3 >>> 14) & mask;
-      output[11 + outputOffset] = ((intValue3 >>> 25) | (intValue4 << 7)) & mask;
-      output[12 + outputOffset] = (intValue4 >>> 4) & mask;
-      output[13 + outputOffset] = (intValue4 >>> 15) & mask;
-      output[14 + outputOffset] = ((intValue4 >>> 26) | (intValue5 << 6)) & mask;
-      output[15 + outputOffset] = (intValue5 >>> 5) & mask;
-      output[16 + outputOffset] = (intValue5 >>> 16) & mask;
-      output[17 + outputOffset] = ((intValue5 >>> 27) | (intValue6 << 5)) & mask;
-      output[18 + outputOffset] = (intValue6 >>> 6) & mask;
-      output[19 + outputOffset] = (intValue6 >>> 17) & mask;
-      output[20 + outputOffset] = ((intValue6 >>> 28) | (intValue7 << 4)) & mask;
-      output[21 + outputOffset] = (intValue7 >>> 7) & mask;
-      output[22 + outputOffset] = (intValue7 >>> 18) & mask;
-      output[23 + outputOffset] = ((intValue7 >>> 29) | (intValue8 << 3)) & mask;
-      output[24 + outputOffset] = (intValue8 >>> 8) & mask;
-      output[25 + outputOffset] = (intValue8 >>> 19) & mask;
-      output[26 + outputOffset] = ((intValue8 >>> 30) | (intValue9 << 2)) & mask;
-      output[27 + outputOffset] = (intValue9 >>> 9) & mask;
-      output[28 + outputOffset] = (intValue9 >>> 20) & mask;
-      output[29 + outputOffset] = ((intValue9 >>> 31) | (intValue10 << 1)) & mask;
-      output[30 + outputOffset] = (intValue10 >>> 10) & mask;
-      output[31 + outputOffset] = intValue10 >>> 21;
-      outputOffset += 32;
-    }
-  }
-  public static void decode12(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 12;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      int intValue5 = compressedBuffer.get();
-      int intValue6 = compressedBuffer.get();
-      int intValue7 = compressedBuffer.get();
-      int intValue8 = compressedBuffer.get();
-      int intValue9 = compressedBuffer.get();
-      int intValue10 = compressedBuffer.get();
-      int intValue11 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = (intValue0 >>> 12) & mask;
-      output[2 + outputOffset] = ((intValue0 >>> 24) | (intValue1 << 8)) & mask;
-      output[3 + outputOffset] = (intValue1 >>> 4) & mask;
-      output[4 + outputOffset] = (intValue1 >>> 16) & mask;
-      output[5 + outputOffset] = ((intValue1 >>> 28) | (intValue2 << 4)) & mask;
-      output[6 + outputOffset] = (intValue2 >>> 8) & mask;
-      output[7 + outputOffset] = intValue2 >>> 20;
-      output[8 + outputOffset] = intValue3 & mask;
-      output[9 + outputOffset] = (intValue3 >>> 12) & mask;
-      output[10 + outputOffset] = ((intValue3 >>> 24) | (intValue4 << 8)) & mask;
-      output[11 + outputOffset] = (intValue4 >>> 4) & mask;
-      output[12 + outputOffset] = (intValue4 >>> 16) & mask;
-      output[13 + outputOffset] = ((intValue4 >>> 28) | (intValue5 << 4)) & mask;
-      output[14 + outputOffset] = (intValue5 >>> 8) & mask;
-      output[15 + outputOffset] = intValue5 >>> 20;
-      output[16 + outputOffset] = intValue6 & mask;
-      output[17 + outputOffset] = (intValue6 >>> 12) & mask;
-      output[18 + outputOffset] = ((intValue6 >>> 24) | (intValue7 << 8)) & mask;
-      output[19 + outputOffset] = (intValue7 >>> 4) & mask;
-      output[20 + outputOffset] = (intValue7 >>> 16) & mask;
-      output[21 + outputOffset] = ((intValue7 >>> 28) | (intValue8 << 4)) & mask;
-      output[22 + outputOffset] = (intValue8 >>> 8) & mask;
-      output[23 + outputOffset] = intValue8 >>> 20;
-      output[24 + outputOffset] = intValue9 & mask;
-      output[25 + outputOffset] = (intValue9 >>> 12) & mask;
-      output[26 + outputOffset] = ((intValue9 >>> 24) | (intValue10 << 8)) & mask;
-      output[27 + outputOffset] = (intValue10 >>> 4) & mask;
-      output[28 + outputOffset] = (intValue10 >>> 16) & mask;
-      output[29 + outputOffset] = ((intValue10 >>> 28) | (intValue11 << 4)) & mask;
-      output[30 + outputOffset] = (intValue11 >>> 8) & mask;
-      output[31 + outputOffset] = intValue11 >>> 20;
-      outputOffset += 32;
-    }
-  }
-  public static void decode13(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 13;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      int intValue5 = compressedBuffer.get();
-      int intValue6 = compressedBuffer.get();
-      int intValue7 = compressedBuffer.get();
-      int intValue8 = compressedBuffer.get();
-      int intValue9 = compressedBuffer.get();
-      int intValue10 = compressedBuffer.get();
-      int intValue11 = compressedBuffer.get();
-      int intValue12 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = (intValue0 >>> 13) & mask;
-      output[2 + outputOffset] = ((intValue0 >>> 26) | (intValue1 << 6)) & mask;
-      output[3 + outputOffset] = (intValue1 >>> 7) & mask;
-      output[4 + outputOffset] = ((intValue1 >>> 20) | (intValue2 << 12)) & mask;
-      output[5 + outputOffset] = (intValue2 >>> 1) & mask;
-      output[6 + outputOffset] = (intValue2 >>> 14) & mask;
-      output[7 + outputOffset] = ((intValue2 >>> 27) | (intValue3 << 5)) & mask;
-      output[8 + outputOffset] = (intValue3 >>> 8) & mask;
-      output[9 + outputOffset] = ((intValue3 >>> 21) | (intValue4 << 11)) & mask;
-      output[10 + outputOffset] = (intValue4 >>> 2) & mask;
-      output[11 + outputOffset] = (intValue4 >>> 15) & mask;
-      output[12 + outputOffset] = ((intValue4 >>> 28) | (intValue5 << 4)) & mask;
-      output[13 + outputOffset] = (intValue5 >>> 9) & mask;
-      output[14 + outputOffset] = ((intValue5 >>> 22) | (intValue6 << 10)) & mask;
-      output[15 + outputOffset] = (intValue6 >>> 3) & mask;
-      output[16 + outputOffset] = (intValue6 >>> 16) & mask;
-      output[17 + outputOffset] = ((intValue6 >>> 29) | (intValue7 << 3)) & mask;
-      output[18 + outputOffset] = (intValue7 >>> 10) & mask;
-      output[19 + outputOffset] = ((intValue7 >>> 23) | (intValue8 << 9)) & mask;
-      output[20 + outputOffset] = (intValue8 >>> 4) & mask;
-      output[21 + outputOffset] = (intValue8 >>> 17) & mask;
-      output[22 + outputOffset] = ((intValue8 >>> 30) | (intValue9 << 2)) & mask;
-      output[23 + outputOffset] = (intValue9 >>> 11) & mask;
-      output[24 + outputOffset] = ((intValue9 >>> 24) | (intValue10 << 8)) & mask;
-      output[25 + outputOffset] = (intValue10 >>> 5) & mask;
-      output[26 + outputOffset] = (intValue10 >>> 18) & mask;
-      output[27 + outputOffset] = ((intValue10 >>> 31) | (intValue11 << 1)) & mask;
-      output[28 + outputOffset] = (intValue11 >>> 12) & mask;
-      output[29 + outputOffset] = ((intValue11 >>> 25) | (intValue12 << 7)) & mask;
-      output[30 + outputOffset] = (intValue12 >>> 6) & mask;
-      output[31 + outputOffset] = intValue12 >>> 19;
-      outputOffset += 32;
-    }
-  }
-  public static void decode14(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 14;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      int intValue5 = compressedBuffer.get();
-      int intValue6 = compressedBuffer.get();
-      int intValue7 = compressedBuffer.get();
-      int intValue8 = compressedBuffer.get();
-      int intValue9 = compressedBuffer.get();
-      int intValue10 = compressedBuffer.get();
-      int intValue11 = compressedBuffer.get();
-      int intValue12 = compressedBuffer.get();
-      int intValue13 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = (intValue0 >>> 14) & mask;
-      output[2 + outputOffset] = ((intValue0 >>> 28) | (intValue1 << 4)) & mask;
-      output[3 + outputOffset] = (intValue1 >>> 10) & mask;
-      output[4 + outputOffset] = ((intValue1 >>> 24) | (intValue2 << 8)) & mask;
-      output[5 + outputOffset] = (intValue2 >>> 6) & mask;
-      output[6 + outputOffset] = ((intValue2 >>> 20) | (intValue3 << 12)) & mask;
-      output[7 + outputOffset] = (intValue3 >>> 2) & mask;
-      output[8 + outputOffset] = (intValue3 >>> 16) & mask;
-      output[9 + outputOffset] = ((intValue3 >>> 30) | (intValue4 << 2)) & mask;
-      output[10 + outputOffset] = (intValue4 >>> 12) & mask;
-      output[11 + outputOffset] = ((intValue4 >>> 26) | (intValue5 << 6)) & mask;
-      output[12 + outputOffset] = (intValue5 >>> 8) & mask;
-      output[13 + outputOffset] = ((intValue5 >>> 22) | (intValue6 << 10)) & mask;
-      output[14 + outputOffset] = (intValue6 >>> 4) & mask;
-      output[15 + outputOffset] = intValue6 >>> 18;
-      output[16 + outputOffset] = intValue7 & mask;
-      output[17 + outputOffset] = (intValue7 >>> 14) & mask;
-      output[18 + outputOffset] = ((intValue7 >>> 28) | (intValue8 << 4)) & mask;
-      output[19 + outputOffset] = (intValue8 >>> 10) & mask;
-      output[20 + outputOffset] = ((intValue8 >>> 24) | (intValue9 << 8)) & mask;
-      output[21 + outputOffset] = (intValue9 >>> 6) & mask;
-      output[22 + outputOffset] = ((intValue9 >>> 20) | (intValue10 << 12)) & mask;
-      output[23 + outputOffset] = (intValue10 >>> 2) & mask;
-      output[24 + outputOffset] = (intValue10 >>> 16) & mask;
-      output[25 + outputOffset] = ((intValue10 >>> 30) | (intValue11 << 2)) & mask;
-      output[26 + outputOffset] = (intValue11 >>> 12) & mask;
-      output[27 + outputOffset] = ((intValue11 >>> 26) | (intValue12 << 6)) & mask;
-      output[28 + outputOffset] = (intValue12 >>> 8) & mask;
-      output[29 + outputOffset] = ((intValue12 >>> 22) | (intValue13 << 10)) & mask;
-      output[30 + outputOffset] = (intValue13 >>> 4) & mask;
-      output[31 + outputOffset] = intValue13 >>> 18;
-      outputOffset += 32;
-    }
-  }
-  public static void decode15(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 15;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      int intValue5 = compressedBuffer.get();
-      int intValue6 = compressedBuffer.get();
-      int intValue7 = compressedBuffer.get();
-      int intValue8 = compressedBuffer.get();
-      int intValue9 = compressedBuffer.get();
-      int intValue10 = compressedBuffer.get();
-      int intValue11 = compressedBuffer.get();
-      int intValue12 = compressedBuffer.get();
-      int intValue13 = compressedBuffer.get();
-      int intValue14 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = (intValue0 >>> 15) & mask;
-      output[2 + outputOffset] = ((intValue0 >>> 30) | (intValue1 << 2)) & mask;
-      output[3 + outputOffset] = (intValue1 >>> 13) & mask;
-      output[4 + outputOffset] = ((intValue1 >>> 28) | (intValue2 << 4)) & mask;
-      output[5 + outputOffset] = (intValue2 >>> 11) & mask;
-      output[6 + outputOffset] = ((intValue2 >>> 26) | (intValue3 << 6)) & mask;
-      output[7 + outputOffset] = (intValue3 >>> 9) & mask;
-      output[8 + outputOffset] = ((intValue3 >>> 24) | (intValue4 << 8)) & mask;
-      output[9 + outputOffset] = (intValue4 >>> 7) & mask;
-      output[10 + outputOffset] = ((intValue4 >>> 22) | (intValue5 << 10)) & mask;
-      output[11 + outputOffset] = (intValue5 >>> 5) & mask;
-      output[12 + outputOffset] = ((intValue5 >>> 20) | (intValue6 << 12)) & mask;
-      output[13 + outputOffset] = (intValue6 >>> 3) & mask;
-      output[14 + outputOffset] = ((intValue6 >>> 18) | (intValue7 << 14)) & mask;
-      output[15 + outputOffset] = (intValue7 >>> 1) & mask;
-      output[16 + outputOffset] = (intValue7 >>> 16) & mask;
-      output[17 + outputOffset] = ((intValue7 >>> 31) | (intValue8 << 1)) & mask;
-      output[18 + outputOffset] = (intValue8 >>> 14) & mask;
-      output[19 + outputOffset] = ((intValue8 >>> 29) | (intValue9 << 3)) & mask;
-      output[20 + outputOffset] = (intValue9 >>> 12) & mask;
-      output[21 + outputOffset] = ((intValue9 >>> 27) | (intValue10 << 5)) & mask;
-      output[22 + outputOffset] = (intValue10 >>> 10) & mask;
-      output[23 + outputOffset] = ((intValue10 >>> 25) | (intValue11 << 7)) & mask;
-      output[24 + outputOffset] = (intValue11 >>> 8) & mask;
-      output[25 + outputOffset] = ((intValue11 >>> 23) | (intValue12 << 9)) & mask;
-      output[26 + outputOffset] = (intValue12 >>> 6) & mask;
-      output[27 + outputOffset] = ((intValue12 >>> 21) | (intValue13 << 11)) & mask;
-      output[28 + outputOffset] = (intValue13 >>> 4) & mask;
-      output[29 + outputOffset] = ((intValue13 >>> 19) | (intValue14 << 13)) & mask;
-      output[30 + outputOffset] = (intValue14 >>> 2) & mask;
-      output[31 + outputOffset] = intValue14 >>> 17;
-      outputOffset += 32;
-    }
-  }
-  public static void decode16(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 16;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      int intValue5 = compressedBuffer.get();
-      int intValue6 = compressedBuffer.get();
-      int intValue7 = compressedBuffer.get();
-      int intValue8 = compressedBuffer.get();
-      int intValue9 = compressedBuffer.get();
-      int intValue10 = compressedBuffer.get();
-      int intValue11 = compressedBuffer.get();
-      int intValue12 = compressedBuffer.get();
-      int intValue13 = compressedBuffer.get();
-      int intValue14 = compressedBuffer.get();
-      int intValue15 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = intValue0 >>> 16;
-      output[2 + outputOffset] = intValue1 & mask;
-      output[3 + outputOffset] = intValue1 >>> 16;
-      output[4 + outputOffset] = intValue2 & mask;
-      output[5 + outputOffset] = intValue2 >>> 16;
-      output[6 + outputOffset] = intValue3 & mask;
-      output[7 + outputOffset] = intValue3 >>> 16;
-      output[8 + outputOffset] = intValue4 & mask;
-      output[9 + outputOffset] = intValue4 >>> 16;
-      output[10 + outputOffset] = intValue5 & mask;
-      output[11 + outputOffset] = intValue5 >>> 16;
-      output[12 + outputOffset] = intValue6 & mask;
-      output[13 + outputOffset] = intValue6 >>> 16;
-      output[14 + outputOffset] = intValue7 & mask;
-      output[15 + outputOffset] = intValue7 >>> 16;
-      output[16 + outputOffset] = intValue8 & mask;
-      output[17 + outputOffset] = intValue8 >>> 16;
-      output[18 + outputOffset] = intValue9 & mask;
-      output[19 + outputOffset] = intValue9 >>> 16;
-      output[20 + outputOffset] = intValue10 & mask;
-      output[21 + outputOffset] = intValue10 >>> 16;
-      output[22 + outputOffset] = intValue11 & mask;
-      output[23 + outputOffset] = intValue11 >>> 16;
-      output[24 + outputOffset] = intValue12 & mask;
-      output[25 + outputOffset] = intValue12 >>> 16;
-      output[26 + outputOffset] = intValue13 & mask;
-      output[27 + outputOffset] = intValue13 >>> 16;
-      output[28 + outputOffset] = intValue14 & mask;
-      output[29 + outputOffset] = intValue14 >>> 16;
-      output[30 + outputOffset] = intValue15 & mask;
-      output[31 + outputOffset] = intValue15 >>> 16;
-      outputOffset += 32;
-    }
-  }
-  public static void decode17(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 17;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      int intValue5 = compressedBuffer.get();
-      int intValue6 = compressedBuffer.get();
-      int intValue7 = compressedBuffer.get();
-      int intValue8 = compressedBuffer.get();
-      int intValue9 = compressedBuffer.get();
-      int intValue10 = compressedBuffer.get();
-      int intValue11 = compressedBuffer.get();
-      int intValue12 = compressedBuffer.get();
-      int intValue13 = compressedBuffer.get();
-      int intValue14 = compressedBuffer.get();
-      int intValue15 = compressedBuffer.get();
-      int intValue16 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = ((intValue0 >>> 17) | (intValue1 << 15)) & mask;
-      output[2 + outputOffset] = (intValue1 >>> 2) & mask;
-      output[3 + outputOffset] = ((intValue1 >>> 19) | (intValue2 << 13)) & mask;
-      output[4 + outputOffset] = (intValue2 >>> 4) & mask;
-      output[5 + outputOffset] = ((intValue2 >>> 21) | (intValue3 << 11)) & mask;
-      output[6 + outputOffset] = (intValue3 >>> 6) & mask;
-      output[7 + outputOffset] = ((intValue3 >>> 23) | (intValue4 << 9)) & mask;
-      output[8 + outputOffset] = (intValue4 >>> 8) & mask;
-      output[9 + outputOffset] = ((intValue4 >>> 25) | (intValue5 << 7)) & mask;
-      output[10 + outputOffset] = (intValue5 >>> 10) & mask;
-      output[11 + outputOffset] = ((intValue5 >>> 27) | (intValue6 << 5)) & mask;
-      output[12 + outputOffset] = (intValue6 >>> 12) & mask;
-      output[13 + outputOffset] = ((intValue6 >>> 29) | (intValue7 << 3)) & mask;
-      output[14 + outputOffset] = (intValue7 >>> 14) & mask;
-      output[15 + outputOffset] = ((intValue7 >>> 31) | (intValue8 << 1)) & mask;
-      output[16 + outputOffset] = ((intValue8 >>> 16) | (intValue9 << 16)) & mask;
-      output[17 + outputOffset] = (intValue9 >>> 1) & mask;
-      output[18 + outputOffset] = ((intValue9 >>> 18) | (intValue10 << 14)) & mask;
-      output[19 + outputOffset] = (intValue10 >>> 3) & mask;
-      output[20 + outputOffset] = ((intValue10 >>> 20) | (intValue11 << 12)) & mask;
-      output[21 + outputOffset] = (intValue11 >>> 5) & mask;
-      output[22 + outputOffset] = ((intValue11 >>> 22) | (intValue12 << 10)) & mask;
-      output[23 + outputOffset] = (intValue12 >>> 7) & mask;
-      output[24 + outputOffset] = ((intValue12 >>> 24) | (intValue13 << 8)) & mask;
-      output[25 + outputOffset] = (intValue13 >>> 9) & mask;
-      output[26 + outputOffset] = ((intValue13 >>> 26) | (intValue14 << 6)) & mask;
-      output[27 + outputOffset] = (intValue14 >>> 11) & mask;
-      output[28 + outputOffset] = ((intValue14 >>> 28) | (intValue15 << 4)) & mask;
-      output[29 + outputOffset] = (intValue15 >>> 13) & mask;
-      output[30 + outputOffset] = ((intValue15 >>> 30) | (intValue16 << 2)) & mask;
-      output[31 + outputOffset] = intValue16 >>> 15;
-      outputOffset += 32;
-    }
-  }
-  public static void decode18(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 18;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      int intValue5 = compressedBuffer.get();
-      int intValue6 = compressedBuffer.get();
-      int intValue7 = compressedBuffer.get();
-      int intValue8 = compressedBuffer.get();
-      int intValue9 = compressedBuffer.get();
-      int intValue10 = compressedBuffer.get();
-      int intValue11 = compressedBuffer.get();
-      int intValue12 = compressedBuffer.get();
-      int intValue13 = compressedBuffer.get();
-      int intValue14 = compressedBuffer.get();
-      int intValue15 = compressedBuffer.get();
-      int intValue16 = compressedBuffer.get();
-      int intValue17 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = ((intValue0 >>> 18) | (intValue1 << 14)) & mask;
-      output[2 + outputOffset] = (intValue1 >>> 4) & mask;
-      output[3 + outputOffset] = ((intValue1 >>> 22) | (intValue2 << 10)) & mask;
-      output[4 + outputOffset] = (intValue2 >>> 8) & mask;
-      output[5 + outputOffset] = ((intValue2 >>> 26) | (intValue3 << 6)) & mask;
-      output[6 + outputOffset] = (intValue3 >>> 12) & mask;
-      output[7 + outputOffset] = ((intValue3 >>> 30) | (intValue4 << 2)) & mask;
-      output[8 + outputOffset] = ((intValue4 >>> 16) | (intValue5 << 16)) & mask;
-      output[9 + outputOffset] = (intValue5 >>> 2) & mask;
-      output[10 + outputOffset] = ((intValue5 >>> 20) | (intValue6 << 12)) & mask;
-      output[11 + outputOffset] = (intValue6 >>> 6) & mask;
-      output[12 + outputOffset] = ((intValue6 >>> 24) | (intValue7 << 8)) & mask;
-      output[13 + outputOffset] = (intValue7 >>> 10) & mask;
-      output[14 + outputOffset] = ((intValue7 >>> 28) | (intValue8 << 4)) & mask;
-      output[15 + outputOffset] = intValue8 >>> 14;
-      output[16 + outputOffset] = intValue9 & mask;
-      output[17 + outputOffset] = ((intValue9 >>> 18) | (intValue10 << 14)) & mask;
-      output[18 + outputOffset] = (intValue10 >>> 4) & mask;
-      output[19 + outputOffset] = ((intValue10 >>> 22) | (intValue11 << 10)) & mask;
-      output[20 + outputOffset] = (intValue11 >>> 8) & mask;
-      output[21 + outputOffset] = ((intValue11 >>> 26) | (intValue12 << 6)) & mask;
-      output[22 + outputOffset] = (intValue12 >>> 12) & mask;
-      output[23 + outputOffset] = ((intValue12 >>> 30) | (intValue13 << 2)) & mask;
-      output[24 + outputOffset] = ((intValue13 >>> 16) | (intValue14 << 16)) & mask;
-      output[25 + outputOffset] = (intValue14 >>> 2) & mask;
-      output[26 + outputOffset] = ((intValue14 >>> 20) | (intValue15 << 12)) & mask;
-      output[27 + outputOffset] = (intValue15 >>> 6) & mask;
-      output[28 + outputOffset] = ((intValue15 >>> 24) | (intValue16 << 8)) & mask;
-      output[29 + outputOffset] = (intValue16 >>> 10) & mask;
-      output[30 + outputOffset] = ((intValue16 >>> 28) | (intValue17 << 4)) & mask;
-      output[31 + outputOffset] = intValue17 >>> 14;
-      outputOffset += 32;
-    }
-  }
-  public static void decode19(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 19;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      int intValue5 = compressedBuffer.get();
-      int intValue6 = compressedBuffer.get();
-      int intValue7 = compressedBuffer.get();
-      int intValue8 = compressedBuffer.get();
-      int intValue9 = compressedBuffer.get();
-      int intValue10 = compressedBuffer.get();
-      int intValue11 = compressedBuffer.get();
-      int intValue12 = compressedBuffer.get();
-      int intValue13 = compressedBuffer.get();
-      int intValue14 = compressedBuffer.get();
-      int intValue15 = compressedBuffer.get();
-      int intValue16 = compressedBuffer.get();
-      int intValue17 = compressedBuffer.get();
-      int intValue18 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = ((intValue0 >>> 19) | (intValue1 << 13)) & mask;
-      output[2 + outputOffset] = (intValue1 >>> 6) & mask;
-      output[3 + outputOffset] = ((intValue1 >>> 25) | (intValue2 << 7)) & mask;
-      output[4 + outputOffset] = (intValue2 >>> 12) & mask;
-      output[5 + outputOffset] = ((intValue2 >>> 31) | (intValue3 << 1)) & mask;
-      output[6 + outputOffset] = ((intValue3 >>> 18) | (intValue4 << 14)) & mask;
-      output[7 + outputOffset] = (intValue4 >>> 5) & mask;
-      output[8 + outputOffset] = ((intValue4 >>> 24) | (intValue5 << 8)) & mask;
-      output[9 + outputOffset] = (intValue5 >>> 11) & mask;
-      output[10 + outputOffset] = ((intValue5 >>> 30) | (intValue6 << 2)) & mask;
-      output[11 + outputOffset] = ((intValue6 >>> 17) | (intValue7 << 15)) & mask;
-      output[12 + outputOffset] = (intValue7 >>> 4) & mask;
-      output[13 + outputOffset] = ((intValue7 >>> 23) | (intValue8 << 9)) & mask;
-      output[14 + outputOffset] = (intValue8 >>> 10) & mask;
-      output[15 + outputOffset] = ((intValue8 >>> 29) | (intValue9 << 3)) & mask;
-      output[16 + outputOffset] = ((intValue9 >>> 16) | (intValue10 << 16)) & mask;
-      output[17 + outputOffset] = (intValue10 >>> 3) & mask;
-      output[18 + outputOffset] = ((intValue10 >>> 22) | (intValue11 << 10)) & mask;
-      output[19 + outputOffset] = (intValue11 >>> 9) & mask;
-      output[20 + outputOffset] = ((intValue11 >>> 28) | (intValue12 << 4)) & mask;
-      output[21 + outputOffset] = ((intValue12 >>> 15) | (intValue13 << 17)) & mask;
-      output[22 + outputOffset] = (intValue13 >>> 2) & mask;
-      output[23 + outputOffset] = ((intValue13 >>> 21) | (intValue14 << 11)) & mask;
-      output[24 + outputOffset] = (intValue14 >>> 8) & mask;
-      output[25 + outputOffset] = ((intValue14 >>> 27) | (intValue15 << 5)) & mask;
-      output[26 + outputOffset] = ((intValue15 >>> 14) | (intValue16 << 18)) & mask;
-      output[27 + outputOffset] = (intValue16 >>> 1) & mask;
-      output[28 + outputOffset] = ((intValue16 >>> 20) | (intValue17 << 12)) & mask;
-      output[29 + outputOffset] = (intValue17 >>> 7) & mask;
-      output[30 + outputOffset] = ((intValue17 >>> 26) | (intValue18 << 6)) & mask;
-      output[31 + outputOffset] = intValue18 >>> 13;
-      outputOffset += 32;
-    }
-  }
-  public static void decode20(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 20;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      int intValue5 = compressedBuffer.get();
-      int intValue6 = compressedBuffer.get();
-      int intValue7 = compressedBuffer.get();
-      int intValue8 = compressedBuffer.get();
-      int intValue9 = compressedBuffer.get();
-      int intValue10 = compressedBuffer.get();
-      int intValue11 = compressedBuffer.get();
-      int intValue12 = compressedBuffer.get();
-      int intValue13 = compressedBuffer.get();
-      int intValue14 = compressedBuffer.get();
-      int intValue15 = compressedBuffer.get();
-      int intValue16 = compressedBuffer.get();
-      int intValue17 = compressedBuffer.get();
-      int intValue18 = compressedBuffer.get();
-      int intValue19 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = ((intValue0 >>> 20) | (intValue1 << 12)) & mask;
-      output[2 + outputOffset] = (intValue1 >>> 8) & mask;
-      output[3 + outputOffset] = ((intValue1 >>> 28) | (intValue2 << 4)) & mask;
-      output[4 + outputOffset] = ((intValue2 >>> 16) | (intValue3 << 16)) & mask;
-      output[5 + outputOffset] = (intValue3 >>> 4) & mask;
-      output[6 + outputOffset] = ((intValue3 >>> 24) | (intValue4 << 8)) & mask;
-      output[7 + outputOffset] = intValue4 >>> 12;
-      output[8 + outputOffset] = intValue5 & mask;
-      output[9 + outputOffset] = ((intValue5 >>> 20) | (intValue6 << 12)) & mask;
-      output[10 + outputOffset] = (intValue6 >>> 8) & mask;
-      output[11 + outputOffset] = ((intValue6 >>> 28) | (intValue7 << 4)) & mask;
-      output[12 + outputOffset] = ((intValue7 >>> 16) | (intValue8 << 16)) & mask;
-      output[13 + outputOffset] = (intValue8 >>> 4) & mask;
-      output[14 + outputOffset] = ((intValue8 >>> 24) | (intValue9 << 8)) & mask;
-      output[15 + outputOffset] = intValue9 >>> 12;
-      output[16 + outputOffset] = intValue10 & mask;
-      output[17 + outputOffset] = ((intValue10 >>> 20) | (intValue11 << 12)) & mask;
-      output[18 + outputOffset] = (intValue11 >>> 8) & mask;
-      output[19 + outputOffset] = ((intValue11 >>> 28) | (intValue12 << 4)) & mask;
-      output[20 + outputOffset] = ((intValue12 >>> 16) | (intValue13 << 16)) & mask;
-      output[21 + outputOffset] = (intValue13 >>> 4) & mask;
-      output[22 + outputOffset] = ((intValue13 >>> 24) | (intValue14 << 8)) & mask;
-      output[23 + outputOffset] = intValue14 >>> 12;
-      output[24 + outputOffset] = intValue15 & mask;
-      output[25 + outputOffset] = ((intValue15 >>> 20) | (intValue16 << 12)) & mask;
-      output[26 + outputOffset] = (intValue16 >>> 8) & mask;
-      output[27 + outputOffset] = ((intValue16 >>> 28) | (intValue17 << 4)) & mask;
-      output[28 + outputOffset] = ((intValue17 >>> 16) | (intValue18 << 16)) & mask;
-      output[29 + outputOffset] = (intValue18 >>> 4) & mask;
-      output[30 + outputOffset] = ((intValue18 >>> 24) | (intValue19 << 8)) & mask;
-      output[31 + outputOffset] = intValue19 >>> 12;
-      outputOffset += 32;
-    }
-  }
-  public static void decode21(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 21;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      int intValue5 = compressedBuffer.get();
-      int intValue6 = compressedBuffer.get();
-      int intValue7 = compressedBuffer.get();
-      int intValue8 = compressedBuffer.get();
-      int intValue9 = compressedBuffer.get();
-      int intValue10 = compressedBuffer.get();
-      int intValue11 = compressedBuffer.get();
-      int intValue12 = compressedBuffer.get();
-      int intValue13 = compressedBuffer.get();
-      int intValue14 = compressedBuffer.get();
-      int intValue15 = compressedBuffer.get();
-      int intValue16 = compressedBuffer.get();
-      int intValue17 = compressedBuffer.get();
-      int intValue18 = compressedBuffer.get();
-      int intValue19 = compressedBuffer.get();
-      int intValue20 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = ((intValue0 >>> 21) | (intValue1 << 11)) & mask;
-      output[2 + outputOffset] = (intValue1 >>> 10) & mask;
-      output[3 + outputOffset] = ((intValue1 >>> 31) | (intValue2 << 1)) & mask;
-      output[4 + outputOffset] = ((intValue2 >>> 20) | (intValue3 << 12)) & mask;
-      output[5 + outputOffset] = (intValue3 >>> 9) & mask;
-      output[6 + outputOffset] = ((intValue3 >>> 30) | (intValue4 << 2)) & mask;
-      output[7 + outputOffset] = ((intValue4 >>> 19) | (intValue5 << 13)) & mask;
-      output[8 + outputOffset] = (intValue5 >>> 8) & mask;
-      output[9 + outputOffset] = ((intValue5 >>> 29) | (intValue6 << 3)) & mask;
-      output[10 + outputOffset] = ((intValue6 >>> 18) | (intValue7 << 14)) & mask;
-      output[11 + outputOffset] = (intValue7 >>> 7) & mask;
-      output[12 + outputOffset] = ((intValue7 >>> 28) | (intValue8 << 4)) & mask;
-      output[13 + outputOffset] = ((intValue8 >>> 17) | (intValue9 << 15)) & mask;
-      output[14 + outputOffset] = (intValue9 >>> 6) & mask;
-      output[15 + outputOffset] = ((intValue9 >>> 27) | (intValue10 << 5)) & mask;
-      output[16 + outputOffset] = ((intValue10 >>> 16) | (intValue11 << 16)) & mask;
-      output[17 + outputOffset] = (intValue11 >>> 5) & mask;
-      output[18 + outputOffset] = ((intValue11 >>> 26) | (intValue12 << 6)) & mask;
-      output[19 + outputOffset] = ((intValue12 >>> 15) | (intValue13 << 17)) & mask;
-      output[20 + outputOffset] = (intValue13 >>> 4) & mask;
-      output[21 + outputOffset] = ((intValue13 >>> 25) | (intValue14 << 7)) & mask;
-      output[22 + outputOffset] = ((intValue14 >>> 14) | (intValue15 << 18)) & mask;
-      output[23 + outputOffset] = (intValue15 >>> 3) & mask;
-      output[24 + outputOffset] = ((intValue15 >>> 24) | (intValue16 << 8)) & mask;
-      output[25 + outputOffset] = ((intValue16 >>> 13) | (intValue17 << 19)) & mask;
-      output[26 + outputOffset] = (intValue17 >>> 2) & mask;
-      output[27 + outputOffset] = ((intValue17 >>> 23) | (intValue18 << 9)) & mask;
-      output[28 + outputOffset] = ((intValue18 >>> 12) | (intValue19 << 20)) & mask;
-      output[29 + outputOffset] = (intValue19 >>> 1) & mask;
-      output[30 + outputOffset] = ((intValue19 >>> 22) | (intValue20 << 10)) & mask;
-      output[31 + outputOffset] = intValue20 >>> 11;
-      outputOffset += 32;
-    }
-  }
-  public static void decode22(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 22;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      int intValue5 = compressedBuffer.get();
-      int intValue6 = compressedBuffer.get();
-      int intValue7 = compressedBuffer.get();
-      int intValue8 = compressedBuffer.get();
-      int intValue9 = compressedBuffer.get();
-      int intValue10 = compressedBuffer.get();
-      int intValue11 = compressedBuffer.get();
-      int intValue12 = compressedBuffer.get();
-      int intValue13 = compressedBuffer.get();
-      int intValue14 = compressedBuffer.get();
-      int intValue15 = compressedBuffer.get();
-      int intValue16 = compressedBuffer.get();
-      int intValue17 = compressedBuffer.get();
-      int intValue18 = compressedBuffer.get();
-      int intValue19 = compressedBuffer.get();
-      int intValue20 = compressedBuffer.get();
-      int intValue21 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = ((intValue0 >>> 22) | (intValue1 << 10)) & mask;
-      output[2 + outputOffset] = ((intValue1 >>> 12) | (intValue2 << 20)) & mask;
-      output[3 + outputOffset] = (intValue2 >>> 2) & mask;
-      output[4 + outputOffset] = ((intValue2 >>> 24) | (intValue3 << 8)) & mask;
-      output[5 + outputOffset] = ((intValue3 >>> 14) | (intValue4 << 18)) & mask;
-      output[6 + outputOffset] = (intValue4 >>> 4) & mask;
-      output[7 + outputOffset] = ((intValue4 >>> 26) | (intValue5 << 6)) & mask;
-      output[8 + outputOffset] = ((intValue5 >>> 16) | (intValue6 << 16)) & mask;
-      output[9 + outputOffset] = (intValue6 >>> 6) & mask;
-      output[10 + outputOffset] = ((intValue6 >>> 28) | (intValue7 << 4)) & mask;
-      output[11 + outputOffset] = ((intValue7 >>> 18) | (intValue8 << 14)) & mask;
-      output[12 + outputOffset] = (intValue8 >>> 8) & mask;
-      output[13 + outputOffset] = ((intValue8 >>> 30) | (intValue9 << 2)) & mask;
-      output[14 + outputOffset] = ((intValue9 >>> 20) | (intValue10 << 12)) & mask;
-      output[15 + outputOffset] = intValue10 >>> 10;
-      output[16 + outputOffset] = intValue11 & mask;
-      output[17 + outputOffset] = ((intValue11 >>> 22) | (intValue12 << 10)) & mask;
-      output[18 + outputOffset] = ((intValue12 >>> 12) | (intValue13 << 20)) & mask;
-      output[19 + outputOffset] = (intValue13 >>> 2) & mask;
-      output[20 + outputOffset] = ((intValue13 >>> 24) | (intValue14 << 8)) & mask;
-      output[21 + outputOffset] = ((intValue14 >>> 14) | (intValue15 << 18)) & mask;
-      output[22 + outputOffset] = (intValue15 >>> 4) & mask;
-      output[23 + outputOffset] = ((intValue15 >>> 26) | (intValue16 << 6)) & mask;
-      output[24 + outputOffset] = ((intValue16 >>> 16) | (intValue17 << 16)) & mask;
-      output[25 + outputOffset] = (intValue17 >>> 6) & mask;
-      output[26 + outputOffset] = ((intValue17 >>> 28) | (intValue18 << 4)) & mask;
-      output[27 + outputOffset] = ((intValue18 >>> 18) | (intValue19 << 14)) & mask;
-      output[28 + outputOffset] = (intValue19 >>> 8) & mask;
-      output[29 + outputOffset] = ((intValue19 >>> 30) | (intValue20 << 2)) & mask;
-      output[30 + outputOffset] = ((intValue20 >>> 20) | (intValue21 << 12)) & mask;
-      output[31 + outputOffset] = intValue21 >>> 10;
-      outputOffset += 32;
-    }
-  }
-  public static void decode23(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 23;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      int intValue5 = compressedBuffer.get();
-      int intValue6 = compressedBuffer.get();
-      int intValue7 = compressedBuffer.get();
-      int intValue8 = compressedBuffer.get();
-      int intValue9 = compressedBuffer.get();
-      int intValue10 = compressedBuffer.get();
-      int intValue11 = compressedBuffer.get();
-      int intValue12 = compressedBuffer.get();
-      int intValue13 = compressedBuffer.get();
-      int intValue14 = compressedBuffer.get();
-      int intValue15 = compressedBuffer.get();
-      int intValue16 = compressedBuffer.get();
-      int intValue17 = compressedBuffer.get();
-      int intValue18 = compressedBuffer.get();
-      int intValue19 = compressedBuffer.get();
-      int intValue20 = compressedBuffer.get();
-      int intValue21 = compressedBuffer.get();
-      int intValue22 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = ((intValue0 >>> 23) | (intValue1 << 9)) & mask;
-      output[2 + outputOffset] = ((intValue1 >>> 14) | (intValue2 << 18)) & mask;
-      output[3 + outputOffset] = (intValue2 >>> 5) & mask;
-      output[4 + outputOffset] = ((intValue2 >>> 28) | (intValue3 << 4)) & mask;
-      output[5 + outputOffset] = ((intValue3 >>> 19) | (intValue4 << 13)) & mask;
-      output[6 + outputOffset] = ((intValue4 >>> 10) | (intValue5 << 22)) & mask;
-      output[7 + outputOffset] = (intValue5 >>> 1) & mask;
-      output[8 + outputOffset] = ((intValue5 >>> 24) | (intValue6 << 8)) & mask;
-      output[9 + outputOffset] = ((intValue6 >>> 15) | (intValue7 << 17)) & mask;
-      output[10 + outputOffset] = (intValue7 >>> 6) & mask;
-      output[11 + outputOffset] = ((intValue7 >>> 29) | (intValue8 << 3)) & mask;
-      output[12 + outputOffset] = ((intValue8 >>> 20) | (intValue9 << 12)) & mask;
-      output[13 + outputOffset] = ((intValue9 >>> 11) | (intValue10 << 21)) & mask;
-      output[14 + outputOffset] = (intValue10 >>> 2) & mask;
-      output[15 + outputOffset] = ((intValue10 >>> 25) | (intValue11 << 7)) & mask;
-      output[16 + outputOffset] = ((intValue11 >>> 16) | (intValue12 << 16)) & mask;
-      output[17 + outputOffset] = (intValue12 >>> 7) & mask;
-      output[18 + outputOffset] = ((intValue12 >>> 30) | (intValue13 << 2)) & mask;
-      output[19 + outputOffset] = ((intValue13 >>> 21) | (intValue14 << 11)) & mask;
-      output[20 + outputOffset] = ((intValue14 >>> 12) | (intValue15 << 20)) & mask;
-      output[21 + outputOffset] = (intValue15 >>> 3) & mask;
-      output[22 + outputOffset] = ((intValue15 >>> 26) | (intValue16 << 6)) & mask;
-      output[23 + outputOffset] = ((intValue16 >>> 17) | (intValue17 << 15)) & mask;
-      output[24 + outputOffset] = (intValue17 >>> 8) & mask;
-      output[25 + outputOffset] = ((intValue17 >>> 31) | (intValue18 << 1)) & mask;
-      output[26 + outputOffset] = ((intValue18 >>> 22) | (intValue19 << 10)) & mask;
-      output[27 + outputOffset] = ((intValue19 >>> 13) | (intValue20 << 19)) & mask;
-      output[28 + outputOffset] = (intValue20 >>> 4) & mask;
-      output[29 + outputOffset] = ((intValue20 >>> 27) | (intValue21 << 5)) & mask;
-      output[30 + outputOffset] = ((intValue21 >>> 18) | (intValue22 << 14)) & mask;
-      output[31 + outputOffset] = intValue22 >>> 9;
-      outputOffset += 32;
-    }
-  }
-  public static void decode24(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 24;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      int intValue5 = compressedBuffer.get();
-      int intValue6 = compressedBuffer.get();
-      int intValue7 = compressedBuffer.get();
-      int intValue8 = compressedBuffer.get();
-      int intValue9 = compressedBuffer.get();
-      int intValue10 = compressedBuffer.get();
-      int intValue11 = compressedBuffer.get();
-      int intValue12 = compressedBuffer.get();
-      int intValue13 = compressedBuffer.get();
-      int intValue14 = compressedBuffer.get();
-      int intValue15 = compressedBuffer.get();
-      int intValue16 = compressedBuffer.get();
-      int intValue17 = compressedBuffer.get();
-      int intValue18 = compressedBuffer.get();
-      int intValue19 = compressedBuffer.get();
-      int intValue20 = compressedBuffer.get();
-      int intValue21 = compressedBuffer.get();
-      int intValue22 = compressedBuffer.get();
-      int intValue23 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = ((intValue0 >>> 24) | (intValue1 << 8)) & mask;
-      output[2 + outputOffset] = ((intValue1 >>> 16) | (intValue2 << 16)) & mask;
-      output[3 + outputOffset] = intValue2 >>> 8;
-      output[4 + outputOffset] = intValue3 & mask;
-      output[5 + outputOffset] = ((intValue3 >>> 24) | (intValue4 << 8)) & mask;
-      output[6 + outputOffset] = ((intValue4 >>> 16) | (intValue5 << 16)) & mask;
-      output[7 + outputOffset] = intValue5 >>> 8;
-      output[8 + outputOffset] = intValue6 & mask;
-      output[9 + outputOffset] = ((intValue6 >>> 24) | (intValue7 << 8)) & mask;
-      output[10 + outputOffset] = ((intValue7 >>> 16) | (intValue8 << 16)) & mask;
-      output[11 + outputOffset] = intValue8 >>> 8;
-      output[12 + outputOffset] = intValue9 & mask;
-      output[13 + outputOffset] = ((intValue9 >>> 24) | (intValue10 << 8)) & mask;
-      output[14 + outputOffset] = ((intValue10 >>> 16) | (intValue11 << 16)) & mask;
-      output[15 + outputOffset] = intValue11 >>> 8;
-      output[16 + outputOffset] = intValue12 & mask;
-      output[17 + outputOffset] = ((intValue12 >>> 24) | (intValue13 << 8)) & mask;
-      output[18 + outputOffset] = ((intValue13 >>> 16) | (intValue14 << 16)) & mask;
-      output[19 + outputOffset] = intValue14 >>> 8;
-      output[20 + outputOffset] = intValue15 & mask;
-      output[21 + outputOffset] = ((intValue15 >>> 24) | (intValue16 << 8)) & mask;
-      output[22 + outputOffset] = ((intValue16 >>> 16) | (intValue17 << 16)) & mask;
-      output[23 + outputOffset] = intValue17 >>> 8;
-      output[24 + outputOffset] = intValue18 & mask;
-      output[25 + outputOffset] = ((intValue18 >>> 24) | (intValue19 << 8)) & mask;
-      output[26 + outputOffset] = ((intValue19 >>> 16) | (intValue20 << 16)) & mask;
-      output[27 + outputOffset] = intValue20 >>> 8;
-      output[28 + outputOffset] = intValue21 & mask;
-      output[29 + outputOffset] = ((intValue21 >>> 24) | (intValue22 << 8)) & mask;
-      output[30 + outputOffset] = ((intValue22 >>> 16) | (intValue23 << 16)) & mask;
-      output[31 + outputOffset] = intValue23 >>> 8;
-      outputOffset += 32;
-    }
-  }
-  public static void decode25(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 25;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      int intValue5 = compressedBuffer.get();
-      int intValue6 = compressedBuffer.get();
-      int intValue7 = compressedBuffer.get();
-      int intValue8 = compressedBuffer.get();
-      int intValue9 = compressedBuffer.get();
-      int intValue10 = compressedBuffer.get();
-      int intValue11 = compressedBuffer.get();
-      int intValue12 = compressedBuffer.get();
-      int intValue13 = compressedBuffer.get();
-      int intValue14 = compressedBuffer.get();
-      int intValue15 = compressedBuffer.get();
-      int intValue16 = compressedBuffer.get();
-      int intValue17 = compressedBuffer.get();
-      int intValue18 = compressedBuffer.get();
-      int intValue19 = compressedBuffer.get();
-      int intValue20 = compressedBuffer.get();
-      int intValue21 = compressedBuffer.get();
-      int intValue22 = compressedBuffer.get();
-      int intValue23 = compressedBuffer.get();
-      int intValue24 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = ((intValue0 >>> 25) | (intValue1 << 7)) & mask;
-      output[2 + outputOffset] = ((intValue1 >>> 18) | (intValue2 << 14)) & mask;
-      output[3 + outputOffset] = ((intValue2 >>> 11) | (intValue3 << 21)) & mask;
-      output[4 + outputOffset] = (intValue3 >>> 4) & mask;
-      output[5 + outputOffset] = ((intValue3 >>> 29) | (intValue4 << 3)) & mask;
-      output[6 + outputOffset] = ((intValue4 >>> 22) | (intValue5 << 10)) & mask;
-      output[7 + outputOffset] = ((intValue5 >>> 15) | (intValue6 << 17)) & mask;
-      output[8 + outputOffset] = ((intValue6 >>> 8) | (intValue7 << 24)) & mask;
-      output[9 + outputOffset] = (intValue7 >>> 1) & mask;
-      output[10 + outputOffset] = ((intValue7 >>> 26) | (intValue8 << 6)) & mask;
-      output[11 + outputOffset] = ((intValue8 >>> 19) | (intValue9 << 13)) & mask;
-      output[12 + outputOffset] = ((intValue9 >>> 12) | (intValue10 << 20)) & mask;
-      output[13 + outputOffset] = (intValue10 >>> 5) & mask;
-      output[14 + outputOffset] = ((intValue10 >>> 30) | (intValue11 << 2)) & mask;
-      output[15 + outputOffset] = ((intValue11 >>> 23) | (intValue12 << 9)) & mask;
-      output[16 + outputOffset] = ((intValue12 >>> 16) | (intValue13 << 16)) & mask;
-      output[17 + outputOffset] = ((intValue13 >>> 9) | (intValue14 << 23)) & mask;
-      output[18 + outputOffset] = (intValue14 >>> 2) & mask;
-      output[19 + outputOffset] = ((intValue14 >>> 27) | (intValue15 << 5)) & mask;
-      output[20 + outputOffset] = ((intValue15 >>> 20) | (intValue16 << 12)) & mask;
-      output[21 + outputOffset] = ((intValue16 >>> 13) | (intValue17 << 19)) & mask;
-      output[22 + outputOffset] = (intValue17 >>> 6) & mask;
-      output[23 + outputOffset] = ((intValue17 >>> 31) | (intValue18 << 1)) & mask;
-      output[24 + outputOffset] = ((intValue18 >>> 24) | (intValue19 << 8)) & mask;
-      output[25 + outputOffset] = ((intValue19 >>> 17) | (intValue20 << 15)) & mask;
-      output[26 + outputOffset] = ((intValue20 >>> 10) | (intValue21 << 22)) & mask;
-      output[27 + outputOffset] = (intValue21 >>> 3) & mask;
-      output[28 + outputOffset] = ((intValue21 >>> 28) | (intValue22 << 4)) & mask;
-      output[29 + outputOffset] = ((intValue22 >>> 21) | (intValue23 << 11)) & mask;
-      output[30 + outputOffset] = ((intValue23 >>> 14) | (intValue24 << 18)) & mask;
-      output[31 + outputOffset] = intValue24 >>> 7;
-      outputOffset += 32;
-    }
-  }
-  public static void decode26(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 26;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      int intValue5 = compressedBuffer.get();
-      int intValue6 = compressedBuffer.get();
-      int intValue7 = compressedBuffer.get();
-      int intValue8 = compressedBuffer.get();
-      int intValue9 = compressedBuffer.get();
-      int intValue10 = compressedBuffer.get();
-      int intValue11 = compressedBuffer.get();
-      int intValue12 = compressedBuffer.get();
-      int intValue13 = compressedBuffer.get();
-      int intValue14 = compressedBuffer.get();
-      int intValue15 = compressedBuffer.get();
-      int intValue16 = compressedBuffer.get();
-      int intValue17 = compressedBuffer.get();
-      int intValue18 = compressedBuffer.get();
-      int intValue19 = compressedBuffer.get();
-      int intValue20 = compressedBuffer.get();
-      int intValue21 = compressedBuffer.get();
-      int intValue22 = compressedBuffer.get();
-      int intValue23 = compressedBuffer.get();
-      int intValue24 = compressedBuffer.get();
-      int intValue25 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = ((intValue0 >>> 26) | (intValue1 << 6)) & mask;
-      output[2 + outputOffset] = ((intValue1 >>> 20) | (intValue2 << 12)) & mask;
-      output[3 + outputOffset] = ((intValue2 >>> 14) | (intValue3 << 18)) & mask;
-      output[4 + outputOffset] = ((intValue3 >>> 8) | (intValue4 << 24)) & mask;
-      output[5 + outputOffset] = (intValue4 >>> 2) & mask;
-      output[6 + outputOffset] = ((intValue4 >>> 28) | (intValue5 << 4)) & mask;
-      output[7 + outputOffset] = ((intValue5 >>> 22) | (intValue6 << 10)) & mask;
-      output[8 + outputOffset] = ((intValue6 >>> 16) | (intValue7 << 16)) & mask;
-      output[9 + outputOffset] = ((intValue7 >>> 10) | (intValue8 << 22)) & mask;
-      output[10 + outputOffset] = (intValue8 >>> 4) & mask;
-      output[11 + outputOffset] = ((intValue8 >>> 30) | (intValue9 << 2)) & mask;
-      output[12 + outputOffset] = ((intValue9 >>> 24) | (intValue10 << 8)) & mask;
-      output[13 + outputOffset] = ((intValue10 >>> 18) | (intValue11 << 14)) & mask;
-      output[14 + outputOffset] = ((intValue11 >>> 12) | (intValue12 << 20)) & mask;
-      output[15 + outputOffset] = intValue12 >>> 6;
-      output[16 + outputOffset] = intValue13 & mask;
-      output[17 + outputOffset] = ((intValue13 >>> 26) | (intValue14 << 6)) & mask;
-      output[18 + outputOffset] = ((intValue14 >>> 20) | (intValue15 << 12)) & mask;
-      output[19 + outputOffset] = ((intValue15 >>> 14) | (intValue16 << 18)) & mask;
-      output[20 + outputOffset] = ((intValue16 >>> 8) | (intValue17 << 24)) & mask;
-      output[21 + outputOffset] = (intValue17 >>> 2) & mask;
-      output[22 + outputOffset] = ((intValue17 >>> 28) | (intValue18 << 4)) & mask;
-      output[23 + outputOffset] = ((intValue18 >>> 22) | (intValue19 << 10)) & mask;
-      output[24 + outputOffset] = ((intValue19 >>> 16) | (intValue20 << 16)) & mask;
-      output[25 + outputOffset] = ((intValue20 >>> 10) | (intValue21 << 22)) & mask;
-      output[26 + outputOffset] = (intValue21 >>> 4) & mask;
-      output[27 + outputOffset] = ((intValue21 >>> 30) | (intValue22 << 2)) & mask;
-      output[28 + outputOffset] = ((intValue22 >>> 24) | (intValue23 << 8)) & mask;
-      output[29 + outputOffset] = ((intValue23 >>> 18) | (intValue24 << 14)) & mask;
-      output[30 + outputOffset] = ((intValue24 >>> 12) | (intValue25 << 20)) & mask;
-      output[31 + outputOffset] = intValue25 >>> 6;
-      outputOffset += 32;
-    }
-  }
-  public static void decode27(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 27;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      int intValue5 = compressedBuffer.get();
-      int intValue6 = compressedBuffer.get();
-      int intValue7 = compressedBuffer.get();
-      int intValue8 = compressedBuffer.get();
-      int intValue9 = compressedBuffer.get();
-      int intValue10 = compressedBuffer.get();
-      int intValue11 = compressedBuffer.get();
-      int intValue12 = compressedBuffer.get();
-      int intValue13 = compressedBuffer.get();
-      int intValue14 = compressedBuffer.get();
-      int intValue15 = compressedBuffer.get();
-      int intValue16 = compressedBuffer.get();
-      int intValue17 = compressedBuffer.get();
-      int intValue18 = compressedBuffer.get();
-      int intValue19 = compressedBuffer.get();
-      int intValue20 = compressedBuffer.get();
-      int intValue21 = compressedBuffer.get();
-      int intValue22 = compressedBuffer.get();
-      int intValue23 = compressedBuffer.get();
-      int intValue24 = compressedBuffer.get();
-      int intValue25 = compressedBuffer.get();
-      int intValue26 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = ((intValue0 >>> 27) | (intValue1 << 5)) & mask;
-      output[2 + outputOffset] = ((intValue1 >>> 22) | (intValue2 << 10)) & mask;
-      output[3 + outputOffset] = ((intValue2 >>> 17) | (intValue3 << 15)) & mask;
-      output[4 + outputOffset] = ((intValue3 >>> 12) | (intValue4 << 20)) & mask;
-      output[5 + outputOffset] = ((intValue4 >>> 7) | (intValue5 << 25)) & mask;
-      output[6 + outputOffset] = (intValue5 >>> 2) & mask;
-      output[7 + outputOffset] = ((intValue5 >>> 29) | (intValue6 << 3)) & mask;
-      output[8 + outputOffset] = ((intValue6 >>> 24) | (intValue7 << 8)) & mask;
-      output[9 + outputOffset] = ((intValue7 >>> 19) | (intValue8 << 13)) & mask;
-      output[10 + outputOffset] = ((intValue8 >>> 14) | (intValue9 << 18)) & mask;
-      output[11 + outputOffset] = ((intValue9 >>> 9) | (intValue10 << 23)) & mask;
-      output[12 + outputOffset] = (intValue10 >>> 4) & mask;
-      output[13 + outputOffset] = ((intValue10 >>> 31) | (intValue11 << 1)) & mask;
-      output[14 + outputOffset] = ((intValue11 >>> 26) | (intValue12 << 6)) & mask;
-      output[15 + outputOffset] = ((intValue12 >>> 21) | (intValue13 << 11)) & mask;
-      output[16 + outputOffset] = ((intValue13 >>> 16) | (intValue14 << 16)) & mask;
-      output[17 + outputOffset] = ((intValue14 >>> 11) | (intValue15 << 21)) & mask;
-      output[18 + outputOffset] = ((intValue15 >>> 6) | (intValue16 << 26)) & mask;
-      output[19 + outputOffset] = (intValue16 >>> 1) & mask;
-      output[20 + outputOffset] = ((intValue16 >>> 28) | (intValue17 << 4)) & mask;
-      output[21 + outputOffset] = ((intValue17 >>> 23) | (intValue18 << 9)) & mask;
-      output[22 + outputOffset] = ((intValue18 >>> 18) | (intValue19 << 14)) & mask;
-      output[23 + outputOffset] = ((intValue19 >>> 13) | (intValue20 << 19)) & mask;
-      output[24 + outputOffset] = ((intValue20 >>> 8) | (intValue21 << 24)) & mask;
-      output[25 + outputOffset] = (intValue21 >>> 3) & mask;
-      output[26 + outputOffset] = ((intValue21 >>> 30) | (intValue22 << 2)) & mask;
-      output[27 + outputOffset] = ((intValue22 >>> 25) | (intValue23 << 7)) & mask;
-      output[28 + outputOffset] = ((intValue23 >>> 20) | (intValue24 << 12)) & mask;
-      output[29 + outputOffset] = ((intValue24 >>> 15) | (intValue25 << 17)) & mask;
-      output[30 + outputOffset] = ((intValue25 >>> 10) | (intValue26 << 22)) & mask;
-      output[31 + outputOffset] = intValue26 >>> 5;
-      outputOffset += 32;
-    }
-  }
-  public static void decode28(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 28;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      int intValue5 = compressedBuffer.get();
-      int intValue6 = compressedBuffer.get();
-      int intValue7 = compressedBuffer.get();
-      int intValue8 = compressedBuffer.get();
-      int intValue9 = compressedBuffer.get();
-      int intValue10 = compressedBuffer.get();
-      int intValue11 = compressedBuffer.get();
-      int intValue12 = compressedBuffer.get();
-      int intValue13 = compressedBuffer.get();
-      int intValue14 = compressedBuffer.get();
-      int intValue15 = compressedBuffer.get();
-      int intValue16 = compressedBuffer.get();
-      int intValue17 = compressedBuffer.get();
-      int intValue18 = compressedBuffer.get();
-      int intValue19 = compressedBuffer.get();
-      int intValue20 = compressedBuffer.get();
-      int intValue21 = compressedBuffer.get();
-      int intValue22 = compressedBuffer.get();
-      int intValue23 = compressedBuffer.get();
-      int intValue24 = compressedBuffer.get();
-      int intValue25 = compressedBuffer.get();
-      int intValue26 = compressedBuffer.get();
-      int intValue27 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = ((intValue0 >>> 28) | (intValue1 << 4)) & mask;
-      output[2 + outputOffset] = ((intValue1 >>> 24) | (intValue2 << 8)) & mask;
-      output[3 + outputOffset] = ((intValue2 >>> 20) | (intValue3 << 12)) & mask;
-      output[4 + outputOffset] = ((intValue3 >>> 16) | (intValue4 << 16)) & mask;
-      output[5 + outputOffset] = ((intValue4 >>> 12) | (intValue5 << 20)) & mask;
-      output[6 + outputOffset] = ((intValue5 >>> 8) | (intValue6 << 24)) & mask;
-      output[7 + outputOffset] = intValue6 >>> 4;
-      output[8 + outputOffset] = intValue7 & mask;
-      output[9 + outputOffset] = ((intValue7 >>> 28) | (intValue8 << 4)) & mask;
-      output[10 + outputOffset] = ((intValue8 >>> 24) | (intValue9 << 8)) & mask;
-      output[11 + outputOffset] = ((intValue9 >>> 20) | (intValue10 << 12)) & mask;
-      output[12 + outputOffset] = ((intValue10 >>> 16) | (intValue11 << 16)) & mask;
-      output[13 + outputOffset] = ((intValue11 >>> 12) | (intValue12 << 20)) & mask;
-      output[14 + outputOffset] = ((intValue12 >>> 8) | (intValue13 << 24)) & mask;
-      output[15 + outputOffset] = intValue13 >>> 4;
-      output[16 + outputOffset] = intValue14 & mask;
-      output[17 + outputOffset] = ((intValue14 >>> 28) | (intValue15 << 4)) & mask;
-      output[18 + outputOffset] = ((intValue15 >>> 24) | (intValue16 << 8)) & mask;
-      output[19 + outputOffset] = ((intValue16 >>> 20) | (intValue17 << 12)) & mask;
-      output[20 + outputOffset] = ((intValue17 >>> 16) | (intValue18 << 16)) & mask;
-      output[21 + outputOffset] = ((intValue18 >>> 12) | (intValue19 << 20)) & mask;
-      output[22 + outputOffset] = ((intValue19 >>> 8) | (intValue20 << 24)) & mask;
-      output[23 + outputOffset] = intValue20 >>> 4;
-      output[24 + outputOffset] = intValue21 & mask;
-      output[25 + outputOffset] = ((intValue21 >>> 28) | (intValue22 << 4)) & mask;
-      output[26 + outputOffset] = ((intValue22 >>> 24) | (intValue23 << 8)) & mask;
-      output[27 + outputOffset] = ((intValue23 >>> 20) | (intValue24 << 12)) & mask;
-      output[28 + outputOffset] = ((intValue24 >>> 16) | (intValue25 << 16)) & mask;
-      output[29 + outputOffset] = ((intValue25 >>> 12) | (intValue26 << 20)) & mask;
-      output[30 + outputOffset] = ((intValue26 >>> 8) | (intValue27 << 24)) & mask;
-      output[31 + outputOffset] = intValue27 >>> 4;
-      outputOffset += 32;
-    }
-  }
-  public static void decode29(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 29;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      int intValue5 = compressedBuffer.get();
-      int intValue6 = compressedBuffer.get();
-      int intValue7 = compressedBuffer.get();
-      int intValue8 = compressedBuffer.get();
-      int intValue9 = compressedBuffer.get();
-      int intValue10 = compressedBuffer.get();
-      int intValue11 = compressedBuffer.get();
-      int intValue12 = compressedBuffer.get();
-      int intValue13 = compressedBuffer.get();
-      int intValue14 = compressedBuffer.get();
-      int intValue15 = compressedBuffer.get();
-      int intValue16 = compressedBuffer.get();
-      int intValue17 = compressedBuffer.get();
-      int intValue18 = compressedBuffer.get();
-      int intValue19 = compressedBuffer.get();
-      int intValue20 = compressedBuffer.get();
-      int intValue21 = compressedBuffer.get();
-      int intValue22 = compressedBuffer.get();
-      int intValue23 = compressedBuffer.get();
-      int intValue24 = compressedBuffer.get();
-      int intValue25 = compressedBuffer.get();
-      int intValue26 = compressedBuffer.get();
-      int intValue27 = compressedBuffer.get();
-      int intValue28 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = ((intValue0 >>> 29) | (intValue1 << 3)) & mask;
-      output[2 + outputOffset] = ((intValue1 >>> 26) | (intValue2 << 6)) & mask;
-      output[3 + outputOffset] = ((intValue2 >>> 23) | (intValue3 << 9)) & mask;
-      output[4 + outputOffset] = ((intValue3 >>> 20) | (intValue4 << 12)) & mask;
-      output[5 + outputOffset] = ((intValue4 >>> 17) | (intValue5 << 15)) & mask;
-      output[6 + outputOffset] = ((intValue5 >>> 14) | (intValue6 << 18)) & mask;
-      output[7 + outputOffset] = ((intValue6 >>> 11) | (intValue7 << 21)) & mask;
-      output[8 + outputOffset] = ((intValue7 >>> 8) | (intValue8 << 24)) & mask;
-      output[9 + outputOffset] = ((intValue8 >>> 5) | (intValue9 << 27)) & mask;
-      output[10 + outputOffset] = (intValue9 >>> 2) & mask;
-      output[11 + outputOffset] = ((intValue9 >>> 31) | (intValue10 << 1)) & mask;
-      output[12 + outputOffset] = ((intValue10 >>> 28) | (intValue11 << 4)) & mask;
-      output[13 + outputOffset] = ((intValue11 >>> 25) | (intValue12 << 7)) & mask;
-      output[14 + outputOffset] = ((intValue12 >>> 22) | (intValue13 << 10)) & mask;
-      output[15 + outputOffset] = ((intValue13 >>> 19) | (intValue14 << 13)) & mask;
-      output[16 + outputOffset] = ((intValue14 >>> 16) | (intValue15 << 16)) & mask;
-      output[17 + outputOffset] = ((intValue15 >>> 13) | (intValue16 << 19)) & mask;
-      output[18 + outputOffset] = ((intValue16 >>> 10) | (intValue17 << 22)) & mask;
-      output[19 + outputOffset] = ((intValue17 >>> 7) | (intValue18 << 25)) & mask;
-      output[20 + outputOffset] = ((intValue18 >>> 4) | (intValue19 << 28)) & mask;
-      output[21 + outputOffset] = (intValue19 >>> 1) & mask;
-      output[22 + outputOffset] = ((intValue19 >>> 30) | (intValue20 << 2)) & mask;
-      output[23 + outputOffset] = ((intValue20 >>> 27) | (intValue21 << 5)) & mask;
-      output[24 + outputOffset] = ((intValue21 >>> 24) | (intValue22 << 8)) & mask;
-      output[25 + outputOffset] = ((intValue22 >>> 21) | (intValue23 << 11)) & mask;
-      output[26 + outputOffset] = ((intValue23 >>> 18) | (intValue24 << 14)) & mask;
-      output[27 + outputOffset] = ((intValue24 >>> 15) | (intValue25 << 17)) & mask;
-      output[28 + outputOffset] = ((intValue25 >>> 12) | (intValue26 << 20)) & mask;
-      output[29 + outputOffset] = ((intValue26 >>> 9) | (intValue27 << 23)) & mask;
-      output[30 + outputOffset] = ((intValue27 >>> 6) | (intValue28 << 26)) & mask;
-      output[31 + outputOffset] = intValue28 >>> 3;
-      outputOffset += 32;
-    }
-  }
-  public static void decode30(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 30;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      int intValue5 = compressedBuffer.get();
-      int intValue6 = compressedBuffer.get();
-      int intValue7 = compressedBuffer.get();
-      int intValue8 = compressedBuffer.get();
-      int intValue9 = compressedBuffer.get();
-      int intValue10 = compressedBuffer.get();
-      int intValue11 = compressedBuffer.get();
-      int intValue12 = compressedBuffer.get();
-      int intValue13 = compressedBuffer.get();
-      int intValue14 = compressedBuffer.get();
-      int intValue15 = compressedBuffer.get();
-      int intValue16 = compressedBuffer.get();
-      int intValue17 = compressedBuffer.get();
-      int intValue18 = compressedBuffer.get();
-      int intValue19 = compressedBuffer.get();
-      int intValue20 = compressedBuffer.get();
-      int intValue21 = compressedBuffer.get();
-      int intValue22 = compressedBuffer.get();
-      int intValue23 = compressedBuffer.get();
-      int intValue24 = compressedBuffer.get();
-      int intValue25 = compressedBuffer.get();
-      int intValue26 = compressedBuffer.get();
-      int intValue27 = compressedBuffer.get();
-      int intValue28 = compressedBuffer.get();
-      int intValue29 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = ((intValue0 >>> 30) | (intValue1 << 2)) & mask;
-      output[2 + outputOffset] = ((intValue1 >>> 28) | (intValue2 << 4)) & mask;
-      output[3 + outputOffset] = ((intValue2 >>> 26) | (intValue3 << 6)) & mask;
-      output[4 + outputOffset] = ((intValue3 >>> 24) | (intValue4 << 8)) & mask;
-      output[5 + outputOffset] = ((intValue4 >>> 22) | (intValue5 << 10)) & mask;
-      output[6 + outputOffset] = ((intValue5 >>> 20) | (intValue6 << 12)) & mask;
-      output[7 + outputOffset] = ((intValue6 >>> 18) | (intValue7 << 14)) & mask;
-      output[8 + outputOffset] = ((intValue7 >>> 16) | (intValue8 << 16)) & mask;
-      output[9 + outputOffset] = ((intValue8 >>> 14) | (intValue9 << 18)) & mask;
-      output[10 + outputOffset] = ((intValue9 >>> 12) | (intValue10 << 20)) & mask;
-      output[11 + outputOffset] = ((intValue10 >>> 10) | (intValue11 << 22)) & mask;
-      output[12 + outputOffset] = ((intValue11 >>> 8) | (intValue12 << 24)) & mask;
-      output[13 + outputOffset] = ((intValue12 >>> 6) | (intValue13 << 26)) & mask;
-      output[14 + outputOffset] = ((intValue13 >>> 4) | (intValue14 << 28)) & mask;
-      output[15 + outputOffset] = intValue14 >>> 2;
-      output[16 + outputOffset] = intValue15 & mask;
-      output[17 + outputOffset] = ((intValue15 >>> 30) | (intValue16 << 2)) & mask;
-      output[18 + outputOffset] = ((intValue16 >>> 28) | (intValue17 << 4)) & mask;
-      output[19 + outputOffset] = ((intValue17 >>> 26) | (intValue18 << 6)) & mask;
-      output[20 + outputOffset] = ((intValue18 >>> 24) | (intValue19 << 8)) & mask;
-      output[21 + outputOffset] = ((intValue19 >>> 22) | (intValue20 << 10)) & mask;
-      output[22 + outputOffset] = ((intValue20 >>> 20) | (intValue21 << 12)) & mask;
-      output[23 + outputOffset] = ((intValue21 >>> 18) | (intValue22 << 14)) & mask;
-      output[24 + outputOffset] = ((intValue22 >>> 16) | (intValue23 << 16)) & mask;
-      output[25 + outputOffset] = ((intValue23 >>> 14) | (intValue24 << 18)) & mask;
-      output[26 + outputOffset] = ((intValue24 >>> 12) | (intValue25 << 20)) & mask;
-      output[27 + outputOffset] = ((intValue25 >>> 10) | (intValue26 << 22)) & mask;
-      output[28 + outputOffset] = ((intValue26 >>> 8) | (intValue27 << 24)) & mask;
-      output[29 + outputOffset] = ((intValue27 >>> 6) | (intValue28 << 26)) & mask;
-      output[30 + outputOffset] = ((intValue28 >>> 4) | (intValue29 << 28)) & mask;
-      output[31 + outputOffset] = intValue29 >>> 2;
-      outputOffset += 32;
-    }
-  }
-  public static void decode31(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 31;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      int intValue5 = compressedBuffer.get();
-      int intValue6 = compressedBuffer.get();
-      int intValue7 = compressedBuffer.get();
-      int intValue8 = compressedBuffer.get();
-      int intValue9 = compressedBuffer.get();
-      int intValue10 = compressedBuffer.get();
-      int intValue11 = compressedBuffer.get();
-      int intValue12 = compressedBuffer.get();
-      int intValue13 = compressedBuffer.get();
-      int intValue14 = compressedBuffer.get();
-      int intValue15 = compressedBuffer.get();
-      int intValue16 = compressedBuffer.get();
-      int intValue17 = compressedBuffer.get();
-      int intValue18 = compressedBuffer.get();
-      int intValue19 = compressedBuffer.get();
-      int intValue20 = compressedBuffer.get();
-      int intValue21 = compressedBuffer.get();
-      int intValue22 = compressedBuffer.get();
-      int intValue23 = compressedBuffer.get();
-      int intValue24 = compressedBuffer.get();
-      int intValue25 = compressedBuffer.get();
-      int intValue26 = compressedBuffer.get();
-      int intValue27 = compressedBuffer.get();
-      int intValue28 = compressedBuffer.get();
-      int intValue29 = compressedBuffer.get();
-      int intValue30 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0 & mask;
-      output[1 + outputOffset] = ((intValue0 >>> 31) | (intValue1 << 1)) & mask;
-      output[2 + outputOffset] = ((intValue1 >>> 30) | (intValue2 << 2)) & mask;
-      output[3 + outputOffset] = ((intValue2 >>> 29) | (intValue3 << 3)) & mask;
-      output[4 + outputOffset] = ((intValue3 >>> 28) | (intValue4 << 4)) & mask;
-      output[5 + outputOffset] = ((intValue4 >>> 27) | (intValue5 << 5)) & mask;
-      output[6 + outputOffset] = ((intValue5 >>> 26) | (intValue6 << 6)) & mask;
-      output[7 + outputOffset] = ((intValue6 >>> 25) | (intValue7 << 7)) & mask;
-      output[8 + outputOffset] = ((intValue7 >>> 24) | (intValue8 << 8)) & mask;
-      output[9 + outputOffset] = ((intValue8 >>> 23) | (intValue9 << 9)) & mask;
-      output[10 + outputOffset] = ((intValue9 >>> 22) | (intValue10 << 10)) & mask;
-      output[11 + outputOffset] = ((intValue10 >>> 21) | (intValue11 << 11)) & mask;
-      output[12 + outputOffset] = ((intValue11 >>> 20) | (intValue12 << 12)) & mask;
-      output[13 + outputOffset] = ((intValue12 >>> 19) | (intValue13 << 13)) & mask;
-      output[14 + outputOffset] = ((intValue13 >>> 18) | (intValue14 << 14)) & mask;
-      output[15 + outputOffset] = ((intValue14 >>> 17) | (intValue15 << 15)) & mask;
-      output[16 + outputOffset] = ((intValue15 >>> 16) | (intValue16 << 16)) & mask;
-      output[17 + outputOffset] = ((intValue16 >>> 15) | (intValue17 << 17)) & mask;
-      output[18 + outputOffset] = ((intValue17 >>> 14) | (intValue18 << 18)) & mask;
-      output[19 + outputOffset] = ((intValue18 >>> 13) | (intValue19 << 19)) & mask;
-      output[20 + outputOffset] = ((intValue19 >>> 12) | (intValue20 << 20)) & mask;
-      output[21 + outputOffset] = ((intValue20 >>> 11) | (intValue21 << 21)) & mask;
-      output[22 + outputOffset] = ((intValue21 >>> 10) | (intValue22 << 22)) & mask;
-      output[23 + outputOffset] = ((intValue22 >>> 9) | (intValue23 << 23)) & mask;
-      output[24 + outputOffset] = ((intValue23 >>> 8) | (intValue24 << 24)) & mask;
-      output[25 + outputOffset] = ((intValue24 >>> 7) | (intValue25 << 25)) & mask;
-      output[26 + outputOffset] = ((intValue25 >>> 6) | (intValue26 << 26)) & mask;
-      output[27 + outputOffset] = ((intValue26 >>> 5) | (intValue27 << 27)) & mask;
-      output[28 + outputOffset] = ((intValue27 >>> 4) | (intValue28 << 28)) & mask;
-      output[29 + outputOffset] = ((intValue28 >>> 3) | (intValue29 << 29)) & mask;
-      output[30 + outputOffset] = ((intValue29 >>> 2) | (intValue30 << 30)) & mask;
-      output[31 + outputOffset] = intValue30 >>> 1;
-      outputOffset += 32;
-    }
-  }
-  public static void decode32(final IntBuffer compressedBuffer, final int[] output) {
-    final int numFrameBits = 32;
-    final int mask = (int) ((1L<<numFrameBits) - 1);
-    int outputOffset = 0;
-    for(int step=0;step<4;step++) {
-      int intValue0 = compressedBuffer.get();
-      int intValue1 = compressedBuffer.get();
-      int intValue2 = compressedBuffer.get();
-      int intValue3 = compressedBuffer.get();
-      int intValue4 = compressedBuffer.get();
-      int intValue5 = compressedBuffer.get();
-      int intValue6 = compressedBuffer.get();
-      int intValue7 = compressedBuffer.get();
-      int intValue8 = compressedBuffer.get();
-      int intValue9 = compressedBuffer.get();
-      int intValue10 = compressedBuffer.get();
-      int intValue11 = compressedBuffer.get();
-      int intValue12 = compressedBuffer.get();
-      int intValue13 = compressedBuffer.get();
-      int intValue14 = compressedBuffer.get();
-      int intValue15 = compressedBuffer.get();
-      int intValue16 = compressedBuffer.get();
-      int intValue17 = compressedBuffer.get();
-      int intValue18 = compressedBuffer.get();
-      int intValue19 = compressedBuffer.get();
-      int intValue20 = compressedBuffer.get();
-      int intValue21 = compressedBuffer.get();
-      int intValue22 = compressedBuffer.get();
-      int intValue23 = compressedBuffer.get();
-      int intValue24 = compressedBuffer.get();
-      int intValue25 = compressedBuffer.get();
-      int intValue26 = compressedBuffer.get();
-      int intValue27 = compressedBuffer.get();
-      int intValue28 = compressedBuffer.get();
-      int intValue29 = compressedBuffer.get();
-      int intValue30 = compressedBuffer.get();
-      int intValue31 = compressedBuffer.get();
-      output[0 + outputOffset] = intValue0;
-      output[1 + outputOffset] = intValue1;
-      output[2 + outputOffset] = intValue2;
-      output[3 + outputOffset] = intValue3;
-      output[4 + outputOffset] = intValue4;
-      output[5 + outputOffset] = intValue5;
-      output[6 + outputOffset] = intValue6;
-      output[7 + outputOffset] = intValue7;
-      output[8 + outputOffset] = intValue8;
-      output[9 + outputOffset] = intValue9;
-      output[10 + outputOffset] = intValue10;
-      output[11 + outputOffset] = intValue11;
-      output[12 + outputOffset] = intValue12;
-      output[13 + outputOffset] = intValue13;
-      output[14 + outputOffset] = intValue14;
-      output[15 + outputOffset] = intValue15;
-      output[16 + outputOffset] = intValue16;
-      output[17 + outputOffset] = intValue17;
-      output[18 + outputOffset] = intValue18;
-      output[19 + outputOffset] = intValue19;
-      output[20 + outputOffset] = intValue20;
-      output[21 + outputOffset] = intValue21;
-      output[22 + outputOffset] = intValue22;
-      output[23 + outputOffset] = intValue23;
-      output[24 + outputOffset] = intValue24;
-      output[25 + outputOffset] = intValue25;
-      output[26 + outputOffset] = intValue26;
-      output[27 + outputOffset] = intValue27;
-      output[28 + outputOffset] = intValue28;
-      output[29 + outputOffset] = intValue29;
-      output[30 + outputOffset] = intValue30;
-      output[31 + outputOffset] = intValue31;
-      outputOffset += 32;
-    }
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/pfor/gendecompress.py b/lucene/core/src/java/org/apache/lucene/codecs/pfor/gendecompress.py
deleted file mode 100755
index 3ea9f60..0000000
--- a/lucene/core/src/java/org/apache/lucene/codecs/pfor/gendecompress.py
+++ /dev/null
@@ -1,107 +0,0 @@
-#!/usr/bin/env python2
-"""
-  Licensed to the Apache Software Foundation (ASF) under one or more
-  contributor license agreements.  See the NOTICE file distributed with
-  this work for additional information regarding copyright ownership.
-  The ASF licenses this file to You under the Apache License, Version 2.0
-  (the "License"); you may not use this file except in compliance with
-  the License.  You may obtain a copy of the License at
-  
-     http://www.apache.org/licenses/LICENSE-2.0
-  
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
-"""
-
-"""
-Generate source code for java classes for For or PFor decompression.
-"""
-
-def bitsExpr(i, numFrameBits):
-  framePos = i * numFrameBits
-  intValNum = (framePos / 32)
-  bitPos = framePos % 32
-  bitsInInt = "intValue" + str(intValNum)
-  needBrackets = 0
-  if bitPos > 0:
-    bitsInInt +=  " >>> " + str(bitPos)
-    needBrackets = 1
-  if bitPos + numFrameBits > 32:
-    if needBrackets:
-      bitsInInt = "(" + bitsInInt + ")"
-    bitsInInt += " | (intValue" + str(intValNum+1) + " << "+ str(32 - bitPos) + ")"
-    needBrackets = 1
-  if bitPos + numFrameBits != 32:
-    if needBrackets:
-      bitsInInt = "(" + bitsInInt + ")"
-    bitsInInt += " & mask"
-  return bitsInInt
-
-
-def genDecompress():
-  className = "PackedIntsDecompress"
-  fileName = className + ".java"
-  imports = "import java.nio.IntBuffer;\n"
-  f = open(fileName, 'w')
-  w = f.write
-  try:
-    w("package org.apache.lucene.codecs.pfor;\n")
-    w("""/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
- """)
-
-    w("\n/* This code is generated, do not modify. See gendecompress.py */\n\n")
-
-    w("import java.nio.IntBuffer;\n")
-    w("import java.util.Arrays;\n\n")
-
-    w("final class PackedIntsDecompress {\n")
-
-    w('\n  // nocommit: assess perf of this to see if specializing is really needed\n')
-    w('\n  // NOTE: hardwired to blockSize == 128\n\n')
-
-    w('  public static void decode0(final IntBuffer compressedBuffer, final int[] output) {\n')
-    w('    Arrays.fill(output, compressedBuffer.get());\n')
-    w('  }\n')
-
-    for numFrameBits in xrange(1, 33):
-      w('  public static void decode%d(final IntBuffer compressedBuffer, final int[] output) {\n' % numFrameBits)
-      w('    final int numFrameBits = %d;\n' % numFrameBits)
-      w('    final int mask = (int) ((1L<<numFrameBits) - 1);\n')
-      w('    int outputOffset = 0;\n')
-      w('    for(int step=0;step<4;step++) {\n')
-
-      for i in range(numFrameBits): # declare int vars and init from buffer
-        w("      int intValue" + str(i) + " = compressedBuffer.get();\n")
-
-      for i in range(32): # set output from int vars
-        w("      output[" + str(i) + " + outputOffset] = " + bitsExpr(i, numFrameBits) + ";\n")
-
-      w('      outputOffset += 32;\n')
-      w('    }\n')
-      w('  }\n')
-
-    w('}\n')
-      
-  finally:
-    f.close()
-
-if __name__ == "__main__":
-  genDecompress()
diff --git a/lucene/core/src/resources/META-INF/services/org.apache.lucene.codecs.PostingsFormat b/lucene/core/src/resources/META-INF/services/org.apache.lucene.codecs.PostingsFormat
index a89e870..115cb3d 100644
--- a/lucene/core/src/resources/META-INF/services/org.apache.lucene.codecs.PostingsFormat
+++ b/lucene/core/src/resources/META-INF/services/org.apache.lucene.codecs.PostingsFormat
@@ -17,8 +17,6 @@ org.apache.lucene.codecs.lucene40.Lucene40PostingsFormat
 org.apache.lucene.codecs.pulsing.Pulsing40PostingsFormat
 org.apache.lucene.codecs.simpletext.SimpleTextPostingsFormat
 org.apache.lucene.codecs.memory.MemoryPostingsFormat
-org.apache.lucene.codecs.pfor.ForPostingsFormat
-org.apache.lucene.codecs.pfor.PForPostingsFormat
 org.apache.lucene.codecs.bulkvint.BulkVIntPostingsFormat
 org.apache.lucene.codecs.block.BlockPostingsFormat
 org.apache.lucene.codecs.memory.DirectPostingsFormat
diff --git a/lucene/core/src/test/org/apache/lucene/codecs/pfor/TestPForUtil.java b/lucene/core/src/test/org/apache/lucene/codecs/pfor/TestPForUtil.java
deleted file mode 100644
index 6394d92..0000000
--- a/lucene/core/src/test/org/apache/lucene/codecs/pfor/TestPForUtil.java
+++ /dev/null
@@ -1,293 +0,0 @@
-package org.apache.lucene.codecs.pfor;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.nio.ByteBuffer;
-import java.nio.IntBuffer;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Locale;
-import java.util.Random;
-
-import org.apache.lucene.codecs.pfor.ForPostingsFormat;
-import org.apache.lucene.codecs.pfor.PForUtil;
-import org.apache.lucene.util.LuceneTestCase;
-
-/**
- * Test the core utility for PFor compress and decompress
- * We don't specially provide test case for For encoder/decoder, since
- * PFor is a extended version of For, and most methods will be reused 
- * here.
- */
-public class TestPForUtil extends LuceneTestCase {
-  static final int[] MASK={ 0x00000000,
-    0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f,
-    0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff,
-    0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff, 0x0001ffff, 0x0003ffff,
-    0x0007ffff, 0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff, 0x00ffffff,
-    0x01ffffff, 0x03ffffff, 0x07ffffff, 0x0fffffff, 0x1fffffff, 0x3fffffff,
-    0x7fffffff, 0xffffffff};
-  Random gen;
-  public void initRandom() {
-    this.gen = random();
-  }
-
-  /**
-   * Should not encode extra information other than single int
-   */
-  public void testAllEqual() throws Exception {
-    initRandom();
-    int sz=ForPostingsFormat.DEFAULT_BLOCK_SIZE;
-    int[] data=new int[sz];
-    byte[] res = new byte[sz*8];
-    int[] copy = new int[sz];
-    IntBuffer resBuffer = ByteBuffer.wrap(res).asIntBuffer();
-    int ensz;
-    int header;
-
-    Arrays.fill(data,gen.nextInt());
-    header = ForUtil.compress(data,resBuffer); // test For
-    ensz = ForUtil.getEncodedSize(header);
-    assert ensz == 4;
-
-    ForUtil.decompress(resBuffer,copy,header);
-    assert cmp(data,sz,copy,sz)==true;
-
-    Arrays.fill(data,gen.nextInt());
-    header = PForUtil.compress(data,resBuffer); // test PFor
-    ensz = PForUtil.getEncodedSize(header);
-    assert ensz == 4;
-
-    PForUtil.decompress(resBuffer,copy,header);
-    assert cmp(data,sz,copy,sz)==true;
-  }
-
-  /**
-   * Test correctness of forced exception.
-   * the forced ones should exactly fit max chain 
-   */
-  public void testForcedExceptionDistance() throws Exception {
-    initRandom();
-    int sz=ForPostingsFormat.DEFAULT_BLOCK_SIZE;
-    int[] data=new int[sz];
-    byte[] res = new byte[sz*8];
-    int[] copy = new int[sz];
-    IntBuffer resBuffer = ByteBuffer.wrap(res).asIntBuffer();
-    int numBits = gen.nextInt(5)+1;
-
-    int i,j;
-    int pace, ensz, header;
-    int expect, got;
-
-    // fill exception value with same pace, there should
-    // be no forced exceptions.
-    createDistribution(data, sz, 1, MASK[numBits], MASK[numBits]);
-    pace = 1<<numBits;
-    for (i=0,j=0; i<sz; i+=pace) {
-      int exc = gen.nextInt();
-      data[i] = (exc & 0xffff0000) == 0 ? exc | 0xffff0000 : exc;
-      j++;
-    }
-    header = PForUtil.compress(data,resBuffer);
-    ensz = PForUtil.getEncodedSize(header);
-    expect = j; 
-    got = PForUtil.getExcNum(header);
-    assert expect == got: expect+" expected but got "+got;
-
-    // there should exactly one forced exception before each
-    // exception when i>0
-    createDistribution(data, sz, 1, MASK[numBits], MASK[numBits]);
-    pace = (1<<numBits)+1;
-    for (i=0,j=0; i<sz; i+=pace) {
-      int exc = gen.nextInt();
-      data[i] = (exc & 0xffff0000) == 0 ? exc | 0xffff0000 : exc;
-      j++;
-    }
-    header = PForUtil.compress(data,resBuffer);
-    ensz = PForUtil.getEncodedSize(header);
-    expect = 2*(j-1)+1; 
-    got = PForUtil.getExcNum(header);
-    assert expect == got: expect+" expected but got "+got;
-
-
-    // two forced exception  
-    createDistribution(data, sz, 1, MASK[numBits], MASK[numBits]);
-    pace = (1<<numBits)*2+1;
-    for (i=0,j=0; i<sz; i+=pace) {
-      int exc = gen.nextInt();
-      data[i] = (exc & 0xffff0000) == 0 ? exc | 0xffff0000 : exc;
-      j++;
-    }
-    header = PForUtil.compress(data,resBuffer);
-    ensz = PForUtil.getEncodedSize(header);
-    expect = 3*(j-1)+1; 
-    got = PForUtil.getExcNum(header);
-    assert expect == got: expect+" expected but got "+got;
-
-  }
-  /**
-   * Test correctness of ignored forced exception.
-   * The trailing forced exceptions should always be reverted
-   * since they're not necessary. 
-   */
-  public void testTrailingForcedException() throws Exception {
-    initRandom();
-    int sz=ForPostingsFormat.DEFAULT_BLOCK_SIZE;
-    assert sz % 32 == 0;
-    Integer[] buff= new Integer[sz];
-    int[] data = new int[sz];
-    int[] copy = new int[sz];
-    byte[] res = new byte[sz*8];
-    IntBuffer resBuffer = ByteBuffer.wrap(res).asIntBuffer();
-
-    int excIndex = gen.nextInt(sz/2);
-    int excValue = gen.nextInt();
-    if ((excValue & 0xffff0000) == 0) {
-      excValue |= 0xffff0000; // always prepare a 4 bytes exception
-    }
-
-    // make value of numFrameBits to be small, 
-    // thus easy to get forced exceptions
-    for (int i=0; i<sz; ++i) {
-      buff[i]=gen.nextInt() & 1;
-    }
-    // create only one value exception
-    buff[excIndex]=excValue;
-
-    for (int i=0; i<sz; ++i)
-      data[i] = buff[i];
-
-    int header = PForUtil.compress(data,resBuffer);
-    int ensz = PForUtil.getEncodedSize(header);
-
-    assert (ensz <= sz*8): ensz+" > "+sz*8;  // must not exceed the loose upperbound
-    assert (ensz >= 4);       // at least we have an exception, right?
-
-    PForUtil.decompress(resBuffer,copy,header);
-
-//    println(getHex(data,sz)+"\n");
-//    println(getHex(res,ensz)+"\n");
-//    println(getHex(copy,sz)+"\n");
-
-    // fetch the last int, i.e. last exception.
-    int lastExc = (res[ensz-4] << 24) | 
-         ((0xff & res[ensz-3]) << 16) | 
-         ((0xff & res[ensz-2]) << 8 ) | 
-          (0xff & res[ensz-1]);
-
-    // trailing forced exceptions are suppressed, 
-    // so the last exception should be what we assigned. 
-    assert lastExc==excValue;  
-    assert cmp(data,sz,copy,sz)==true;
-  }
-
-  /**
-   * Test correctness of compressing and decompressing.
-   * Here we randomly assign a rate of exception (i.e. 1-alpha), 
-   * and test different scale of normal/exception values.
-   */
-  public void testAllDistribution() throws Exception {
-    initRandom();
-    int sz = ForPostingsFormat.DEFAULT_BLOCK_SIZE;
-    int[] data = new int[sz];
-    for (int i=0; i<=32; ++i) { // try to test every kinds of distribution
-      double alpha=gen.nextDouble(); // rate of normal value
-      for (int j=i; j<=32; ++j) {
-        createDistribution(data,sz,alpha,MASK[i],MASK[j]);
-        tryCompressAndDecompress(data, sz);
-      }
-    }
-  }
-  public void createDistribution(int[] data, int sz, double alpha, int masknorm, int maskexc) {
-    Integer[] buff= new Integer[sz];
-    int i=0;
-    for (; i<sz*alpha; ++i)
-      buff[i]=gen.nextInt() & masknorm;
-    for (; i<sz; ++i)
-      buff[i]=gen.nextInt() & maskexc;
-    Collections.shuffle(Arrays.asList(buff),gen);
-    for (i=0; i<sz; ++i)
-      data[i] = buff[i];
-  }
-  public void tryCompressAndDecompress(final int[] data, int sz) throws Exception {
-    byte[] res = new byte[sz*8];      // loosely upperbound
-    IntBuffer resBuffer = ByteBuffer.wrap(res).asIntBuffer();
-
-    int header = PForUtil.compress(data,resBuffer);
-    int ensz = PForUtil.getEncodedSize(header);
-    
-    assert (ensz <= sz*8);  // must not exceed the loose upperbound
-
-    int[] copy = new int[sz];
-    PForUtil.decompress(resBuffer,copy,header);
-
-//    println(getHex(data,sz)+"\n");
-//    println(getHex(res,ensz)+"\n");
-//    println(getHex(copy,sz)+"\n");
-
-    assert cmp(data,sz,copy,sz)==true;
-  }
-  public boolean cmp(int[] a, int sza, int[] b, int szb) {
-    if (sza!=szb)
-      return false;
-    for (int i=0; i<sza; ++i) {
-      if (a[i]!=b[i]) {
-        System.err.println(String.format(Locale.ENGLISH, "! %08x != %08x in %d",a[i],b[i],i));
-        return false;
-      }
-    }
-    return true;
-  }
-  public static String getHex( byte [] raw, int sz ) {
-    final String HEXES = "0123456789ABCDEF";
-    if ( raw == null ) {
-      return null;
-    }
-    final StringBuilder hex = new StringBuilder( 2 * raw.length );
-    for ( int i=0; i<sz; i++ ) {
-      if (i>0 && (i)%16 == 0)
-        hex.append("\n");
-      byte b=raw[i];
-      hex.append(HEXES.charAt((b & 0xF0) >> 4))
-         .append(HEXES.charAt((b & 0x0F)))
-         .append(" ");
-    }
-    return hex.toString();
-  }
-  public static String getHex( int [] raw, int sz ) {
-    if ( raw == null ) {
-      return null;
-    }
-    final StringBuilder hex = new StringBuilder( 4 * raw.length );
-    for ( int i=0; i<sz; i++ ) {
-      if (i>0 && i%8 == 0)
-        hex.append("\n");
-      hex.append(String.format(Locale.ENGLISH, "%08x ",raw[i]));
-    }
-    return hex.toString();
-  }
-  static void eprintln(String format, Object... args) {
-    System.err.println(String.format(Locale.ENGLISH, format,args)); 
-  }
-  static void println(String format, Object... args) {
-    System.out.println(String.format(Locale.ENGLISH, format,args)); 
-  }
-  static void print(String format, Object... args) {
-    System.out.print(String.format(Locale.ENGLISH, format,args)); 
-  }
-}
diff --git a/lucene/test-framework/src/java/org/apache/lucene/codecs/mockrandom/MockRandomPostingsFormat.java b/lucene/test-framework/src/java/org/apache/lucene/codecs/mockrandom/MockRandomPostingsFormat.java
index a8bbb94..97fef58 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/codecs/mockrandom/MockRandomPostingsFormat.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/codecs/mockrandom/MockRandomPostingsFormat.java
@@ -61,7 +61,6 @@ import org.apache.lucene.store.IndexOutput;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util._TestUtil;
-import org.apache.lucene.codecs.pfor.*;
 
 /**
  * Randomly combines terms index impl w/ postings impls.
@@ -103,8 +102,6 @@ public class MockRandomPostingsFormat extends PostingsFormat {
       final int baseBlockSize = _TestUtil.nextInt(random, 1, 127);
       delegates.add(new MockVariableIntBlockPostingsFormat.MockIntFactory(baseBlockSize));
       // TODO: others
-      delegates.add(new ForFactory());
-      delegates.add(new PForFactory());
     }
 
     private static String getExtension(String fileName) {
diff --git a/lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java b/lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
index 538559a..f9527a8 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
@@ -282,9 +282,7 @@ public abstract class LuceneTestCase extends Assert {
     "MockFixedIntBlock",
     "MockVariableIntBlock",
     "MockSep",
-    "MockRandom",
-    "For",
-    "PFor"
+    "MockRandom"
   ));
   
   // -----------------------------------------------------------------

