GitDiffStart: e4beeafa035b452f70523c79ca94457a6ed0d0ac | Fri Jun 3 16:14:18 2011 +0000
diff --git a/lucene/src/java/org/apache/lucene/document/DocValuesField.java b/lucene/src/java/org/apache/lucene/document/DocValuesField.java
deleted file mode 100644
index 38d6c3d..0000000
--- a/lucene/src/java/org/apache/lucene/document/DocValuesField.java
+++ /dev/null
@@ -1,286 +0,0 @@
-package org.apache.lucene.document;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-import java.io.Reader;
-import java.util.Comparator;
-
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.document.Field.Index;
-import org.apache.lucene.document.Field.Store;
-import org.apache.lucene.document.Field.TermVector;
-import org.apache.lucene.index.values.PerDocFieldValues;
-import org.apache.lucene.index.values.ValueType;
-import org.apache.lucene.util.BytesRef;
-
-/**
- * <p>
- * This class provides a {@link AbstractField} that enables storing of typed
- * per-document values for scoring, sorting or value retrieval. Here's an
- * example usage, adding an int value:
- * 
- * <pre>
- * document.add(new DocValuesField(name).setInt(value));
- * </pre>
- * 
- * For optimal performance, re-use the <code>DocValuesField</code> and
- * {@link Document} instance for more than one document:
- * 
- * <pre>
- *  DocValuesField field = new DocValuesField(name);
- *  Document document = new Document();
- *  document.add(field);
- * 
- *  for(all documents) {
- *    ...
- *    field.setInt(value)
- *    writer.addDocument(document);
- *    ...
- *  }
- * </pre>
- * 
- * <p>
- * If doc values are stored in addition to an indexed ({@link Index}) or stored
- * ({@link Store}) value it's recommended to use the {@link DocValuesField}'s
- * {@link #set(AbstractField)} API:
- * 
- * <pre>
- *  DocValuesField field = new DocValuesField(name);
- *  Field indexedField = new Field(name, stringValue, Stored.NO, Indexed.ANALYZED);
- *  Document document = new Document();
- *  document.add(indexedField);
- *  field.set(indexedField);
- *  for(all documents) {
- *    ...
- *    field.setInt(value)
- *    writer.addDocument(document);
- *    ...
- *  }
- * </pre>
- * 
- * */
-public class DocValuesField extends AbstractField implements PerDocFieldValues {
-
-  protected BytesRef bytes;
-  protected double doubleValue;
-  protected long longValue;
-  protected ValueType type;
-  protected Comparator<BytesRef> bytesComparator;
-
-  /**
-   * Creates a new {@link DocValuesField} with the given name.
-   */
-  public DocValuesField(String name) {
-    super(name, Store.NO, Index.NO, TermVector.NO);
-    setDocValues(this);
-  }
-
-  /**
-   * Creates a {@link DocValuesField} prototype
-   */
-  DocValuesField() {
-    this("");
-  }
-
-  /**
-   * Sets the given <code>long</code> value and sets the field's {@link ValueType} to
-   * {@link ValueType#INTS} unless already set. If you want to change the
-   * default type use {@link #setType(ValueType)}.
-   */
-  public void setInt(long value) {
-    if (type == null) {
-      type = ValueType.INTS;
-    }
-    longValue = value;
-  }
-
-  /**
-   * Sets the given <code>float</code> value and sets the field's {@link ValueType}
-   * to {@link ValueType#FLOAT_32} unless already set. If you want to
-   * change the type use {@link #setType(ValueType)}.
-   */
-  public void setFloat(float value) {
-    if (type == null) {
-      type = ValueType.FLOAT_32;
-    }
-    doubleValue = value;
-  }
-
-  /**
-   * Sets the given <code>double</code> value and sets the field's {@link ValueType}
-   * to {@link ValueType#FLOAT_64} unless already set. If you want to
-   * change the default type use {@link #setType(ValueType)}.
-   */
-  public void setFloat(double value) {
-    if (type == null) {
-      type = ValueType.FLOAT_64;
-    }
-    doubleValue = value;
-  }
-
-  /**
-   * Sets the given {@link BytesRef} value and the field's {@link ValueType}. The
-   * comparator for this field is set to <code>null</code>. If a
-   * <code>null</code> comparator is set the default comparator for the given
-   * {@link ValueType} is used.
-   */
-  public void setBytes(BytesRef value, ValueType type) {
-    setBytes(value, type, null);
-  }
-
-  /**
-   * Sets the given {@link BytesRef} value, the field's {@link ValueType} and the
-   * field's comparator. If the {@link Comparator} is set to <code>null</code>
-   * the default for the given {@link ValueType} is used instead.
-   * 
-   * @throws IllegalArgumentException
-   *           if the value or the type are null
-   */
-  public void setBytes(BytesRef value, ValueType type, Comparator<BytesRef> comp) {
-    if (value == null) {
-      throw new IllegalArgumentException("value must not be null");
-    }
-    setType(type);
-    if (bytes == null) {
-      bytes = new BytesRef(value);
-    } else {
-      bytes.copy(value);
-    }
-    bytesComparator = comp;
-  }
-
-  /**
-   * Returns the set {@link BytesRef} or <code>null</code> if not set.
-   */
-  public BytesRef getBytes() {
-    return bytes;
-  }
-
-  /**
-   * Returns the set {@link BytesRef} comparator or <code>null</code> if not set
-   */
-  public Comparator<BytesRef> bytesComparator() {
-    return bytesComparator;
-  }
-
-  /**
-   * Returns the set floating point value or <code>0.0d</code> if not set.
-   */
-  public double getFloat() {
-    return doubleValue;
-  }
-
-  /**
-   * Returns the set <code>long</code> value of <code>0</code> if not set.
-   */
-  public long getInt() {
-    return longValue;
-  }
-
-  /**
-   * Sets the {@link BytesRef} comparator for this field. If the field has a
-   * numeric {@link ValueType} the comparator will be ignored.
-   */
-  public void setBytesComparator(Comparator<BytesRef> comp) {
-    this.bytesComparator = comp;
-  }
-
-  /**
-   * Sets the {@link ValueType} for this field.
-   */
-  public void setType(ValueType type) {
-    if (type == null) {
-      throw new IllegalArgumentException("Type must not be null");
-    }
-    this.type = type;
-  }
-
-  /**
-   * Returns the field's {@link ValueType}
-   */
-  public ValueType type() {
-    return type;
-  }
-
-  /**
-   * Returns always <code>null</code>
-   */
-  public Reader readerValue() {
-    return null;
-  }
-
-  /**
-   * Returns always <code>null</code>
-   */
-  public String stringValue() {
-    return null;
-  }
-
-  /**
-   * Returns always <code>null</code>
-   */
-  public TokenStream tokenStreamValue() {
-    return null;
-  }
-
-  /**
-   * Sets this {@link DocValuesField} to the given {@link AbstractField} and
-   * returns the given field. Any modifications to this instance will be visible
-   * to the given field.
-   */
-  public <T extends AbstractField> T set(T field) {
-    field.setDocValues(this);
-    return field;
-  }
-
-  /**
-   * Sets a new {@link PerDocFieldValues} instance on the given field with the
-   * given type and returns it.
-   * 
-   */
-  public static <T extends AbstractField> T set(T field, ValueType type) {
-    if (field instanceof DocValuesField)
-      return field;
-    final DocValuesField valField = new DocValuesField();
-    switch (type) {
-    case BYTES_FIXED_DEREF:
-    case BYTES_FIXED_SORTED:
-    case BYTES_FIXED_STRAIGHT:
-    case BYTES_VAR_DEREF:
-    case BYTES_VAR_SORTED:
-    case BYTES_VAR_STRAIGHT:
-      BytesRef ref = field.isBinary() ? new BytesRef(field.getBinaryValue(),
-          field.getBinaryOffset(), field.getBinaryLength()) : new BytesRef(
-          field.stringValue());
-      valField.setBytes(ref, type);
-      break;
-    case INTS:
-      valField.setInt(Long.parseLong(field.stringValue()));
-      break;
-    case FLOAT_32:
-      valField.setFloat(Float.parseFloat(field.stringValue()));
-      break;
-    case FLOAT_64:
-      valField.setFloat(Double.parseDouble(field.stringValue()));
-      break;
-    default:
-      throw new IllegalArgumentException("unknown type: " + type);
-    }
-    return valField.set(field);
-  }
-
-}
diff --git a/lucene/src/java/org/apache/lucene/document/IndexDocValuesField.java b/lucene/src/java/org/apache/lucene/document/IndexDocValuesField.java
new file mode 100644
index 0000000..997cde2
--- /dev/null
+++ b/lucene/src/java/org/apache/lucene/document/IndexDocValuesField.java
@@ -0,0 +1,286 @@
+package org.apache.lucene.document;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+import java.io.Reader;
+import java.util.Comparator;
+
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.document.Field.Index;
+import org.apache.lucene.document.Field.Store;
+import org.apache.lucene.document.Field.TermVector;
+import org.apache.lucene.index.values.PerDocFieldValues;
+import org.apache.lucene.index.values.ValueType;
+import org.apache.lucene.util.BytesRef;
+
+/**
+ * <p>
+ * This class provides a {@link AbstractField} that enables storing of typed
+ * per-document values for scoring, sorting or value retrieval. Here's an
+ * example usage, adding an int value:
+ * 
+ * <pre>
+ * document.add(new IndexDocValuesField(name).setInt(value));
+ * </pre>
+ * 
+ * For optimal performance, re-use the <code>DocValuesField</code> and
+ * {@link Document} instance for more than one document:
+ * 
+ * <pre>
+ *  IndexDocValuesField field = new IndexDocValuesField(name);
+ *  Document document = new Document();
+ *  document.add(field);
+ * 
+ *  for(all documents) {
+ *    ...
+ *    field.setInt(value)
+ *    writer.addDocument(document);
+ *    ...
+ *  }
+ * </pre>
+ * 
+ * <p>
+ * If doc values are stored in addition to an indexed ({@link Index}) or stored
+ * ({@link Store}) value it's recommended to use the {@link IndexDocValuesField}'s
+ * {@link #set(AbstractField)} API:
+ * 
+ * <pre>
+ *  IndexDocValuesField field = new IndexDocValuesField(name);
+ *  Field indexedField = new Field(name, stringValue, Stored.NO, Indexed.ANALYZED);
+ *  Document document = new Document();
+ *  document.add(indexedField);
+ *  field.set(indexedField);
+ *  for(all documents) {
+ *    ...
+ *    field.setInt(value)
+ *    writer.addDocument(document);
+ *    ...
+ *  }
+ * </pre>
+ * 
+ * */
+public class IndexDocValuesField extends AbstractField implements PerDocFieldValues {
+
+  protected BytesRef bytes;
+  protected double doubleValue;
+  protected long longValue;
+  protected ValueType type;
+  protected Comparator<BytesRef> bytesComparator;
+
+  /**
+   * Creates a new {@link IndexDocValuesField} with the given name.
+   */
+  public IndexDocValuesField(String name) {
+    super(name, Store.NO, Index.NO, TermVector.NO);
+    setDocValues(this);
+  }
+
+  /**
+   * Creates a {@link IndexDocValuesField} prototype
+   */
+  IndexDocValuesField() {
+    this("");
+  }
+
+  /**
+   * Sets the given <code>long</code> value and sets the field's {@link ValueType} to
+   * {@link ValueType#INTS} unless already set. If you want to change the
+   * default type use {@link #setType(ValueType)}.
+   */
+  public void setInt(long value) {
+    if (type == null) {
+      type = ValueType.INTS;
+    }
+    longValue = value;
+  }
+
+  /**
+   * Sets the given <code>float</code> value and sets the field's {@link ValueType}
+   * to {@link ValueType#FLOAT_32} unless already set. If you want to
+   * change the type use {@link #setType(ValueType)}.
+   */
+  public void setFloat(float value) {
+    if (type == null) {
+      type = ValueType.FLOAT_32;
+    }
+    doubleValue = value;
+  }
+
+  /**
+   * Sets the given <code>double</code> value and sets the field's {@link ValueType}
+   * to {@link ValueType#FLOAT_64} unless already set. If you want to
+   * change the default type use {@link #setType(ValueType)}.
+   */
+  public void setFloat(double value) {
+    if (type == null) {
+      type = ValueType.FLOAT_64;
+    }
+    doubleValue = value;
+  }
+
+  /**
+   * Sets the given {@link BytesRef} value and the field's {@link ValueType}. The
+   * comparator for this field is set to <code>null</code>. If a
+   * <code>null</code> comparator is set the default comparator for the given
+   * {@link ValueType} is used.
+   */
+  public void setBytes(BytesRef value, ValueType type) {
+    setBytes(value, type, null);
+  }
+
+  /**
+   * Sets the given {@link BytesRef} value, the field's {@link ValueType} and the
+   * field's comparator. If the {@link Comparator} is set to <code>null</code>
+   * the default for the given {@link ValueType} is used instead.
+   * 
+   * @throws IllegalArgumentException
+   *           if the value or the type are null
+   */
+  public void setBytes(BytesRef value, ValueType type, Comparator<BytesRef> comp) {
+    if (value == null) {
+      throw new IllegalArgumentException("value must not be null");
+    }
+    setType(type);
+    if (bytes == null) {
+      bytes = new BytesRef(value);
+    } else {
+      bytes.copy(value);
+    }
+    bytesComparator = comp;
+  }
+
+  /**
+   * Returns the set {@link BytesRef} or <code>null</code> if not set.
+   */
+  public BytesRef getBytes() {
+    return bytes;
+  }
+
+  /**
+   * Returns the set {@link BytesRef} comparator or <code>null</code> if not set
+   */
+  public Comparator<BytesRef> bytesComparator() {
+    return bytesComparator;
+  }
+
+  /**
+   * Returns the set floating point value or <code>0.0d</code> if not set.
+   */
+  public double getFloat() {
+    return doubleValue;
+  }
+
+  /**
+   * Returns the set <code>long</code> value of <code>0</code> if not set.
+   */
+  public long getInt() {
+    return longValue;
+  }
+
+  /**
+   * Sets the {@link BytesRef} comparator for this field. If the field has a
+   * numeric {@link ValueType} the comparator will be ignored.
+   */
+  public void setBytesComparator(Comparator<BytesRef> comp) {
+    this.bytesComparator = comp;
+  }
+
+  /**
+   * Sets the {@link ValueType} for this field.
+   */
+  public void setType(ValueType type) {
+    if (type == null) {
+      throw new IllegalArgumentException("Type must not be null");
+    }
+    this.type = type;
+  }
+
+  /**
+   * Returns the field's {@link ValueType}
+   */
+  public ValueType type() {
+    return type;
+  }
+
+  /**
+   * Returns always <code>null</code>
+   */
+  public Reader readerValue() {
+    return null;
+  }
+
+  /**
+   * Returns always <code>null</code>
+   */
+  public String stringValue() {
+    return null;
+  }
+
+  /**
+   * Returns always <code>null</code>
+   */
+  public TokenStream tokenStreamValue() {
+    return null;
+  }
+
+  /**
+   * Sets this {@link IndexDocValuesField} to the given {@link AbstractField} and
+   * returns the given field. Any modifications to this instance will be visible
+   * to the given field.
+   */
+  public <T extends AbstractField> T set(T field) {
+    field.setDocValues(this);
+    return field;
+  }
+
+  /**
+   * Sets a new {@link PerDocFieldValues} instance on the given field with the
+   * given type and returns it.
+   * 
+   */
+  public static <T extends AbstractField> T set(T field, ValueType type) {
+    if (field instanceof IndexDocValuesField)
+      return field;
+    final IndexDocValuesField valField = new IndexDocValuesField();
+    switch (type) {
+    case BYTES_FIXED_DEREF:
+    case BYTES_FIXED_SORTED:
+    case BYTES_FIXED_STRAIGHT:
+    case BYTES_VAR_DEREF:
+    case BYTES_VAR_SORTED:
+    case BYTES_VAR_STRAIGHT:
+      BytesRef ref = field.isBinary() ? new BytesRef(field.getBinaryValue(),
+          field.getBinaryOffset(), field.getBinaryLength()) : new BytesRef(
+          field.stringValue());
+      valField.setBytes(ref, type);
+      break;
+    case INTS:
+      valField.setInt(Long.parseLong(field.stringValue()));
+      break;
+    case FLOAT_32:
+      valField.setFloat(Float.parseFloat(field.stringValue()));
+      break;
+    case FLOAT_64:
+      valField.setFloat(Double.parseDouble(field.stringValue()));
+      break;
+    default:
+      throw new IllegalArgumentException("unknown type: " + type);
+    }
+    return valField.set(field);
+  }
+
+}
diff --git a/lucene/src/java/org/apache/lucene/index/CheckIndex.java b/lucene/src/java/org/apache/lucene/index/CheckIndex.java
index 1da3d4d..cc5d1d2 100644
--- a/lucene/src/java/org/apache/lucene/index/CheckIndex.java
+++ b/lucene/src/java/org/apache/lucene/index/CheckIndex.java
@@ -29,7 +29,7 @@ import org.apache.lucene.index.codecs.CodecProvider;
 import org.apache.lucene.index.codecs.DefaultSegmentInfosWriter;
 import org.apache.lucene.index.codecs.PerDocValues;
 import org.apache.lucene.index.values.IndexDocValues;
-import org.apache.lucene.index.values.DocValuesEnum;
+import org.apache.lucene.index.values.ValuesEnum;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
 
@@ -956,8 +956,8 @@ public class CheckIndex {
           if (docValues == null) {
             continue;
           }
-          final DocValuesEnum values = docValues.getEnum();
-          while (values.nextDoc() != DocValuesEnum.NO_MORE_DOCS) {
+          final ValuesEnum values = docValues.getEnum();
+          while (values.nextDoc() != ValuesEnum.NO_MORE_DOCS) {
             switch (fieldInfo.docValues) {
             case BYTES_FIXED_DEREF:
             case BYTES_FIXED_SORTED:
diff --git a/lucene/src/java/org/apache/lucene/index/DirectoryReader.java b/lucene/src/java/org/apache/lucene/index/DirectoryReader.java
index a5cbbfb..2b05adf 100644
--- a/lucene/src/java/org/apache/lucene/index/DirectoryReader.java
+++ b/lucene/src/java/org/apache/lucene/index/DirectoryReader.java
@@ -1026,6 +1026,6 @@ class DirectoryReader extends IndexReader implements Cloneable {
 
   @Override
   public PerDocValues perDocValues() throws IOException {
-    throw new UnsupportedOperationException("please use MultiPerDoc#getPerDocs, or wrap your IndexReader with SlowMultiReaderWrapper, if you really need a top level Fields");
+    throw new UnsupportedOperationException("please use MultiPerDocValues#getPerDocs, or wrap your IndexReader with SlowMultiReaderWrapper, if you really need a top level Fields");
   }
 }
diff --git a/lucene/src/java/org/apache/lucene/index/FieldsEnum.java b/lucene/src/java/org/apache/lucene/index/FieldsEnum.java
index 5d2d707..3fa3729 100644
--- a/lucene/src/java/org/apache/lucene/index/FieldsEnum.java
+++ b/lucene/src/java/org/apache/lucene/index/FieldsEnum.java
@@ -20,7 +20,7 @@ package org.apache.lucene.index;
 import java.io.IOException;
 
 import org.apache.lucene.index.values.IndexDocValues;
-import org.apache.lucene.index.values.DocValuesEnum;
+import org.apache.lucene.index.values.ValuesEnum;
 import org.apache.lucene.util.AttributeSource;
 
 /** Enumerates indexed fields.  You must first call {@link
diff --git a/lucene/src/java/org/apache/lucene/index/MultiFields.java b/lucene/src/java/org/apache/lucene/index/MultiFields.java
index 920bcf6..ffe1ac5 100644
--- a/lucene/src/java/org/apache/lucene/index/MultiFields.java
+++ b/lucene/src/java/org/apache/lucene/index/MultiFields.java
@@ -23,9 +23,9 @@ import java.util.List;
 import java.util.ArrayList;
 
 import org.apache.lucene.index.values.IndexDocValues;
-import org.apache.lucene.index.values.MultiDocValues;
+import org.apache.lucene.index.values.MultiIndexDocValues;
 import org.apache.lucene.index.values.ValueType;
-import org.apache.lucene.index.values.MultiDocValues.DocValuesIndex;
+import org.apache.lucene.index.values.MultiIndexDocValues.DocValuesIndex;
 import java.util.concurrent.ConcurrentHashMap;
 import org.apache.lucene.util.ReaderUtil;
 import org.apache.lucene.util.ReaderUtil.Gather;  // for javadocs
diff --git a/lucene/src/java/org/apache/lucene/index/MultiFieldsEnum.java b/lucene/src/java/org/apache/lucene/index/MultiFieldsEnum.java
index 173cd68..feaa617 100644
--- a/lucene/src/java/org/apache/lucene/index/MultiFieldsEnum.java
+++ b/lucene/src/java/org/apache/lucene/index/MultiFieldsEnum.java
@@ -17,7 +17,7 @@ package org.apache.lucene.index;
  * limitations under the License.
  */
 
-import org.apache.lucene.index.values.MultiDocValues;
+import org.apache.lucene.index.values.MultiIndexDocValues;
 import org.apache.lucene.util.PriorityQueue;
 import org.apache.lucene.util.ReaderUtil;
 
@@ -45,7 +45,7 @@ public final  class MultiFieldsEnum extends FieldsEnum {
 
   // Re-used TermsEnum
   private final MultiTermsEnum terms;
-  private final MultiDocValues docValues;
+  private final MultiIndexDocValues docValues;
 
 
   private String currentField;
@@ -55,7 +55,7 @@ public final  class MultiFieldsEnum extends FieldsEnum {
   public MultiFieldsEnum(FieldsEnum[] subs, ReaderUtil.Slice[] subSlices) throws IOException {
     terms = new MultiTermsEnum(subSlices);
     queue = new FieldMergeQueue(subs.length);
-    docValues = new MultiDocValues();
+    docValues = new MultiIndexDocValues();
     top = new FieldsEnumWithSlice[subs.length];
     List<FieldsEnumWithSlice> enumWithSlices = new ArrayList<FieldsEnumWithSlice>();
 
diff --git a/lucene/src/java/org/apache/lucene/index/MultiPerDocValues.java b/lucene/src/java/org/apache/lucene/index/MultiPerDocValues.java
index d4a5c06..34397fb 100644
--- a/lucene/src/java/org/apache/lucene/index/MultiPerDocValues.java
+++ b/lucene/src/java/org/apache/lucene/index/MultiPerDocValues.java
@@ -25,9 +25,9 @@ import java.util.concurrent.ConcurrentHashMap;
 
 import org.apache.lucene.index.codecs.PerDocValues;
 import org.apache.lucene.index.values.IndexDocValues;
-import org.apache.lucene.index.values.MultiDocValues;
+import org.apache.lucene.index.values.MultiIndexDocValues;
 import org.apache.lucene.index.values.ValueType;
-import org.apache.lucene.index.values.MultiDocValues.DocValuesIndex;
+import org.apache.lucene.index.values.MultiIndexDocValues.DocValuesIndex;
 import org.apache.lucene.util.ReaderUtil;
 import org.apache.lucene.util.ReaderUtil.Gather;
 
@@ -115,7 +115,7 @@ public class MultiPerDocValues extends PerDocValues {
     if (result == null) {
       // Lazy init: first time this field is requested, we
       // create & add to docValues:
-      final List<MultiDocValues.DocValuesIndex> docValuesIndex = new ArrayList<MultiDocValues.DocValuesIndex>();
+      final List<MultiIndexDocValues.DocValuesIndex> docValuesIndex = new ArrayList<MultiIndexDocValues.DocValuesIndex>();
       int docsUpto = 0;
       ValueType type = null;
       // Gather all sub-readers that share this field
@@ -126,24 +126,24 @@ public class MultiPerDocValues extends PerDocValues {
         if (values != null) {
           if (docsUpto != start) {
             type = values.type();
-            docValuesIndex.add(new MultiDocValues.DocValuesIndex(
-                new MultiDocValues.DummyDocValues(start, type), docsUpto, start
+            docValuesIndex.add(new MultiIndexDocValues.DocValuesIndex(
+                new MultiIndexDocValues.DummyDocValues(start, type), docsUpto, start
                     - docsUpto));
           }
-          docValuesIndex.add(new MultiDocValues.DocValuesIndex(values, start,
+          docValuesIndex.add(new MultiIndexDocValues.DocValuesIndex(values, start,
               length));
           docsUpto = start + length;
 
         } else if (i + 1 == subs.length && !docValuesIndex.isEmpty()) {
-          docValuesIndex.add(new MultiDocValues.DocValuesIndex(
-              new MultiDocValues.DummyDocValues(start, type), docsUpto, start
+          docValuesIndex.add(new MultiIndexDocValues.DocValuesIndex(
+              new MultiIndexDocValues.DummyDocValues(start, type), docsUpto, start
                   - docsUpto));
         }
       }
       if (docValuesIndex.isEmpty()) {
         return null;
       }
-      result = new MultiDocValues(
+      result = new MultiIndexDocValues(
           docValuesIndex.toArray(DocValuesIndex.EMPTY_ARRAY));
       docValues.put(field, result);
     }
diff --git a/lucene/src/java/org/apache/lucene/index/MultiReader.java b/lucene/src/java/org/apache/lucene/index/MultiReader.java
index 7a943fa..a674709 100644
--- a/lucene/src/java/org/apache/lucene/index/MultiReader.java
+++ b/lucene/src/java/org/apache/lucene/index/MultiReader.java
@@ -407,6 +407,6 @@ public class MultiReader extends IndexReader implements Cloneable {
 
   @Override
   public PerDocValues perDocValues() throws IOException {
-    throw new UnsupportedOperationException("please use MultiPerDoc#getPerDocs, or wrap your IndexReader with SlowMultiReaderWrapper, if you really need a top level Fields");
+    throw new UnsupportedOperationException("please use MultiPerDocValues#getPerDocs, or wrap your IndexReader with SlowMultiReaderWrapper, if you really need a top level Fields");
   }
 }
diff --git a/lucene/src/java/org/apache/lucene/index/values/Bytes.java b/lucene/src/java/org/apache/lucene/index/values/Bytes.java
index cddc69e..0944fc9 100644
--- a/lucene/src/java/org/apache/lucene/index/values/Bytes.java
+++ b/lucene/src/java/org/apache/lucene/index/values/Bytes.java
@@ -223,7 +223,7 @@ public final class Bytes {
     protected abstract int maxDoc();
 
     @Override
-    public DocValuesEnum getEnum(AttributeSource attrSource) throws IOException {
+    public ValuesEnum getEnum(AttributeSource attrSource) throws IOException {
       return new SourceEnum(attrSource, type(), this, maxDoc()) {
         @Override
         public int advance(int target) throws IOException {
@@ -315,7 +315,7 @@ public final class Bytes {
     }
 
     @Override
-    public DocValuesEnum getEnum(AttributeSource attrSource) throws IOException {
+    public ValuesEnum getEnum(AttributeSource attrSource) throws IOException {
       return new SourceEnum(attrSource, type(), this, maxDoc()) {
 
         @Override
@@ -400,7 +400,7 @@ public final class Bytes {
     }
 
     @Override
-    protected void setNextEnum(DocValuesEnum valuesEnum) {
+    protected void setNextEnum(ValuesEnum valuesEnum) {
       bytesRef = valuesEnum.bytes();
     }
 
diff --git a/lucene/src/java/org/apache/lucene/index/values/DocValuesEnum.java b/lucene/src/java/org/apache/lucene/index/values/DocValuesEnum.java
deleted file mode 100644
index 2c9ef2b..0000000
--- a/lucene/src/java/org/apache/lucene/index/values/DocValuesEnum.java
+++ /dev/null
@@ -1,173 +0,0 @@
-package org.apache.lucene.index.values;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-import java.io.IOException;
-
-import org.apache.lucene.search.DocIdSetIterator;
-import org.apache.lucene.util.AttributeSource;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.FloatsRef;
-import org.apache.lucene.util.LongsRef;
-
-/**
- * {@link DocValuesEnum} is a {@link DocIdSetIterator} iterating <tt>byte[]</tt>
- * , <tt>long</tt> and <tt>double</tt> stored per document. Depending on the
- * enum's {@link ValueType} ({@link #type()}) the enum might skip over documents that
- * have no value stored. Types like {@link ValueType#BYTES_VAR_STRAIGHT} might not
- * skip over documents even if there is no value associated with a document. The
- * value for document without values again depends on the types implementation
- * although a reference for a {@link ValueType} returned from a accessor method
- * {@link #getFloat()}, {@link #getInt()} or {@link #bytes()} will never be
- * <code>null</code> even if a document has no value.
- * <p>
- * Note: Only the reference for the enum's type are initialized to non
- * <code>null</code> ie. {@link #getInt()} will always return <code>null</code>
- * if the enum's Type is {@link ValueType#FLOAT_32}.
- * 
- * @lucene.experimental
- */
-public abstract class DocValuesEnum extends DocIdSetIterator {
-  private AttributeSource source;
-  private final ValueType enumType;
-  protected BytesRef bytesRef;
-  protected FloatsRef floatsRef;
-  protected LongsRef intsRef;
-
-  /**
-   * Creates a new {@link DocValuesEnum} for the given type. The
-   * {@link AttributeSource} for this enum is set to <code>null</code>
-   */
-  protected DocValuesEnum(ValueType enumType) {
-    this(null, enumType);
-  }
-
-  /**
-   * Creates a new {@link DocValuesEnum} for the given type.
-   */
-  protected DocValuesEnum(AttributeSource source, ValueType enumType) {
-    this.source = source;
-    this.enumType = enumType;
-    switch (enumType) {
-    case BYTES_FIXED_DEREF:
-    case BYTES_FIXED_SORTED:
-    case BYTES_FIXED_STRAIGHT:
-    case BYTES_VAR_DEREF:
-    case BYTES_VAR_SORTED:
-    case BYTES_VAR_STRAIGHT:
-      bytesRef = new BytesRef();
-      break;
-    case INTS:
-      intsRef = new LongsRef(1);
-      break;
-    case FLOAT_32:
-    case FLOAT_64:
-      floatsRef = new FloatsRef(1);
-      break;
-    }
-  }
-
-  /**
-   * Returns the type of this enum
-   */
-  public ValueType type() {
-    return enumType;
-  }
-
-  /**
-   * Returns a {@link BytesRef} or <code>null</code> if this enum doesn't
-   * enumerate byte[] values
-   */
-  public BytesRef bytes() {
-    return bytesRef;
-  }
-
-  /**
-   * Returns a {@link FloatsRef} or <code>null</code> if this enum doesn't
-   * enumerate floating point values
-   */
-  public FloatsRef getFloat() {
-    return floatsRef;
-  }
-
-  /**
-   * Returns a {@link LongsRef} or <code>null</code> if this enum doesn't
-   * enumerate integer values.
-   */
-  public LongsRef getInt() {
-    return intsRef;
-  }
-
-  /**
-   * Copies the internal state from the given enum
-   */
-  protected void copyFrom(DocValuesEnum valuesEnum) {
-    intsRef = valuesEnum.intsRef;
-    floatsRef = valuesEnum.floatsRef;
-    bytesRef = valuesEnum.bytesRef;
-    source = valuesEnum.source;
-  }
-
-  /**
-   * Returns the {@link AttributeSource} associated with this enum.
-   * <p>
-   * Note: this method might create a new AttribueSource if no
-   * {@link AttributeSource} has been provided during enum creation.
-   */
-  public AttributeSource attributes() {
-    if (source == null) {
-      source = new AttributeSource();
-    }
-    return source;
-  }
-
-  /**
-   * Closes the enum
-   * 
-   * @throws IOException
-   *           if an {@link IOException} occurs
-   */
-  public abstract void close() throws IOException;
-
-  /**
-   * Returns an empty {@link DocValuesEnum} for the given {@link ValueType}.
-   */
-  public static DocValuesEnum emptyEnum(ValueType type) {
-    return new DocValuesEnum(type) {
-      @Override
-      public int nextDoc() throws IOException {
-        return NO_MORE_DOCS;
-      }
-
-      @Override
-      public int docID() {
-        return NO_MORE_DOCS;
-      }
-
-      @Override
-      public int advance(int target) throws IOException {
-        return NO_MORE_DOCS;
-      }
-
-      @Override
-      public void close() throws IOException {
-
-      }
-    };
-  }
-
-}
diff --git a/lucene/src/java/org/apache/lucene/index/values/FixedDerefBytesImpl.java b/lucene/src/java/org/apache/lucene/index/values/FixedDerefBytesImpl.java
index 5513e4e..20f2e32 100644
--- a/lucene/src/java/org/apache/lucene/index/values/FixedDerefBytesImpl.java
+++ b/lucene/src/java/org/apache/lucene/index/values/FixedDerefBytesImpl.java
@@ -184,11 +184,11 @@ class FixedDerefBytesImpl {
     }
 
     @Override
-    public DocValuesEnum getEnum(AttributeSource source) throws IOException {
+    public ValuesEnum getEnum(AttributeSource source) throws IOException {
       return new DerefBytesEnum(source, cloneData(), cloneIndex(), size);
     }
 
-    static class DerefBytesEnum extends DocValuesEnum {
+    static class DerefBytesEnum extends ValuesEnum {
       protected final IndexInput datIn;
       private final PackedInts.ReaderIterator idx;
       protected final long fp;
@@ -215,7 +215,7 @@ class FixedDerefBytesImpl {
         valueCount = idx.size();
       }
 
-      protected void copyFrom(DocValuesEnum valuesEnum) {
+      protected void copyFrom(ValuesEnum valuesEnum) {
         bytesRef = valuesEnum.bytesRef;
         if (bytesRef.bytes.length < size) {
           bytesRef.grow(size);
diff --git a/lucene/src/java/org/apache/lucene/index/values/FixedSortedBytesImpl.java b/lucene/src/java/org/apache/lucene/index/values/FixedSortedBytesImpl.java
index b5ba7e8..3a32f98 100644
--- a/lucene/src/java/org/apache/lucene/index/values/FixedSortedBytesImpl.java
+++ b/lucene/src/java/org/apache/lucene/index/values/FixedSortedBytesImpl.java
@@ -229,7 +229,7 @@ class FixedSortedBytesImpl {
     }
 
     @Override
-    public DocValuesEnum getEnum(AttributeSource source) throws IOException {
+    public ValuesEnum getEnum(AttributeSource source) throws IOException {
       // do unsorted
       return new DerefBytesEnum(source, cloneData(), cloneIndex(), size);
     }
diff --git a/lucene/src/java/org/apache/lucene/index/values/FixedStraightBytesImpl.java b/lucene/src/java/org/apache/lucene/index/values/FixedStraightBytesImpl.java
index a28e7d2..7b1e167 100644
--- a/lucene/src/java/org/apache/lucene/index/values/FixedStraightBytesImpl.java
+++ b/lucene/src/java/org/apache/lucene/index/values/FixedStraightBytesImpl.java
@@ -180,11 +180,11 @@ class FixedStraightBytesImpl {
     }
 
     @Override
-    public DocValuesEnum getEnum(AttributeSource source) throws IOException {
+    public ValuesEnum getEnum(AttributeSource source) throws IOException {
       return new FixedStraightBytesEnum(source, cloneData(), size, maxDoc);
     }
 
-    private static final class FixedStraightBytesEnum extends DocValuesEnum {
+    private static final class FixedStraightBytesEnum extends ValuesEnum {
       private final IndexInput datIn;
       private final int size;
       private final int maxDoc;
@@ -203,7 +203,7 @@ class FixedStraightBytesImpl {
         fp = datIn.getFilePointer();
       }
 
-      protected void copyFrom(DocValuesEnum valuesEnum) {
+      protected void copyFrom(ValuesEnum valuesEnum) {
         bytesRef = valuesEnum.bytesRef;
         if (bytesRef.bytes.length < size) {
           bytesRef.grow(size);
diff --git a/lucene/src/java/org/apache/lucene/index/values/Floats.java b/lucene/src/java/org/apache/lucene/index/values/Floats.java
index 52a1f2f..efe26b8 100644
--- a/lucene/src/java/org/apache/lucene/index/values/Floats.java
+++ b/lucene/src/java/org/apache/lucene/index/values/Floats.java
@@ -111,7 +111,7 @@ public class Floats {
     }
 
     @Override
-    protected void setNextEnum(DocValuesEnum valuesEnum) {
+    protected void setNextEnum(ValuesEnum valuesEnum) {
       floatsRef = valuesEnum.getFloat();
     }
 
@@ -305,7 +305,7 @@ public class Floats {
       }
 
       @Override
-      public DocValuesEnum getEnum(AttributeSource attrSource)
+      public ValuesEnum getEnum(AttributeSource attrSource)
           throws IOException {
         return new SourceEnum(attrSource, ValueType.FLOAT_32, this, maxDoc) {
           @Override
@@ -337,7 +337,7 @@ public class Floats {
       }
 
       @Override
-      public DocValuesEnum getEnum(AttributeSource attrSource)
+      public ValuesEnum getEnum(AttributeSource attrSource)
           throws IOException {
         return new SourceEnum(attrSource, type(), this, maxDoc) {
           @Override
@@ -363,7 +363,7 @@ public class Floats {
     }
 
     @Override
-    public DocValuesEnum getEnum(AttributeSource source) throws IOException {
+    public ValuesEnum getEnum(AttributeSource source) throws IOException {
       IndexInput indexInput = (IndexInput) datIn.clone();
       indexInput.seek(CodecUtil.headerLength(CODEC_NAME));
       // skip precision:
@@ -443,7 +443,7 @@ public class Floats {
     }
   }
 
-  static abstract class FloatsEnumImpl extends DocValuesEnum {
+  static abstract class FloatsEnumImpl extends ValuesEnum {
     protected final IndexInput dataIn;
     protected int pos = -1;
     protected final int precision;
diff --git a/lucene/src/java/org/apache/lucene/index/values/IndexDocValues.java b/lucene/src/java/org/apache/lucene/index/values/IndexDocValues.java
index e4d68bc..3288567 100644
--- a/lucene/src/java/org/apache/lucene/index/values/IndexDocValues.java
+++ b/lucene/src/java/org/apache/lucene/index/values/IndexDocValues.java
@@ -20,15 +20,35 @@ import java.io.Closeable;
 import java.io.IOException;
 import java.util.Comparator;
 
+import org.apache.lucene.document.IndexDocValuesField;
 import org.apache.lucene.index.Fields;
 import org.apache.lucene.index.FieldsEnum;
 import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.codecs.Codec;
+import org.apache.lucene.index.codecs.CodecProvider;
 import org.apache.lucene.util.AttributeSource;
 import org.apache.lucene.util.BytesRef;
 
 /**
- * nocommit - javadoc 
+ * {@link IndexDocValues} provides a dense per-document typed storage for fast
+ * value access based on the lucene internal document id. {@link IndexDocValues}
+ * exposes two distinct APIs:
+ * <ul>
+ * <li>via {@link Source} an entirely RAM resident API for random access</li>
+ * <li>via {@link ValuesEnum} a disk resident API for sequential access</li>
+ * </ul> {@link IndexDocValues} are exposed via
+ * {@link IndexReader#perDocValues()} on a per-segment basis. For best
+ * performance {@link IndexDocValues} should be consumed per-segment just like
+ * IndexReader.
+ * <p>
+ * {@link IndexDocValues} are fully integrated into the {@link Codec} API.
+ * Custom implementations can be exposed on a per field basis via
+ * {@link CodecProvider}.
  * 
+ * @see ValueType for limitations and default implementation documentation
+ * @see IndexDocValuesField for adding values to the index
+ * @see Codec#docsConsumer(org.apache.lucene.index.PerDocWriteState) for
+ *      customization
  * @lucene.experimental
  */
 public abstract class IndexDocValues implements Closeable {
@@ -45,23 +65,23 @@ public abstract class IndexDocValues implements Closeable {
 
   /**
    * Returns an iterator that steps through all documents values for this
-   * {@link IndexDocValues} field instance. {@link DocValuesEnum} will skip document
+   * {@link IndexDocValues} field instance. {@link ValuesEnum} will skip document
    * without a value if applicable.
    */
-  public DocValuesEnum getEnum() throws IOException {
+  public ValuesEnum getEnum() throws IOException {
     return getEnum(null);
   }
 
   /**
    * Returns an iterator that steps through all documents values for this
-   * {@link IndexDocValues} field instance. {@link DocValuesEnum} will skip document
+   * {@link IndexDocValues} field instance. {@link ValuesEnum} will skip document
    * without a value if applicable.
    * <p>
    * If an {@link AttributeSource} is supplied to this method the
-   * {@link DocValuesEnum} will use the given source to access implementation
+   * {@link ValuesEnum} will use the given source to access implementation
    * related attributes.
    */
-  public abstract DocValuesEnum getEnum(AttributeSource attrSource)
+  public abstract ValuesEnum getEnum(AttributeSource attrSource)
       throws IOException;
 
   /**
@@ -215,9 +235,9 @@ public abstract class IndexDocValues implements Closeable {
     }
 
     /**
-     * Returns a {@link DocValuesEnum} for this source.
+     * Returns a {@link ValuesEnum} for this source.
      */
-    public DocValuesEnum getEnum() throws IOException {
+    public ValuesEnum getEnum() throws IOException {
       return getEnum(null);
     }
 
@@ -229,18 +249,18 @@ public abstract class IndexDocValues implements Closeable {
     public abstract ValueType type();
 
     /**
-     * Returns a {@link DocValuesEnum} for this source which uses the given
+     * Returns a {@link ValuesEnum} for this source which uses the given
      * {@link AttributeSource}.
      */
-    public abstract DocValuesEnum getEnum(AttributeSource attrSource)
+    public abstract ValuesEnum getEnum(AttributeSource attrSource)
         throws IOException;
   }
 
   /**
-   * {@link DocValuesEnum} utility for {@link Source} implemenations.
+   * {@link ValuesEnum} utility for {@link Source} implemenations.
    * 
    */
-  public abstract static class SourceEnum extends DocValuesEnum {
+  public abstract static class SourceEnum extends ValuesEnum {
     protected final Source source;
     protected final int numDocs;
     protected int pos = -1;
@@ -284,7 +304,7 @@ public abstract class IndexDocValues implements Closeable {
   /**
    * A sorted variant of {@link Source} for <tt>byte[]</tt> values per document.
    * <p>
-   * Note: {@link DocValuesEnum} obtained from a {@link SortedSource} will
+   * Note: {@link ValuesEnum} obtained from a {@link SortedSource} will
    * enumerate values in document order and not in sorted order.
    */
   public static abstract class SortedSource extends Source {
diff --git a/lucene/src/java/org/apache/lucene/index/values/Ints.java b/lucene/src/java/org/apache/lucene/index/values/Ints.java
index d11b548..d3cf103 100644
--- a/lucene/src/java/org/apache/lucene/index/values/Ints.java
+++ b/lucene/src/java/org/apache/lucene/index/values/Ints.java
@@ -20,8 +20,8 @@ package org.apache.lucene.index.values;
 import java.io.IOException;
 import java.util.concurrent.atomic.AtomicLong;
 
-import org.apache.lucene.index.values.PackedIntsImpl.IntsReader;
-import org.apache.lucene.index.values.PackedIntsImpl.IntsWriter;
+import org.apache.lucene.index.values.IntsImpl.IntsReader;
+import org.apache.lucene.index.values.IntsImpl.IntsWriter;
 import org.apache.lucene.store.Directory;
 
 /**
diff --git a/lucene/src/java/org/apache/lucene/index/values/IntsImpl.java b/lucene/src/java/org/apache/lucene/index/values/IntsImpl.java
new file mode 100644
index 0000000..af93a52
--- /dev/null
+++ b/lucene/src/java/org/apache/lucene/index/values/IntsImpl.java
@@ -0,0 +1,430 @@
+package org.apache.lucene.index.values;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+import java.io.IOException;
+import java.util.Collection;
+import java.util.concurrent.atomic.AtomicLong;
+
+import org.apache.lucene.index.IndexFileNames;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IndexInput;
+import org.apache.lucene.store.IndexOutput;
+import org.apache.lucene.util.ArrayUtil;
+import org.apache.lucene.util.AttributeSource;
+import org.apache.lucene.util.CodecUtil;
+import org.apache.lucene.util.IOUtils;
+import org.apache.lucene.util.LongsRef;
+import org.apache.lucene.util.RamUsageEstimator;
+import org.apache.lucene.util.packed.PackedInts;
+
+/**
+ * Stores ints packed with fixed-bit precision.
+ * 
+ * @lucene.experimental
+ * */
+class IntsImpl {
+
+  private static final String CODEC_NAME = "Ints";
+  private static final byte PACKED = 0x00;
+  private static final byte FIXED = 0x01;
+
+  static final int VERSION_START = 0;
+  static final int VERSION_CURRENT = VERSION_START;
+
+  static class IntsWriter extends Writer {
+
+    // TODO: can we bulkcopy this on a merge?
+    private LongsRef intsRef;
+    private long[] docToValue;
+    private long minValue;
+    private long maxValue;
+    private boolean started;
+    private final String id;
+    private int lastDocId = -1;
+    private IndexOutput datOut;
+
+    protected IntsWriter(Directory dir, String id, AtomicLong bytesUsed)
+        throws IOException {
+      super(bytesUsed);
+      datOut = dir.createOutput(IndexFileNames.segmentFileName(id, "",
+          DATA_EXTENSION));
+      boolean success = false;
+      try {
+        CodecUtil.writeHeader(datOut, CODEC_NAME, VERSION_CURRENT);
+        this.id = id;
+        docToValue = new long[1];
+        bytesUsed.addAndGet(RamUsageEstimator.NUM_BYTES_LONG); // TODO the
+                                                               // bitset
+                                                               // needs memory
+                                                               // too
+        success = true;
+      } finally {
+        if (!success) {
+          datOut.close();
+        }
+      }
+    }
+
+    @Override
+    public void add(int docID, long v) throws IOException {
+      assert lastDocId < docID;
+      if (!started) {
+        started = true;
+        minValue = maxValue = v;
+      } else {
+        if (v < minValue) {
+          minValue = v;
+        } else if (v > maxValue) {
+          maxValue = v;
+        }
+      }
+      lastDocId = docID;
+
+      if (docID >= docToValue.length) {
+        final long len = docToValue.length;
+        docToValue = ArrayUtil.grow(docToValue, 1 + docID);
+        bytesUsed.addAndGet(RamUsageEstimator.NUM_BYTES_LONG
+            * ((docToValue.length) - len));
+      }
+      docToValue[docID] = v;
+    }
+
+    @Override
+    public void finish(int docCount) throws IOException {
+      try {
+        if (!started) {
+          minValue = maxValue = 0;
+        }
+        // if we exceed the range of positive longs we must switch to fixed ints
+        if ((maxValue - minValue) < (((long)1) << 63) && (maxValue - minValue) > 0) {
+          writePackedInts(docCount);
+        } else {
+          writeFixedInts(docCount);
+        }
+
+      } finally {
+        datOut.close();
+        bytesUsed
+            .addAndGet(-(RamUsageEstimator.NUM_BYTES_LONG * docToValue.length));
+        docToValue = null;
+      }
+    }
+
+    private void writeFixedInts(int docCount) throws IOException {
+      datOut.writeByte(FIXED);
+      datOut.writeInt(docCount);
+      for (int i = 0; i < docToValue.length; i++) {
+        datOut.writeLong(docToValue[i]); // write full array - we use 0 as default
+      }
+      for (int i = docToValue.length; i < docCount; i++) {
+        datOut.writeLong(0); // fill with defaults values
+      }
+    }
+
+    private void writePackedInts(int docCount) throws IOException {
+      datOut.writeByte(PACKED);
+      // TODO -- long can't work right since it's signed
+      datOut.writeLong(minValue);
+      // write a default value to recognize docs without a value for that
+      // field
+      final long defaultValue = maxValue>= 0 && minValue <=0 ? 0-minValue : ++maxValue-minValue;
+      datOut.writeLong(defaultValue);
+      PackedInts.Writer w = PackedInts.getWriter(datOut, docCount,
+          PackedInts.bitsRequired(maxValue-minValue));
+      final int limit = docToValue.length > docCount ? docCount : docToValue.length;
+      for (int i = 0; i < limit; i++) {
+        w.add(docToValue[i] == 0 ? defaultValue : docToValue[i] - minValue);
+      }
+      for (int i = limit; i < docCount; i++) {
+        w.add(defaultValue);
+      }
+      
+      w.finish();
+    }
+
+    @Override
+    protected void add(int docID) throws IOException {
+      add(docID, intsRef.get());
+    }
+
+    @Override
+    protected void setNextEnum(ValuesEnum valuesEnum) {
+      intsRef = valuesEnum.getInt();
+    }
+
+    @Override
+    public void add(int docID, PerDocFieldValues docValues) throws IOException {
+      add(docID, docValues.getInt());
+    }
+
+    @Override
+    public void files(Collection<String> files) throws IOException {
+      files.add(IndexFileNames.segmentFileName(id, "", DATA_EXTENSION));
+    }
+  }
+
+  /**
+   * Opens all necessary files, but does not read any data in until you call
+   * {@link #load}.
+   */
+  static class IntsReader extends IndexDocValues {
+    private final IndexInput datIn;
+    private final boolean packed;
+
+    protected IntsReader(Directory dir, String id) throws IOException {
+      datIn = dir.openInput(IndexFileNames.segmentFileName(id, "",
+          Writer.DATA_EXTENSION));
+      boolean success = false;
+      try {
+        CodecUtil.checkHeader(datIn, CODEC_NAME, VERSION_START, VERSION_START);
+        packed = PACKED == datIn.readByte();
+        success = true;
+      } finally {
+        if (!success) {
+          IOUtils.closeSafely(true, datIn);
+        }
+      }
+    }
+
+    /**
+     * Loads the actual values. You may call this more than once, eg if you
+     * already previously loaded but then discarded the Source.
+     */
+    @Override
+    public Source load() throws IOException {
+      final IndexInput input = (IndexInput) datIn.clone();
+      boolean success = false;
+      try {
+        final Source source = packed ? new PackedIntsSource(input)
+            : new FixedIntsSource(input);
+        success = true;
+        return source;
+      } finally {
+        if (!success) {
+          IOUtils.closeSafely(true, datIn);
+        }
+      }
+    }
+    
+    private static class FixedIntsSource extends Source {
+      private final long[] values;
+      public FixedIntsSource(IndexInput dataIn) throws IOException {
+        dataIn.seek(CodecUtil.headerLength(CODEC_NAME) + 1);
+        final int numDocs = dataIn.readInt();
+        values = new long[numDocs];
+        for (int i = 0; i < values.length; i++) {
+          values[i] = dataIn.readLong();
+        }
+      }
+      
+      @Override
+      public long getInt(int docID) {
+        assert docID >= 0 && docID < values.length;
+        return values[docID];
+      }
+
+      @Override
+      public ValueType type() {
+        return ValueType.INTS;
+      }
+
+      @Override
+      public ValuesEnum getEnum(AttributeSource attrSource)
+          throws IOException {
+        return new SourceEnum(attrSource, type(), this, values.length) {
+          
+          @Override
+          public int advance(int target) throws IOException {
+            if (target >= numDocs)
+              return pos = NO_MORE_DOCS;
+            intsRef.ints[intsRef.offset] = values[target];
+            return pos = target;
+          }
+        };
+      }
+      
+    }
+
+    private static class PackedIntsSource extends Source {
+      private final long minValue;
+      private final long defaultValue;
+      private final PackedInts.Reader values;
+
+      public PackedIntsSource(IndexInput dataIn) throws IOException {
+        dataIn.seek(CodecUtil.headerLength(CODEC_NAME) + 1);
+        minValue = dataIn.readLong();
+        defaultValue = dataIn.readLong();
+        values = PackedInts.getReader(dataIn);
+      }
+
+      @Override
+      public long getInt(int docID) {
+        // TODO -- can we somehow avoid 2X method calls
+        // on each get? must push minValue down, and make
+        // PackedInts implement Ints.Source
+        assert docID >= 0;
+        final long value = values.get(docID);
+        return value == defaultValue ? 0 : minValue + value;
+      }
+
+      @Override
+      public ValuesEnum getEnum(AttributeSource attrSource)
+          throws IOException {
+        return new SourceEnum(attrSource, type(), this, values.size()) {
+          @Override
+          public int advance(int target) throws IOException {
+            if (target >= numDocs)
+              return pos = NO_MORE_DOCS;
+            intsRef.ints[intsRef.offset] = source.getInt(target);
+            return pos = target;
+          }
+        };
+      }
+
+      @Override
+      public ValueType type() {
+        return ValueType.INTS;
+      }
+    }
+
+    @Override
+    public void close() throws IOException {
+      super.close();
+      datIn.close();
+    }
+
+    @Override
+    public ValuesEnum getEnum(AttributeSource source) throws IOException {
+      final IndexInput input = (IndexInput) datIn.clone();
+      boolean success = false;
+      try {
+        ValuesEnum inst = packed ? new PackedIntsEnumImpl(source, input)
+            : new FixedIntsEnumImpl(source, input);
+        success = true;
+        return inst;
+      } finally {
+        if (!success) {
+          IOUtils.closeSafely(true, input);
+        }
+      }
+    }
+
+    @Override
+    public ValueType type() {
+      return ValueType.INTS;
+    }
+
+  }
+
+  private static final class PackedIntsEnumImpl extends ValuesEnum {
+    private final PackedInts.ReaderIterator ints;
+    private long minValue;
+    private final IndexInput dataIn;
+    private final long defaultValue;
+    private final int maxDoc;
+    private int pos = -1;
+
+    private PackedIntsEnumImpl(AttributeSource source, IndexInput dataIn)
+        throws IOException {
+      super(source, ValueType.INTS);
+      intsRef.offset = 0;
+      this.dataIn = dataIn;
+      dataIn.seek(CodecUtil.headerLength(CODEC_NAME) + 1);
+      minValue = dataIn.readLong();
+      defaultValue = dataIn.readLong();
+      this.ints = PackedInts.getReaderIterator(dataIn);
+      maxDoc = ints.size();
+    }
+
+    @Override
+    public void close() throws IOException {
+      ints.close();
+      dataIn.close();
+    }
+
+    @Override
+    public int advance(int target) throws IOException {
+      if (target >= maxDoc) {
+        return pos = NO_MORE_DOCS;
+      }
+      final long val = ints.advance(target);
+      intsRef.ints[intsRef.offset] = val == defaultValue ? 0 : minValue + val;
+      return pos = target;
+    }
+
+    @Override
+    public int docID() {
+      return pos;
+    }
+
+    @Override
+    public int nextDoc() throws IOException {
+      if (pos >= maxDoc) {
+        return pos = NO_MORE_DOCS;
+      }
+      return advance(pos + 1);
+    }
+  }
+  
+  private static final class FixedIntsEnumImpl extends ValuesEnum {
+    private final IndexInput dataIn;
+    private final int maxDoc;
+    private int pos = -1;
+
+    private FixedIntsEnumImpl(AttributeSource source, IndexInput dataIn)
+        throws IOException {
+      super(source, ValueType.INTS);
+      intsRef.offset = 0;
+      this.dataIn = dataIn;
+      dataIn.seek(CodecUtil.headerLength(CODEC_NAME) + 1);
+      maxDoc = dataIn.readInt();
+    }
+
+    @Override
+    public void close() throws IOException {
+      dataIn.close();
+    }
+
+    @Override
+    public int advance(int target) throws IOException {
+      if (target >= maxDoc) {
+        return pos = NO_MORE_DOCS;
+      }
+      assert target > pos;
+      if (target > pos+1) {
+        dataIn.seek(dataIn.getFilePointer() + ((target - pos - 1) * 8));
+      }
+      intsRef.ints[intsRef.offset] = dataIn.readLong();
+      return pos = target;
+    }
+
+    @Override
+    public int docID() {
+      return pos;
+    }
+
+    @Override
+    public int nextDoc() throws IOException {
+      if (pos >= maxDoc) {
+        return pos = NO_MORE_DOCS;
+      }
+      return advance(pos + 1);
+    }
+  }
+ 
+}
\ No newline at end of file
diff --git a/lucene/src/java/org/apache/lucene/index/values/MultiDocValues.java b/lucene/src/java/org/apache/lucene/index/values/MultiDocValues.java
deleted file mode 100644
index 3187d80..0000000
--- a/lucene/src/java/org/apache/lucene/index/values/MultiDocValues.java
+++ /dev/null
@@ -1,275 +0,0 @@
-package org.apache.lucene.index.values;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-import java.io.IOException;
-import java.util.Arrays;
-
-import org.apache.lucene.util.AttributeSource;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.ReaderUtil;
-
-/**
- * @lucene.experimental
- */
-public class MultiDocValues extends IndexDocValues {
-
-  public static class DocValuesIndex {
-    public final static DocValuesIndex[] EMPTY_ARRAY = new DocValuesIndex[0];
-    final int start;
-    final int length;
-    final IndexDocValues docValues;
-
-    public DocValuesIndex(IndexDocValues docValues, int start, int length) {
-      this.docValues = docValues;
-      this.start = start;
-      this.length = length;
-    }
-  }
-
-  private DocValuesIndex[] docValuesIdx;
-  private int[] starts;
-
-  public MultiDocValues() {
-    starts = new int[0];
-    docValuesIdx = new DocValuesIndex[0];
-  }
-
-  public MultiDocValues(DocValuesIndex[] docValuesIdx) {
-    reset(docValuesIdx);
-  }
-
-  @Override
-  public DocValuesEnum getEnum(AttributeSource source) throws IOException {
-    return new MultiValuesEnum(docValuesIdx, starts);
-  }
-
-  @Override
-  public Source load() throws IOException {
-    return new MultiSource(docValuesIdx, starts);
-  }
-
-  public void close() throws IOException {
-    super.close();
-  }
-
-  public IndexDocValues reset(DocValuesIndex[] docValuesIdx) {
-    int[] start = new int[docValuesIdx.length];
-    for (int i = 0; i < docValuesIdx.length; i++) {
-      start[i] = docValuesIdx[i].start;
-    }
-    this.starts = start;
-    this.docValuesIdx = docValuesIdx;
-    return this;
-  }
-
-  public static class DummyDocValues extends IndexDocValues {
-    final int maxDoc;
-    final Source emptySoruce;
-
-    public DummyDocValues(int maxDoc, ValueType type) {
-      this.maxDoc = maxDoc;
-      this.emptySoruce = new EmptySource(type);
-    }
-
-    @Override
-    public DocValuesEnum getEnum(AttributeSource attrSource) throws IOException {
-      return emptySoruce.getEnum(attrSource);
-    }
-
-    @Override
-    public Source load() throws IOException {
-      return emptySoruce;
-    }
-
-    @Override
-    public ValueType type() {
-      return emptySoruce.type();
-    }
-
-    public void close() throws IOException {
-      super.close();
-    }
-
-  }
-
-  private static class MultiValuesEnum extends DocValuesEnum {
-    private DocValuesIndex[] docValuesIdx;
-    private final int maxDoc;
-    private int currentStart;
-    private int currentMax;
-    private int currentDoc = -1;
-    private DocValuesEnum currentEnum;
-    private final int[] starts;
-
-    public MultiValuesEnum(DocValuesIndex[] docValuesIdx, int[] starts)
-        throws IOException {
-      super(docValuesIdx[0].docValues.type());
-      this.docValuesIdx = docValuesIdx;
-      final DocValuesIndex last = docValuesIdx[docValuesIdx.length - 1];
-      maxDoc = last.start + last.length;
-      final DocValuesIndex idx = docValuesIdx[0];
-      currentEnum = idx.docValues.getEnum(this.attributes());
-      currentEnum.copyFrom(this);
-      intsRef = currentEnum.intsRef;
-      currentMax = idx.length;
-      currentStart = 0;
-      this.starts = starts;
-    }
-
-    @Override
-    public void close() throws IOException {
-      currentEnum.close();
-    }
-
-    @Override
-    public int advance(int target) throws IOException {
-      assert target > currentDoc : "target " + target
-          + " must be > than the current doc " + currentDoc;
-      int relativeDoc = target - currentStart;
-      do {
-        if (target >= maxDoc) {// we are beyond max doc
-          return currentDoc = NO_MORE_DOCS;
-        }
-        if (target >= currentMax) {
-          final int idx = ReaderUtil.subIndex(target, starts);
-          currentEnum.close();
-          currentEnum = docValuesIdx[idx].docValues.getEnum();
-          currentEnum.copyFrom(this);
-          currentStart = docValuesIdx[idx].start;
-          currentMax = currentStart + docValuesIdx[idx].length;
-          relativeDoc = target - currentStart;
-        }
-        target = currentMax; // make sure that we advance to the next enum if the current is exhausted
-
-      } while ((relativeDoc = currentEnum.advance(relativeDoc)) == NO_MORE_DOCS);
-      return currentDoc = currentStart + relativeDoc;
-    }
-
-    @Override
-    public int docID() {
-      return currentDoc;
-    }
-
-    @Override
-    public int nextDoc() throws IOException {
-      return advance(currentDoc + 1);
-    }
-  }
-
-  private static class MultiSource extends Source {
-    private int numDocs = 0;
-    private int start = 0;
-    private Source current;
-    private final int[] starts;
-    private final DocValuesIndex[] docValuesIdx;
-
-    public MultiSource(DocValuesIndex[] docValuesIdx, int[] starts) {
-      this.docValuesIdx = docValuesIdx;
-      this.starts = starts;
-      assert docValuesIdx.length != 0;
-
-    }
-
-    public long getInt(int docID) {
-      final int doc = ensureSource(docID);
-      return current.getInt(doc);
-    }
-
-    private final int ensureSource(int docID) {
-      if (docID >= start && docID < start+numDocs) {
-        return docID - start;
-      } else {
-        final int idx = ReaderUtil.subIndex(docID, starts);
-        assert idx >= 0 && idx < docValuesIdx.length : "idx was " + idx
-            + " for doc id: " + docID + " slices : " + Arrays.toString(starts);
-        assert docValuesIdx[idx] != null;
-        try {
-          current = docValuesIdx[idx].docValues.getSource();
-        } catch (IOException e) {
-          throw new RuntimeException("load failed", e); // TODO how should we
-          // handle this
-        }
-
-        start = docValuesIdx[idx].start;
-        numDocs = docValuesIdx[idx].length;
-        return docID - start;
-      }
-    }
-
-    public double getFloat(int docID) {
-      final int doc = ensureSource(docID);
-      return current.getFloat(doc);
-    }
-
-    public BytesRef getBytes(int docID, BytesRef bytesRef) {
-      final int doc = ensureSource(docID);
-      return current.getBytes(doc, bytesRef);
-    }
-
-    @Override
-    public DocValuesEnum getEnum(AttributeSource attrSource) throws IOException {
-      throw new UnsupportedOperationException(); // TODO
-    }
-
-    @Override
-    public ValueType type() {
-      return docValuesIdx[0].docValues.type();
-    }
-
-  }
-
-  private static class EmptySource extends Source {
-    private final ValueType type;
-
-    public EmptySource(ValueType type) {
-      this.type = type;
-    }
-
-    @Override
-    public BytesRef getBytes(int docID, BytesRef ref) {
-      ref.length = 0;
-      return ref;
-
-    }
-
-    @Override
-    public double getFloat(int docID) {
-      return 0d;
-    }
-
-    @Override
-    public long getInt(int docID) {
-      return 0;
-    }
-
-    @Override
-    public DocValuesEnum getEnum(AttributeSource attrSource) throws IOException {
-      return DocValuesEnum.emptyEnum(type);
-    }
-
-    @Override
-    public ValueType type() {
-      return type;
-    }
-  }
-
-  @Override
-  public ValueType type() {
-    return this.docValuesIdx[0].docValues.type();
-  }
-}
diff --git a/lucene/src/java/org/apache/lucene/index/values/MultiIndexDocValues.java b/lucene/src/java/org/apache/lucene/index/values/MultiIndexDocValues.java
new file mode 100644
index 0000000..c6c4c4b
--- /dev/null
+++ b/lucene/src/java/org/apache/lucene/index/values/MultiIndexDocValues.java
@@ -0,0 +1,278 @@
+package org.apache.lucene.index.values;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+import java.io.IOException;
+import java.util.Arrays;
+
+import org.apache.lucene.util.AttributeSource;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.ReaderUtil;
+
+/**
+ * A wrapper for compound IndexReader providing access to per segment
+ * {@link IndexDocValues}
+ * 
+ * @lucene.experimental
+ */
+public class MultiIndexDocValues extends IndexDocValues {
+
+  public static class DocValuesIndex {
+    public final static DocValuesIndex[] EMPTY_ARRAY = new DocValuesIndex[0];
+    final int start;
+    final int length;
+    final IndexDocValues docValues;
+
+    public DocValuesIndex(IndexDocValues docValues, int start, int length) {
+      this.docValues = docValues;
+      this.start = start;
+      this.length = length;
+    }
+  }
+
+  private DocValuesIndex[] docValuesIdx;
+  private int[] starts;
+
+  public MultiIndexDocValues() {
+    starts = new int[0];
+    docValuesIdx = new DocValuesIndex[0];
+  }
+
+  public MultiIndexDocValues(DocValuesIndex[] docValuesIdx) {
+    reset(docValuesIdx);
+  }
+
+  @Override
+  public ValuesEnum getEnum(AttributeSource source) throws IOException {
+    return new MultiValuesEnum(docValuesIdx, starts);
+  }
+
+  @Override
+  public Source load() throws IOException {
+    return new MultiSource(docValuesIdx, starts);
+  }
+
+  public void close() throws IOException {
+    super.close();
+  }
+
+  public IndexDocValues reset(DocValuesIndex[] docValuesIdx) {
+    int[] start = new int[docValuesIdx.length];
+    for (int i = 0; i < docValuesIdx.length; i++) {
+      start[i] = docValuesIdx[i].start;
+    }
+    this.starts = start;
+    this.docValuesIdx = docValuesIdx;
+    return this;
+  }
+
+  public static class DummyDocValues extends IndexDocValues {
+    final int maxDoc;
+    final Source emptySoruce;
+
+    public DummyDocValues(int maxDoc, ValueType type) {
+      this.maxDoc = maxDoc;
+      this.emptySoruce = new EmptySource(type);
+    }
+
+    @Override
+    public ValuesEnum getEnum(AttributeSource attrSource) throws IOException {
+      return emptySoruce.getEnum(attrSource);
+    }
+
+    @Override
+    public Source load() throws IOException {
+      return emptySoruce;
+    }
+
+    @Override
+    public ValueType type() {
+      return emptySoruce.type();
+    }
+
+    public void close() throws IOException {
+      super.close();
+    }
+
+  }
+
+  private static class MultiValuesEnum extends ValuesEnum {
+    private DocValuesIndex[] docValuesIdx;
+    private final int maxDoc;
+    private int currentStart;
+    private int currentMax;
+    private int currentDoc = -1;
+    private ValuesEnum currentEnum;
+    private final int[] starts;
+
+    public MultiValuesEnum(DocValuesIndex[] docValuesIdx, int[] starts)
+        throws IOException {
+      super(docValuesIdx[0].docValues.type());
+      this.docValuesIdx = docValuesIdx;
+      final DocValuesIndex last = docValuesIdx[docValuesIdx.length - 1];
+      maxDoc = last.start + last.length;
+      final DocValuesIndex idx = docValuesIdx[0];
+      currentEnum = idx.docValues.getEnum(this.attributes());
+      currentEnum.copyFrom(this);
+      intsRef = currentEnum.intsRef;
+      currentMax = idx.length;
+      currentStart = 0;
+      this.starts = starts;
+    }
+
+    @Override
+    public void close() throws IOException {
+      currentEnum.close();
+    }
+
+    @Override
+    public int advance(int target) throws IOException {
+      assert target > currentDoc : "target " + target
+          + " must be > than the current doc " + currentDoc;
+      int relativeDoc = target - currentStart;
+      do {
+        if (target >= maxDoc) {// we are beyond max doc
+          return currentDoc = NO_MORE_DOCS;
+        }
+        if (target >= currentMax) {
+          final int idx = ReaderUtil.subIndex(target, starts);
+          currentEnum.close();
+          currentEnum = docValuesIdx[idx].docValues.getEnum();
+          currentEnum.copyFrom(this);
+          currentStart = docValuesIdx[idx].start;
+          currentMax = currentStart + docValuesIdx[idx].length;
+          relativeDoc = target - currentStart;
+        }
+        target = currentMax; // make sure that we advance to the next enum if the current is exhausted
+
+      } while ((relativeDoc = currentEnum.advance(relativeDoc)) == NO_MORE_DOCS);
+      return currentDoc = currentStart + relativeDoc;
+    }
+
+    @Override
+    public int docID() {
+      return currentDoc;
+    }
+
+    @Override
+    public int nextDoc() throws IOException {
+      return advance(currentDoc + 1);
+    }
+  }
+
+  private static class MultiSource extends Source {
+    private int numDocs = 0;
+    private int start = 0;
+    private Source current;
+    private final int[] starts;
+    private final DocValuesIndex[] docValuesIdx;
+
+    public MultiSource(DocValuesIndex[] docValuesIdx, int[] starts) {
+      this.docValuesIdx = docValuesIdx;
+      this.starts = starts;
+      assert docValuesIdx.length != 0;
+
+    }
+
+    public long getInt(int docID) {
+      final int doc = ensureSource(docID);
+      return current.getInt(doc);
+    }
+
+    private final int ensureSource(int docID) {
+      if (docID >= start && docID < start+numDocs) {
+        return docID - start;
+      } else {
+        final int idx = ReaderUtil.subIndex(docID, starts);
+        assert idx >= 0 && idx < docValuesIdx.length : "idx was " + idx
+            + " for doc id: " + docID + " slices : " + Arrays.toString(starts);
+        assert docValuesIdx[idx] != null;
+        try {
+          current = docValuesIdx[idx].docValues.getSource();
+        } catch (IOException e) {
+          throw new RuntimeException("load failed", e); // TODO how should we
+          // handle this
+        }
+
+        start = docValuesIdx[idx].start;
+        numDocs = docValuesIdx[idx].length;
+        return docID - start;
+      }
+    }
+
+    public double getFloat(int docID) {
+      final int doc = ensureSource(docID);
+      return current.getFloat(doc);
+    }
+
+    public BytesRef getBytes(int docID, BytesRef bytesRef) {
+      final int doc = ensureSource(docID);
+      return current.getBytes(doc, bytesRef);
+    }
+
+    @Override
+    public ValuesEnum getEnum(AttributeSource attrSource) throws IOException {
+      throw new UnsupportedOperationException(); // TODO
+    }
+
+    @Override
+    public ValueType type() {
+      return docValuesIdx[0].docValues.type();
+    }
+
+  }
+
+  private static class EmptySource extends Source {
+    private final ValueType type;
+
+    public EmptySource(ValueType type) {
+      this.type = type;
+    }
+
+    @Override
+    public BytesRef getBytes(int docID, BytesRef ref) {
+      ref.length = 0;
+      return ref;
+
+    }
+
+    @Override
+    public double getFloat(int docID) {
+      return 0d;
+    }
+
+    @Override
+    public long getInt(int docID) {
+      return 0;
+    }
+
+    @Override
+    public ValuesEnum getEnum(AttributeSource attrSource) throws IOException {
+      return ValuesEnum.emptyEnum(type);
+    }
+
+    @Override
+    public ValueType type() {
+      return type;
+    }
+  }
+
+  @Override
+  public ValueType type() {
+    return this.docValuesIdx[0].docValues.type();
+  }
+}
diff --git a/lucene/src/java/org/apache/lucene/index/values/PackedIntsImpl.java b/lucene/src/java/org/apache/lucene/index/values/PackedIntsImpl.java
deleted file mode 100644
index 4f3f885..0000000
--- a/lucene/src/java/org/apache/lucene/index/values/PackedIntsImpl.java
+++ /dev/null
@@ -1,430 +0,0 @@
-package org.apache.lucene.index.values;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-import java.io.IOException;
-import java.util.Collection;
-import java.util.concurrent.atomic.AtomicLong;
-
-import org.apache.lucene.index.IndexFileNames;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IndexInput;
-import org.apache.lucene.store.IndexOutput;
-import org.apache.lucene.util.ArrayUtil;
-import org.apache.lucene.util.AttributeSource;
-import org.apache.lucene.util.CodecUtil;
-import org.apache.lucene.util.IOUtils;
-import org.apache.lucene.util.LongsRef;
-import org.apache.lucene.util.RamUsageEstimator;
-import org.apache.lucene.util.packed.PackedInts;
-
-/**
- * Stores ints packed with fixed-bit precision.
- * 
- * @lucene.experimental
- * */
-class PackedIntsImpl {
-
-  private static final String CODEC_NAME = "Ints";
-  private static final byte PACKED = 0x00;
-  private static final byte FIXED = 0x01;
-
-  static final int VERSION_START = 0;
-  static final int VERSION_CURRENT = VERSION_START;
-
-  static class IntsWriter extends Writer {
-
-    // TODO: can we bulkcopy this on a merge?
-    private LongsRef intsRef;
-    private long[] docToValue;
-    private long minValue;
-    private long maxValue;
-    private boolean started;
-    private final String id;
-    private int lastDocId = -1;
-    private IndexOutput datOut;
-
-    protected IntsWriter(Directory dir, String id, AtomicLong bytesUsed)
-        throws IOException {
-      super(bytesUsed);
-      datOut = dir.createOutput(IndexFileNames.segmentFileName(id, "",
-          DATA_EXTENSION));
-      boolean success = false;
-      try {
-        CodecUtil.writeHeader(datOut, CODEC_NAME, VERSION_CURRENT);
-        this.id = id;
-        docToValue = new long[1];
-        bytesUsed.addAndGet(RamUsageEstimator.NUM_BYTES_LONG); // TODO the
-                                                               // bitset
-                                                               // needs memory
-                                                               // too
-        success = true;
-      } finally {
-        if (!success) {
-          datOut.close();
-        }
-      }
-    }
-
-    @Override
-    public void add(int docID, long v) throws IOException {
-      assert lastDocId < docID;
-      if (!started) {
-        started = true;
-        minValue = maxValue = v;
-      } else {
-        if (v < minValue) {
-          minValue = v;
-        } else if (v > maxValue) {
-          maxValue = v;
-        }
-      }
-      lastDocId = docID;
-
-      if (docID >= docToValue.length) {
-        final long len = docToValue.length;
-        docToValue = ArrayUtil.grow(docToValue, 1 + docID);
-        bytesUsed.addAndGet(RamUsageEstimator.NUM_BYTES_LONG
-            * ((docToValue.length) - len));
-      }
-      docToValue[docID] = v;
-    }
-
-    @Override
-    public void finish(int docCount) throws IOException {
-      try {
-        if (!started) {
-          minValue = maxValue = 0;
-        }
-        // if we exceed the range of positive longs we must switch to fixed ints
-        if ((maxValue - minValue) < (((long)1) << 63) && (maxValue - minValue) > 0) {
-          writePackedInts(docCount);
-        } else {
-          writeFixedInts(docCount);
-        }
-
-      } finally {
-        datOut.close();
-        bytesUsed
-            .addAndGet(-(RamUsageEstimator.NUM_BYTES_LONG * docToValue.length));
-        docToValue = null;
-      }
-    }
-
-    private void writeFixedInts(int docCount) throws IOException {
-      datOut.writeByte(FIXED);
-      datOut.writeInt(docCount);
-      for (int i = 0; i < docToValue.length; i++) {
-        datOut.writeLong(docToValue[i]); // write full array - we use 0 as default
-      }
-      for (int i = docToValue.length; i < docCount; i++) {
-        datOut.writeLong(0); // fill with defaults values
-      }
-    }
-
-    private void writePackedInts(int docCount) throws IOException {
-      datOut.writeByte(PACKED);
-      // TODO -- long can't work right since it's signed
-      datOut.writeLong(minValue);
-      // write a default value to recognize docs without a value for that
-      // field
-      final long defaultValue = maxValue>= 0 && minValue <=0 ? 0-minValue : ++maxValue-minValue;
-      datOut.writeLong(defaultValue);
-      PackedInts.Writer w = PackedInts.getWriter(datOut, docCount,
-          PackedInts.bitsRequired(maxValue-minValue));
-      final int limit = docToValue.length > docCount ? docCount : docToValue.length;
-      for (int i = 0; i < limit; i++) {
-        w.add(docToValue[i] == 0 ? defaultValue : docToValue[i] - minValue);
-      }
-      for (int i = limit; i < docCount; i++) {
-        w.add(defaultValue);
-      }
-      
-      w.finish();
-    }
-
-    @Override
-    protected void add(int docID) throws IOException {
-      add(docID, intsRef.get());
-    }
-
-    @Override
-    protected void setNextEnum(DocValuesEnum valuesEnum) {
-      intsRef = valuesEnum.getInt();
-    }
-
-    @Override
-    public void add(int docID, PerDocFieldValues docValues) throws IOException {
-      add(docID, docValues.getInt());
-    }
-
-    @Override
-    public void files(Collection<String> files) throws IOException {
-      files.add(IndexFileNames.segmentFileName(id, "", DATA_EXTENSION));
-    }
-  }
-
-  /**
-   * Opens all necessary files, but does not read any data in until you call
-   * {@link #load}.
-   */
-  static class IntsReader extends IndexDocValues {
-    private final IndexInput datIn;
-    private final boolean packed;
-
-    protected IntsReader(Directory dir, String id) throws IOException {
-      datIn = dir.openInput(IndexFileNames.segmentFileName(id, "",
-          Writer.DATA_EXTENSION));
-      boolean success = false;
-      try {
-        CodecUtil.checkHeader(datIn, CODEC_NAME, VERSION_START, VERSION_START);
-        packed = PACKED == datIn.readByte();
-        success = true;
-      } finally {
-        if (!success) {
-          IOUtils.closeSafely(true, datIn);
-        }
-      }
-    }
-
-    /**
-     * Loads the actual values. You may call this more than once, eg if you
-     * already previously loaded but then discarded the Source.
-     */
-    @Override
-    public Source load() throws IOException {
-      final IndexInput input = (IndexInput) datIn.clone();
-      boolean success = false;
-      try {
-        final Source source = packed ? new PackedIntsSource(input)
-            : new FixedIntsSource(input);
-        success = true;
-        return source;
-      } finally {
-        if (!success) {
-          IOUtils.closeSafely(true, datIn);
-        }
-      }
-    }
-    
-    private static class FixedIntsSource extends Source {
-      private final long[] values;
-      public FixedIntsSource(IndexInput dataIn) throws IOException {
-        dataIn.seek(CodecUtil.headerLength(CODEC_NAME) + 1);
-        final int numDocs = dataIn.readInt();
-        values = new long[numDocs];
-        for (int i = 0; i < values.length; i++) {
-          values[i] = dataIn.readLong();
-        }
-      }
-      
-      @Override
-      public long getInt(int docID) {
-        assert docID >= 0 && docID < values.length;
-        return values[docID];
-      }
-
-      @Override
-      public ValueType type() {
-        return ValueType.INTS;
-      }
-
-      @Override
-      public DocValuesEnum getEnum(AttributeSource attrSource)
-          throws IOException {
-        return new SourceEnum(attrSource, type(), this, values.length) {
-          
-          @Override
-          public int advance(int target) throws IOException {
-            if (target >= numDocs)
-              return pos = NO_MORE_DOCS;
-            intsRef.ints[intsRef.offset] = values[target];
-            return pos = target;
-          }
-        };
-      }
-      
-    }
-
-    private static class PackedIntsSource extends Source {
-      private final long minValue;
-      private final long defaultValue;
-      private final PackedInts.Reader values;
-
-      public PackedIntsSource(IndexInput dataIn) throws IOException {
-        dataIn.seek(CodecUtil.headerLength(CODEC_NAME) + 1);
-        minValue = dataIn.readLong();
-        defaultValue = dataIn.readLong();
-        values = PackedInts.getReader(dataIn);
-      }
-
-      @Override
-      public long getInt(int docID) {
-        // TODO -- can we somehow avoid 2X method calls
-        // on each get? must push minValue down, and make
-        // PackedInts implement Ints.Source
-        assert docID >= 0;
-        final long value = values.get(docID);
-        return value == defaultValue ? 0 : minValue + value;
-      }
-
-      @Override
-      public DocValuesEnum getEnum(AttributeSource attrSource)
-          throws IOException {
-        return new SourceEnum(attrSource, type(), this, values.size()) {
-          @Override
-          public int advance(int target) throws IOException {
-            if (target >= numDocs)
-              return pos = NO_MORE_DOCS;
-            intsRef.ints[intsRef.offset] = source.getInt(target);
-            return pos = target;
-          }
-        };
-      }
-
-      @Override
-      public ValueType type() {
-        return ValueType.INTS;
-      }
-    }
-
-    @Override
-    public void close() throws IOException {
-      super.close();
-      datIn.close();
-    }
-
-    @Override
-    public DocValuesEnum getEnum(AttributeSource source) throws IOException {
-      final IndexInput input = (IndexInput) datIn.clone();
-      boolean success = false;
-      try {
-        DocValuesEnum inst = packed ? new PackedIntsEnumImpl(source, input)
-            : new FixedIntsEnumImpl(source, input);
-        success = true;
-        return inst;
-      } finally {
-        if (!success) {
-          IOUtils.closeSafely(true, input);
-        }
-      }
-    }
-
-    @Override
-    public ValueType type() {
-      return ValueType.INTS;
-    }
-
-  }
-
-  private static final class PackedIntsEnumImpl extends DocValuesEnum {
-    private final PackedInts.ReaderIterator ints;
-    private long minValue;
-    private final IndexInput dataIn;
-    private final long defaultValue;
-    private final int maxDoc;
-    private int pos = -1;
-
-    private PackedIntsEnumImpl(AttributeSource source, IndexInput dataIn)
-        throws IOException {
-      super(source, ValueType.INTS);
-      intsRef.offset = 0;
-      this.dataIn = dataIn;
-      dataIn.seek(CodecUtil.headerLength(CODEC_NAME) + 1);
-      minValue = dataIn.readLong();
-      defaultValue = dataIn.readLong();
-      this.ints = PackedInts.getReaderIterator(dataIn);
-      maxDoc = ints.size();
-    }
-
-    @Override
-    public void close() throws IOException {
-      ints.close();
-      dataIn.close();
-    }
-
-    @Override
-    public int advance(int target) throws IOException {
-      if (target >= maxDoc) {
-        return pos = NO_MORE_DOCS;
-      }
-      final long val = ints.advance(target);
-      intsRef.ints[intsRef.offset] = val == defaultValue ? 0 : minValue + val;
-      return pos = target;
-    }
-
-    @Override
-    public int docID() {
-      return pos;
-    }
-
-    @Override
-    public int nextDoc() throws IOException {
-      if (pos >= maxDoc) {
-        return pos = NO_MORE_DOCS;
-      }
-      return advance(pos + 1);
-    }
-  }
-  
-  private static final class FixedIntsEnumImpl extends DocValuesEnum {
-    private final IndexInput dataIn;
-    private final int maxDoc;
-    private int pos = -1;
-
-    private FixedIntsEnumImpl(AttributeSource source, IndexInput dataIn)
-        throws IOException {
-      super(source, ValueType.INTS);
-      intsRef.offset = 0;
-      this.dataIn = dataIn;
-      dataIn.seek(CodecUtil.headerLength(CODEC_NAME) + 1);
-      maxDoc = dataIn.readInt();
-    }
-
-    @Override
-    public void close() throws IOException {
-      dataIn.close();
-    }
-
-    @Override
-    public int advance(int target) throws IOException {
-      if (target >= maxDoc) {
-        return pos = NO_MORE_DOCS;
-      }
-      assert target > pos;
-      if (target > pos+1) {
-        dataIn.seek(dataIn.getFilePointer() + ((target - pos - 1) * 8));
-      }
-      intsRef.ints[intsRef.offset] = dataIn.readLong();
-      return pos = target;
-    }
-
-    @Override
-    public int docID() {
-      return pos;
-    }
-
-    @Override
-    public int nextDoc() throws IOException {
-      if (pos >= maxDoc) {
-        return pos = NO_MORE_DOCS;
-      }
-      return advance(pos + 1);
-    }
-  }
- 
-}
\ No newline at end of file
diff --git a/lucene/src/java/org/apache/lucene/index/values/PerDocFieldValues.java b/lucene/src/java/org/apache/lucene/index/values/PerDocFieldValues.java
index cbd0bb7..130d5b3 100644
--- a/lucene/src/java/org/apache/lucene/index/values/PerDocFieldValues.java
+++ b/lucene/src/java/org/apache/lucene/index/values/PerDocFieldValues.java
@@ -18,14 +18,14 @@ package org.apache.lucene.index.values;
  */
 import java.util.Comparator;
 
-import org.apache.lucene.document.DocValuesField;
+import org.apache.lucene.document.IndexDocValuesField;
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.index.codecs.DocValuesConsumer;
 import org.apache.lucene.util.BytesRef;
 
 /**
  * Per document and field values consumed by {@link DocValuesConsumer}. 
- * @see DocValuesField
+ * @see IndexDocValuesField
  * @see Fieldable#setDocValues(PerDocFieldValues)
  * 
  * @lucene.experimental
diff --git a/lucene/src/java/org/apache/lucene/index/values/ValueType.java b/lucene/src/java/org/apache/lucene/index/values/ValueType.java
index fa8f95a..af953f6 100644
--- a/lucene/src/java/org/apache/lucene/index/values/ValueType.java
+++ b/lucene/src/java/org/apache/lucene/index/values/ValueType.java
@@ -20,12 +20,14 @@ package org.apache.lucene.index.values;
 import org.apache.lucene.index.codecs.Codec;
 import org.apache.lucene.index.codecs.PerDocConsumer;
 import org.apache.lucene.index.values.IndexDocValues.SortedSource;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.packed.PackedInts;
 
 /**
- * {@link ValueType} specifies the type of the {@link IndexDocValues} for a certain field.
- * A {@link ValueType} only defines the data type for a field while the actual
- * Implementation used to encode and decode the values depends on the field's
- * {@link Codec}. It is up to the {@link Codec} implementing
+ * {@link ValueType} specifies the type of the {@link IndexDocValues} for a
+ * certain field. A {@link ValueType} only defines the data type for a field
+ * while the actual Implementation used to encode and decode the values depends
+ * on the field's {@link Codec}. It is up to the {@link Codec} implementing
  * {@link PerDocConsumer#addValuesField(org.apache.lucene.index.FieldInfo)} and
  * using a different low-level implementations to write the stored values for a
  * field.
@@ -37,50 +39,141 @@ public enum ValueType {
    * TODO: Add INT_32 INT_64 INT_16 & INT_8?!
    */
   /**
-   * Integer values.
+   * Defines an 64 bit integer value. By default this type uses a simple
+   * compression technique based on {@link PackedInts}. Internally only the used
+   * value range is encoded if it fits into 2<sup>63</sup>-1. If that range is
+   * exceeded the default implementation falls back to fixed size 64bit
+   * integers.
+   * <p>
+   * NOTE: this type uses <tt>0</tt> as the default value without any
+   * distinction between provided <tt>0</tt> values during indexing. All
+   * documents without an explicit value will use <tt>0</tt> instead. In turn,
+   * {@link ValuesEnum} instances will not skip documents without an explicit
+   * value assigned. Custom default values must be assigned explicitly.
+   * </p>
    */
   INTS,
-   
+
   /**
-   * 32 bit floating point values.
+   * Defines a 32 bit floating point values. By default there is no compression
+   * applied. To fit custom float values into less than 32bit either a custom
+   * implementation is needed or values must be encoded into a
+   * {@link #BYTES_FIXED_STRAIGHT} type.
+   * <p>
+   * NOTE: this type uses <tt>0.0f</tt> as the default value without any
+   * distinction between provided <tt>0.0f</tt> values during indexing. All
+   * documents without an explicit value will use <tt>0.0f</tt> instead. In
+   * turn, {@link ValuesEnum} instances will not skip documents without an
+   * explicit value assigned. Custom default values must be assigned explicitly.
+   * </p>
    */
   FLOAT_32,
   /**
-   * 64 bit floating point values.
+   * Defines a 64 bit floating point values. By default there is no compression
+   * applied. To fit custom float values into less than 64bit either a custom
+   * implementation is needed or values must be encoded into a
+   * {@link #BYTES_FIXED_STRAIGHT} type.
+   * <p>
+   * NOTE: this type uses <tt>0.0d</tt> as the default value without any
+   * distinction between provided <tt>0.0d</tt> values during indexing. All
+   * documents without an explicit value will use <tt>0.0d</tt> instead. In
+   * turn, {@link ValuesEnum} instances will not skip documents without an
+   * explicit value assigned. Custom default values must be assigned explicitly.
+   * </p>
    */
   FLOAT_64,
 
   // TODO(simonw): -- shouldn't lucene decide/detect straight vs
   // deref, as well fixed vs var?
   /**
-   * Fixed length straight stored byte variant
+   * Defines a fixed length straight stored byte variant. All values added to
+   * such a field must be of the same length. All bytes are stored sequentially
+   * for fast offset access.
+   * <p>
+   * NOTE: this type uses <tt>0-bytes</tt> based on the length of the first seen
+   * values as the default value without any distinction between explicitly
+   * provided values during indexing. All documents without an explicit value
+   * will use the default instead. In turn, {@link ValuesEnum} instances will
+   * not skip documents without an explicit value assigned. Custom default
+   * values must be assigned explicitly.
+   * </p>
    */
   BYTES_FIXED_STRAIGHT,
 
   /**
-   * Fixed length dereferenced (indexed) byte variant
+   * Defines a fixed length dereferenced (indexed) byte variant. Fields with
+   * this type only store distinct byte values and store an additional offset
+   * pointer per document to dereference the payload.
+   * <p>
+   * NOTE: Fields of this type will not store values for documents without and
+   * explicitly provided value. If a documents value is accessed while no
+   * explicit value is stored the returned {@link BytesRef} will be a 0-length
+   * reference. In turn, {@link ValuesEnum} instances will skip over documents
+   * without an explicit value assigned. Custom default values must be assigned
+   * explicitly.
+   * </p>
    */
   BYTES_FIXED_DEREF,
 
   /**
-   * Fixed length pre-sorted byte variant
+   * Defines a fixed length pre-sorted byte variant. Fields with this type only
+   * store distinct byte values and store an additional offset pointer per
+   * document to dereference the payload. The stored byte payload is presorted
+   * and allows access via document id, ordinal and by-value.
+   * <p>
+   * NOTE: Fields of this type will not store values for documents without and
+   * explicitly provided value. If a documents value is accessed while no
+   * explicit value is stored the returned {@link BytesRef} will be a 0-length
+   * reference. In turn, {@link ValuesEnum} instances will skip over documents
+   * without an explicit value assigned. Custom default values must be assigned
+   * explicitly.
+   * </p>
    * 
    * @see SortedSource
    */
   BYTES_FIXED_SORTED,
 
   /**
-   * Variable length straight stored byte variant
+   * Defines a variable length straight stored byte variant. All bytes are
+   * stored sequentially for compactness. Usage of this type via the
+   * disk-resident API might yield performance degradation since no additional
+   * index is used to advance by more than one documents value at a time.
+   * <p>
+   * NOTE: Fields of this type will not store values for documents without and
+   * explicitly provided value. If a documents value is accessed while no
+   * explicit value is stored the returned {@link BytesRef} will be a 0-length
+   * reference. Yet, in contrast to dereferences variants {@link ValuesEnum}
+   * instances will <b>not</b> skip over documents without an explicit value
+   * assigned. Custom default values must be assigned explicitly.
+   * </p>
    */
   BYTES_VAR_STRAIGHT,
 
   /**
-   * Variable length dereferenced (indexed) byte variant
+   * Defines a variable length dereferenced (indexed) byte variant. Just as
+   * {@link #BYTES_FIXED_DEREF} yet supporting variable length values.
+   * <p>
+   * NOTE: Fields of this type will not store values for documents without and
+   * explicitly provided value. If a documents value is accessed while no
+   * explicit value is stored the returned {@link BytesRef} will be a 0-length
+   * reference. In turn, {@link ValuesEnum} instances will skip over documents
+   * without an explicit value assigned. Custom default values must be assigned
+   * explicitly.
+   * </p>
    */
   BYTES_VAR_DEREF,
 
   /**
-   * Variable length pre-sorted byte variant
+   * Defines a variable length pre-sorted byte variant. Just as
+   * {@link #BYTES_FIXED_SORTED} yet supporting variable length values.
+   * <p>
+   * NOTE: Fields of this type will not store values for documents without and
+   * explicitly provided value. If a documents value is accessed while no
+   * explicit value is stored the returned {@link BytesRef} will be a 0-length
+   * reference. In turn, {@link ValuesEnum} instances will skip over documents
+   * without an explicit value assigned. Custom default values must be assigned
+   * explicitly.
+   * </p>
    * 
    * @see SortedSource
    */
diff --git a/lucene/src/java/org/apache/lucene/index/values/ValuesEnum.java b/lucene/src/java/org/apache/lucene/index/values/ValuesEnum.java
new file mode 100644
index 0000000..0351207
--- /dev/null
+++ b/lucene/src/java/org/apache/lucene/index/values/ValuesEnum.java
@@ -0,0 +1,173 @@
+package org.apache.lucene.index.values;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+import java.io.IOException;
+
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.util.AttributeSource;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.FloatsRef;
+import org.apache.lucene.util.LongsRef;
+
+/**
+ * {@link ValuesEnum} is a {@link DocIdSetIterator} iterating <tt>byte[]</tt>
+ * , <tt>long</tt> and <tt>double</tt> stored per document. Depending on the
+ * enum's {@link ValueType} ({@link #type()}) the enum might skip over documents that
+ * have no value stored. Types like {@link ValueType#BYTES_VAR_STRAIGHT} might not
+ * skip over documents even if there is no value associated with a document. The
+ * value for document without values again depends on the types implementation
+ * although a reference for a {@link ValueType} returned from a accessor method
+ * {@link #getFloat()}, {@link #getInt()} or {@link #bytes()} will never be
+ * <code>null</code> even if a document has no value.
+ * <p>
+ * Note: Only the reference for the enum's type are initialized to non
+ * <code>null</code> ie. {@link #getInt()} will always return <code>null</code>
+ * if the enum's Type is {@link ValueType#FLOAT_32}.
+ * 
+ * @lucene.experimental
+ */
+public abstract class ValuesEnum extends DocIdSetIterator {
+  private AttributeSource source;
+  private final ValueType enumType;
+  protected BytesRef bytesRef;
+  protected FloatsRef floatsRef;
+  protected LongsRef intsRef;
+
+  /**
+   * Creates a new {@link ValuesEnum} for the given type. The
+   * {@link AttributeSource} for this enum is set to <code>null</code>
+   */
+  protected ValuesEnum(ValueType enumType) {
+    this(null, enumType);
+  }
+
+  /**
+   * Creates a new {@link ValuesEnum} for the given type.
+   */
+  protected ValuesEnum(AttributeSource source, ValueType enumType) {
+    this.source = source;
+    this.enumType = enumType;
+    switch (enumType) {
+    case BYTES_FIXED_DEREF:
+    case BYTES_FIXED_SORTED:
+    case BYTES_FIXED_STRAIGHT:
+    case BYTES_VAR_DEREF:
+    case BYTES_VAR_SORTED:
+    case BYTES_VAR_STRAIGHT:
+      bytesRef = new BytesRef();
+      break;
+    case INTS:
+      intsRef = new LongsRef(1);
+      break;
+    case FLOAT_32:
+    case FLOAT_64:
+      floatsRef = new FloatsRef(1);
+      break;
+    }
+  }
+
+  /**
+   * Returns the type of this enum
+   */
+  public ValueType type() {
+    return enumType;
+  }
+
+  /**
+   * Returns a {@link BytesRef} or <code>null</code> if this enum doesn't
+   * enumerate byte[] values
+   */
+  public BytesRef bytes() {
+    return bytesRef;
+  }
+
+  /**
+   * Returns a {@link FloatsRef} or <code>null</code> if this enum doesn't
+   * enumerate floating point values
+   */
+  public FloatsRef getFloat() {
+    return floatsRef;
+  }
+
+  /**
+   * Returns a {@link LongsRef} or <code>null</code> if this enum doesn't
+   * enumerate integer values.
+   */
+  public LongsRef getInt() {
+    return intsRef;
+  }
+
+  /**
+   * Copies the internal state from the given enum
+   */
+  protected void copyFrom(ValuesEnum valuesEnum) {
+    intsRef = valuesEnum.intsRef;
+    floatsRef = valuesEnum.floatsRef;
+    bytesRef = valuesEnum.bytesRef;
+    source = valuesEnum.source;
+  }
+
+  /**
+   * Returns the {@link AttributeSource} associated with this enum.
+   * <p>
+   * Note: this method might create a new AttribueSource if no
+   * {@link AttributeSource} has been provided during enum creation.
+   */
+  public AttributeSource attributes() {
+    if (source == null) {
+      source = new AttributeSource();
+    }
+    return source;
+  }
+
+  /**
+   * Closes the enum
+   * 
+   * @throws IOException
+   *           if an {@link IOException} occurs
+   */
+  public abstract void close() throws IOException;
+
+  /**
+   * Returns an empty {@link ValuesEnum} for the given {@link ValueType}.
+   */
+  public static ValuesEnum emptyEnum(ValueType type) {
+    return new ValuesEnum(type) {
+      @Override
+      public int nextDoc() throws IOException {
+        return NO_MORE_DOCS;
+      }
+
+      @Override
+      public int docID() {
+        return NO_MORE_DOCS;
+      }
+
+      @Override
+      public int advance(int target) throws IOException {
+        return NO_MORE_DOCS;
+      }
+
+      @Override
+      public void close() throws IOException {
+
+      }
+    };
+  }
+
+}
diff --git a/lucene/src/java/org/apache/lucene/index/values/VarDerefBytesImpl.java b/lucene/src/java/org/apache/lucene/index/values/VarDerefBytesImpl.java
index f049119..215acd4 100644
--- a/lucene/src/java/org/apache/lucene/index/values/VarDerefBytesImpl.java
+++ b/lucene/src/java/org/apache/lucene/index/values/VarDerefBytesImpl.java
@@ -249,7 +249,7 @@ class VarDerefBytesImpl {
     }
 
     @Override
-    public DocValuesEnum getEnum(AttributeSource source) throws IOException {
+    public ValuesEnum getEnum(AttributeSource source) throws IOException {
       return new VarDerefBytesEnum(source, cloneData(), cloneIndex());
     }
 
diff --git a/lucene/src/java/org/apache/lucene/index/values/VarSortedBytesImpl.java b/lucene/src/java/org/apache/lucene/index/values/VarSortedBytesImpl.java
index ac6bbbe..89d4b7b 100644
--- a/lucene/src/java/org/apache/lucene/index/values/VarSortedBytesImpl.java
+++ b/lucene/src/java/org/apache/lucene/index/values/VarSortedBytesImpl.java
@@ -230,11 +230,11 @@ class VarSortedBytesImpl {
     }
 
     @Override
-    public DocValuesEnum getEnum(AttributeSource source) throws IOException {
+    public ValuesEnum getEnum(AttributeSource source) throws IOException {
       return new VarSortedBytesEnum(source, cloneData(), cloneIndex());
     }
 
-    private static class VarSortedBytesEnum extends DocValuesEnum {
+    private static class VarSortedBytesEnum extends ValuesEnum {
       private PackedInts.Reader docToOrdIndex;
       private PackedInts.Reader ordToOffsetIndex;
       private IndexInput idxIn;
diff --git a/lucene/src/java/org/apache/lucene/index/values/VarStraightBytesImpl.java b/lucene/src/java/org/apache/lucene/index/values/VarStraightBytesImpl.java
index 477055d..7d71643 100644
--- a/lucene/src/java/org/apache/lucene/index/values/VarStraightBytesImpl.java
+++ b/lucene/src/java/org/apache/lucene/index/values/VarStraightBytesImpl.java
@@ -164,11 +164,11 @@ class VarStraightBytesImpl {
     }
 
     @Override
-    public DocValuesEnum getEnum(AttributeSource source) throws IOException {
+    public ValuesEnum getEnum(AttributeSource source) throws IOException {
       return new VarStraightBytesEnum(source, cloneData(), cloneIndex());
     }
 
-    private class VarStraightBytesEnum extends DocValuesEnum {
+    private class VarStraightBytesEnum extends ValuesEnum {
       private final PackedInts.Reader addresses;
       private final IndexInput datIn;
       private final IndexInput idxIn;
diff --git a/lucene/src/java/org/apache/lucene/index/values/Writer.java b/lucene/src/java/org/apache/lucene/index/values/Writer.java
index 4c61324..e344454 100644
--- a/lucene/src/java/org/apache/lucene/index/values/Writer.java
+++ b/lucene/src/java/org/apache/lucene/index/values/Writer.java
@@ -99,15 +99,15 @@ public abstract class Writer extends DocValuesConsumer {
 
   /**
    * Records a value from the given document id. The methods implementation
-   * obtains the value for the document id from the last {@link DocValuesEnum}
-   * set to {@link #setNextEnum(DocValuesEnum)}.
+   * obtains the value for the document id from the last {@link ValuesEnum}
+   * set to {@link #setNextEnum(ValuesEnum)}.
    * <p>
    * This method is used during merging to provide implementation agnostic
    * default merge implementation.
    * </p>
    * <p>
    * The given document id must be the same document id returned from
-   * {@link DocValuesEnum#docID()} when this method is called. All documents IDs
+   * {@link ValuesEnum#docID()} when this method is called. All documents IDs
    * between the given ID and the previously given ID or <tt>0</tt> if the
    * method is call the first time are filled with default values depending on
    * the {@link Writer} implementation. The given document ID must always be
@@ -116,13 +116,13 @@ public abstract class Writer extends DocValuesConsumer {
   protected abstract void add(int docID) throws IOException;
 
   /**
-   * Sets the next {@link DocValuesEnum} to consume values from on calls to
+   * Sets the next {@link ValuesEnum} to consume values from on calls to
    * {@link #add(int)}
    * 
    * @param valuesEnum
-   *          the next {@link DocValuesEnum}, this must not be null
+   *          the next {@link ValuesEnum}, this must not be null
    */
-  protected abstract void setNextEnum(DocValuesEnum valuesEnum);
+  protected abstract void setNextEnum(ValuesEnum valuesEnum);
 
   /**
    * Finish writing and close any files and resources used by this Writer.
@@ -140,7 +140,7 @@ public abstract class Writer extends DocValuesConsumer {
     // simply override this and decide if they want to merge
     // segments using this generic implementation or if a bulk merge is possible
     // / feasible.
-    final DocValuesEnum valEnum = state.reader.getEnum();
+    final ValuesEnum valEnum = state.reader.getEnum();
     assert valEnum != null;
     try {
       setNextEnum(valEnum); // set the current enum we are working on - the
@@ -150,11 +150,11 @@ public abstract class Writer extends DocValuesConsumer {
       final Bits bits = state.bits;
       final int docCount = state.docCount;
       int currentDocId;
-      if ((currentDocId = valEnum.advance(0)) != DocValuesEnum.NO_MORE_DOCS) {
+      if ((currentDocId = valEnum.advance(0)) != ValuesEnum.NO_MORE_DOCS) {
         for (int i = 0; i < docCount; i++) {
           if (bits == null || !bits.get(i)) {
             if (currentDocId < i) {
-              if ((currentDocId = valEnum.advance(i)) == DocValuesEnum.NO_MORE_DOCS) {
+              if ((currentDocId = valEnum.advance(i)) == ValuesEnum.NO_MORE_DOCS) {
                 break; // advance can jump over default values
               }
             }
diff --git a/lucene/src/test-framework/org/apache/lucene/index/RandomIndexWriter.java b/lucene/src/test-framework/org/apache/lucene/index/RandomIndexWriter.java
index 4f6d575..ea1f891 100644
--- a/lucene/src/test-framework/org/apache/lucene/index/RandomIndexWriter.java
+++ b/lucene/src/test-framework/org/apache/lucene/index/RandomIndexWriter.java
@@ -24,7 +24,7 @@ import java.util.Random;
 
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.MockAnalyzer;
-import org.apache.lucene.document.DocValuesField;
+import org.apache.lucene.document.IndexDocValuesField;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.index.IndexWriter; // javadoc
 import org.apache.lucene.index.codecs.CodecProvider;
@@ -173,7 +173,7 @@ public class RandomIndexWriter implements Closeable {
     String name = "random_" + type.name() + "" + docValuesFieldPrefix;
     if ("PreFlex".equals(codecProvider.getFieldCodec(name)) || doc.getFieldable(name) != null)
         return;
-    DocValuesField docValuesField = new DocValuesField(name);
+    IndexDocValuesField docValuesField = new IndexDocValuesField(name);
     switch (type) {
     case BYTES_FIXED_DEREF:
     case BYTES_FIXED_SORTED:
diff --git a/lucene/src/test/org/apache/lucene/index/values/TestDocValues.java b/lucene/src/test/org/apache/lucene/index/values/TestDocValues.java
index 42d32a0..c1365d8 100644
--- a/lucene/src/test/org/apache/lucene/index/values/TestDocValues.java
+++ b/lucene/src/test/org/apache/lucene/index/values/TestDocValues.java
@@ -83,7 +83,7 @@ public class TestDocValues extends LuceneTestCase {
 
     IndexDocValues r = Bytes.getValues(dir, "test", mode, fixedSize, maxDoc);
     for (int iter = 0; iter < 2; iter++) {
-      DocValuesEnum bytesEnum = getEnum(r);
+      ValuesEnum bytesEnum = getEnum(r);
       assertNotNull("enum is null", bytesEnum);
       BytesRef ref = bytesEnum.bytes();
 
@@ -94,8 +94,8 @@ public class TestDocValues extends LuceneTestCase {
         assertEquals("doc: " + idx + " lenLeft: " + values[idx].length()
             + " lenRight: " + utf8String.length(), values[idx], utf8String);
       }
-      assertEquals(DocValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));
-      assertEquals(DocValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));
+      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));
+      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));
 
       bytesEnum.close();
     }
@@ -209,7 +209,7 @@ public class TestDocValues extends LuceneTestCase {
         }
 
         for (int iter = 0; iter < 2; iter++) {
-          DocValuesEnum iEnum = getEnum(r);
+          ValuesEnum iEnum = getEnum(r);
           LongsRef ints = iEnum.getInt();
           for (int i = 0; i < NUM_VALUES + additionalDocs; i++) {
             assertEquals(i, iEnum.nextDoc());
@@ -219,12 +219,12 @@ public class TestDocValues extends LuceneTestCase {
               assertEquals(0, ints.get());
             }
           }
-          assertEquals(DocValuesEnum.NO_MORE_DOCS, iEnum.nextDoc());
+          assertEquals(ValuesEnum.NO_MORE_DOCS, iEnum.nextDoc());
           iEnum.close();
         }
 
         for (int iter = 0; iter < 2; iter++) {
-          DocValuesEnum iEnum = getEnum(r);
+          ValuesEnum iEnum = getEnum(r);
           LongsRef ints = iEnum.getInt();
           for (int i = 0; i < NUM_VALUES + additionalDocs; i += 1 + random.nextInt(25)) {
             assertEquals(i, iEnum.advance(i));
@@ -234,7 +234,7 @@ public class TestDocValues extends LuceneTestCase {
               assertEquals(0, ints.get());
             }
           }
-          assertEquals(DocValuesEnum.NO_MORE_DOCS, iEnum.advance(NUM_VALUES + additionalDocs));
+          assertEquals(ValuesEnum.NO_MORE_DOCS, iEnum.advance(NUM_VALUES + additionalDocs));
           iEnum.close();
         }
         r.close();
@@ -272,7 +272,7 @@ public class TestDocValues extends LuceneTestCase {
     }
 
     for (int iter = 0; iter < 2; iter++) {
-      DocValuesEnum fEnum = getEnum(r);
+      ValuesEnum fEnum = getEnum(r);
       FloatsRef floats = fEnum.getFloat();
       for (int i = 0; i < NUM_VALUES + additionalValues; i++) {
         assertEquals(i, fEnum.nextDoc());
@@ -282,11 +282,11 @@ public class TestDocValues extends LuceneTestCase {
           assertEquals(0.0d, floats.get(), delta);
         }
       }
-      assertEquals(DocValuesEnum.NO_MORE_DOCS, fEnum.nextDoc());
+      assertEquals(ValuesEnum.NO_MORE_DOCS, fEnum.nextDoc());
       fEnum.close();
     }
     for (int iter = 0; iter < 2; iter++) {
-      DocValuesEnum fEnum = getEnum(r);
+      ValuesEnum fEnum = getEnum(r);
       FloatsRef floats = fEnum.getFloat();
       for (int i = 0; i < NUM_VALUES + additionalValues; i += 1 + random.nextInt(25)) {
         assertEquals(i, fEnum.advance(i));
@@ -296,7 +296,7 @@ public class TestDocValues extends LuceneTestCase {
           assertEquals(0.0d, floats.get(), delta);
         }
       }
-      assertEquals(DocValuesEnum.NO_MORE_DOCS, fEnum.advance(NUM_VALUES + additionalValues));
+      assertEquals(ValuesEnum.NO_MORE_DOCS, fEnum.advance(NUM_VALUES + additionalValues));
       fEnum.close();
     }
 
@@ -308,7 +308,7 @@ public class TestDocValues extends LuceneTestCase {
     runTestFloats(8, 0.0);
   }
   
-  private DocValuesEnum getEnum(IndexDocValues values) throws IOException {
+  private ValuesEnum getEnum(IndexDocValues values) throws IOException {
     return random.nextBoolean() ? values.getEnum() : getSource(values).getEnum();
   }
 
diff --git a/lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing.java b/lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing.java
index 910fe38..20ffa08 100644
--- a/lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing.java
+++ b/lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing.java
@@ -26,7 +26,7 @@ import java.util.List;
 
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.AbstractField;
-import org.apache.lucene.document.DocValuesField;
+import org.apache.lucene.document.IndexDocValuesField;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.Field.Index;
@@ -64,10 +64,6 @@ import org.junit.Before;
  */
 public class TestDocValuesIndexing extends LuceneTestCase {
   /*
-   * TODO: Roadmap to land on trunk
-   * 
-   * - Add documentation for: 
-   *  - DocValues 
    * - add test for unoptimized case with deletes
    * - add multithreaded tests / integrate into stress indexing?
    */
@@ -87,7 +83,7 @@ public class TestDocValuesIndexing extends LuceneTestCase {
     IndexWriter writer = new IndexWriter(dir, writerConfig(false));
     for (int i = 0; i < 5; i++) {
       Document doc = new Document();
-      DocValuesField valuesField = new DocValuesField("docId");
+      IndexDocValuesField valuesField = new IndexDocValuesField("docId");
       valuesField.setInt(i);
       doc.add(valuesField);
       doc.add(new Field("docId", "" + i, Store.NO, Index.ANALYZED));
@@ -198,10 +194,10 @@ public class TestDocValuesIndexing extends LuceneTestCase {
     // check values
     
     IndexReader merged = IndexReader.open(w, true);
-    DocValuesEnum vE_1 = getValuesEnum(getDocValues(r_1, first.name()));
-    DocValuesEnum vE_2 = getValuesEnum(getDocValues(r_2, second.name()));
-    DocValuesEnum vE_1_merged = getValuesEnum(getDocValues(merged, first.name()));
-    DocValuesEnum vE_2_merged = getValuesEnum(getDocValues(merged, second
+    ValuesEnum vE_1 = getValuesEnum(getDocValues(r_1, first.name()));
+    ValuesEnum vE_2 = getValuesEnum(getDocValues(r_2, second.name()));
+    ValuesEnum vE_1_merged = getValuesEnum(getDocValues(merged, first.name()));
+    ValuesEnum vE_2_merged = getValuesEnum(getDocValues(merged, second
         .name()));
     switch (second) { // these variants don't advance over missing values
     case BYTES_FIXED_STRAIGHT:
@@ -219,10 +215,10 @@ public class TestDocValuesIndexing extends LuceneTestCase {
       assertEquals(msg, i, vE_2.nextDoc());
       assertEquals(msg, i + valuesPerIndex, vE_2_merged.nextDoc());
     }
-    assertEquals(msg, DocValuesEnum.NO_MORE_DOCS, vE_1.nextDoc());
-    assertEquals(msg, DocValuesEnum.NO_MORE_DOCS, vE_2.nextDoc());
-    assertEquals(msg, DocValuesEnum.NO_MORE_DOCS, vE_1_merged.advance(valuesPerIndex*2));
-    assertEquals(msg, DocValuesEnum.NO_MORE_DOCS, vE_2_merged.nextDoc());
+    assertEquals(msg, ValuesEnum.NO_MORE_DOCS, vE_1.nextDoc());
+    assertEquals(msg, ValuesEnum.NO_MORE_DOCS, vE_2.nextDoc());
+    assertEquals(msg, ValuesEnum.NO_MORE_DOCS, vE_1_merged.advance(valuesPerIndex*2));
+    assertEquals(msg, ValuesEnum.NO_MORE_DOCS, vE_2_merged.nextDoc());
 
     // close resources
     r_1.close();
@@ -274,7 +270,7 @@ public class TestDocValuesIndexing extends LuceneTestCase {
           assertEquals("index " + i, 0, value);
         }
 
-        DocValuesEnum intsEnum = getValuesEnum(intsReader);
+        ValuesEnum intsEnum = getValuesEnum(intsReader);
         assertTrue(intsEnum.advance(base) >= base);
 
         intsEnum = getValuesEnum(intsReader);
@@ -303,7 +299,7 @@ public class TestDocValuesIndexing extends LuceneTestCase {
           assertEquals(val + " failed for doc: " + i + " base: " + base,
               0.0d, value, 0.0d);
         }
-        DocValuesEnum floatEnum = getValuesEnum(floatReader);
+        ValuesEnum floatEnum = getValuesEnum(floatReader);
         assertTrue(floatEnum.advance(base) >= base);
 
         floatEnum = getValuesEnum(floatReader);
@@ -388,7 +384,7 @@ public class TestDocValuesIndexing extends LuceneTestCase {
           assertNotNull("expected none null - " + msg, br);
           assertEquals(0, br.length);
           // make sure we advance at least until base
-          DocValuesEnum bytesEnum = getValuesEnum(bytesReader);
+          ValuesEnum bytesEnum = getValuesEnum(bytesReader);
           try {
           
           final int advancedTo = bytesEnum.advance(0);
@@ -403,7 +399,7 @@ public class TestDocValuesIndexing extends LuceneTestCase {
         }
       }
 
-      DocValuesEnum bytesEnum = getValuesEnum(bytesReader);
+      ValuesEnum bytesEnum = getValuesEnum(bytesReader);
       final BytesRef enumRef = bytesEnum.bytes();
       // test the actual doc values added in this iteration
       assertEquals(base + numRemainingValues, r.numDocs());
@@ -480,9 +476,9 @@ public class TestDocValuesIndexing extends LuceneTestCase {
     return source;
   }
 
-  private DocValuesEnum getValuesEnum(IndexDocValues values) throws IOException {
-    DocValuesEnum valuesEnum;
-    if (!(values instanceof MultiDocValues) && random.nextInt(10) == 0) {
+  private ValuesEnum getValuesEnum(IndexDocValues values) throws IOException {
+    ValuesEnum valuesEnum;
+    if (!(values instanceof MultiIndexDocValues) && random.nextInt(10) == 0) {
       // TODO not supported by MultiDocValues yet!
       valuesEnum = getSource(values).getEnum();
     } else {
@@ -511,11 +507,11 @@ public class TestDocValuesIndexing extends LuceneTestCase {
     OpenBitSet deleted = new OpenBitSet(numValues);
     Document doc = new Document();
     Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];
-    AbstractField field = random.nextBoolean() ? new DocValuesField(value.name())
+    AbstractField field = random.nextBoolean() ? new IndexDocValuesField(value.name())
         : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,
             10), idx == Index.NO ? Store.YES : Store.NO, idx);
     doc.add(field);
-    DocValuesField valField = new DocValuesField("prototype");
+    IndexDocValuesField valField = new IndexDocValuesField("prototype");
     final BytesRef bytesRef = new BytesRef();
 
     final String idBase = value.name() + "_";
diff --git a/lucene/src/test/org/apache/lucene/search/TestSort.java b/lucene/src/test/org/apache/lucene/search/TestSort.java
index 4c81a18..170857b 100644
--- a/lucene/src/test/org/apache/lucene/search/TestSort.java
+++ b/lucene/src/test/org/apache/lucene/search/TestSort.java
@@ -25,7 +25,7 @@ import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 
 import org.apache.lucene.analysis.MockAnalyzer;
-import org.apache.lucene.document.DocValuesField;
+import org.apache.lucene.document.IndexDocValuesField;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.CorruptIndexException;
@@ -124,13 +124,13 @@ public class TestSort extends LuceneTestCase {
         doc.add (new Field ("contents", data[i][1], Field.Store.NO, Field.Index.ANALYZED));
         if (data[i][2] != null) {
           Field f = supportsDocValues ? 
-              DocValuesField.set(new Field ("int",      data[i][2], Field.Store.NO, Field.Index.NOT_ANALYZED), ValueType.INTS)
+              IndexDocValuesField.set(new Field ("int",      data[i][2], Field.Store.NO, Field.Index.NOT_ANALYZED), ValueType.INTS)
                                : new Field ("int",      data[i][2], Field.Store.NO, Field.Index.NOT_ANALYZED);
           doc.add(f);
         }
         if (data[i][3] != null) {
           Field f = supportsDocValues ?
-              DocValuesField.set(new Field ("float",    data[i][3], Field.Store.NO, Field.Index.NOT_ANALYZED), ValueType.FLOAT_32)
+              IndexDocValuesField.set(new Field ("float",    data[i][3], Field.Store.NO, Field.Index.NOT_ANALYZED), ValueType.FLOAT_32)
                               :  new Field ("float",    data[i][3], Field.Store.NO, Field.Index.NOT_ANALYZED);
           doc.add(f);
         }
@@ -140,7 +140,7 @@ public class TestSort extends LuceneTestCase {
         if (data[i][7] != null) doc.add (new Field ("long",     data[i][7], Field.Store.NO, Field.Index.NOT_ANALYZED));
         if (data[i][8] != null) {
           Field f = supportsDocValues ?
-              DocValuesField.set(new Field ("double",     data[i][8], Field.Store.NO, Field.Index.NOT_ANALYZED), ValueType.FLOAT_64)
+              IndexDocValuesField.set(new Field ("double",     data[i][8], Field.Store.NO, Field.Index.NOT_ANALYZED), ValueType.FLOAT_64)
                               :  new Field ("double",     data[i][8], Field.Store.NO, Field.Index.NOT_ANALYZED);
           doc.add(f);
         }

