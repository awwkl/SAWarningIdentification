GitDiffStart: e34753cd57cd73cc59f194816f188165eb4a0457 | Tue Apr 17 18:12:09 2012 +0000
diff --git a/dev-tools/eclipse/dot.classpath b/dev-tools/eclipse/dot.classpath
index 6df57ff..734a70a 100644
--- a/dev-tools/eclipse/dot.classpath
+++ b/dev-tools/eclipse/dot.classpath
@@ -110,8 +110,8 @@
 	<classpathentry kind="lib" path="solr/lib/commons-lang-2.6.jar"/>
 	<classpathentry kind="lib" path="solr/lib/easymock-2.2.jar"/>
 	<classpathentry kind="lib" path="solr/lib/guava-r05.jar"/>
+	<classpathentry kind="lib" path="solr/lib/log4j-1.2.16.jar"/>
 	<classpathentry kind="lib" path="solr/lib/jcl-over-slf4j-1.6.4.jar"/>
-	<classpathentry kind="lib" path="solr/lib/log4j-over-slf4j-1.6.4.jar"/>
 	<classpathentry kind="lib" path="solr/lib/slf4j-api-1.6.4.jar"/>
 	<classpathentry kind="lib" path="solr/lib/slf4j-jdk14-1.6.4.jar"/>
 	<classpathentry kind="lib" path="solr/lib/wstx-asl-3.2.7.jar"/>
diff --git a/dev-tools/maven/solr/core/pom.xml.template b/dev-tools/maven/solr/core/pom.xml.template
index c6c416a..c3273c9 100644
--- a/dev-tools/maven/solr/core/pom.xml.template
+++ b/dev-tools/maven/solr/core/pom.xml.template
@@ -215,6 +215,12 @@
       <groupId>org.apache.httpcomponents</groupId>
       <artifactId>httpmime</artifactId>
     </dependency>
+    <dependency>
+      <groupId>log4j</groupId>
+      <artifactId>log4j</artifactId>
+      <version>1.2.16</version>
+      <scope>provided</scope><!-- we only want this for compilation, at runtime use whatever you want -->
+    </dependency>
   </dependencies>
   <build>
     <directory>${build-directory}</directory>
diff --git a/solr/CHANGES.txt b/solr/CHANGES.txt
index c5112fd..5d73cf6 100644
--- a/solr/CHANGES.txt
+++ b/solr/CHANGES.txt
@@ -204,7 +204,6 @@ New Features
 * SOLR-2134 Trie* fields should support sortMissingLast=true, and deprecate Sortable* Field Types
   (Ryan McKinley, Mike McCandless, Uwe Schindler, Erick Erickson)
     
-  
 * SOLR-2438 added MultiTermAwareComponent to the various classes to allow automatic lowercasing
   for multiterm queries (wildcards, regex, prefix, range, etc). You can now optionally specify a
   "multiterm" analyzer in our schema.xml, but Solr should "do the right thing" if you don't
@@ -265,6 +264,10 @@ New Features
 
 * SOLR-3255: OpenExchangeRates.Org Exchange Rate Provider for CurrencyField (janhoy)
 
+* SOLR-3358: Logging events are captured and available from the /admin/logging 
+  request handler. (ryan)
+  
+
 Optimizations
 ----------------------
 
diff --git a/solr/build.xml b/solr/build.xml
index 0e55e92..d15faa2 100644
--- a/solr/build.xml
+++ b/solr/build.xml
@@ -317,6 +317,7 @@
   <target name="dist-war"
           description="Creates the Solr WAR Distribution file.">
     <ant dir="webapp" target="dist" inheritall="false">
+      <property name="exclude.from.war" value="log4j-*" />
       <propertyset refid="uptodate.and.compiled.properties"/>
     </ant>
   </target>
@@ -325,7 +326,7 @@
           description="Creates a Solr WAR Distribution file, excluding slf4j bindings.">
     <ant dir="webapp" target="dist" inheritall="false">
       <propertyset refid="uptodate.and.compiled.properties"/>
-      <property name="exclude.from.war" value="*over-slf4j*,slf4j-jdk14*" />
+      <property name="exclude.from.war" value="*over-slf4j*,slf4j-jdk14*,log4j-*" />
       <property name="solr.war.suffix" value="-excl-slf4j" />
     </ant>
   </target>
diff --git a/solr/core/ivy.xml b/solr/core/ivy.xml
index afb6c17..f4a5bcf 100644
--- a/solr/core/ivy.xml
+++ b/solr/core/ivy.xml
@@ -25,6 +25,7 @@
       <dependency org="org.apache.httpcomponents" name="httpcore" rev="4.1.4" transitive="false"/>
       <dependency org="org.apache.httpcomponents" name="httpclient" rev="4.1.3" transitive="false"/>
       <dependency org="org.apache.httpcomponents" name="httpmime" rev="4.1.3" transitive="false"/>
+      <dependency org="log4j" name="log4j" rev="1.2.16" transitive="false"/>
       <dependency org="org.slf4j" name="jcl-over-slf4j" rev="1.6.4" transitive="false"/>
       <dependency org="commons-io" name="commons-io" rev="2.1" transitive="false"/>
       <dependency org="commons-lang" name="commons-lang" rev="2.6" transitive="false"/>
diff --git a/solr/core/src/java/org/apache/solr/core/CoreContainer.java b/solr/core/src/java/org/apache/solr/core/CoreContainer.java
index 02b906f..1c140c0 100644
--- a/solr/core/src/java/org/apache/solr/core/CoreContainer.java
+++ b/solr/core/src/java/org/apache/solr/core/CoreContainer.java
@@ -65,11 +65,16 @@ import org.apache.solr.core.SolrXMLSerializer.SolrXMLDef;
 import org.apache.solr.handler.admin.CoreAdminHandler;
 import org.apache.solr.handler.component.HttpShardHandlerFactory;
 import org.apache.solr.handler.component.ShardHandlerFactory;
+import org.apache.solr.logging.ListenerConfig;
+import org.apache.solr.logging.LogWatcher;
+import org.apache.solr.logging.jul.JulWatcher;
+import org.apache.solr.logging.log4j.Log4jWatcher;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.update.SolrCoreState;
 import org.apache.zookeeper.KeeperException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
+import org.slf4j.impl.StaticLoggerBinder;
 import org.w3c.dom.Document;
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
@@ -114,7 +119,7 @@ public class CoreContainer
   private ZkController zkController;
   private SolrZkServer zkServer;
   private ShardHandlerFactory shardHandlerFactory;
-
+  protected LogWatcher logging = null;
   private String zkHost;
   private Map<SolrCore,String> coreToOrigName = new ConcurrentHashMap<SolrCore,String>();
 
@@ -383,6 +388,55 @@ public class CoreContainer
     
     cfg.substituteProperties();
     
+    // Initialize Logging
+    if(cfg.getBool("solr/logging/@enabled",true)) {
+      String slf4jImpl = null;
+      String fname = cfg.get("solr/logging/watcher/@class", null);
+      try {
+        slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();
+        if(fname==null) {
+          if( slf4jImpl.indexOf("Log4j") > 0) {
+            fname = "Log4j";
+          }
+          else if( slf4jImpl.indexOf("JDK") > 0) {
+            fname = "JUL";
+          }
+        }
+      }
+      catch(Exception ex) {
+        log.warn("Unable to read SLF4J version", ex);
+      }
+      
+      // Now load the framework
+      if(fname!=null) {
+        if("JUL".equalsIgnoreCase(fname)) {
+          logging = new JulWatcher(slf4jImpl);
+        }
+        else if( "Log4j".equals(fname) ) {
+          logging = new Log4jWatcher(slf4jImpl);
+        }
+        else {
+          try {
+            logging = loader.newInstance(fname, LogWatcher.class);
+          }
+          catch (Exception e) {
+            throw new SolrException(ErrorCode.SERVER_ERROR, e);
+          }
+        }
+        
+        if( logging != null ) {
+          ListenerConfig v = new ListenerConfig();
+          v.size = cfg.getInt("solr/logging/watcher/@size",50);
+          v.threshold = cfg.get("solr/logging/watcher/@threshold",null);
+          if(v.size>0) {
+            log.info("Registering Log Listener");
+            logging.registerListener(v, this);
+          }
+        }
+      }
+    }
+    
+    
     String dcoreName = cfg.get("solr/cores/@defaultCoreName", null);
     if(dcoreName != null) {
       defaultCoreName = dcoreName;
@@ -1022,6 +1076,13 @@ public class CoreContainer
     this.managementPath = path;
   }
   
+  public LogWatcher getLogging() {
+    return logging;
+  }
+  public void setLogging(LogWatcher v) {
+    logging = v;
+  }
+  
   public File getConfigFile() {
     return configFile;
   }
diff --git a/solr/core/src/java/org/apache/solr/handler/admin/AdminHandlers.java b/solr/core/src/java/org/apache/solr/handler/admin/AdminHandlers.java
index 802d2eb..6ad01bc 100644
--- a/solr/core/src/java/org/apache/solr/handler/admin/AdminHandlers.java
+++ b/solr/core/src/java/org/apache/solr/handler/admin/AdminHandlers.java
@@ -31,7 +31,6 @@ import org.apache.solr.util.plugin.SolrCoreAware;
 /**
  * A special Handler that registers all standard admin handlers
  * 
- *
  * @since solr 1.3
  */
 public class AdminHandlers implements SolrCoreAware, SolrRequestHandler
@@ -86,7 +85,7 @@ public class AdminHandlers implements SolrCoreAware, SolrRequestHandler
       new StandardHandler( "plugins", new PluginInfoHandler() ),
       new StandardHandler( "threads", new ThreadDumpHandler() ),
       new StandardHandler( "properties", new PropertiesRequestHandler() ),
-      new StandardHandler( "loglevel", new LogLevelHandler() ),
+      new StandardHandler( "logging", new LoggingHandler() ),
       new StandardHandler( "file", new ShowFileRequestHandler() )
     };
     
@@ -95,7 +94,7 @@ public class AdminHandlers implements SolrCoreAware, SolrRequestHandler
         handler.handler.init( initArgs );
         core.registerRequestHandler( path+handler.name, handler.handler );
         if( handler.handler instanceof SolrCoreAware ) {
-          ((SolrCoreAware)handler).inform(core);
+          ((SolrCoreAware)handler.handler).inform(core);
         }
       }
     }
diff --git a/solr/core/src/java/org/apache/solr/handler/admin/LogLevelHandler.java b/solr/core/src/java/org/apache/solr/handler/admin/LogLevelHandler.java
deleted file mode 100644
index c9653a8..0000000
--- a/solr/core/src/java/org/apache/solr/handler/admin/LogLevelHandler.java
+++ /dev/null
@@ -1,444 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.handler.admin;
-
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Enumeration;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.logging.Level;
-import java.util.logging.LogManager;
-import java.util.logging.Logger;
-
-import org.apache.solr.common.SolrException;
-import org.apache.solr.common.SolrException.ErrorCode;
-import org.apache.solr.common.params.SolrParams;
-import org.apache.solr.common.util.NamedList;
-import org.apache.solr.common.util.SimpleOrderedMap;
-import org.apache.solr.handler.RequestHandlerBase;
-import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.response.SolrQueryResponse;
-import org.slf4j.impl.StaticLoggerBinder;
-
-
-/**
- * A request handler to show which loggers are registered and allows you to set them
- *
- * @since 4.0
- */
-public class LogLevelHandler extends RequestHandlerBase {
-  public static final String ROOT_NAME = "root";
-
-  //-------------------------------------------------------------------------------------------------
-  //
-  //   Logger wrapper classes
-  //
-  //-------------------------------------------------------------------------------------------------
-
-  public abstract static class LoggerWrapper implements Comparable<LoggerWrapper> {
-    protected final String name;
-    protected String level;
-
-    public LoggerWrapper(String name) {
-      this.name = name;
-    }
-
-    public String getLevel() {
-      return level;
-    }
-
-    public String getName() {
-      return name;
-    }
-    
-    public abstract boolean isSet();
-
-    public SimpleOrderedMap<?> getInfo() {
-      SimpleOrderedMap info = new SimpleOrderedMap();
-      info.add("name", getName());
-      info.add("level", getLevel());
-      info.add("set", isSet());
-      return info;
-    }
-
-    @Override
-    public int compareTo(LoggerWrapper other) {
-      if (this.equals(other))
-        return 0;
-
-      String tN = this.getName();
-      String oN = other.getName();
-
-      if(ROOT_NAME.equals(tN))
-        return -1;
-      if(ROOT_NAME.equals(oN))
-        return 1;
-
-      return tN.compareTo(oN);
-    }
-  }
-
-  public static interface LoggerFactoryWrapper {
-    public String getName();
-    public List<String> getAllLevels();
-    public void setLogLevel(String category, String level);
-    public Collection<LoggerWrapper> getLoggers();
-  }
-
-
-  //-------------------------------------------------------------------------------------------------
-  //
-  //   java.util.logging
-  //
-  //-------------------------------------------------------------------------------------------------
-
-
-  public static class LoggerFactoryWrapperJUL implements LoggerFactoryWrapper {
-
-    @Override
-    public String getName() {
-      return "java.util.logging";
-    }
-
-    @Override
-    public List<String> getAllLevels() {
-      return Arrays.asList(
-        Level.FINEST.getName(),
-        Level.FINE.getName(),
-        Level.CONFIG.getName(),
-        Level.INFO.getName(),
-        Level.WARNING.getName(),
-        Level.SEVERE.getName(),
-        Level.OFF.getName() );
-    }
-
-    @Override
-    public void setLogLevel(String category, String level) {
-      if(ROOT_NAME.equals(category)) {
-        category = "";
-      }
-      
-      Logger log = LogManager.getLogManager().getLogger(category);
-      if(level==null||"unset".equals(level)||"null".equals(level)) {
-        if(log!=null) {
-          log.setLevel(null);
-        }
-      }
-      else {
-        if(log==null) {
-          log = Logger.getLogger(category); // create it
-        }
-        log.setLevel(Level.parse(level));
-      }
-    }
-
-    @Override
-    public Collection<LoggerWrapper> getLoggers() {
-      LogManager manager = LogManager.getLogManager();
-
-      Logger root = manager.getLogger("");
-      Map<String,LoggerWrapper> map = new HashMap<String,LoggerWrapper>();
-      Enumeration<String> names = manager.getLoggerNames();
-      while (names.hasMoreElements()) {
-        String name = names.nextElement();
-        Logger logger = Logger.getLogger(name);
-        if( logger == root) {
-          continue;
-        }
-        map.put(name, new LoggerWrapperJUL(name, logger));
-
-        while (true) {
-          int dot = name.lastIndexOf(".");
-          if (dot < 0)
-            break;
-          name = name.substring(0, dot);
-          if(!map.containsKey(name)) {
-            map.put(name, new LoggerWrapperJUL(name, null));
-          }
-        }
-      }
-      map.put(ROOT_NAME, new LoggerWrapperJUL(ROOT_NAME, root));
-      return map.values();
-    }
-  }
-
-  public static class LoggerWrapperJUL extends LoggerWrapper {
-    private static final Level[] LEVELS = {
-        null, // aka unset
-        Level.FINEST,
-        Level.FINE,
-        Level.CONFIG,
-        Level.INFO,
-        Level.WARNING,
-        Level.SEVERE,
-        Level.OFF
-        // Level.ALL -- ignore. It is useless.
-    };
-
-    final Logger logger;
-
-    public LoggerWrapperJUL(String name, Logger logger) {
-      super(name);
-      this.logger = logger;
-    }
-
-    @Override
-    public String getLevel() {
-      if(logger==null) {
-        return null;
-      }
-      Level level = logger.getLevel();
-      if (level != null) {
-        return level.getName();
-      }
-      for (Level l : LEVELS) {
-        if (l == null) {
-          // avoid NPE
-          continue;
-        }
-        if (logger.isLoggable(l)) {
-          // return first level loggable
-          return l.getName();
-        }
-      }
-      return Level.OFF.getName();
-    }
-    
-    @Override
-    public boolean isSet() {
-      return (logger!=null && logger.getLevel()!=null);
-    }
-  }
-
-  //-------------------------------------------------------------------------------------------------
-  //
-  //   Log4j
-  //
-  //-------------------------------------------------------------------------------------------------
-
-  public static class LoggerWrapperLog4j extends LoggerWrapper {
-    final org.apache.log4j.Logger logger;
-
-    public LoggerWrapperLog4j(String name, org.apache.log4j.Logger logger) {
-      super(name);
-      this.logger = logger;
-    }
-
-    @Override
-    public String getLevel() {
-      if(logger==null) {
-        return null;
-      }
-      Object level = logger.getLevel();
-      if(level==null) {
-        return null;
-      }
-      return level.toString();
-    }
-
-    @Override
-    public String getName() {
-      return name;
-    }
-
-    @Override
-    public boolean isSet() {
-      return (logger!=null && logger.getLevel()!=null);
-    }
-  }
-
-  public static class LoggerFactoryWrapperLog4j implements LoggerFactoryWrapper {
-
-    @Override
-    public String getName() {
-      return "log4j";
-    }
-
-    @Override
-    public List<String> getAllLevels() {
-      return Arrays.asList(
-          org.apache.log4j.Level.ALL.toString(),
-          org.apache.log4j.Level.TRACE.toString(),
-          org.apache.log4j.Level.DEBUG.toString(),
-          org.apache.log4j.Level.INFO.toString(),
-          org.apache.log4j.Level.WARN.toString(),
-          org.apache.log4j.Level.ERROR.toString(),
-          org.apache.log4j.Level.FATAL.toString(),
-          org.apache.log4j.Level.OFF.toString());
-    }
-
-    @Override
-    public void setLogLevel(String category, String level) {
-      if(ROOT_NAME.equals(category)) {
-        category = "";
-      }
-      org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(category);
-      if(level==null||"unset".equals(level)||"null".equals(level)) {
-        setLevelWithReflection(log,null);
-      }
-      else {
-        setLevelWithReflection(log,org.apache.log4j.Level.toLevel(level));
-      }
-    }
-    
-    /**
-     * log.setLevel(level);
-     */
-    private void setLevelWithReflection(org.apache.log4j.Logger log, org.apache.log4j.Level level) {
-      try {
-        Class<?> logclass = Class.forName("org.apache.log4j.Logger");
-        Class<?> levelclass = Class.forName("org.apache.log4j.Level");
-        Method method = logclass.getMethod("setLevel", levelclass);
-        method.invoke(log, level);
-      }
-      catch(Exception ex) {
-        throw new RuntimeException("Unable to set Log4j Level", ex);
-      }
-    }
-
-    @Override
-    public Collection<LoggerWrapper> getLoggers() {
-
-      org.apache.log4j.Logger root = org.apache.log4j.LogManager.getRootLogger();
-      Map<String,LoggerWrapper> map = new HashMap<String,LoggerWrapper>();
-      Enumeration<?> loggers = org.apache.log4j.LogManager.getCurrentLoggers();
-      while (loggers.hasMoreElements()) {
-        org.apache.log4j.Logger logger = (org.apache.log4j.Logger)loggers.nextElement();
-        String name = logger.getName();
-        if( logger == root) {
-          continue;
-        }
-        map.put(name, new LoggerWrapperLog4j(name, logger));
-
-        while (true) {
-          int dot = name.lastIndexOf(".");
-          if (dot < 0)
-            break;
-          name = name.substring(0, dot);
-          if(!map.containsKey(name)) {
-            map.put(name, new LoggerWrapperJUL(name, null));
-          }
-        }
-      }
-      map.put(ROOT_NAME, new LoggerWrapperLog4j(ROOT_NAME, root));
-      return map.values();
-    }
-  }
-  
-
-  //-------------------------------------------------------------------------------------------------
-  //
-  //   The Request Handler
-  //
-  //-------------------------------------------------------------------------------------------------
-
-  LoggerFactoryWrapper factory;
-  String slf4jImpl = null;
-
-  @Override
-  public void init(NamedList args) {
-    String fname = (String)args.get("logger.factory");
-    try {
-      slf4jImpl = StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr();
-      if(fname == null ) {
-        if( slf4jImpl.indexOf("Log4j") > 0) {
-          fname = "Log4j";
-        }
-        else if( slf4jImpl.indexOf("JDK") > 0) {
-          fname = "JUL";
-        }
-        else {
-          return; // unsuppored
-        }
-      }
-    }
-    catch(Exception ex) {}
-    
-    if("JUL".equalsIgnoreCase(fname)) {
-      factory = new LoggerFactoryWrapperJUL();
-    }
-    else if( "Log4j".equals(fname) ) {
-      factory = new LoggerFactoryWrapperLog4j();
-    }
-    else {
-      try {
-        factory = (LoggerFactoryWrapper) Class.forName(fname).newInstance();
-      }
-      catch (Exception e) {
-        throw new SolrException(ErrorCode.SERVER_ERROR, e);
-      }
-    }
-  }
-
-  @Override
-  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {
-    // Don't do anything if the framework is unknown
-    if(factory==null) {
-      rsp.add("error", "Unsupported Logging Framework: "+slf4jImpl);
-      return;
-    }
-    
-    SolrParams params = req.getParams();
-    String[] set = params.getParams("set");
-    if (set != null) {
-      for (String pair : set) {
-        String[] split = pair.split(":");
-        if (split.length != 2) {
-          throw new SolrException(
-              SolrException.ErrorCode.SERVER_ERROR,
-              "Invalid format, expected level:value, got " + pair);
-        }
-        String category = split[0];
-        String level = split[1];
-
-        factory.setLogLevel(category, level);
-      }
-    }
-
-    rsp.add("framework", factory.getName());
-    rsp.add("slfj4", slf4jImpl);
-    rsp.add("levels", factory.getAllLevels());
-
-    List<LoggerWrapper> loggers = new ArrayList<LogLevelHandler.LoggerWrapper>(factory.getLoggers());
-    Collections.sort(loggers);
-
-    List<SimpleOrderedMap<?>> info = new ArrayList<SimpleOrderedMap<?>>();
-    for(LoggerWrapper wrap:loggers) {
-      info.add(wrap.getInfo());
-    }
-    rsp.add("loggers", info);
-    rsp.setHttpCaching(false);
-  }
-
-  // ////////////////////// SolrInfoMBeans methods //////////////////////
-
-  @Override
-  public String getDescription() {
-    return "Lucene Log Level info";
-  }
-
-  @Override
-  public String getSource() {
-    return "$URL$";
-  }
-}
diff --git a/solr/core/src/java/org/apache/solr/handler/admin/LoggingHandler.java b/solr/core/src/java/org/apache/solr/handler/admin/LoggingHandler.java
new file mode 100644
index 0000000..ee83329
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/handler/admin/LoggingHandler.java
@@ -0,0 +1,152 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.handler.admin;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.apache.solr.common.SolrDocumentList;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.SolrException.ErrorCode;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.SimpleOrderedMap;
+import org.apache.solr.core.SolrCore;
+import org.apache.solr.handler.RequestHandlerBase;
+import org.apache.solr.logging.LogWatcher;
+import org.apache.solr.logging.LoggerInfo;
+import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.response.SolrQueryResponse;
+import org.apache.solr.util.plugin.SolrCoreAware;
+import org.slf4j.LoggerFactory;
+
+
+/**
+ * A request handler to show which loggers are registered and allows you to set them
+ *
+ * @since 4.0
+ */
+public class LoggingHandler extends RequestHandlerBase implements SolrCoreAware {
+  static final org.slf4j.Logger log = LoggerFactory.getLogger(LoggingHandler.class);
+  
+  LogWatcher watcher = null;
+  
+  @Override
+  public void inform(SolrCore core) {
+    watcher = core.getCoreDescriptor().getCoreContainer().getLogging();
+  }
+
+  @Override
+  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {
+    // Don't do anything if the framework is unknown
+    if(watcher==null) {
+      rsp.add("error", "Logging Not Initalized");
+      return;
+    }
+    rsp.add("watcher", watcher.getName());
+    
+    SolrParams params = req.getParams();
+    if(params.get("threshold")!=null) {
+      watcher.setThreshold(params.get("threshold"));
+    }
+    
+    // Write something at each level
+    if(params.get("test")!=null) {
+      log.trace("trace message");
+      log.debug( "debug message");
+      log.info("info (with exception)", new RuntimeException("test") );
+      log.warn("warn (with exception)", new RuntimeException("test") );
+      log.error("error (with exception)", new RuntimeException("test") );
+    }
+    
+    String[] set = params.getParams("set");
+    if (set != null) {
+      for (String pair : set) {
+        String[] split = pair.split(":");
+        if (split.length != 2) {
+          throw new SolrException(
+              SolrException.ErrorCode.SERVER_ERROR,
+              "Invalid format, expected level:value, got " + pair);
+        }
+        String category = split[0];
+        String level = split[1];
+
+        watcher.setLogLevel(category, level);
+      }
+    }
+    
+    String since = req.getParams().get("since");
+    if(since != null) {
+      long time = -1;
+      try {
+        time = Long.parseLong(since);
+      }
+      catch(Exception ex) {
+        throw new SolrException(ErrorCode.BAD_REQUEST, "invalid timestamp: "+since);
+      }
+      AtomicBoolean found = new AtomicBoolean(false);
+      SolrDocumentList docs = watcher.getHistory(time, found);
+      if(docs==null) {
+        rsp.add("error", "History not enabled");
+        return;
+      }
+      else {
+        SimpleOrderedMap<Object> info = new SimpleOrderedMap<Object>();
+        if(time>0) {
+          info.add("since", time);
+          info.add("found", found);
+        }
+        else {
+          info.add("levels", watcher.getAllLevels()); // show for the first request
+        }
+        info.add("last", watcher.getLastEvent());
+        info.add("buffer", watcher.getHistorySize());
+        info.add("threshold", watcher.getThreshold());
+        
+        rsp.add("info", info);
+        rsp.add("history", docs);
+      }
+    }
+    else {
+      rsp.add("levels", watcher.getAllLevels());
+  
+      List<LoggerInfo> loggers = new ArrayList<LoggerInfo>(watcher.getAllLoggers());
+      Collections.sort(loggers);
+  
+      List<SimpleOrderedMap<?>> info = new ArrayList<SimpleOrderedMap<?>>();
+      for(LoggerInfo wrap:loggers) {
+        info.add(wrap.getInfo());
+      }
+      rsp.add("loggers", info);
+    }
+    rsp.setHttpCaching(false);
+  }
+
+  // ////////////////////// SolrInfoMBeans methods //////////////////////
+
+  @Override
+  public String getDescription() {
+    return "Logging Handler";
+  }
+
+  @Override
+  public String getSource() {
+    return "$URL$";
+  }
+}
\ No newline at end of file
diff --git a/solr/core/src/java/org/apache/solr/logging/CircularList.java b/solr/core/src/java/org/apache/solr/logging/CircularList.java
new file mode 100644
index 0000000..7095d72
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/logging/CircularList.java
@@ -0,0 +1,154 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.logging;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+/**
+ * FIFO Circular List.
+ * 
+ * Once the size is reached, it will overwrite previous entries
+ * 
+ */
+public class CircularList<T> implements Iterable<T>
+{
+  private T[] data;
+  private int head=0;
+  private int tail=0;
+  private int size=0;
+
+  @SuppressWarnings("unchecked")
+  public CircularList(int size) {
+    data = (T[])new Object[size];
+  }
+
+  @SuppressWarnings("unchecked")
+  public synchronized void resize(int newsize) {
+    if(newsize==this.size) return;
+    
+    T[] vals = (T[])new Object[newsize];
+    int i = 0;
+    if(newsize>size) {
+      for(i=0; i<size; i++) {
+        vals[i] = data[convert(i)];
+      }
+    }
+    else {
+      int off=size-newsize;
+      for(i=0; i<newsize; i++) {
+        vals[i] = data[convert(i+off)];
+      }
+    }
+    data = vals;
+    head = 0;
+    tail = i;
+  }
+
+  private int convert(int index) {
+    return (index + head) % data.length;
+  }
+
+  public boolean isEmpty() {
+    return head == tail; // or size == 0
+  }
+
+  public int size() {
+    return size;
+  }
+  
+  public int getBufferSize() {
+    return data.length;
+  }
+
+  private void checkIndex(int index) {
+    if (index >= size || index < 0)
+      throw new IndexOutOfBoundsException("Index: "+index+", Size: "+size);
+  }
+
+  public T get(int index) {
+    checkIndex(index);
+    return data[convert(index)];
+  }
+
+  public synchronized void add(T o) {
+    data[tail] = o;
+    tail = (tail+1)%data.length;
+    if( size == data.length ) {
+      head = (head+1)%data.length;
+    }
+    size++;
+    if( size > data.length ) {
+      size = data.length;
+    }
+  }
+
+  public synchronized void clear() {
+    for( int i=0; i<data.length; i++ ) {
+      data[i] = null;  // for GC
+    }
+    head = tail = size = 0;
+  }
+
+  public List<T> toList()
+  {
+    ArrayList<T> list = new ArrayList<T>( size );
+    for( int i=0; i<size; i++ ) {
+      list.add( data[convert(i)] );
+    }
+    return list;
+  }
+
+  @Override
+  public String toString()
+  {
+    StringBuilder str = new StringBuilder();
+    str.append( "[" );
+    for( int i=0; i<size; i++ ) {
+      if( i > 0 ) {
+        str.append( "," );
+      }
+      str.append( data[convert(i)] );
+    }
+    str.append( "]" );
+    return str.toString();
+  }
+
+  @Override
+  public Iterator<T> iterator() {
+    return new Iterator<T>() {
+      int idx = 0;
+
+      @Override
+      public boolean hasNext() {
+        return idx<size;
+      }
+
+      @Override
+      public T next() {
+        return get( idx++ );
+      }
+
+      @Override
+      public void remove() {
+        throw new UnsupportedOperationException();
+      }
+    };
+  }
+}
diff --git a/solr/core/src/java/org/apache/solr/logging/ListenerConfig.java b/solr/core/src/java/org/apache/solr/logging/ListenerConfig.java
new file mode 100644
index 0000000..5d1ef3a
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/logging/ListenerConfig.java
@@ -0,0 +1,26 @@
+package org.apache.solr.logging;
+
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class ListenerConfig {
+  public int size = 50;
+  public String threshold = null;
+  
+  // Down the line, settings for solr URL/core to store logging
+}
diff --git a/solr/core/src/java/org/apache/solr/logging/LogWatcher.java b/solr/core/src/java/org/apache/solr/logging/LogWatcher.java
new file mode 100644
index 0000000..62f388c
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/logging/LogWatcher.java
@@ -0,0 +1,107 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.logging;
+
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.apache.solr.common.SolrDocument;
+import org.apache.solr.common.SolrDocumentList;
+import org.apache.solr.core.CoreContainer;
+
+/**
+ * A Class to monitor Logging events and hold N events in memory
+ * 
+ * This is abstract so we can support both JUL and Log4j (and other logging platforms)
+ */
+public abstract class LogWatcher<E> {
+  
+  protected CircularList<E> history;
+  protected long last = -1;
+  
+  /**
+   * @return The implementation name
+   */
+  public abstract String getName();
+  
+  /**
+   * @return The valid level names for this framework
+   */
+  public abstract List<String> getAllLevels();
+  
+  /**
+   * Sets the log level within this framework
+   */
+  public abstract void setLogLevel(String category, String level);
+  
+  /**
+   * @return all registered loggers
+   */
+  public abstract Collection<LoggerInfo> getAllLoggers();
+  
+  public abstract void setThreshold(String level);
+  public abstract String getThreshold();
+
+  public void add(E event, long timstamp) {
+    history.add(event);
+    last = timstamp;
+  }
+  
+  public long getLastEvent() {
+    return last;
+  }
+  
+  public int getHistorySize() {
+    return (history==null) ? -1 : history.getBufferSize();
+  }
+  
+  public SolrDocumentList getHistory(long since, AtomicBoolean found) {
+    if(history==null) {
+      return null;
+    }
+    
+    SolrDocumentList docs = new SolrDocumentList();
+    Iterator<E> iter = history.iterator();
+    while(iter.hasNext()) {
+      E e = iter.next();
+      long ts = getTimestamp(e);
+      if(ts == since) {
+        if(found!=null) {
+          found.set(true);
+        }
+      }
+      if(ts>since) {
+        docs.add(toSolrDocument(e));
+      }
+    }
+    docs.setNumFound(docs.size()); // make it not look too funny
+    return docs;
+  }
+  
+  public abstract long getTimestamp(E event);
+  public abstract SolrDocument toSolrDocument(E event);
+  
+  public abstract void registerListener(ListenerConfig cfg, CoreContainer container);
+
+  public void reset() {
+    history.clear();
+    last = -1;
+  }
+}
\ No newline at end of file
diff --git a/solr/core/src/java/org/apache/solr/logging/LoggerInfo.java b/solr/core/src/java/org/apache/solr/logging/LoggerInfo.java
new file mode 100644
index 0000000..08987bb
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/logging/LoggerInfo.java
@@ -0,0 +1,68 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.logging;
+
+import org.apache.solr.common.util.SimpleOrderedMap;
+
+/**
+ * Wrapper class for Logger implementaions
+ */
+public abstract class LoggerInfo implements Comparable<LoggerInfo> {
+  public static final String ROOT_NAME = "root";
+
+  protected final String name;
+  protected String level;
+
+  public LoggerInfo(String name) {
+    this.name = name;
+  }
+
+  public String getLevel() {
+    return level;
+  }
+
+  public String getName() {
+    return name;
+  }
+  
+  public abstract boolean isSet();
+
+  public SimpleOrderedMap<?> getInfo() {
+    SimpleOrderedMap<Object> info = new SimpleOrderedMap<Object>();
+    info.add("name", getName());
+    info.add("level", getLevel());
+    info.add("set", isSet());
+    return info;
+  }
+
+  @Override
+  public int compareTo(LoggerInfo other) {
+    if (this.equals(other))
+      return 0;
+
+    String tN = this.getName();
+    String oN = other.getName();
+
+    if(ROOT_NAME.equals(tN))
+      return -1;
+    if(ROOT_NAME.equals(oN))
+      return 1;
+
+    return tN.compareTo(oN);
+  }
+}
\ No newline at end of file
diff --git a/solr/core/src/java/org/apache/solr/logging/jul/JulInfo.java b/solr/core/src/java/org/apache/solr/logging/jul/JulInfo.java
new file mode 100644
index 0000000..7ec22c6
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/logging/jul/JulInfo.java
@@ -0,0 +1,70 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.logging.jul;
+
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+import org.apache.solr.logging.LoggerInfo;
+
+public class JulInfo extends LoggerInfo {
+  private static final Level[] LEVELS = {
+      null, // aka unset
+      Level.FINEST,
+      Level.FINE,
+      Level.CONFIG,
+      Level.INFO,
+      Level.WARNING,
+      Level.SEVERE,
+      Level.OFF
+      // Level.ALL -- ignore. It is useless.
+  };
+
+  final Logger logger;
+
+  public JulInfo(String name, Logger logger) {
+    super(name);
+    this.logger = logger;
+  }
+
+  @Override
+  public String getLevel() {
+    if(logger==null) {
+      return null;
+    }
+    Level level = logger.getLevel();
+    if (level != null) {
+      return level.getName();
+    }
+    for (Level l : LEVELS) {
+      if (l == null) {
+        // avoid NPE
+        continue;
+      }
+      if (logger.isLoggable(l)) {
+        // return first level loggable
+        return l.getName();
+      }
+    }
+    return Level.OFF.getName();
+  }
+  
+  @Override
+  public boolean isSet() {
+    return (logger!=null && logger.getLevel()!=null);
+  }
+}
\ No newline at end of file
diff --git a/solr/core/src/java/org/apache/solr/logging/jul/JulWatcher.java b/solr/core/src/java/org/apache/solr/logging/jul/JulWatcher.java
new file mode 100644
index 0000000..de6adff
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/logging/jul/JulWatcher.java
@@ -0,0 +1,169 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.logging.jul;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Date;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.logging.Level;
+import java.util.logging.LogManager;
+import java.util.logging.LogRecord;
+import java.util.logging.Logger;
+
+import org.apache.solr.common.SolrDocument;
+import org.apache.solr.core.CoreContainer;
+import org.apache.solr.logging.CircularList;
+import org.apache.solr.logging.ListenerConfig;
+import org.apache.solr.logging.LoggerInfo;
+import org.apache.solr.logging.LogWatcher;
+
+import com.google.common.base.Throwables;
+
+public class JulWatcher extends LogWatcher<LogRecord> {
+
+  final String name;
+  RecordHandler handler = null;
+  
+  public JulWatcher(String name) {
+    this.name = name;
+  }
+  
+  @Override
+  public String getName() {
+    return "JUL ("+name+")";
+  }
+
+
+  @Override
+  public List<String> getAllLevels() {
+    return Arrays.asList(
+      Level.FINEST.getName(),
+      Level.FINER.getName(),
+      Level.FINE.getName(),
+      Level.CONFIG.getName(),
+      Level.INFO.getName(),
+      Level.WARNING.getName(),
+      Level.SEVERE.getName(),
+      Level.OFF.getName() );
+  }
+
+  @Override
+  public void setLogLevel(String category, String level) {
+    if(LoggerInfo.ROOT_NAME.equals(category)) {
+      category = "";
+    }
+    
+    Logger log = LogManager.getLogManager().getLogger(category);
+    if(level==null||"unset".equals(level)||"null".equals(level)) {
+      if(log!=null) {
+        log.setLevel(null);
+      }
+    }
+    else {
+      if(log==null) {
+        log = Logger.getLogger(category); // create it
+      }
+      log.setLevel(Level.parse(level));
+    }
+  }
+
+  @Override
+  public Collection<LoggerInfo> getAllLoggers() {
+    LogManager manager = LogManager.getLogManager();
+
+    Logger root = manager.getLogger("");
+    Map<String,LoggerInfo> map = new HashMap<String,LoggerInfo>();
+    Enumeration<String> names = manager.getLoggerNames();
+    while (names.hasMoreElements()) {
+      String name = names.nextElement();
+      Logger logger = Logger.getLogger(name);
+      if( logger == root) {
+        continue;
+      }
+      map.put(name, new JulInfo(name, logger));
+
+      while (true) {
+        int dot = name.lastIndexOf(".");
+        if (dot < 0)
+          break;
+        name = name.substring(0, dot);
+        if(!map.containsKey(name)) {
+          map.put(name, new JulInfo(name, null));
+        }
+      }
+    }
+    map.put(LoggerInfo.ROOT_NAME, new JulInfo(LoggerInfo.ROOT_NAME, root));
+    return map.values();
+  }
+
+  @Override
+  public void setThreshold(String level) {
+    if(handler==null) {
+      throw new IllegalStateException("Must have an handler");
+    }
+    handler.setLevel( Level.parse(level) );
+  }
+
+  @Override
+  public String getThreshold() {
+    if(handler==null) {
+      throw new IllegalStateException("Must have an handler");
+    }
+    return handler.getLevel().toString();
+  }
+
+  @Override
+  public void registerListener(ListenerConfig cfg, CoreContainer container) {
+    if(history!=null) {
+      throw new IllegalStateException("History already registered");
+    }
+    history = new CircularList<LogRecord>(cfg.size);
+    handler = new RecordHandler(this);
+    if(cfg.threshold != null) {
+      handler.setLevel(Level.parse(cfg.threshold));
+    }
+    else {
+      handler.setLevel(Level.WARNING);
+    }
+    
+    Logger log = LogManager.getLogManager().getLogger("");
+    log.addHandler(handler);
+  }
+
+  @Override
+  public long getTimestamp(LogRecord event) {
+    return event.getMillis();
+  }
+
+  @Override
+  public SolrDocument toSolrDocument(LogRecord event) {
+    SolrDocument doc = new SolrDocument();
+    doc.setField("time", new Date(event.getMillis()));
+    doc.setField("level", event.getLevel().toString());
+    doc.setField("logger", event.getLoggerName());
+    doc.setField("message", event.getMessage().toString());
+    Throwable t = event.getThrown();
+    if(t!=null) {
+      doc.setField("trace", Throwables.getStackTraceAsString(t));
+    }
+    return doc;
+  }
+}
\ No newline at end of file
diff --git a/solr/core/src/java/org/apache/solr/logging/jul/RecordHandler.java b/solr/core/src/java/org/apache/solr/logging/jul/RecordHandler.java
new file mode 100644
index 0000000..1067e20
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/logging/jul/RecordHandler.java
@@ -0,0 +1,47 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.logging.jul;
+
+
+import java.util.logging.LogRecord;
+
+import org.apache.solr.logging.LogWatcher;
+
+public final class RecordHandler extends java.util.logging.Handler {
+  final LogWatcher<LogRecord> framework;
+  
+  public RecordHandler(LogWatcher<LogRecord> framework) {
+    this.framework = framework;
+  }
+  
+  @Override
+  public void close() throws SecurityException {
+    //history.reset();
+  }
+  
+  @Override
+  public void flush() {
+    // nothing
+  }
+  
+  @Override
+  public void publish(LogRecord r) {
+    if(isLoggable(r)) {
+      framework.add(r, r.getMillis());
+    }
+  }
+}
\ No newline at end of file
diff --git a/solr/core/src/java/org/apache/solr/logging/log4j/EventAppender.java b/solr/core/src/java/org/apache/solr/logging/log4j/EventAppender.java
new file mode 100644
index 0000000..90fbc8d
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/logging/log4j/EventAppender.java
@@ -0,0 +1,48 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.logging.log4j;
+
+import org.apache.log4j.AppenderSkeleton;
+import org.apache.log4j.spi.LoggingEvent;
+
+import org.apache.solr.logging.LogWatcher;
+
+
+public final class EventAppender extends AppenderSkeleton {
+
+  final LogWatcher<LoggingEvent> watcher;
+  
+  public EventAppender(LogWatcher<LoggingEvent> framework) {
+    this.watcher = framework;
+  }
+  
+  @Override
+  public void append( LoggingEvent event )
+  {
+    watcher.add(event,event.timeStamp);
+  }
+
+  @Override
+  public void close() {
+    watcher.reset();
+  }
+
+  @Override
+  public boolean requiresLayout() {
+    return false;
+  }
+}
\ No newline at end of file
diff --git a/solr/core/src/java/org/apache/solr/logging/log4j/Log4jInfo.java b/solr/core/src/java/org/apache/solr/logging/log4j/Log4jInfo.java
new file mode 100644
index 0000000..42cf761
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/logging/log4j/Log4jInfo.java
@@ -0,0 +1,50 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.logging.log4j;
+
+import org.apache.solr.logging.LoggerInfo;
+
+public class Log4jInfo extends LoggerInfo {
+  final org.apache.log4j.Logger logger;
+
+  public Log4jInfo(String name, org.apache.log4j.Logger logger) {
+    super(name);
+    this.logger = logger;
+  }
+
+  @Override
+  public String getLevel() {
+    if(logger==null) {
+      return null;
+    }
+    Object level = logger.getLevel();
+    if(level==null) {
+      return null;
+    }
+    return level.toString();
+  }
+
+  @Override
+  public String getName() {
+    return name;
+  }
+
+  @Override
+  public boolean isSet() {
+    return (logger!=null && logger.getLevel()!=null);
+  }
+}
\ No newline at end of file
diff --git a/solr/core/src/java/org/apache/solr/logging/log4j/Log4jWatcher.java b/solr/core/src/java/org/apache/solr/logging/log4j/Log4jWatcher.java
new file mode 100644
index 0000000..d7cd22e
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/logging/log4j/Log4jWatcher.java
@@ -0,0 +1,162 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.logging.log4j;
+
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Date;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.log4j.AppenderSkeleton;
+import org.apache.log4j.Level;
+import org.apache.log4j.Logger;
+import org.apache.log4j.spi.LoggingEvent;
+import org.apache.log4j.spi.ThrowableInformation;
+import org.apache.solr.common.SolrDocument;
+import org.apache.solr.core.CoreContainer;
+import org.apache.solr.logging.CircularList;
+import org.apache.solr.logging.ListenerConfig;
+import org.apache.solr.logging.LoggerInfo;
+import org.apache.solr.logging.LogWatcher;
+
+import com.google.common.base.Throwables;
+
+public class Log4jWatcher extends LogWatcher<LoggingEvent> {
+
+  final String name;
+  AppenderSkeleton appender = null;
+  
+  public Log4jWatcher(String name) {
+    this.name = name;
+  }
+  
+  @Override
+  public String getName() {
+    return "Log4j ("+name+")";
+  }
+
+  @Override
+  public List<String> getAllLevels() {
+    return Arrays.asList(
+        org.apache.log4j.Level.ALL.toString(),
+        org.apache.log4j.Level.TRACE.toString(),
+        org.apache.log4j.Level.DEBUG.toString(),
+        org.apache.log4j.Level.INFO.toString(),
+        org.apache.log4j.Level.WARN.toString(),
+        org.apache.log4j.Level.ERROR.toString(),
+        org.apache.log4j.Level.FATAL.toString(),
+        org.apache.log4j.Level.OFF.toString());
+  }
+
+  @Override
+  public void setLogLevel(String category, String level) {
+    if(LoggerInfo.ROOT_NAME.equals(category)) {
+      category = "";
+    }
+    org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(category);
+    if(level==null||"unset".equals(level)||"null".equals(level)) {
+      log.setLevel(null);
+    }
+    else {
+      log.setLevel(org.apache.log4j.Level.toLevel(level));
+    }
+  }
+
+  @Override
+  public Collection<LoggerInfo> getAllLoggers() {
+    org.apache.log4j.Logger root = org.apache.log4j.LogManager.getRootLogger();
+    Map<String,LoggerInfo> map = new HashMap<String,LoggerInfo>();
+    Enumeration<?> loggers = org.apache.log4j.LogManager.getCurrentLoggers();
+    while (loggers.hasMoreElements()) {
+      org.apache.log4j.Logger logger = (org.apache.log4j.Logger)loggers.nextElement();
+      String name = logger.getName();
+      if( logger == root) {
+        continue;
+      }
+      map.put(name, new Log4jInfo(name, logger));
+
+      while (true) {
+        int dot = name.lastIndexOf(".");
+        if (dot < 0)
+          break;
+        name = name.substring(0, dot);
+        if(!map.containsKey(name)) {
+          map.put(name, new Log4jInfo(name, null));
+        }
+      }
+    }
+    map.put(LoggerInfo.ROOT_NAME, new Log4jInfo(LoggerInfo.ROOT_NAME, root));
+    return map.values();
+  }
+
+  @Override
+  public void setThreshold(String level) {
+    if(appender==null) {
+      throw new IllegalStateException("Must have an appender");
+    }
+    appender.setThreshold(Level.toLevel(level));
+  }
+
+  @Override
+  public String getThreshold() {
+    if(appender==null) {
+      throw new IllegalStateException("Must have an appender");
+    }
+    return appender.getThreshold().toString();
+  }
+
+  @Override
+  public void registerListener(ListenerConfig cfg, CoreContainer container) {
+    if(history!=null) {
+      throw new IllegalStateException("History already registered");
+    }
+    history = new CircularList<LoggingEvent>(cfg.size);
+
+    appender = new EventAppender(this);
+    if(cfg.threshold != null) {
+      appender.setThreshold(Level.toLevel(cfg.threshold));
+    }
+    else {
+      appender.setThreshold(Level.WARN);
+    }
+    Logger log = org.apache.log4j.LogManager.getRootLogger();
+    log.addAppender(appender);
+  }
+
+  @Override
+  public long getTimestamp(LoggingEvent event) {
+    return event.timeStamp;
+  }
+
+  @Override
+  public SolrDocument toSolrDocument(LoggingEvent event) {
+    SolrDocument doc = new SolrDocument();
+    doc.setField("time", new Date(event.getTimeStamp()));
+    doc.setField("level", event.getLevel().toString());
+    doc.setField("logger", event.getLogger().getName());
+    doc.setField("message", event.getMessage().toString());
+    ThrowableInformation t = event.getThrowableInformation();
+    if(t!=null) {
+      doc.setField("trace", Throwables.getStackTraceAsString(t.getThrowable()));
+    }
+    return doc;
+  }
+}
\ No newline at end of file
diff --git a/solr/core/src/test/org/apache/solr/handler/admin/LogLevelHandlerTest.java b/solr/core/src/test/org/apache/solr/handler/admin/LogLevelHandlerTest.java
deleted file mode 100644
index c298379..0000000
--- a/solr/core/src/test/org/apache/solr/handler/admin/LogLevelHandlerTest.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.handler.admin;
-
-
-import java.util.logging.Logger;
-
-import org.apache.solr.SolrTestCaseJ4;
-import org.apache.solr.common.params.CommonParams;
-import org.junit.BeforeClass;
-import org.junit.Test;
-
-public class LogLevelHandlerTest extends SolrTestCaseJ4 {
-  
-  @BeforeClass
-  public static void beforeClass() throws Exception {
-    initCore("solrconfig.xml", "schema.xml");
-  }
-
-  @Test
-  public void testLogLevelHandlerOutput() throws Exception {
-    Logger log = Logger.getLogger("org.apache.solr.SolrTestCaseJ4");
-    LogLevelHandler.LoggerWrapperJUL wrap = new LogLevelHandler.LoggerWrapperJUL(log.getName(), log);
-    
-    assertQ("Show Log Levels OK",
-            req(CommonParams.QT,"/admin/loglevel")
-            ,"//arr[@name='loggers']/lst/str[.='"+wrap.getName()+"']/../str[@name='level'][.='"+wrap.getLevel()+"']"
-            ,"//arr[@name='loggers']/lst/str[.='org.apache']/../null[@name='level']"
-            );
-
-    assertQ("Set and remove a level",
-            req(CommonParams.QT,"/admin/loglevel",  
-                "set", "org.xxx.yyy.abc:null",
-                "set", "org.xxx.yyy.zzz:FINEST")
-            ,"//arr[@name='loggers']/lst/str[.='org.xxx.yyy.zzz']/../str[@name='level'][.='FINEST']"
-            );
-  }
-}
diff --git a/solr/core/src/test/org/apache/solr/handler/admin/LoggingHandlerTest.java b/solr/core/src/test/org/apache/solr/handler/admin/LoggingHandlerTest.java
new file mode 100644
index 0000000..2f7f82a
--- /dev/null
+++ b/solr/core/src/test/org/apache/solr/handler/admin/LoggingHandlerTest.java
@@ -0,0 +1,53 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.handler.admin;
+
+import java.util.logging.Logger;
+
+import org.apache.solr.SolrTestCaseJ4;
+import org.apache.solr.common.params.CommonParams;
+import org.apache.solr.logging.jul.JulInfo;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+public class LoggingHandlerTest extends SolrTestCaseJ4 {
+  
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    initCore("solrconfig.xml", "schema.xml");
+  }
+
+  @Test
+  public void testLogLevelHandlerOutput() throws Exception {
+    Logger tst = Logger.getLogger("org.apache.solr.SolrTestCaseJ4");
+    JulInfo wrap = new JulInfo(tst.getName(), tst);
+    
+    assertQ("Show Log Levels OK",
+            req(CommonParams.QT,"/admin/logging")
+            ,"//arr[@name='loggers']/lst/str[.='"+wrap.getName()+"']/../str[@name='level'][.='"+wrap.getLevel()+"']"
+            ,"//arr[@name='loggers']/lst/str[.='org.apache']/../null[@name='level']"
+            );
+
+    assertQ("Set and remove a level",
+            req(CommonParams.QT,"/admin/logging",  
+                "set", "org.xxx.yyy.abc:null",
+                "set", "org.xxx.yyy.zzz:FINEST")
+            ,"//arr[@name='loggers']/lst/str[.='org.xxx.yyy.zzz']/../str[@name='level'][.='FINEST']"
+            );
+  }
+}
diff --git a/solr/core/src/test/org/apache/solr/util/CircularListTest.java b/solr/core/src/test/org/apache/solr/util/CircularListTest.java
new file mode 100644
index 0000000..c781ca8
--- /dev/null
+++ b/solr/core/src/test/org/apache/solr/util/CircularListTest.java
@@ -0,0 +1,50 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.util;
+
+import java.io.IOException;
+
+import junit.framework.TestCase;
+
+import org.apache.solr.logging.CircularList;
+import org.junit.Test;
+
+/** 
+ * Test circular list
+ */
+public class CircularListTest  extends TestCase {  
+
+  @Test
+  public void testCircularList() throws IOException {
+    CircularList<Integer> list = new CircularList<Integer>(10);
+    for(int i=0;i<10; i++) {
+      list.add(new Integer(i));
+    }
+    assertEquals("within list", new Integer(0), list.get(0));
+    for(int i=10;i<20; i++) {
+      list.add(new Integer(i));
+      assertEquals("within list", new Integer(i-9), list.get(0));
+    }
+    
+    // now try the resize
+    list.resize(5);
+    assertEquals(new Integer(15), list.get(0));
+    list.resize(10);
+    assertEquals(new Integer(15), list.get(0));
+  }
+}
diff --git a/solr/example/solr/solr.xml b/solr/example/solr/solr.xml
index 5539771..bdd0417 100644
--- a/solr/example/solr/solr.xml
+++ b/solr/example/solr/solr.xml
@@ -33,6 +33,11 @@
   sharedLib: path to a lib directory that will be shared across all cores
 -->
 <solr persistent="false">
+	<!-- by default, this is 50 @ WARN
+  <logging enabled="true">
+  	<watcher size="100" threshold="INFO" />
+  </logging>
+   -->
 
   <!--
   adminPath: RequestHandler path to manage cores.  
diff --git a/solr/lib/log4j-1.2.16.jar.sha1 b/solr/lib/log4j-1.2.16.jar.sha1
new file mode 100644
index 0000000..e300a57
--- /dev/null
+++ b/solr/lib/log4j-1.2.16.jar.sha1
@@ -0,0 +1 @@
+7999a63bfccbc7c247a9aea10d83d4272bd492c6
\ No newline at end of file
diff --git a/solr/lib/log4j-LICENSE-ASL.txt b/solr/lib/log4j-LICENSE-ASL.txt
new file mode 100644
index 0000000..d645695
--- /dev/null
+++ b/solr/lib/log4j-LICENSE-ASL.txt
@@ -0,0 +1,202 @@
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/solr/lib/log4j-NOTICE.txt b/solr/lib/log4j-NOTICE.txt
new file mode 100644
index 0000000..0375732
--- /dev/null
+++ b/solr/lib/log4j-NOTICE.txt
@@ -0,0 +1,5 @@
+Apache log4j
+Copyright 2007 The Apache Software Foundation
+
+This product includes software developed at
+The Apache Software Foundation (http://www.apache.org/).
\ No newline at end of file
diff --git a/solr/test-framework/src/java/org/apache/solr/util/TestHarness.java b/solr/test-framework/src/java/org/apache/solr/util/TestHarness.java
index 2820a9d..0d0a26c 100644
--- a/solr/test-framework/src/java/org/apache/solr/util/TestHarness.java
+++ b/solr/test-framework/src/java/org/apache/solr/util/TestHarness.java
@@ -27,6 +27,9 @@ import org.apache.solr.core.CoreContainer;
 import org.apache.solr.core.CoreDescriptor;
 import org.apache.solr.core.SolrResourceLoader;
 import org.apache.solr.handler.XmlUpdateRequestHandler;
+import org.apache.solr.logging.ListenerConfig;
+import org.apache.solr.logging.LogWatcher;
+import org.apache.solr.logging.jul.JulWatcher;
 import org.apache.solr.request.LocalSolrQueryRequest;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrRequestHandler;
@@ -207,6 +210,9 @@ public class TestHarness {
           initZooKeeper(System.getProperty("zkHost"), 10000);
         }
       };
+      LogWatcher<?> logging = new JulWatcher("test");
+      logging.registerListener(new ListenerConfig(), container);
+      container.setLogging(logging);
       
       CoreDescriptor dcore = new CoreDescriptor(container, coreName, solrConfig.getResourceLoader().getInstanceDir());
       dcore.setConfigName(solrConfig.getResourceName());
@@ -219,7 +225,6 @@ public class TestHarness {
         // always kick off recovery if we are in standalone mode.
         core.getUpdateHandler().getUpdateLog().recoverFromLog();
       }
-      
       return container;
     }
   }
diff --git a/solr/webapp/web/js/scripts/logging.js b/solr/webapp/web/js/scripts/logging.js
index add2373..784a091 100644
--- a/solr/webapp/web/js/scripts/logging.js
+++ b/solr/webapp/web/js/scripts/logging.js
@@ -117,7 +117,7 @@ var logging_handler = function( response, text_status, xhr )
   };
 
   var logger_content = '<div class="block">' + "\n"
-                     + '<h2><span>' + response.framework.esc() + '<span>' + response.slfj4.esc() + '</span></span></h2>' + "\n"
+                     + '<h2><span>' + response.watcher.esc() + '</span></h2>' + "\n"
                      + '<ul class="tree jstree">' + logger_tree( null ) + '</ul>' + "\n"
                      + '</div>';
 
@@ -228,7 +228,7 @@ sammy.get
   /^#\/~(logging)$/,
   function( context )
   {
-    loglevel_path = app_config.solr_path + '/admin/loglevel';
+    loglevel_path = app_config.solr_path + '/admin/logging';
     var content_element = $( '#content' );
         
     content_element

